import type { InvokeFunctionResponse, Signature } from "starknet";
import { z } from "zod";
export declare const CallSchema: z.ZodObject<{
    contractAddress: z.ZodString;
    entrypoint: z.ZodString;
    calldata: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodString, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>, z.ZodNumber, z.ZodBigInt]>, "many">>;
}, "strip", z.ZodTypeAny, {
    contractAddress?: string;
    calldata?: (string | number | bigint)[];
    entrypoint?: string;
}, {
    contractAddress?: string;
    calldata?: (string | number | bigint)[];
    entrypoint?: string;
}>;
export declare const typedDataSchema: z.ZodObject<{
    types: z.ZodRecord<z.ZodString, z.ZodArray<z.ZodUnion<[z.ZodObject<{
        name: z.ZodString;
        type: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type?: string;
        name?: string;
    }, {
        type?: string;
        name?: string;
    }>, z.ZodObject<{
        name: z.ZodString;
        type: z.ZodLiteral<"merkletree">;
        contains: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type?: "merkletree";
        name?: string;
        contains?: string;
    }, {
        type?: "merkletree";
        name?: string;
        contains?: string;
    }>]>, "many">>;
    primaryType: z.ZodString;
    domain: z.ZodRecord<z.ZodString, z.ZodUnknown>;
    message: z.ZodRecord<z.ZodString, z.ZodUnknown>;
}, "strip", z.ZodTypeAny, {
    message?: Record<string, unknown>;
    types?: Record<string, ({
        type?: string;
        name?: string;
    } | {
        type?: "merkletree";
        name?: string;
        contains?: string;
    })[]>;
    primaryType?: string;
    domain?: Record<string, unknown>;
}, {
    message?: Record<string, unknown>;
    types?: Record<string, ({
        type?: string;
        name?: string;
    } | {
        type?: "merkletree";
        name?: string;
        contains?: string;
    })[]>;
    primaryType?: string;
    domain?: Record<string, unknown>;
}>;
export declare const StarknetMethodArgumentsSchemas: {
    readonly enable: z.ZodUnion<[z.ZodTuple<[z.ZodOptional<z.ZodObject<{
        starknetVersion: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"v4">, z.ZodLiteral<"v5">]>>;
    }, "strip", z.ZodTypeAny, {
        starknetVersion?: "v5" | "v4";
    }, {
        starknetVersion?: "v5" | "v4";
    }>>], null>, z.ZodTuple<[], null>]>;
    readonly addStarknetChain: z.ZodTuple<[z.ZodObject<{
        id: z.ZodString;
        chainId: z.ZodString;
        chainName: z.ZodString;
        rpcUrls: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        nativeCurrency: z.ZodOptional<z.ZodObject<{
            name: z.ZodString;
            symbol: z.ZodString;
            decimals: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            symbol?: string;
            name?: string;
            decimals?: number;
        }, {
            symbol?: string;
            name?: string;
            decimals?: number;
        }>>;
        blockExplorerUrls: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        chainId?: string;
        id?: string;
        chainName?: string;
        rpcUrls?: string[];
        nativeCurrency?: {
            symbol?: string;
            name?: string;
            decimals?: number;
        };
        blockExplorerUrls?: string[];
    }, {
        chainId?: string;
        id?: string;
        chainName?: string;
        rpcUrls?: string[];
        nativeCurrency?: {
            symbol?: string;
            name?: string;
            decimals?: number;
        };
        blockExplorerUrls?: string[];
    }>], null>;
    readonly switchStarknetChain: z.ZodTuple<[z.ZodObject<{
        chainId: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        chainId?: string;
    }, {
        chainId?: string;
    }>], null>;
    readonly watchAsset: z.ZodTuple<[z.ZodObject<{
        type: z.ZodLiteral<"ERC20">;
        options: z.ZodObject<{
            address: z.ZodString;
            symbol: z.ZodOptional<z.ZodString>;
            decimals: z.ZodOptional<z.ZodNumber>;
            image: z.ZodOptional<z.ZodString>;
            name: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            symbol?: string;
            address?: string;
            image?: string;
            name?: string;
            decimals?: number;
        }, {
            symbol?: string;
            address?: string;
            image?: string;
            name?: string;
            decimals?: number;
        }>;
    }, "strip", z.ZodTypeAny, {
        type?: "ERC20";
        options?: {
            symbol?: string;
            address?: string;
            image?: string;
            name?: string;
            decimals?: number;
        };
    }, {
        type?: "ERC20";
        options?: {
            symbol?: string;
            address?: string;
            image?: string;
            name?: string;
            decimals?: number;
        };
    }>], null>;
    readonly execute: z.ZodTuple<[z.ZodUnion<[z.ZodArray<z.ZodObject<{
        contractAddress: z.ZodString;
        entrypoint: z.ZodString;
        calldata: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodString, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>, z.ZodNumber, z.ZodBigInt]>, "many">>;
    }, "strip", z.ZodTypeAny, {
        contractAddress?: string;
        calldata?: (string | number | bigint)[];
        entrypoint?: string;
    }, {
        contractAddress?: string;
        calldata?: (string | number | bigint)[];
        entrypoint?: string;
    }>, "atleastone">, z.ZodObject<{
        contractAddress: z.ZodString;
        entrypoint: z.ZodString;
        calldata: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodString, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>, z.ZodNumber, z.ZodBigInt]>, "many">>;
    }, "strip", z.ZodTypeAny, {
        contractAddress?: string;
        calldata?: (string | number | bigint)[];
        entrypoint?: string;
    }, {
        contractAddress?: string;
        calldata?: (string | number | bigint)[];
        entrypoint?: string;
    }>]>, z.ZodOptional<z.ZodArray<z.ZodAny, "many">>, z.ZodOptional<z.ZodObject<{
        nonce: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodString, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>, z.ZodNumber, z.ZodBigInt]>>;
        maxFee: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodString, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>, z.ZodNumber, z.ZodBigInt]>>;
        version: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodString, z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>, z.ZodNumber, z.ZodBigInt]>>;
    }, "strip", z.ZodTypeAny, {
        nonce?: string | number | bigint;
        maxFee?: string | number | bigint;
        version?: string | number | bigint;
    }, {
        nonce?: string | number | bigint;
        maxFee?: string | number | bigint;
        version?: string | number | bigint;
    }>>], null>;
    readonly signMessage: z.ZodTuple<[z.ZodObject<{
        types: z.ZodRecord<z.ZodString, z.ZodArray<z.ZodUnion<[z.ZodObject<{
            name: z.ZodString;
            type: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type?: string;
            name?: string;
        }, {
            type?: string;
            name?: string;
        }>, z.ZodObject<{
            name: z.ZodString;
            type: z.ZodLiteral<"merkletree">;
            contains: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            type?: "merkletree";
            name?: string;
            contains?: string;
        }, {
            type?: "merkletree";
            name?: string;
            contains?: string;
        }>]>, "many">>;
        primaryType: z.ZodString;
        domain: z.ZodRecord<z.ZodString, z.ZodUnknown>;
        message: z.ZodRecord<z.ZodString, z.ZodUnknown>;
    }, "strip", z.ZodTypeAny, {
        message?: Record<string, unknown>;
        types?: Record<string, ({
            type?: string;
            name?: string;
        } | {
            type?: "merkletree";
            name?: string;
            contains?: string;
        })[]>;
        primaryType?: string;
        domain?: Record<string, unknown>;
    }, {
        message?: Record<string, unknown>;
        types?: Record<string, ({
            type?: string;
            name?: string;
        } | {
            type?: "merkletree";
            name?: string;
            contains?: string;
        })[]>;
        primaryType?: string;
        domain?: Record<string, unknown>;
    }>], null>;
};
export type StarknetMethods = {
    enable: (...args: z.infer<typeof StarknetMethodArgumentsSchemas.enable>) => Promise<string[]>;
    addStarknetChain: (...args: z.infer<typeof StarknetMethodArgumentsSchemas.addStarknetChain>) => Promise<boolean>;
    switchStarknetChain: (...args: z.infer<typeof StarknetMethodArgumentsSchemas.switchStarknetChain>) => Promise<boolean>;
    watchAsset: (...args: z.infer<typeof StarknetMethodArgumentsSchemas.watchAsset>) => Promise<boolean>;
    execute: (...args: z.infer<typeof StarknetMethodArgumentsSchemas.execute>) => Promise<InvokeFunctionResponse>;
    signMessage: (...args: z.infer<typeof StarknetMethodArgumentsSchemas.signMessage>) => Promise<Signature>;
    getLoginStatus: () => Promise<{
        isLoggedIn: false;
    } | {
        isLoggedIn: true;
        hasSession: boolean;
        isPreauthorized: boolean;
    }>;
};
export type ConnectMethods = {
    connect: () => void;
};
export type ModalMethods = {
    shouldShow: () => void;
    shouldHide: () => void;
    heightChanged: (height: number) => void;
};
export type WebWalletMethods = ConnectMethods & ModalMethods;
export type IframeMethods = {
    connect: () => void;
};
