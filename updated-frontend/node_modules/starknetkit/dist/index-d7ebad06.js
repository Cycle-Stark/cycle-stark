var rn = Object.defineProperty;
var nn = (t, e, r) => e in t ? rn(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var ie = (t, e, r) => (nn(t, typeof e != "symbol" ? e + "" : e, r), r);
import { g as ir, c as Ie, C as sn, a as me, b as Mt, U as $t, d as an } from "./connector-ca2f4153.js";
import { Account as on, RpcProvider as cn } from "starknet";
const ar = "https://web.argent.xyz", Dt = `<svg
    width="32"
    height="28"
    viewBox="0 0 18 14"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M1.5 0.4375C0.982233 0.4375 0.5625 0.857233 0.5625 1.375V12C0.5625 12.4144 0.72712 12.8118 1.02015 13.1049C1.31317 13.3979 1.7106 13.5625 2.125 13.5625H15.875C16.2894 13.5625 16.6868 13.3979 16.9799 13.1049C17.2729 12.8118 17.4375 12.4144 17.4375 12V1.375C17.4375 0.857233 17.0178 0.4375 16.5 0.4375H1.5ZM2.4375 3.50616V11.6875H15.5625V3.50616L9.63349 8.94108C9.27507 9.26964 8.72493 9.26964 8.36651 8.94108L2.4375 3.50616ZM14.0899 2.3125H3.91013L9 6.97822L14.0899 2.3125Z"
      fill="currentColor"
    />
  </svg>`, Zt = "https://api.hydrogen.argent47.net/v1/starknet/goerli/rpc/v0.5", ct = "https://cloud.argent-api.com/v1/starknet/goerli/rpc/v0.5";
function un(t) {
  return t;
}
function ln(t) {
  return t.length === 0 ? un : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function dn(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function Ye(t) {
  const e = {
    subscribe(r) {
      let n = null, s = !1, i = !1, a = !1;
      function o() {
        if (n === null) {
          a = !0;
          return;
        }
        i || (i = !0, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          s || r.next?.(c);
        },
        error(c) {
          s || (s = !0, r.error?.(c), o());
        },
        complete() {
          s || (s = !0, r.complete?.(), o());
        }
      }), a && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return ln(r)(e);
    }
  };
  return e;
}
function or(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e.subscribe({
        next(o) {
          for (const c of s)
            c.next?.(o);
        },
        error(o) {
          for (const c of s)
            c.error?.(o);
        },
        complete() {
          for (const o of s)
            o.complete?.();
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function fn(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(i) {
          r.next?.(t(i, n++));
        },
        error(i) {
          r.error?.(i);
        },
        complete() {
          r.complete?.();
        }
      });
    }
  });
}
function cr(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          t.next?.(n), r.next?.(n);
        },
        error(n) {
          t.error?.(n), r.error?.(n);
        },
        complete() {
          t.complete?.(), r.complete?.();
        }
      });
    }
  });
}
let pn = class ur extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, ur.prototype);
  }
};
function lr(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let i = !1;
      function a() {
        i || (i = !0, s(new pn("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          i = !0, n(c), a();
        },
        error(c) {
          i = !0, s(c), a();
        },
        complete() {
          i = !0, a();
        }
      });
      e = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
const hn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isObservable: dn,
  map: fn,
  observable: Ye,
  observableToPromise: lr,
  share: or,
  tap: cr
}, Symbol.toStringTag, { value: "Module" }));
function dr(t) {
  return Ye((e) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function Ut(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function mn(t) {
  return (e) => {
    const r = Ut(t.true).map((s) => s(e)), n = Ut(t.false).map((s) => s(e));
    return (s) => Ye((i) => {
      const a = t.condition(s.op) ? r : n;
      return dr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
function yn(t) {
  return t instanceof fr || /**
  * @deprecated
  * Delete in next major
  */
  t.name === "TRPCClientError";
}
let fr = class Ae extends Error {
  static from(e, r = {}) {
    return e instanceof Error ? yn(e) ? (r.meta && (e.meta = {
      ...e.meta,
      ...r.meta
    }), e) : new Ae(e.message, {
      ...r,
      cause: e,
      result: null
    }) : new Ae(e.error.message ?? "", {
      ...r,
      cause: void 0,
      result: e
    });
  }
  constructor(e, r) {
    const n = r?.cause;
    super(e, {
      cause: n
    }), this.meta = r?.meta, this.cause = n, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Ae.prototype);
  }
};
function pr(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const r in t) {
    const n = t[r];
    e[n] = r;
  }
  return e;
}
const Qe = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
pr(Qe);
pr(Qe);
const gn = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  METHOD_NOT_SUPPORTED: 405,
  TIMEOUT: 408,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  CLIENT_CLOSED_REQUEST: 499,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501
};
function _n(t) {
  return gn[t] ?? 500;
}
function hr(t) {
  return _n(t.code);
}
const mr = () => {
};
function yr(t, e) {
  return new Proxy(mr, {
    get(n, s) {
      if (!(typeof s != "string" || s === "then"))
        return yr(t, [
          ...e,
          s
        ]);
    },
    apply(n, s, i) {
      const a = e[e.length - 1] === "apply";
      return t({
        args: a ? i.length >= 2 ? i[1] : [] : i,
        path: a ? e.slice(0, -1) : e
      });
    }
  });
}
const Tt = (t) => yr(t, []), Et = (t) => new Proxy(mr, {
  get(e, r) {
    if (!(typeof r != "string" || r === "then"))
      return t(r);
  }
});
function bn(t) {
  const { path: e, error: r, config: n } = t, { code: s } = t.error, i = {
    message: r.message,
    code: Qe[s],
    data: {
      code: s,
      httpStatus: hr(r)
    }
  };
  return n.isDev && typeof t.error.stack == "string" && (i.data.stack = t.error.stack), typeof e == "string" && (i.data.path = e), n.errorFormatter({
    ...t,
    shape: i
  });
}
function Wt(t, e) {
  return "error" in e ? {
    ...e,
    error: t.transformer.output.serialize(e.error)
  } : "data" in e.result ? {
    ...e,
    result: {
      ...e.result,
      data: t.transformer.output.serialize(e.result.data)
    }
  } : e;
}
function vn(t, e) {
  return Array.isArray(e) ? e.map((r) => Wt(t, r)) : Wt(t, e);
}
const wn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createFlatProxy: Et,
  createRecursiveProxy: Tt,
  getErrorShape: bn,
  transformTRPCResponse: vn
}, Symbol.toStringTag, { value: "Module" }));
function xn(t) {
  return typeof FormData > "u" ? !1 : t instanceof FormData;
}
const ut = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function Tn(t) {
  const { direction: e, type: r, path: n, id: s, input: i } = t, a = [], o = [];
  if (t.colorMode === "ansi") {
    const [h, m] = ut.ansi.regular[r], [x, E] = ut.ansi.bold[r], S = "\x1B[0m";
    return a.push(e === "up" ? h : m, e === "up" ? ">>" : "<<", r, e === "up" ? x : E, `#${s}`, n, S), e === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o
    };
  }
  const [c, u] = ut.css[r], l = `
    background-color: #${e === "up" ? c : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(l, `${l}; font-weight: bold;`, `${l}; font-weight: normal;`), e === "up" ? o.push({
    input: i,
    context: t.context
  }) : o.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o
  };
}
const En = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = xn(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = Tn({
    ...r,
    colorMode: e,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    i.join(" ")
  ].concat(a));
};
function kn(t = {}) {
  const { enabled: e = () => !0 } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = En({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => Ye((a) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const l = Date.now() - o;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l,
        result: u
      });
    }
    return i(s).pipe(cr({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(a);
  });
}
let Cn = class {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return dr({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(or());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = lr(r);
    return new Promise((a, o) => {
      e.signal?.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o(fr.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n?.context
    }).subscribe({
      next(i) {
        i.result.type === "started" ? n.onStarted?.() : i.result.type === "stopped" ? n.onStopped?.() : n.onData?.(i.result.data);
      },
      error(i) {
        n.onError?.(i);
      },
      complete() {
        n.onComplete?.();
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
};
const Rn = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, On = (t) => Rn[t];
function Pn(t) {
  return Et((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : Tt(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], i = On(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Sn(t) {
  const e = new Cn(t);
  return Pn(e);
}
function Nn(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function Ln(t) {
  if (t instanceof ue)
    return t;
  const e = new ue({
    code: "INTERNAL_SERVER_ERROR",
    cause: t
  });
  return t instanceof Error && t.stack && (e.stack = t.stack), e;
}
class In extends Error {
}
function jn(t) {
  if (t instanceof Error)
    return t;
  const e = typeof t;
  if (!(e === "undefined" || e === "function" || t === null)) {
    if (e !== "object")
      return new Error(String(t));
    if (Nn(t)) {
      const r = new In();
      for (const n in t)
        r[n] = t[n];
      return r;
    }
  }
}
class ue extends Error {
  constructor(e) {
    const r = jn(e.cause), n = e.message ?? r?.message ?? e.code;
    super(n, {
      cause: r
    }), this.code = e.code, this.name = this.constructor.name;
  }
}
function An(t) {
  return "input" in t ? t : {
    input: t,
    output: t
  };
}
const ye = {
  _default: !0,
  input: {
    serialize: (t) => t,
    deserialize: (t) => t
  },
  output: {
    serialize: (t) => t,
    deserialize: (t) => t
  }
}, ge = ({ shape: t }) => t;
function Mn(t) {
  return Object.assign(/* @__PURE__ */ Object.create(null), t);
}
const $n = [
  "query",
  "mutation",
  "subscription"
];
function Dn(t) {
  return "router" in t._def;
}
const Zn = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: ge,
  transformer: ye
}, Un = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function gr(t) {
  return function(r) {
    const n = new Set(Object.keys(r).filter((c) => Un.includes(c)));
    if (n.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(n).join(", "));
    const s = Mn({});
    function i(c, u = "") {
      for (const [l, h] of Object.entries(c ?? {})) {
        const m = `${u}${l}`;
        if (Dn(h)) {
          i(h._def.procedures, `${m}.`);
          continue;
        }
        if (s[m])
          throw new Error(`Duplicate key: ${m}`);
        s[m] = h;
      }
    }
    i(r);
    const a = {
      _config: t,
      router: !0,
      procedures: s,
      ...Zn,
      record: r,
      queries: Object.entries(s).filter((c) => c[1]._def.query).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {}),
      mutations: Object.entries(s).filter((c) => c[1]._def.mutation).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {}),
      subscriptions: Object.entries(s).filter((c) => c[1]._def.subscription).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {})
    };
    return {
      ...r,
      _def: a,
      createCaller(c) {
        return Tt(({ path: l, args: h }) => {
          if (l.length === 1 && $n.includes(l[0]))
            return Wn({
              procedures: a.procedures,
              path: h[0],
              rawInput: h[1],
              ctx: c,
              type: l[0]
            });
          const m = l.join("."), x = a.procedures[m];
          let E = "query";
          return x._def.mutation ? E = "mutation" : x._def.subscription && (E = "subscription"), x({
            path: m,
            rawInput: h[0],
            ctx: c,
            type: E
          });
        });
      },
      getErrorShape(c) {
        const { path: u, error: l } = c, { code: h } = c.error, m = {
          message: l.message,
          code: Qe[h],
          data: {
            code: h,
            httpStatus: hr(l)
          }
        };
        return t.isDev && typeof c.error.stack == "string" && (m.data.stack = c.error.stack), typeof u == "string" && (m.data.path = u), this._def._config.errorFormatter({
          ...c,
          shape: m
        });
      }
    };
  };
}
function Wn(t) {
  const { type: e, path: r } = t;
  if (!(r in t.procedures) || !t.procedures[r]?._def[e])
    throw new ue({
      code: "NOT_FOUND",
      message: `No "${e}"-procedure on path "${r}"`
    });
  const n = t.procedures[r];
  return n(t);
}
const qt = typeof window > "u" || "Deno" in window || globalThis.process?.env?.NODE_ENV === "test" || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;
function zt(t) {
  const e = t;
  if (typeof e == "function")
    return e;
  if (typeof e.parseAsync == "function")
    return e.parseAsync.bind(e);
  if (typeof e.parse == "function")
    return e.parse.bind(e);
  if (typeof e.validateSync == "function")
    return e.validateSync.bind(e);
  if (typeof e.create == "function")
    return e.create.bind(e);
  if (typeof e.assert == "function")
    return (r) => (e.assert(r), r);
  throw new Error("Could not find a validator fn");
}
function _r(t, ...e) {
  const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
  for (const n of e)
    for (const s in n) {
      if (s in r && r[s] !== n[s])
        throw new Error(`Duplicate key ${s}`);
      r[s] = n[s];
    }
  return r;
}
function qn() {
  function t(r) {
    return {
      _middlewares: r,
      unstable_pipe(n) {
        const s = "_middlewares" in n ? n._middlewares : [
          n
        ];
        return t([
          ...r,
          ...s
        ]);
      }
    };
  }
  function e(r) {
    return t([
      r
    ]);
  }
  return e;
}
function Vt(t) {
  return t && typeof t == "object" && !Array.isArray(t);
}
function zn(t) {
  const e = async ({ next: r, rawInput: n, input: s }) => {
    let i;
    try {
      i = await t(n);
    } catch (o) {
      throw new ue({
        code: "BAD_REQUEST",
        cause: o
      });
    }
    const a = Vt(s) && Vt(i) ? {
      ...s,
      ...i
    } : i;
    return r({
      input: a
    });
  };
  return e._type = "input", e;
}
function Vn(t) {
  const e = async ({ next: r }) => {
    const n = await r();
    if (!n.ok)
      return n;
    try {
      const s = await t(n.data);
      return {
        ...n,
        data: s
      };
    } catch (s) {
      throw new ue({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: s
      });
    }
  };
  return e._type = "output", e;
}
const br = "middlewareMarker";
function ae(t, e) {
  const { middlewares: r = [], inputs: n, meta: s, ...i } = e;
  return vr({
    ..._r(t, i),
    inputs: [
      ...t.inputs,
      ...n ?? []
    ],
    middlewares: [
      ...t.middlewares,
      ...r
    ],
    meta: t.meta && s ? {
      ...t.meta,
      ...s
    } : s ?? t.meta
  });
}
function vr(t = {}) {
  const e = {
    inputs: [],
    middlewares: [],
    ...t
  };
  return {
    _def: e,
    input(r) {
      const n = zt(r);
      return ae(e, {
        inputs: [
          r
        ],
        middlewares: [
          zn(n)
        ]
      });
    },
    output(r) {
      const n = zt(r);
      return ae(e, {
        output: r,
        middlewares: [
          Vn(n)
        ]
      });
    },
    meta(r) {
      return ae(e, {
        meta: r
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(r) {
      return ae(e, r._def);
    },
    use(r) {
      const n = "_middlewares" in r ? r._middlewares : [
        r
      ];
      return ae(e, {
        middlewares: n
      });
    },
    query(r) {
      return lt({
        ...e,
        query: !0
      }, r);
    },
    mutation(r) {
      return lt({
        ...e,
        mutation: !0
      }, r);
    },
    subscription(r) {
      return lt({
        ...e,
        subscription: !0
      }, r);
    }
  };
}
function lt(t, e) {
  const r = ae(t, {
    resolver: e,
    middlewares: [
      async function(s) {
        const i = await e(s);
        return {
          marker: br,
          ok: !0,
          data: i,
          ctx: s.ctx
        };
      }
    ]
  });
  return Hn(r._def);
}
const Bn = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
function Hn(t) {
  const e = async function(n) {
    if (!n || !("rawInput" in n))
      throw new Error(Bn);
    const s = async (a = {
      index: 0,
      ctx: n.ctx
    }) => {
      try {
        const o = t.middlewares[a.index];
        return await o({
          ctx: a.ctx,
          type: n.type,
          path: n.path,
          rawInput: a.rawInput ?? n.rawInput,
          meta: t.meta,
          input: a.input,
          next(u) {
            const l = u;
            return s({
              index: a.index + 1,
              ctx: l && "ctx" in l ? {
                ...a.ctx,
                ...l.ctx
              } : a.ctx,
              input: l && "input" in l ? l.input : a.input,
              rawInput: l && "rawInput" in l ? l.rawInput : a.rawInput
            });
          }
        });
      } catch (o) {
        return {
          ok: !1,
          error: Ln(o),
          marker: br
        };
      }
    }, i = await s();
    if (!i)
      throw new ue({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!i.ok)
      throw i.error;
    return i.data;
  };
  return e._def = t, e.meta = t.meta, e;
}
function Fn(...t) {
  const e = _r({}, ...t.map((i) => i._def.record)), r = t.reduce((i, a) => {
    if (a._def._config.errorFormatter && a._def._config.errorFormatter !== ge) {
      if (i !== ge && i !== a._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return a._def._config.errorFormatter;
    }
    return i;
  }, ge), n = t.reduce((i, a) => {
    if (a._def._config.transformer && a._def._config.transformer !== ye) {
      if (i !== ye && i !== a._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return a._def._config.transformer;
    }
    return i;
  }, ye);
  return gr({
    errorFormatter: r,
    transformer: n,
    isDev: t.some((i) => i._def._config.isDev),
    allowOutsideOfServer: t.some((i) => i._def._config.allowOutsideOfServer),
    isServer: t.some((i) => i._def._config.isServer),
    $types: t[0]?._def._config.$types
  })(e);
}
class Ze {
  context() {
    return new Ze();
  }
  meta() {
    return new Ze();
  }
  create(e) {
    return Gn()(e);
  }
}
const Jn = new Ze();
function Gn() {
  return function(e) {
    const r = e?.errorFormatter ?? ge, s = {
      transformer: An(e?.transformer ?? ye),
      isDev: e?.isDev ?? globalThis.process?.env?.NODE_ENV !== "production",
      allowOutsideOfServer: e?.allowOutsideOfServer ?? !1,
      errorFormatter: r,
      isServer: e?.isServer ?? qt,
      /**
      * @internal
      */
      $types: Et((i) => {
        throw new Error(`Tried to access "$types.${i}" which is not available at runtime`);
      })
    };
    if (!(e?.isServer ?? qt) && e?.allowOutsideOfServer !== !0)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: s,
      /**
      * Builder object for creating procedures
      */
      procedure: vr({
        meta: e?.defaultMeta
      }),
      /**
      * Create reusable middlewares
      */
      middleware: qn(),
      /**
      * Create a router
      */
      router: gr(s),
      /**
      * Merge Routers
      */
      mergeRouters: Fn
    };
  };
}
var yt = {}, Xe = {}, fe = {}, O = {};
const pe = /* @__PURE__ */ ir(hn);
var kt = {}, wr = pe;
function xr(t) {
  return wr.observable((e) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function Bt(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function Yn(t) {
  return (e) => {
    const r = Bt(t.true).map((s) => s(e)), n = Bt(t.false).map((s) => s(e));
    return (s) => wr.observable((i) => {
      const a = t.condition(s.op) ? r : n;
      return xr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
kt.createChain = xr;
kt.splitLink = Yn;
var he = {};
function Qn(t) {
  return t instanceof Tr || /**
  * @deprecated
  * Delete in next major
  */
  t.name === "TRPCClientError";
}
let Tr = class Me extends Error {
  static from(e, r = {}) {
    return e instanceof Error ? Qn(e) ? (r.meta && (e.meta = {
      ...e.meta,
      ...r.meta
    }), e) : new Me(e.message, {
      ...r,
      cause: e,
      result: null
    }) : new Me(e.error.message ?? "", {
      ...r,
      cause: void 0,
      result: e
    });
  }
  constructor(e, r) {
    const n = r?.cause;
    super(e, {
      cause: n
    }), this.meta = r?.meta, this.cause = n, this.shape = r?.result?.error, this.data = r?.result?.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Me.prototype);
  }
};
he.TRPCClientError = Tr;
const Xn = /* @__PURE__ */ ir(wn);
var q = {}, Kn = he;
const Ht = (t) => typeof t == "function";
function Er(t) {
  if (t)
    return t;
  if (typeof window < "u" && Ht(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && Ht(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function es(t) {
  return t || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function ts(t) {
  return {
    url: t.url,
    fetch: t.fetch,
    AbortController: es(t.AbortController)
  };
}
function rs(t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    e[r] = n;
  }
  return e;
}
const ns = {
  query: "GET",
  mutation: "POST"
};
function kr(t) {
  return "input" in t ? t.runtime.transformer.serialize(t.input) : rs(t.inputs.map((e) => t.runtime.transformer.serialize(e)));
}
const Cr = (t) => {
  let e = t.url + "/" + t.path;
  const r = [];
  if ("inputs" in t && r.push("batch=1"), t.type === "query") {
    const n = kr(t);
    n !== void 0 && r.push(`input=${encodeURIComponent(JSON.stringify(n))}`);
  }
  return r.length && (e += "?" + r.join("&")), e;
}, Rr = (t) => {
  if (t.type === "query")
    return;
  const e = kr(t);
  return e !== void 0 ? JSON.stringify(e) : void 0;
}, ss = (t) => Pr({
  ...t,
  contentTypeHeader: "application/json",
  getUrl: Cr,
  getBody: Rr
});
async function Or(t, e) {
  const r = t.getUrl(t), n = t.getBody(t), { type: s } = t, i = await t.headers();
  /* istanbul ignore if -- @preserve */
  if (s === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const a = {
    ...t.contentTypeHeader ? {
      "content-type": t.contentTypeHeader
    } : {},
    ...t.batchModeHeader ? {
      "trpc-batch-mode": t.batchModeHeader
    } : {},
    ...i
  };
  return Er(t.fetch)(r, {
    method: ns[s],
    signal: e?.signal,
    body: n,
    headers: a
  });
}
function Pr(t) {
  const e = t.AbortController ? new t.AbortController() : null, r = {};
  return {
    promise: new Promise((i, a) => {
      Or(t, e).then((o) => (r.response = o, o.json())).then((o) => {
        r.responseJSON = o, i({
          json: o,
          meta: r
        });
      }).catch((o) => {
        a(Kn.TRPCClientError.from(o, {
          meta: r
        }));
      });
    }),
    cancel: () => {
      e?.abort();
    }
  };
}
q.fetchHTTPResponse = Or;
q.getBody = Rr;
q.getFetch = Er;
q.getUrl = Cr;
q.httpRequest = Pr;
q.jsonHttpRequester = ss;
q.resolveHTTPLinkOptions = ts;
var Ct = {}, Ke = {};
function Ft(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function is(t, e) {
  if ("error" in t) {
    const n = e.transformer.deserialize(t.error);
    return {
      ok: !1,
      error: {
        ...t,
        error: n
      }
    };
  }
  return {
    ok: !0,
    result: {
      ...t.result,
      ...(!t.result.type || t.result.type === "data") && {
        type: "data",
        data: e.transformer.deserialize(t.result.data)
      }
    }
  };
}
class dt extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
}
function as(t, e) {
  let r;
  try {
    r = is(t, e);
  } catch {
    throw new dt();
  }
  if (!r.ok && (!Ft(r.error.error) || typeof r.error.error.code != "number"))
    throw new dt();
  if (r.ok && !Ft(r.result))
    throw new dt();
  return r;
}
Ke.transformResult = as;
var os = pe, cs = Ke, Jt = he, gt = q;
const ft = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function pt(t) {
  let e = null, r = null;
  const n = () => {
    clearTimeout(r), r = null, e = null;
  };
  function s(o) {
    const c = [
      []
    ];
    let u = 0;
    for (; ; ) {
      const l = o[u];
      if (!l)
        break;
      const h = c[c.length - 1];
      if (l.aborted) {
        l.reject?.(new Error("Aborted")), u++;
        continue;
      }
      if (t.validate(h.concat(l).map((x) => x.key))) {
        h.push(l), u++;
        continue;
      }
      if (h.length === 0) {
        l.reject?.(new Error("Input is too big for a single dispatch")), u++;
        continue;
      }
      c.push([]);
    }
    return c;
  }
  function i() {
    const o = s(e);
    n();
    for (const c of o) {
      if (!c.length)
        continue;
      const u = {
        items: c,
        cancel: ft
      };
      for (const x of c)
        x.batch = u;
      const l = (x, E) => {
        const S = u.items[x];
        S.resolve?.(E), S.batch = null, S.reject = null, S.resolve = null;
      }, { promise: h, cancel: m } = t.fetch(u.items.map((x) => x.key), l);
      u.cancel = m, h.then((x) => {
        for (let E = 0; E < x.length; E++) {
          const S = x[E];
          l(E, S);
        }
        for (const E of u.items)
          E.reject?.(new Error("Missing result")), E.batch = null;
      }).catch((x) => {
        for (const E of u.items)
          E.reject?.(x), E.batch = null;
      });
    }
  }
  function a(o) {
    const c = {
      aborted: !1,
      key: o,
      batch: null,
      resolve: ft,
      reject: ft
    }, u = new Promise((h, m) => {
      c.reject = m, c.resolve = h, e || (e = []), e.push(c);
    });
    return r || (r = setTimeout(i)), {
      promise: u,
      cancel: () => {
        c.aborted = !0, c.batch?.items.every((h) => h.aborted) && (c.batch.cancel(), c.batch = null);
      }
    };
  }
  return {
    load: a
  };
}
function Sr(t) {
  return function(r) {
    const n = gt.resolveHTTPLinkOptions(r), s = r.maxURLLength ?? 1 / 0;
    return (i) => {
      const a = (h) => {
        const m = (E) => {
          if (s === 1 / 0)
            return !0;
          const S = E.map((z) => z.path).join(","), ne = E.map((z) => z.input);
          return gt.getUrl({
            ...n,
            runtime: i,
            type: h,
            path: S,
            inputs: ne
          }).length <= s;
        }, x = t({
          ...n,
          runtime: i,
          type: h,
          opts: r
        });
        return {
          validate: m,
          fetch: x
        };
      }, o = pt(a("query")), c = pt(a("mutation")), u = pt(a("subscription")), l = {
        query: o,
        subscription: u,
        mutation: c
      };
      return ({ op: h }) => os.observable((m) => {
        const x = l[h.type], { promise: E, cancel: S } = x.load(h);
        let ne;
        return E.then((j) => {
          ne = j;
          const z = cs.transformResult(j.json, i);
          if (!z.ok) {
            m.error(Jt.TRPCClientError.from(z.error, {
              meta: j.meta
            }));
            return;
          }
          m.next({
            context: j.meta,
            result: z.result
          }), m.complete();
        }).catch((j) => {
          m.error(Jt.TRPCClientError.from(j, {
            meta: ne?.meta
          }));
        }), () => {
          S();
        };
      });
    };
  };
}
const us = (t) => (e) => {
  const r = e.map((a) => a.path).join(","), n = e.map((a) => a.input), { promise: s, cancel: i } = gt.jsonHttpRequester({
    ...t,
    path: r,
    inputs: n,
    headers() {
      return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
        opList: e
      }) : t.opts.headers : {};
    }
  });
  return {
    promise: s.then((a) => (Array.isArray(a.json) ? a.json : e.map(() => a.json)).map((u) => ({
      meta: a.meta,
      json: u
    }))),
    cancel: i
  };
}, ls = Sr(us);
Ct.createHTTPBatchLink = Sr;
Ct.httpBatchLink = ls;
var et = {};
Object.defineProperty(et, "__esModule", { value: !0 });
var ds = pe, fs = Ke, Gt = he, Nr = q;
function Lr(t) {
  return (e) => {
    const r = Nr.resolveHTTPLinkOptions(e);
    return (n) => ({ op: s }) => ds.observable((i) => {
      const { path: a, input: o, type: c } = s, { promise: u, cancel: l } = t.requester({
        ...r,
        runtime: n,
        type: c,
        path: a,
        input: o,
        headers() {
          return e.headers ? typeof e.headers == "function" ? e.headers({
            op: s
          }) : e.headers : {};
        }
      });
      let h;
      return u.then((m) => {
        h = m.meta;
        const x = fs.transformResult(m.json, n);
        if (!x.ok) {
          i.error(Gt.TRPCClientError.from(x.error, {
            meta: h
          }));
          return;
        }
        i.next({
          context: m.meta,
          result: x.result
        }), i.complete();
      }).catch((m) => {
        i.error(Gt.TRPCClientError.from(m, {
          meta: h
        }));
      }), () => {
        l();
      };
    });
  };
}
const ps = Lr({
  requester: Nr.jsonHttpRequester
});
et.httpLink = ps;
et.httpLinkFactory = Lr;
var Rt = {};
Object.defineProperty(Rt, "__esModule", { value: !0 });
var Yt = pe;
function hs(t) {
  return typeof FormData > "u" ? !1 : t instanceof FormData;
}
const ht = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function ms(t) {
  const { direction: e, type: r, path: n, id: s, input: i } = t, a = [], o = [];
  if (t.colorMode === "ansi") {
    const [h, m] = ht.ansi.regular[r], [x, E] = ht.ansi.bold[r], S = "\x1B[0m";
    return a.push(e === "up" ? h : m, e === "up" ? ">>" : "<<", r, e === "up" ? x : E, `#${s}`, n, S), e === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o
    };
  }
  const [c, u] = ht.css[r], l = `
    background-color: #${e === "up" ? c : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(l, `${l}; font-weight: bold;`, `${l}; font-weight: normal;`), e === "up" ? o.push({
    input: i,
    context: t.context
  }) : o.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o
  };
}
const ys = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = hs(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = ms({
    ...r,
    colorMode: e,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    i.join(" ")
  ].concat(a));
};
function gs(t = {}) {
  const { enabled: e = () => !0 } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = ys({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => Yt.observable((a) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const l = Date.now() - o;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l,
        result: u
      });
    }
    return i(s).pipe(Yt.tap({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(a);
  });
}
Rt.loggerLink = gs;
var tt = {};
Object.defineProperty(tt, "__esModule", { value: !0 });
var _s = pe, bs = Ke, Ir = he;
/* istanbul ignore next -- @preserve */
const vs = (t) => t === 0 ? 0 : Math.min(1e3 * 2 ** t, 3e4);
function ws(t) {
  const { url: e, WebSocket: r = WebSocket, retryDelayMs: n = vs, onOpen: s, onClose: i } = t;
  /* istanbul ignore next -- @preserve */
  if (!r)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let a = [];
  const o = /* @__PURE__ */ Object.create(null);
  let c = 0, u = null, l = null, h = jt(), m = "connecting";
  function x() {
    m !== "open" || u || (u = setTimeout(() => {
      u = null, a.length === 1 ? h.send(JSON.stringify(a.pop())) : h.send(JSON.stringify(a)), a = [];
    }));
  }
  function E() {
    if (l !== null || m === "closed")
      return;
    const R = n(c++);
    ne(R);
  }
  function S() {
    m = "connecting";
    const R = h;
    h = jt(), j(R);
  }
  function ne(R) {
    l || (m = "connecting", l = setTimeout(S, R));
  }
  function j(R) {
    Object.values(o).some((se) => se.ws === R) || R.close();
  }
  function z() {
    Object.values(o).forEach((R) => {
      R.type === "subscription" && R.callbacks.complete();
    });
  }
  function It(R) {
    a.some((P) => P.id === R.op.id) || At(R.op, R.callbacks);
  }
  function jt() {
    const R = typeof e == "function" ? e() : e, P = new r(R);
    clearTimeout(l), l = null, P.addEventListener("open", () => {
      /* istanbul ignore next -- @preserve */
      P === h && (c = 0, m = "open", s?.(), x());
    }), P.addEventListener("error", () => {
      P === h && E();
    });
    const se = (I) => {
      if (I.method === "reconnect" && P === h) {
        m === "open" && i?.(), S();
        for (const k of Object.values(o))
          k.type === "subscription" && It(k);
      }
    }, ot = (I) => {
      const k = I.id !== null && o[I.id];
      if (k) {
        if (k.callbacks.next?.(I), k.ws !== h && P === h) {
          const V = k.ws;
          k.ws = h, j(V);
        }
        "result" in I && I.result.type === "stopped" && P === h && k.callbacks.complete();
      }
    };
    return P.addEventListener("message", ({ data: I }) => {
      const k = JSON.parse(I);
      "method" in k ? se(k) : ot(k), (P !== h || m === "closed") && j(P);
    }), P.addEventListener("close", ({ code: I }) => {
      m === "open" && i?.({
        code: I
      }), h === P && E();
      for (const [k, V] of Object.entries(o))
        if (V.ws === P) {
          if (m === "closed") {
            delete o[k], V.callbacks.complete?.();
            continue;
          }
          V.type === "subscription" ? It(V) : (delete o[k], V.callbacks.error?.(Ir.TRPCClientError.from(new Ot("WebSocket closed prematurely"))));
        }
    }), P;
  }
  function At(R, P) {
    const { type: se, input: ot, path: I, id: k } = R, V = {
      id: k,
      method: se,
      params: {
        input: ot,
        path: I
      }
    };
    return o[k] = {
      ws: h,
      type: se,
      callbacks: P,
      op: R
    }, a.push(V), x(), () => {
      const en = o[k]?.callbacks;
      delete o[k], a = a.filter((tn) => tn.id !== k), en?.complete?.(), h.readyState === r.OPEN && R.type === "subscription" && (a.push({
        id: k,
        method: "subscription.stop"
      }), x());
    };
  }
  return {
    close: () => {
      m = "closed", i?.(), z(), j(h), clearTimeout(l), l = null;
    },
    request: At,
    getConnection() {
      return h;
    }
  };
}
class Ot extends Error {
  constructor(e) {
    super(e), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, Ot.prototype);
  }
}
function xs(t) {
  return (e) => {
    const { client: r } = t;
    return ({ op: n }) => _s.observable((s) => {
      const { type: i, path: a, id: o, context: c } = n, u = e.transformer.serialize(n.input), l = r.request({
        type: i,
        path: a,
        input: u,
        id: o,
        context: c
      }, {
        error(h) {
          s.error(h), l();
        },
        complete() {
          s.complete();
        },
        next(h) {
          const m = bs.transformResult(h, e);
          if (!m.ok) {
            s.error(Ir.TRPCClientError.from(m.error));
            return;
          }
          s.next({
            result: m.result
          }), n.type !== "subscription" && (l(), s.complete());
        }
      });
      return () => {
        l();
      };
    });
  };
}
tt.createWSClient = ws;
tt.wsLink = xs;
Object.defineProperty(O, "__esModule", { value: !0 });
var Qt = pe, jr = kt, Ar = he, Xt = Xn, _e = q, Mr = Ct, Pt = et, Ts = Rt, $r = tt;
class rt {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return jr.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(Qt.share());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = Qt.observableToPromise(r);
    return new Promise((a, o) => {
      e.signal?.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o(Ar.TRPCClientError.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n?.context,
      signal: n?.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n?.context
    }).subscribe({
      next(i) {
        i.result.type === "started" ? n.onStarted?.() : i.result.type === "stopped" ? n.onStopped?.() : n.onData?.(i.result.data);
      },
      error(i) {
        n.onError?.(i);
      },
      complete() {
        n.onComplete?.();
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
}
function Es(t) {
  return new rt(t);
}
function ks(t) {
  return new rt(t);
}
const Cs = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
}, Dr = (t) => Cs[t];
function Zr(t) {
  return Xt.createFlatProxy((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : Xt.createRecursiveProxy(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], i = Dr(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Rs(t) {
  const e = new rt(t);
  return Zr(e);
}
function Os(t) {
  return t.__untypedClient;
}
function Ps(t) {
  if (t)
    return t;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function Ss(t) {
  const e = t.parse ?? JSON.parse, r = (n) => {
    if (t.signal?.aborted || !n || n === "}")
      return;
    const s = n.indexOf(":"), i = n.substring(2, s - 1), a = n.substring(s + 1);
    t.onSingle(Number(i), e(a));
  };
  await Ns(t.readableStream, r, t.textDecoder);
}
async function Ns(t, e, r) {
  let n = "";
  const s = (i) => {
    const o = r.decode(i).split(`
`);
    if (o.length === 1)
      n += o[0];
    else if (o.length > 1) {
      e(n + o[0]);
      for (let c = 1; c < o.length - 1; c++)
        e(o[c]);
      n = o[o.length - 1];
    }
  };
  "getReader" in t ? await Is(t, s) : await Ls(t, s), e(n);
}
function Ls(t, e) {
  return new Promise((r) => {
    t.on("data", e), t.on("end", r);
  });
}
async function Is(t, e) {
  const r = t.getReader();
  let n = await r.read();
  for (; !n.done; )
    e(n.value), n = await r.read();
}
const js = (t, e) => {
  const r = t.AbortController ? new t.AbortController() : null, n = _e.fetchHTTPResponse({
    ...t,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: _e.getUrl,
    getBody: _e.getBody
  }, r), s = () => r?.abort(), i = n.then(async (a) => {
    if (!a.body)
      throw new Error("Received response without body");
    const o = {
      response: a
    };
    return Ss({
      readableStream: a.body,
      onSingle: e,
      parse: (c) => ({
        json: JSON.parse(c),
        meta: o
      }),
      signal: r?.signal,
      textDecoder: t.textDecoder
    });
  });
  return {
    cancel: s,
    promise: i
  };
}, As = (t) => {
  const e = Ps(t.opts.textDecoder);
  return (r, n) => {
    const s = r.map((c) => c.path).join(","), i = r.map((c) => c.input), { cancel: a, promise: o } = js({
      ...t,
      textDecoder: e,
      path: s,
      inputs: i,
      headers() {
        return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
          opList: r
        }) : t.opts.headers : {};
      }
    }, (c, u) => {
      n(c, u);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: o.then(() => []),
      cancel: a
    };
  };
}, Ms = Mr.createHTTPBatchLink(As), $s = (t) => {
  if ("input" in t) {
    if (!(t.input instanceof FormData))
      throw new Error("Input is not FormData");
    return t.input;
  }
}, Ds = (t) => {
  if (t.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return _e.httpRequest({
    ...t,
    getUrl() {
      return `${t.url}/${t.path}`;
    },
    getBody: $s
  });
}, Zs = Pt.httpLinkFactory({
  requester: Ds
});
O.splitLink = jr.splitLink;
O.TRPCClientError = Ar.TRPCClientError;
O.getFetch = _e.getFetch;
O.httpBatchLink = Mr.httpBatchLink;
O.httpLink = Pt.httpLink;
O.httpLinkFactory = Pt.httpLinkFactory;
O.loggerLink = Ts.loggerLink;
O.createWSClient = $r.createWSClient;
O.wsLink = $r.wsLink;
O.TRPCUntypedClient = rt;
O.clientCallTypeToProcedureType = Dr;
O.createTRPCClient = ks;
O.createTRPCClientProxy = Zr;
O.createTRPCProxyClient = Rs;
O.createTRPCUntypedClient = Es;
O.experimental_formDataLink = Zs;
O.getUntypedClient = Os;
O.unstable_httpBatchStreamLink = Ms;
var X = {}, St = {};
function Us(t) {
  return t;
}
function Ws(t) {
  return t.length === 0 ? Us : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function qs(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function zs(t) {
  const e = {
    subscribe(r) {
      let n = null, s = !1, i = !1, a = !1;
      function o() {
        if (n === null) {
          a = !0;
          return;
        }
        i || (i = !0, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          s || r.next?.(c);
        },
        error(c) {
          s || (s = !0, r.error?.(c), o());
        },
        complete() {
          s || (s = !0, r.complete?.(), o());
        }
      }), a && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return Ws(r)(e);
    }
  };
  return e;
}
St.isObservable = qs;
St.observable = zs;
Object.defineProperty(X, "__esModule", { value: !0 });
var Ur = St;
function Vs(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e.subscribe({
        next(o) {
          for (const c of s)
            c.next?.(o);
        },
        error(o) {
          for (const c of s)
            c.error?.(o);
        },
        complete() {
          for (const o of s)
            o.complete?.();
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function Bs(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(i) {
          r.next?.(t(i, n++));
        },
        error(i) {
          r.error?.(i);
        },
        complete() {
          r.complete?.();
        }
      });
    }
  });
}
function Hs(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          t.next?.(n), r.next?.(n);
        },
        error(n) {
          t.error?.(n), r.error?.(n);
        },
        complete() {
          t.complete?.(), r.complete?.();
        }
      });
    }
  });
}
class Nt extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, Nt.prototype);
  }
}
function Fs(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let i = !1;
      function a() {
        i || (i = !0, s(new Nt("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          i = !0, n(c), a();
        },
        error(c) {
          i = !0, s(c), a();
        },
        complete() {
          i = !0, a();
        }
      });
      e = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
X.isObservable = Ur.isObservable;
X.observable = Ur.observable;
X.map = Bs;
X.observableToPromise = Fs;
X.share = Vs;
X.tap = Hs;
var Z = {};
Object.defineProperty(Z, "__esModule", { value: !0 });
Z.isTRPCRequestWithId = Z.isTRPCRequest = Z.isTRPCResponse = Z.isTRPCMessage = void 0;
function Kt(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function Js(t) {
  return t == null;
}
function Wr(t) {
  return !!(Kt(t) && "trpc" in t && Kt(t.trpc));
}
Z.isTRPCMessage = Wr;
function Lt(t) {
  return Wr(t) && "id" in t.trpc && !Js(t.trpc.id);
}
function Gs(t) {
  return Lt(t) && ("error" in t.trpc || "result" in t.trpc);
}
Z.isTRPCResponse = Gs;
function qr(t) {
  return Lt(t) && "method" in t.trpc;
}
Z.isTRPCRequest = qr;
function Ys(t) {
  return qr(t) && Lt(t);
}
Z.isTRPCRequestWithId = Ys;
Object.defineProperty(fe, "__esModule", { value: !0 });
fe.createBaseLink = void 0;
const mt = O, Qs = X, Xs = Z, Ks = (t) => (e) => ({ op: r }) => (0, Qs.observable)((n) => {
  const s = [], { id: i, type: a, path: o } = r;
  try {
    const c = e.transformer.serialize(r.input), u = () => {
      n.error(new mt.TRPCClientError("Port disconnected prematurely"));
    };
    t.addCloseListener(u), s.push(() => t.removeCloseListener(u));
    const l = (h) => {
      if (!(0, Xs.isTRPCResponse)(h))
        return;
      const { trpc: m } = h;
      if (i === m.id) {
        if ("error" in m) {
          const x = e.transformer.deserialize(m.error);
          n.error(mt.TRPCClientError.from(Object.assign(Object.assign({}, m), { error: x })));
          return;
        }
        n.next({
          result: Object.assign(Object.assign({}, m.result), (!m.result.type || m.result.type === "data") && {
            type: "data",
            data: e.transformer.deserialize(m.result.data)
          })
        }), (a !== "subscription" || m.result.type === "stopped") && n.complete();
      }
    };
    t.addMessageListener(l), s.push(() => t.removeMessageListener(l)), t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: a,
        params: { path: o, input: c }
      }
    });
  } catch (c) {
    n.error(new mt.TRPCClientError(c instanceof Error ? c.message : "Unknown error"));
  }
  return () => {
    a === "subscription" && t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), s.forEach((c) => c());
  };
});
fe.createBaseLink = Ks;
Object.defineProperty(Xe, "__esModule", { value: !0 });
Xe.chromeLink = void 0;
const ei = fe, ti = (t) => (0, ei.createBaseLink)({
  postMessage(e) {
    t.port.postMessage(e);
  },
  addMessageListener(e) {
    t.port.onMessage.addListener(e);
  },
  removeMessageListener(e) {
    t.port.onMessage.removeListener(e);
  },
  addCloseListener(e) {
    t.port.onDisconnect.addListener(e);
  },
  removeCloseListener(e) {
    t.port.onDisconnect.removeListener(e);
  }
});
Xe.chromeLink = ti;
var nt = {};
Object.defineProperty(nt, "__esModule", { value: !0 });
nt.windowLink = void 0;
const ri = fe, ni = (t) => {
  var e;
  const r = /* @__PURE__ */ new Map(), n = t.window, s = (e = t.postWindow) !== null && e !== void 0 ? e : n;
  return (0, ri.createBaseLink)({
    postMessage(i) {
      s.postMessage(i, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(i) {
      const a = (o) => {
        i(o.data);
      };
      r.set(i, a), n.addEventListener("message", a);
    },
    removeMessageListener(i) {
      const a = r.get(i);
      a && n.removeEventListener("message", a);
    },
    addCloseListener(i) {
      n.addEventListener("beforeunload", i);
    },
    removeCloseListener(i) {
      n.removeEventListener("beforeunload", i);
    }
  });
};
nt.windowLink = ni;
var st = {}, it = {};
Object.defineProperty(it, "__esModule", { value: !0 });
it.TRPC_BROWSER_LOADED_EVENT = void 0;
it.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(st, "__esModule", { value: !0 });
st.popupLink = void 0;
const si = it, ii = fe, ai = (t) => {
  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();
  let n = null;
  async function s(i) {
    if (!n || n.closed) {
      n = t.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((a) => {
          var o;
          try {
            (o = n?.addEventListener) === null || o === void 0 || o.call(n, "load", a);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((a) => {
          i.addEventListener("message", (o) => {
            o.data === si.TRPC_BROWSER_LOADED_EVENT && a();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((a) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(a, 15e3);
        })
      ]);
      try {
        if (!n.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        n.addEventListener("beforeunload", () => {
          n = null;
        });
      } catch {
        const o = setInterval(() => {
          n && n.closed && (n = null, r.forEach((c) => {
            c();
          }), clearInterval(o));
        }, 1e3);
      }
    }
    return n;
  }
  return (0, ii.createBaseLink)({
    async postMessage(i) {
      return (await s(t.listenWindow)).postMessage(i, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(i) {
      const a = (o) => {
        i(o.data);
      };
      e.set(i, a), t.listenWindow.addEventListener("message", a);
    },
    removeMessageListener(i) {
      const a = e.get(i);
      a && t.listenWindow.removeEventListener("message", a);
    },
    addCloseListener(i) {
      t.listenWindow.addEventListener("beforeunload", i), r.add(i);
    },
    removeCloseListener(i) {
      t.listenWindow.removeEventListener("beforeunload", i), r.delete(i);
    }
  });
};
st.popupLink = ai;
(function(t) {
  var e = Ie && Ie.__createBinding || (Object.create ? function(n, s, i, a) {
    a === void 0 && (a = i);
    var o = Object.getOwnPropertyDescriptor(s, i);
    (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
      return s[i];
    } }), Object.defineProperty(n, a, o);
  } : function(n, s, i, a) {
    a === void 0 && (a = i), n[a] = s[i];
  }), r = Ie && Ie.__exportStar || function(n, s) {
    for (var i in n)
      i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Xe, t), r(nt, t), r(st, t);
})(yt);
var T;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function r(s) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (s) => {
    const i = {};
    for (const a of s)
      i[a] = a;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), a = {};
    for (const o of i)
      a[o] = s[o];
    return t.objectValues(a);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const a in s)
      Object.prototype.hasOwnProperty.call(s, a) && i.push(a);
    return i;
  }, t.find = (s, i) => {
    for (const a of s)
      if (i(a))
        return a;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function n(s, i = " | ") {
    return s.map((a) => typeof a == "string" ? `'${a}'` : a).join(i);
  }
  t.joinValues = n, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(T || (T = {}));
const p = T.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), G = (t) => {
  switch (typeof t) {
    case "undefined":
      return p.undefined;
    case "string":
      return p.string;
    case "number":
      return isNaN(t) ? p.nan : p.number;
    case "boolean":
      return p.boolean;
    case "function":
      return p.function;
    case "bigint":
      return p.bigint;
    case "symbol":
      return p.symbol;
    case "object":
      return Array.isArray(t) ? p.array : t === null ? p.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? p.promise : typeof Map < "u" && t instanceof Map ? p.map : typeof Set < "u" && t instanceof Set ? p.set : typeof Date < "u" && t instanceof Date ? p.date : p.object;
    default:
      return p.unknown;
  }
}, d = T.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), oi = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class B extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(i) {
      return i.message;
    }, n = { _errors: [] }, s = (i) => {
      for (const a of i.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(s);
        else if (a.code === "invalid_return_type")
          s(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          s(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let o = n, c = 0;
          for (; c < a.path.length; ) {
            const u = a.path[c];
            c === a.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(r(a))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return s(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, T.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const s of this.issues)
      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n.push(e(s));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
B.create = (t) => new B(t);
const ve = (t, e) => {
  let r;
  switch (t.code) {
    case d.invalid_type:
      t.received === p.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case d.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, T.jsonStringifyReplacer)}`;
      break;
    case d.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${T.joinValues(t.keys, ", ")}`;
      break;
    case d.invalid_union:
      r = "Invalid input";
      break;
    case d.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${T.joinValues(t.options)}`;
      break;
    case d.invalid_enum_value:
      r = `Invalid enum value. Expected ${T.joinValues(t.options)}, received '${t.received}'`;
      break;
    case d.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case d.invalid_return_type:
      r = "Invalid function return type";
      break;
    case d.invalid_date:
      r = "Invalid date";
      break;
    case d.invalid_string:
      typeof t.validation == "object" ? "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : T.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case d.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(t.minimum)}` : r = "Invalid input";
      break;
    case d.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(t.maximum)}` : r = "Invalid input";
      break;
    case d.custom:
      r = "Invalid input";
      break;
    case d.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case d.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case d.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, T.assertNever(t);
  }
  return { message: r };
};
let zr = ve;
function ci(t) {
  zr = t;
}
function Ue() {
  return zr;
}
const We = (t) => {
  const { data: e, path: r, errorMaps: n, issueData: s } = t, i = [...r, ...s.path || []], a = {
    ...s,
    path: i
  };
  let o = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(a, { data: e, defaultError: o }).message;
  return {
    ...s,
    path: i,
    message: s.message || o
  };
}, ui = [];
function y(t, e) {
  const r = We({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      Ue(),
      ve
      // then global default map
    ].filter((n) => !!n)
  });
  t.common.issues.push(r);
}
class L {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n = [];
    for (const s of r) {
      if (s.status === "aborted")
        return _;
      s.status === "dirty" && e.dirty(), n.push(s.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, r) {
    const n = [];
    for (const s of r)
      n.push({
        key: await s.key,
        value: await s.value
      });
    return L.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, r) {
    const n = {};
    for (const s of r) {
      const { key: i, value: a } = s;
      if (i.status === "aborted" || a.status === "aborted")
        return _;
      i.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), (typeof a.value < "u" || s.alwaysSet) && (n[i.value] = a.value);
    }
    return { status: e.value, value: n };
  }
}
const _ = Object.freeze({
  status: "aborted"
}), Vr = (t) => ({ status: "dirty", value: t }), N = (t) => ({ status: "valid", value: t }), _t = (t) => t.status === "aborted", bt = (t) => t.status === "dirty", qe = (t) => t.status === "valid", ze = (t) => typeof Promise < "u" && t instanceof Promise;
var w;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})(w || (w = {}));
class U {
  constructor(e, r, n, s) {
    this.parent = e, this.data = r, this._path = n, this._key = s;
  }
  get path() {
    return this._path.concat(this._key);
  }
}
const er = (t, e) => {
  if (qe(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return { success: !1, error: new B(t.common.issues) };
};
function b(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: n, description: s } = t;
  if (e && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (a, o) => a.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: n ?? o.defaultError } : { message: r ?? o.defaultError }, description: s };
}
class v {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return G(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: G(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new L(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: G(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (ze(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n = this.safeParse(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, r) {
    var n;
    const s = {
      common: {
        issues: [],
        async: (n = r?.async) !== null && n !== void 0 ? n : !1,
        contextualErrorMap: r?.errorMap
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: G(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return er(s, i);
  }
  async parseAsync(e, r) {
    const n = await this.safeParseAsync(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r?.errorMap,
        async: !0
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: G(e)
    }, s = this._parse({ data: e, path: n.path, parent: n }), i = await (ze(s) ? s : Promise.resolve(s));
    return er(n, i);
  }
  refine(e, r) {
    const n = (s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r;
    return this._refinement((s, i) => {
      const a = e(s), o = () => i.addIssue({
        code: d.custom,
        ...n(s)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (o(), !1)) : a ? !0 : (o(), !1);
    });
  }
  refinement(e, r) {
    return this._refinement((n, s) => e(n) ? !0 : (s.addIssue(typeof r == "function" ? r(n, s) : r), !1));
  }
  _refinement(e) {
    return new D({
      schema: this,
      typeName: g.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return H.create(this, this._def);
  }
  nullable() {
    return re.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return $.create(this, this._def);
  }
  promise() {
    return de.create(this, this._def);
  }
  or(e) {
    return ke.create([this, e], this._def);
  }
  and(e) {
    return Ce.create(this, e, this._def);
  }
  transform(e) {
    return new D({
      ...b(this._def),
      schema: this,
      typeName: g.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Ne({
      ...b(this._def),
      innerType: this,
      defaultValue: r,
      typeName: g.ZodDefault
    });
  }
  brand() {
    return new Hr({
      typeName: g.ZodBranded,
      type: this,
      ...b(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Je({
      ...b(this._def),
      innerType: this,
      catchValue: r,
      typeName: g.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Le.create(this, e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const li = /^c[^\s-]{8,}$/i, di = /^[a-z][a-z0-9]*$/, fi = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, pi = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|([^-]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,}))$/, hi = (t) => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
class F extends v {
  constructor() {
    super(...arguments), this._regex = (e, r, n) => this.refinement((s) => e.test(s), {
      validation: r,
      code: d.invalid_string,
      ...w.errToObj(n)
    }), this.nonempty = (e) => this.min(1, w.errToObj(e)), this.trim = () => new F({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== p.string) {
      const i = this._getOrReturnCtx(e);
      return y(
        i,
        {
          code: d.invalid_type,
          expected: p.string,
          received: i.parsedType
        }
        //
      ), _;
    }
    const n = new L();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), n.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: i.message
        }), n.dirty());
      else if (i.kind === "length") {
        const a = e.data.length > i.value, o = e.data.length < i.value;
        (a || o) && (s = this._getOrReturnCtx(e, s), a ? y(s, {
          code: d.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }) : o && y(s, {
          code: d.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: i.message
        }), n.dirty());
      } else if (i.kind === "email")
        pi.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "email",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "uuid")
        fi.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "uuid",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid")
        li.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "cuid",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid2")
        di.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "cuid2",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), y(s, {
            validation: "url",
            code: d.invalid_string,
            message: i.message
          }), n.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "regex",
          code: d.invalid_string,
          message: i.message
        }), n.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "datetime" ? hi(i).test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.invalid_string,
          validation: "datetime",
          message: i.message
        }), n.dirty()) : T.assertNever(i);
    return { status: n.value, value: e.data };
  }
  _addCheck(e) {
    return new F({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...w.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...w.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...w.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...w.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...w.errToObj(e) });
  }
  datetime(e) {
    var r;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (r = e?.offset) !== null && r !== void 0 ? r : !1,
      ...w.errToObj(e?.message)
    });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...w.errToObj(r)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...w.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...w.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...w.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...w.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...w.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
F.create = (t) => {
  var e;
  return new F({
    checks: [],
    typeName: g.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...b(t)
  });
};
function mi(t, e) {
  const r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = r > n ? r : n, i = parseInt(t.toFixed(s).replace(".", "")), a = parseInt(e.toFixed(s).replace(".", ""));
  return i % a / Math.pow(10, s);
}
class Y extends v {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== p.number) {
      const i = this._getOrReturnCtx(e);
      return y(i, {
        code: d.invalid_type,
        expected: p.number,
        received: i.parsedType
      }), _;
    }
    let n;
    const s = new L();
    for (const i of this._def.checks)
      i.kind === "int" ? T.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: !1,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? mi(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.not_finite,
        message: i.message
      }), s.dirty()) : T.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, w.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, w.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, w.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, w.toString(r));
  }
  setLimit(e, r, n, s) {
    return new Y({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: w.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Y({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: w.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: w.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: w.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: w.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: w.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: w.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: w.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && T.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
}
Y.create = (t) => new Y({
  checks: [],
  typeName: g.ZodNumber,
  coerce: t?.coerce || !1,
  ...b(t)
});
class we extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== p.bigint) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.bigint,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
}
we.create = (t) => {
  var e;
  return new we({
    typeName: g.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...b(t)
  });
};
class xe extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== p.boolean) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.boolean,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
}
xe.create = (t) => new xe({
  typeName: g.ZodBoolean,
  coerce: t?.coerce || !1,
  ...b(t)
});
class ee extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== p.date) {
      const i = this._getOrReturnCtx(e);
      return y(i, {
        code: d.invalid_type,
        expected: p.date,
        received: i.parsedType
      }), _;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return y(i, {
        code: d.invalid_date
      }), _;
    }
    const n = new L();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), y(s, {
        code: d.too_small,
        message: i.message,
        inclusive: !0,
        exact: !1,
        minimum: i.value,
        type: "date"
      }), n.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), y(s, {
        code: d.too_big,
        message: i.message,
        inclusive: !0,
        exact: !1,
        maximum: i.value,
        type: "date"
      }), n.dirty()) : T.assertNever(i);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new ee({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: w.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: w.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
}
ee.create = (t) => new ee({
  checks: [],
  coerce: t?.coerce || !1,
  typeName: g.ZodDate,
  ...b(t)
});
class Ve extends v {
  _parse(e) {
    if (this._getType(e) !== p.symbol) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.symbol,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
}
Ve.create = (t) => new Ve({
  typeName: g.ZodSymbol,
  ...b(t)
});
class Te extends v {
  _parse(e) {
    if (this._getType(e) !== p.undefined) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.undefined,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
}
Te.create = (t) => new Te({
  typeName: g.ZodUndefined,
  ...b(t)
});
class Ee extends v {
  _parse(e) {
    if (this._getType(e) !== p.null) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.null,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
}
Ee.create = (t) => new Ee({
  typeName: g.ZodNull,
  ...b(t)
});
class le extends v {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return N(e.data);
  }
}
le.create = (t) => new le({
  typeName: g.ZodAny,
  ...b(t)
});
class K extends v {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return N(e.data);
  }
}
K.create = (t) => new K({
  typeName: g.ZodUnknown,
  ...b(t)
});
class J extends v {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return y(r, {
      code: d.invalid_type,
      expected: p.never,
      received: r.parsedType
    }), _;
  }
}
J.create = (t) => new J({
  typeName: g.ZodNever,
  ...b(t)
});
class Be extends v {
  _parse(e) {
    if (this._getType(e) !== p.undefined) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.void,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
}
Be.create = (t) => new Be({
  typeName: g.ZodVoid,
  ...b(t)
});
class $ extends v {
  _parse(e) {
    const { ctx: r, status: n } = this._processInputParams(e), s = this._def;
    if (r.parsedType !== p.array)
      return y(r, {
        code: d.invalid_type,
        expected: p.array,
        received: r.parsedType
      }), _;
    if (s.exactLength !== null) {
      const a = r.data.length > s.exactLength.value, o = r.data.length < s.exactLength.value;
      (a || o) && (y(r, {
        code: a ? d.too_big : d.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: a ? s.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && r.data.length < s.minLength.value && (y(r, {
      code: d.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && (y(r, {
      code: d.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: s.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, o) => s.type._parseAsync(new U(r, a, r.path, o)))).then((a) => L.mergeArray(n, a));
    const i = [...r.data].map((a, o) => s.type._parseSync(new U(r, a, r.path, o)));
    return L.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new $({
      ...this._def,
      minLength: { value: e, message: w.toString(r) }
    });
  }
  max(e, r) {
    return new $({
      ...this._def,
      maxLength: { value: e, message: w.toString(r) }
    });
  }
  length(e, r) {
    return new $({
      ...this._def,
      exactLength: { value: e, message: w.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
$.create = (t, e) => new $({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: g.ZodArray,
  ...b(e)
});
var He;
(function(t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(He || (He = {}));
function oe(t) {
  if (t instanceof C) {
    const e = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e[r] = H.create(oe(n));
    }
    return new C({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof $ ? $.create(oe(t.element)) : t instanceof H ? H.create(oe(t.unwrap())) : t instanceof re ? re.create(oe(t.unwrap())) : t instanceof W ? W.create(t.items.map((e) => oe(e))) : t;
}
class C extends v {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = T.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== p.object) {
      const u = this._getOrReturnCtx(e);
      return y(u, {
        code: d.invalid_type,
        expected: p.object,
        received: u.parsedType
      }), _;
    }
    const { status: n, ctx: s } = this._processInputParams(e), { shape: i, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof J && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        a.includes(u) || o.push(u);
    const c = [];
    for (const u of a) {
      const l = i[u], h = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new U(s, h, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof J) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of o)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (u === "strict")
        o.length > 0 && (y(s, {
          code: d.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of o) {
        const h = s.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new U(s, h, s.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const h = await l.key;
        u.push({
          key: h,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => L.mergeObjectSync(n, u)) : L.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return w.errToObj, new C({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, n) => {
          var s, i, a, o;
          const c = (a = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = w.errToObj(e).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new C({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new C({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new C({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new C({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => He.mergeShapes(this._def.shape(), e._def.shape()),
      typeName: g.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new C({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return T.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new C({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return T.objectKeys(this.shape).forEach((n) => {
      e[n] || (r[n] = this.shape[n]);
    }), new C({
      ...this._def,
      shape: () => r
    });
  }
  deepPartial() {
    return oe(this);
  }
  partial(e) {
    const r = {};
    return T.objectKeys(this.shape).forEach((n) => {
      const s = this.shape[n];
      e && !e[n] ? r[n] = s : r[n] = s.optional();
    }), new C({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return T.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        r[n] = this.shape[n];
      else {
        let i = this.shape[n];
        for (; i instanceof H; )
          i = i._def.innerType;
        r[n] = i;
      }
    }), new C({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return Br(T.objectKeys(this.shape));
  }
}
C.create = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strip",
  catchall: J.create(),
  typeName: g.ZodObject,
  ...b(e)
});
C.strictCreate = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strict",
  catchall: J.create(),
  typeName: g.ZodObject,
  ...b(e)
});
C.lazycreate = (t, e) => new C({
  shape: t,
  unknownKeys: "strip",
  catchall: J.create(),
  typeName: g.ZodObject,
  ...b(e)
});
class ke extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.options;
    function s(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const a = i.map((o) => new B(o.ctx.common.issues));
      return y(r, {
        code: d.invalid_union,
        unionErrors: a
      }), _;
    }
    if (r.common.async)
      return Promise.all(n.map(async (i) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(s);
    {
      let i;
      const a = [];
      for (const c of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: u }), u.common.issues.length && a.push(u.common.issues);
      }
      if (i)
        return r.common.issues.push(...i.ctx.common.issues), i.result;
      const o = a.map((c) => new B(c));
      return y(r, {
        code: d.invalid_union,
        unionErrors: o
      }), _;
    }
  }
  get options() {
    return this._def.options;
  }
}
ke.create = (t, e) => new ke({
  options: t,
  typeName: g.ZodUnion,
  ...b(e)
});
const $e = (t) => t instanceof Oe ? $e(t.schema) : t instanceof D ? $e(t.innerType()) : t instanceof Pe ? [t.value] : t instanceof Q ? t.options : t instanceof Se ? Object.keys(t.enum) : t instanceof Ne ? $e(t._def.innerType) : t instanceof Te ? [void 0] : t instanceof Ee ? [null] : null;
class at extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== p.object)
      return y(r, {
        code: d.invalid_type,
        expected: p.object,
        received: r.parsedType
      }), _;
    const n = this.discriminator, s = r.data[n], i = this.optionsMap.get(s);
    return i ? r.common.async ? i._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : i._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (y(r, {
      code: d.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), _);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i of r) {
      const a = $e(i.shape[e]);
      if (!a)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (s.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        s.set(o, i);
      }
    }
    return new at({
      typeName: g.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: s,
      ...b(n)
    });
  }
}
function vt(t, e) {
  const r = G(t), n = G(e);
  if (t === e)
    return { valid: !0, data: t };
  if (r === p.object && n === p.object) {
    const s = T.objectKeys(e), i = T.objectKeys(t).filter((o) => s.indexOf(o) !== -1), a = { ...t, ...e };
    for (const o of i) {
      const c = vt(t[o], e[o]);
      if (!c.valid)
        return { valid: !1 };
      a[o] = c.data;
    }
    return { valid: !0, data: a };
  } else if (r === p.array && n === p.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const a = t[i], o = e[i], c = vt(a, o);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else
    return r === p.date && n === p.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class Ce extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = (i, a) => {
      if (_t(i) || _t(a))
        return _;
      const o = vt(i.value, a.value);
      return o.valid ? ((bt(i) || bt(a)) && r.dirty(), { status: r.value, value: o.data }) : (y(n, {
        code: d.invalid_intersection_types
      }), _);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([i, a]) => s(i, a)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
}
Ce.create = (t, e, r) => new Ce({
  left: t,
  right: e,
  typeName: g.ZodIntersection,
  ...b(r)
});
class W extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.array)
      return y(n, {
        code: d.invalid_type,
        expected: p.array,
        received: n.parsedType
      }), _;
    if (n.data.length < this._def.items.length)
      return y(n, {
        code: d.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), _;
    !this._def.rest && n.data.length > this._def.items.length && (y(n, {
      code: d.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const i = [...n.data].map((a, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new U(n, a, n.path, o)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(i).then((a) => L.mergeArray(r, a)) : L.mergeArray(r, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new W({
      ...this._def,
      rest: e
    });
  }
}
W.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new W({
    items: t,
    typeName: g.ZodTuple,
    rest: null,
    ...b(e)
  });
};
class Re extends v {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.object)
      return y(n, {
        code: d.invalid_type,
        expected: p.object,
        received: n.parsedType
      }), _;
    const s = [], i = this._def.keyType, a = this._def.valueType;
    for (const o in n.data)
      s.push({
        key: i._parse(new U(n, o, n.path, o)),
        value: a._parse(new U(n, n.data[o], n.path, o))
      });
    return n.common.async ? L.mergeObjectAsync(r, s) : L.mergeObjectSync(r, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n) {
    return r instanceof v ? new Re({
      keyType: e,
      valueType: r,
      typeName: g.ZodRecord,
      ...b(n)
    }) : new Re({
      keyType: F.create(),
      valueType: e,
      typeName: g.ZodRecord,
      ...b(r)
    });
  }
}
class Fe extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.map)
      return y(n, {
        code: d.invalid_type,
        expected: p.map,
        received: n.parsedType
      }), _;
    const s = this._def.keyType, i = this._def.valueType, a = [...n.data.entries()].map(([o, c], u) => ({
      key: s._parse(new U(n, o, n.path, [u, "key"])),
      value: i._parse(new U(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return _;
          (u.status === "dirty" || l.status === "dirty") && r.dirty(), o.set(u.value, l.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of a) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return _;
        (u.status === "dirty" || l.status === "dirty") && r.dirty(), o.set(u.value, l.value);
      }
      return { status: r.value, value: o };
    }
  }
}
Fe.create = (t, e, r) => new Fe({
  valueType: e,
  keyType: t,
  typeName: g.ZodMap,
  ...b(r)
});
class te extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.set)
      return y(n, {
        code: d.invalid_type,
        expected: p.set,
        received: n.parsedType
      }), _;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (y(n, {
      code: d.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.minSize.message
    }), r.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (y(n, {
      code: d.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: s.maxSize.message
    }), r.dirty());
    const i = this._def.valueType;
    function a(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return _;
        l.status === "dirty" && r.dirty(), u.add(l.value);
      }
      return { status: r.value, value: u };
    }
    const o = [...n.data.values()].map((c, u) => i._parse(new U(n, c, n.path, u)));
    return n.common.async ? Promise.all(o).then((c) => a(c)) : a(o);
  }
  min(e, r) {
    return new te({
      ...this._def,
      minSize: { value: e, message: w.toString(r) }
    });
  }
  max(e, r) {
    return new te({
      ...this._def,
      maxSize: { value: e, message: w.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
te.create = (t, e) => new te({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: g.ZodSet,
  ...b(e)
});
class ce extends v {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== p.function)
      return y(r, {
        code: d.invalid_type,
        expected: p.function,
        received: r.parsedType
      }), _;
    function n(o, c) {
      return We({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Ue(),
          ve
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(o, c) {
      return We({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Ue(),
          ve
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: r.common.contextualErrorMap }, a = r.data;
    return this._def.returns instanceof de ? N(async (...o) => {
      const c = new B([]), u = await this._def.args.parseAsync(o, i).catch((m) => {
        throw c.addIssue(n(o, m)), c;
      }), l = await a(...u);
      return await this._def.returns._def.type.parseAsync(l, i).catch((m) => {
        throw c.addIssue(s(l, m)), c;
      });
    }) : N((...o) => {
      const c = this._def.args.safeParse(o, i);
      if (!c.success)
        throw new B([n(o, c.error)]);
      const u = a(...c.data), l = this._def.returns.safeParse(u, i);
      if (!l.success)
        throw new B([s(u, l.error)]);
      return l.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new ce({
      ...this._def,
      args: W.create(e).rest(K.create())
    });
  }
  returns(e) {
    return new ce({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n) {
    return new ce({
      args: e || W.create([]).rest(K.create()),
      returns: r || K.create(),
      typeName: g.ZodFunction,
      ...b(n)
    });
  }
}
class Oe extends v {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
Oe.create = (t, e) => new Oe({
  getter: t,
  typeName: g.ZodLazy,
  ...b(e)
});
class Pe extends v {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return y(r, {
        received: r.data,
        code: d.invalid_literal,
        expected: this._def.value
      }), _;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Pe.create = (t, e) => new Pe({
  value: t,
  typeName: g.ZodLiteral,
  ...b(e)
});
function Br(t, e) {
  return new Q({
    values: t,
    typeName: g.ZodEnum,
    ...b(e)
  });
}
class Q extends v {
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return y(r, {
        expected: T.joinValues(n),
        received: r.parsedType,
        code: d.invalid_type
      }), _;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return y(r, {
        received: r.data,
        code: d.invalid_enum_value,
        options: n
      }), _;
    }
    return N(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e) {
    return Q.create(e);
  }
  exclude(e) {
    return Q.create(this.options.filter((r) => !e.includes(r)));
  }
}
Q.create = Br;
class Se extends v {
  _parse(e) {
    const r = T.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== p.string && n.parsedType !== p.number) {
      const s = T.objectValues(r);
      return y(n, {
        expected: T.joinValues(s),
        received: n.parsedType,
        code: d.invalid_type
      }), _;
    }
    if (r.indexOf(e.data) === -1) {
      const s = T.objectValues(r);
      return y(n, {
        received: n.data,
        code: d.invalid_enum_value,
        options: s
      }), _;
    }
    return N(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Se.create = (t, e) => new Se({
  values: t,
  typeName: g.ZodNativeEnum,
  ...b(e)
});
class de extends v {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== p.promise && r.common.async === !1)
      return y(r, {
        code: d.invalid_type,
        expected: p.promise,
        received: r.parsedType
      }), _;
    const n = r.parsedType === p.promise ? r.data : Promise.resolve(r.data);
    return N(n.then((s) => this._def.type.parseAsync(s, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
de.create = (t, e) => new de({
  type: t,
  typeName: g.ZodPromise,
  ...b(e)
});
class D extends v {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === g.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = this._def.effect || null;
    if (s.type === "preprocess") {
      const a = s.transform(n.data);
      return n.common.async ? Promise.resolve(a).then((o) => this._def.schema._parseAsync({
        data: o,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: a,
        path: n.path,
        parent: n
      });
    }
    const i = {
      addIssue: (a) => {
        y(n, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "refinement") {
      const a = (o) => {
        const c = s.refinement(o, i);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? _ : (o.status === "dirty" && r.dirty(), a(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? _ : (o.status === "dirty" && r.dirty(), a(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!qe(a))
          return a;
        const o = s.transform(a.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => qe(a) ? Promise.resolve(s.transform(a.value, i)).then((o) => ({ status: r.value, value: o })) : a);
    T.assertNever(s);
  }
}
D.create = (t, e, r) => new D({
  schema: t,
  typeName: g.ZodEffects,
  effect: e,
  ...b(r)
});
D.createWithPreprocess = (t, e, r) => new D({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: g.ZodEffects,
  ...b(r)
});
class H extends v {
  _parse(e) {
    return this._getType(e) === p.undefined ? N(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
H.create = (t, e) => new H({
  innerType: t,
  typeName: g.ZodOptional,
  ...b(e)
});
class re extends v {
  _parse(e) {
    return this._getType(e) === p.null ? N(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
re.create = (t, e) => new re({
  innerType: t,
  typeName: g.ZodNullable,
  ...b(e)
});
class Ne extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n = r.data;
    return r.parsedType === p.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ne.create = (t, e) => new Ne({
  innerType: t,
  typeName: g.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...b(e)
});
class Je extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r,
        common: {
          ...r.common,
          issues: []
          // don't collect issues from inner type
        }
      }
    });
    return ze(n) ? n.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue()
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue()
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Je.create = (t, e) => new Je({
  innerType: t,
  typeName: g.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...b(e)
});
class Ge extends v {
  _parse(e) {
    if (this._getType(e) !== p.nan) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.nan,
        received: n.parsedType
      }), _;
    }
    return { status: "valid", value: e.data };
  }
}
Ge.create = (t) => new Ge({
  typeName: g.ZodNaN,
  ...b(t)
});
const yi = Symbol("zod_brand");
class Hr extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Le extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? _ : i.status === "dirty" ? (r.dirty(), Vr(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? _ : s.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, r) {
    return new Le({
      in: e,
      out: r,
      typeName: g.ZodPipeline
    });
  }
}
const Fr = (t, e = {}, r) => t ? le.create().superRefine((n, s) => {
  if (!t(n)) {
    const i = typeof e == "function" ? e(n) : e, a = typeof i == "string" ? { message: i } : i;
    s.addIssue({ code: "custom", ...a, fatal: r });
  }
}) : le.create(), gi = {
  object: C.lazycreate
};
var g;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline";
})(g || (g = {}));
const _i = (t, e = {
  message: `Input not instance of ${t.name}`
}) => Fr((r) => r instanceof t, e, !0), Jr = F.create, Gr = Y.create, bi = Ge.create, vi = we.create, Yr = xe.create, wi = ee.create, xi = Ve.create, Ti = Te.create, Ei = Ee.create, ki = le.create, Ci = K.create, Ri = J.create, Oi = Be.create, Pi = $.create, Si = C.create, Ni = C.strictCreate, Li = ke.create, Ii = at.create, ji = Ce.create, Ai = W.create, Mi = Re.create, $i = Fe.create, Di = te.create, Zi = ce.create, Ui = Oe.create, Wi = Pe.create, qi = Q.create, zi = Se.create, Vi = de.create, tr = D.create, Bi = H.create, Hi = re.create, Fi = D.createWithPreprocess, Ji = Le.create, Gi = () => Jr().optional(), Yi = () => Gr().optional(), Qi = () => Yr().optional(), Xi = {
  string: (t) => F.create({ ...t, coerce: !0 }),
  number: (t) => Y.create({ ...t, coerce: !0 }),
  boolean: (t) => xe.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => we.create({ ...t, coerce: !0 }),
  date: (t) => ee.create({ ...t, coerce: !0 })
}, Ki = _;
var f = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: ve,
  setErrorMap: ci,
  getErrorMap: Ue,
  makeIssue: We,
  EMPTY_PATH: ui,
  addIssueToContext: y,
  ParseStatus: L,
  INVALID: _,
  DIRTY: Vr,
  OK: N,
  isAborted: _t,
  isDirty: bt,
  isValid: qe,
  isAsync: ze,
  get util() {
    return T;
  },
  ZodParsedType: p,
  getParsedType: G,
  ZodType: v,
  ZodString: F,
  ZodNumber: Y,
  ZodBigInt: we,
  ZodBoolean: xe,
  ZodDate: ee,
  ZodSymbol: Ve,
  ZodUndefined: Te,
  ZodNull: Ee,
  ZodAny: le,
  ZodUnknown: K,
  ZodNever: J,
  ZodVoid: Be,
  ZodArray: $,
  get objectUtil() {
    return He;
  },
  ZodObject: C,
  ZodUnion: ke,
  ZodDiscriminatedUnion: at,
  ZodIntersection: Ce,
  ZodTuple: W,
  ZodRecord: Re,
  ZodMap: Fe,
  ZodSet: te,
  ZodFunction: ce,
  ZodLazy: Oe,
  ZodLiteral: Pe,
  ZodEnum: Q,
  ZodNativeEnum: Se,
  ZodPromise: de,
  ZodEffects: D,
  ZodTransformer: D,
  ZodOptional: H,
  ZodNullable: re,
  ZodDefault: Ne,
  ZodCatch: Je,
  ZodNaN: Ge,
  BRAND: yi,
  ZodBranded: Hr,
  ZodPipeline: Le,
  custom: Fr,
  Schema: v,
  ZodSchema: v,
  late: gi,
  get ZodFirstPartyTypeKind() {
    return g;
  },
  coerce: Xi,
  any: ki,
  array: Pi,
  bigint: vi,
  boolean: Yr,
  date: wi,
  discriminatedUnion: Ii,
  effect: tr,
  enum: qi,
  function: Zi,
  instanceof: _i,
  intersection: ji,
  lazy: Ui,
  literal: Wi,
  map: $i,
  nan: bi,
  nativeEnum: zi,
  never: Ri,
  null: Ei,
  nullable: Hi,
  number: Gr,
  object: Si,
  oboolean: Qi,
  onumber: Yi,
  optional: Bi,
  ostring: Gi,
  pipeline: Ji,
  preprocess: Fi,
  promise: Vi,
  record: Mi,
  set: Di,
  strictObject: Ni,
  string: Jr,
  symbol: xi,
  transformer: tr,
  tuple: Ai,
  undefined: Ti,
  union: Li,
  unknown: Ci,
  void: Oi,
  NEVER: Ki,
  ZodIssueCode: d,
  quotelessJson: oi,
  ZodError: B
});
const Qr = /^0x[0-9a-f]+$/i, Xr = /^\d+$/, ea = f.string().nonempty("The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (t) => !Qr.test(t),
  "The shortString should not be a hex string"
).refine(
  (t) => !Xr.test(t),
  "The shortString should not be an integer string"
), De = f.union([
  f.string().regex(
    Qr,
    "Only hex, integers and bigint are supported in calldata"
  ),
  f.string().regex(
    Xr,
    "Only hex, integers and bigint are supported in calldata"
  ),
  ea,
  f.number().int("Only hex, integers and bigint are supported in calldata"),
  f.bigint()
]), rr = f.object({
  contractAddress: f.string(),
  entrypoint: f.string(),
  calldata: f.array(De).optional()
}), ta = f.object({
  types: f.record(
    f.array(
      f.union([
        f.object({
          name: f.string(),
          type: f.string()
        }),
        f.object({
          name: f.string(),
          type: f.literal("merkletree"),
          contains: f.string()
        })
      ])
    )
  ),
  primaryType: f.string(),
  domain: f.record(f.unknown()),
  message: f.record(f.unknown())
}), nr = {
  enable: f.tuple([
    f.object({
      starknetVersion: f.union([f.literal("v4"), f.literal("v5")]).optional()
    }).optional()
  ]).or(f.tuple([])),
  addStarknetChain: f.tuple([
    f.object({
      id: f.string(),
      chainId: f.string(),
      chainName: f.string(),
      rpcUrls: f.array(f.string()).optional(),
      nativeCurrency: f.object({
        name: f.string(),
        symbol: f.string(),
        decimals: f.number()
      }).optional(),
      blockExplorerUrls: f.array(f.string()).optional()
    })
  ]),
  switchStarknetChain: f.tuple([
    f.object({
      chainId: f.string()
    })
  ]),
  watchAsset: f.tuple([
    f.object({
      type: f.literal("ERC20"),
      options: f.object({
        address: f.string(),
        symbol: f.string().optional(),
        decimals: f.number().optional(),
        image: f.string().optional(),
        name: f.string().optional()
      })
    })
  ]),
  execute: f.tuple([
    f.array(rr).nonempty().or(rr),
    f.array(f.any()).optional(),
    f.object({
      nonce: De.optional(),
      maxFee: De.optional(),
      version: De.optional()
    }).optional()
  ]),
  signMessage: f.tuple([ta])
}, M = Jn.create({
  isServer: !1,
  allowOutsideOfServer: !0
});
let wt = ar, xt = "", Kr = "";
const be = ({
  width: t = 775,
  height: e = 385,
  origin: r,
  location: n,
  atLeftBottom: s = !1
}) => {
  const i = window?.outerWidth ?? window?.innerWidth ?? window?.screen.width ?? 0, a = window?.outerHeight ?? window?.innerHeight ?? window?.screen.height ?? 0, o = window?.screenLeft ?? window?.screenX ?? 0, c = window?.screenTop ?? window?.screenY ?? 0, u = s ? 0 : o + i / 2 - t / 2, l = s ? window.screen.availHeight + 10 : c + a / 2 - e / 2;
  wt = r ?? wt, xt = n ?? xt, Kr = `width=${t},height=${e},top=${l},left=${u},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`;
};
M.router({
  authorize: M.procedure.output(f.boolean()).mutation(async () => !0),
  connect: M.procedure.mutation(async () => ""),
  enable: M.procedure.output(f.string()).mutation(async () => ""),
  execute: M.procedure.input(nr.execute).output(f.string()).mutation(async () => ""),
  signMessage: M.procedure.input(nr.signMessage).output(f.string().array()).mutation(async () => []),
  getLoginStatus: M.procedure.output(
    f.object({
      isLoggedIn: f.boolean(),
      hasSession: f.boolean().optional(),
      isPreauthorized: f.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: !0
  })),
  addStarknetChain: M.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: M.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  watchAsset: M.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  updateModal: M.procedure.subscription(async () => {
  })
});
const ra = ({
  iframe: t
}) => Sn({
  links: [
    kn({
      enabled: (e) => process.env.NODE_ENV === "development" && typeof window < "u" || process.env.NODE_ENV === "development" && e.direction === "down" && e.result instanceof Error
    }),
    mn({
      condition(e) {
        if (!t && e.type === "subscription")
          throw new Error(
            "subscription is not supported without an iframe window"
          );
        return !!t;
      },
      true: yt.windowLink({
        window,
        postWindow: t,
        postOrigin: "*"
      }),
      false: yt.popupLink({
        listenWindow: window,
        createPopup: () => {
          let e = null;
          const r = document.createElement("button");
          if (r.style.display = "none", r.addEventListener("click", () => {
            e = window.open(
              `${wt}${xt}`,
              "popup",
              Kr
            );
          }), r.click(), (async () => {
            for (; !e; )
              await new Promise((n) => setTimeout(n, 100));
          })(), !e)
            throw new Error("Could not open popup");
          return e;
        },
        postOrigin: "*"
      })
    })
  ]
});
function na(t) {
  try {
    const { origin: e } = new URL(t);
    if (e.includes("localhost") || e.includes("127.0.0.1") || e.includes("hydrogen"))
      return Zt;
    if (e.includes("staging") || e.includes("argent.xyz"))
      return ct;
  } catch {
    console.warn(
      "Could not determine rpc nodeUrl from target URL, defaulting to mainnet"
    );
  }
  return ct;
}
const sa = 385, ia = 775, aa = 385, oa = 440, ca = 886, ua = 562;
class sr {
  async getPubKey() {
    throw new Error("Method not implemented");
  }
  async signMessage() {
    throw new Error("Method not implemented");
  }
  async signTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeclareTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeployAccountTransaction() {
    throw new Error("Method not implemented");
  }
}
class la extends on {
  constructor(r, n, s) {
    super(r, n, new sr());
    ie(this, "signer", new sr());
    ie(this, "execute", async (r, n, s) => {
      try {
        return be({
          width: sa,
          height: ia,
          location: "/review"
        }), Array.isArray(r) && r[0] && r[0].entrypoint === "use_offchain_session" && be({
          width: 1,
          height: 1,
          location: "/executeSessionTx",
          atLeftBottom: !0
        }), {
          transaction_hash: await this.proxyLink.execute.mutate([
            r,
            n,
            s
          ])
        };
      } catch (i) {
        throw i instanceof Error ? new Error(i.message) : new Error("Error while execute a transaction");
      }
    });
    ie(this, "signMessage", async (r) => {
      try {
        return be({
          width: aa,
          height: oa,
          location: "/signMessage"
        }), await this.proxyLink.signMessage.mutate([r]);
      } catch (n) {
        throw n instanceof Error ? new Error(n.message) : new Error("Error while sign a message");
      }
    });
    this.address = n, this.proxyLink = s;
  }
}
const je = [], da = (t, e, r) => {
  const n = {
    ...t,
    isConnected: !1,
    provider: e,
    getLoginStatus: () => r.getLoginStatus.mutate(),
    async request(s) {
      switch (s.type) {
        case "wallet_addStarknetChain":
          return await r.addStarknetChain.mutate();
        case "wallet_switchStarknetChain":
          return await r.switchStarknetChain.mutate();
        case "wallet_watchAsset":
          return await r.watchAsset.mutate();
        default:
          throw new Error("not implemented");
      }
    },
    async enable(s) {
      if (s?.starknetVersion !== "v4")
        throw Error("not implemented");
      try {
        be({
          width: ca,
          height: ua,
          location: "/interstitialLogin"
        });
        const a = await r.enable.mutate();
        return await fa(
          n,
          e,
          r,
          a
        ), [a];
      } catch (i) {
        throw i instanceof Error ? new Error(i.message) : new Error("Unknow error on enable wallet");
      }
    },
    async isPreauthorized() {
      const { isLoggedIn: s, isPreauthorized: i } = await r.getLoginStatus.mutate();
      return !!(s && i);
    },
    on: (s, i) => {
      if (s === "accountsChanged")
        je.push({
          type: s,
          handler: i
        });
      else if (s === "networkChanged")
        je.push({
          type: s,
          handler: i
        });
      else
        throw new Error(`Unknwown event: ${s}`);
    },
    off: (s, i) => {
      if (s !== "accountsChanged" && s !== "networkChanged")
        throw new Error(`Unknwown event: ${s}`);
      const a = je.findIndex(
        (o) => o.type === s && o.handler === i
      );
      a >= 0 && je.splice(a, 1);
    }
  };
  return n;
};
async function fa(t, e, r, n) {
  if (t.isConnected)
    return t;
  const i = {
    isConnected: !0,
    chainId: await e.getChainId(),
    selectedAddress: n,
    account: new la(e, n, r),
    provider: e
  };
  return Object.assign(t, i);
}
const pa = async (t, e) => {
  const r = typeof window < "u" ? window : void 0;
  if (!r)
    throw new Error("window is not defined");
  const n = na(t), s = new cn({ nodeUrl: n });
  return da(
    {
      host: r.location.origin,
      id: "argentWebWallet",
      icon: "https://www.argent.xyz/favicon.ico",
      name: "Argent Web Wallet",
      version: "1.0.0"
    },
    s,
    e
  );
};
let A = null;
class _a extends sn {
  constructor(r = {}) {
    super();
    ie(this, "_wallet", null);
    ie(this, "_options");
    this._options = r;
  }
  available() {
    return !0;
  }
  async ready() {
    return A ? (this._wallet = A, this._wallet.isPreauthorized()) : (this._wallet = null, !1);
  }
  get id() {
    return this._wallet = A, this._wallet?.id || "argentWebWallet";
  }
  get name() {
    return this._wallet = A, this._wallet?.name || "Argent Web Wallet";
  }
  get icon() {
    return {
      light: Dt,
      dark: Dt
    };
  }
  get wallet() {
    if (!this._wallet)
      throw new me();
    return this._wallet;
  }
  get title() {
    return "Email";
  }
  get subtitle() {
    return "Powered by Argent";
  }
  async connect() {
    if (await this.ensureWallet(), !this._wallet)
      throw new Mt();
    try {
      await this._wallet.enable({ starknetVersion: "v4" });
    } catch {
      throw new $t();
    }
    if (!this._wallet.isConnected)
      throw new $t();
    const r = this._wallet.account, n = await this.chainId();
    return {
      account: r.address,
      chainId: n
    };
  }
  async disconnect() {
    if (!this.available() && !this._wallet)
      throw new Mt();
    if (!this._wallet?.isConnected)
      throw new an();
    A = null, this._wallet = A;
  }
  async account() {
    if (this._wallet = A, !this._wallet || !this._wallet.account)
      throw new me();
    return this._wallet.account;
  }
  async chainId() {
    if (!this._wallet || !this.wallet.account || !this._wallet.provider)
      throw new me();
    const r = await this._wallet.provider.getChainId();
    return BigInt(r);
  }
  async initEventListener(r) {
    if (this._wallet = A, !this._wallet)
      throw new me();
    this._wallet.on("accountsChanged", r);
  }
  async removeEventListener(r) {
    if (this._wallet = A, !this._wallet)
      throw new me();
    this._wallet.off("accountsChanged", r), A = null, this._wallet = null;
  }
  async ensureWallet() {
    const r = this._options.url || ar;
    be({
      origin: r,
      location: "/interstitialLogin"
    }), A = await pa(r, ra({})) ?? null, this._wallet = A;
  }
}
export {
  ar as D,
  _a as W
};
