{
  "version": 3,
  "sources": ["../../embla-carousel/src/components/utils.ts", "../../embla-carousel/src/components/Alignment.ts", "../../embla-carousel/src/components/Animation.ts", "../../embla-carousel/src/components/Axis.ts", "../../embla-carousel/src/components/Limit.ts", "../../embla-carousel/src/components/Counter.ts", "../../embla-carousel/src/components/Direction.ts", "../../embla-carousel/src/components/EventStore.ts", "../../embla-carousel/src/components/Vector1d.ts", "../../embla-carousel/src/components/DragHandler.ts", "../../embla-carousel/src/components/DragTracker.ts", "../../embla-carousel/src/components/PercentOfView.ts", "../../embla-carousel/src/components/ScrollBody.ts", "../../embla-carousel/src/components/ScrollBounds.ts", "../../embla-carousel/src/components/ScrollContain.ts", "../../embla-carousel/src/components/ScrollLimit.ts", "../../embla-carousel/src/components/ScrollLooper.ts", "../../embla-carousel/src/components/ScrollProgress.ts", "../../embla-carousel/src/components/ScrollSnaps.ts", "../../embla-carousel/src/components/ScrollTarget.ts", "../../embla-carousel/src/components/ScrollTo.ts", "../../embla-carousel/src/components/Translate.ts", "../../embla-carousel/src/components/SlideLooper.ts", "../../embla-carousel/src/components/SlidesInView.ts", "../../embla-carousel/src/components/SlideSizes.ts", "../../embla-carousel/src/components/SlidesToScroll.ts", "../../embla-carousel/src/components/Engine.ts", "../../embla-carousel/src/components/EventHandler.ts", "../../embla-carousel/src/components/Options.ts", "../../embla-carousel/src/components/OptionsHandler.ts", "../../embla-carousel/src/components/PluginsHandler.ts", "../../embla-carousel/src/components/index.ts", "../../embla-carousel-react/src/components/utils.ts", "../../embla-carousel-react/src/components/index.ts", "../../@mantine/carousel/src/Carousel.context.ts", "../../@mantine/carousel/esm/Carousel.module.css.mjs", "../../@mantine/carousel/src/CarouselSlide/CarouselSlide.tsx", "../../@mantine/carousel/src/CarouselVariables/CarouselVariables.tsx", "../../@mantine/carousel/src/get-chevron-rotation.ts", "../../@mantine/carousel/src/Carousel.tsx", "../../@mantine/carousel/src/use-animation-offset-effect.ts"],
  "sourcesContent": ["export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isString(subject: unknown): subject is string {\n  return typeof subject === 'string'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isArray(subject: unknown): subject is Record<number, unknown> {\n  return Array.isArray(subject)\n}\n\nexport function isRecord(\n  subject: unknown,\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || isArray(subject)\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / mathAbs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function objectKeys<Type extends object>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function objectsAreEqual(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): boolean {\n  const objectAKeys = objectKeys(objectA)\n  const objectBKeys = objectKeys(objectB)\n\n  if (objectAKeys.length !== objectBKeys.length) return false\n\n  return objectAKeys.every((key) => {\n    const valueA = objectA[key]\n    const valueB = objectB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return objectsAreEqual(valueA, valueB)\n  })\n}\n", "import { isNumber } from './utils'\n\nexport type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (isNumber(align)) return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n", "type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n", "import { DirectionOptionType } from './Direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  direction: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return direction === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return direction === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n", "import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n", "import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n  min: number\n  max: number\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean,\n): CounterType {\n  const { min, constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    set,\n    min,\n    max,\n  }\n  return self\n}\n", "export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  apply: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function apply(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    apply,\n  }\n  return self\n}\n", "type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = { passive: true },\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => node.removeEventListener(type, handler, options))\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n", "import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n", "import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { DirectionType } from './Direction'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { deltaAbs, factorAbs, mathAbs, mathSign } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  loop: boolean,\n  dragFree: boolean,\n  skipSnaps: boolean,\n): DragHandlerType {\n  const { cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const nonPassiveEvent = { passive: false }\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const dragThreshold = percentOfView.measure(20)\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 5 : 16\n  const baseMass = 1\n\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'dragstart', (evt) => evt.preventDefault(), nonPassiveEvent)\n      .add(node, 'touchmove', () => undefined, nonPassiveEvent)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click, true)\n  }\n\n  function addInteractionEvents(): void {\n    const node = isMouse ? document : rootNode\n    interactionEvents\n      .add(node, 'touchmove', move, nonPassiveEvent)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move, nonPassiveEvent)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.clone().add(mathSign(force) * -1)\n    const isEdge = next.get() === index.min || next.get() === index.max\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < dragThreshold) return baseForce\n    if (!loop && isEdge) return baseForce * 0.4\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    isMouse = !dragTracker.isTouchEvent(evt)\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n    if (isFocusNode(evt.target as Element)) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n  }\n\n  function move(evt: PointerEventType): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      const lastScroll = dragTracker.readPoint(evt)\n      const lastCross = dragTracker.readPoint(evt, crossAxis)\n      const diffScroll = deltaAbs(lastScroll, startScroll)\n      const diffCross = deltaAbs(lastCross, startCross)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.apply(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction.apply(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n    const isVigorous = targetChanged && forceFactor > 0.75\n    const isBelowThreshold = mathAbs(rawForce) < dragThreshold\n    const speed = isVigorous ? 10 : baseSpeed\n    const mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) {\n      evt.stopPropagation()\n      evt.preventDefault()\n    }\n  }\n\n  // DEPRECATED - Remove in v8 because handled automatically\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n", "import { AxisOptionType, AxisType } from './Axis'\nimport { mathAbs } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  isTouchEvent: (evt: PointerEventType) => evt is TouchEvent\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(axis: AxisType): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function isTouchEvent(evt: PointerEventType): evt is TouchEvent {\n    return typeof TouchEvent !== 'undefined' && evt instanceof TouchEvent\n  }\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isTouchEvent(evt) ? evt.touches[0] : evt)[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    isTouchEvent,\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n", "export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure,\n  }\n  return self\n}\n", "import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (target: Vector1DType) => ScrollBodyType\n  settle: (target: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(force: Vector1DType): void {\n    force.divide(mass)\n    acceleration.add(force)\n  }\n\n  function seek(target: Vector1DType): ScrollBodyType {\n    attraction.set(target).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(target: Vector1DType): boolean {\n    const diff = target.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(target)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n", "import { LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType,\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const maxFriction = 0.85\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = Math.min(diffToEdge / edgeOffsetTolerance, maxFriction)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n", "import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snapsAligned[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n", "import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n", "import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[],\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n", "import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n", "import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollType,\n  containScroll: boolean,\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const containedStartSnap = 0\n    const containedEndSnap = arrayLast(snaps) - arrayLast(slideSizesWithGaps)\n\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index, groupedSnaps) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(groupedSnaps)\n        if (containScroll && isFirst) return containedStartSnap\n        if (containScroll && isLast) return containedEndSnap\n        return snap + alignments[index]\n      })\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n", "import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return targets[0]\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    return minDistance(matchingTargets)\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n", "import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n", "import { AxisType } from './Axis'\nimport { DirectionType } from './Direction'\nimport { Vector1DType } from './Vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.apply(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n", "import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './SlidesInView'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\nimport { DirectionType } from './Direction'\n\ntype EdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  index: number\n  translate: TranslateType\n  location: Vector1DType\n  target: () => Vector1DType\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  direction: DirectionType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scroll: Vector1DType,\n  slides: HTMLElement[],\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: EdgeType): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds([offset])\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const shift = Vector1D(-1)\n      const location = Vector1D(-1)\n      const translate = Translate(axis, direction, slides[index])\n      const target = () => shift.set(scroll.get() > point ? initial : altered)\n      return { index, location, translate, target }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, location } = loopPoint\n      const shift = target()\n      if (shift.get() === location.get()) return\n      if (shift.get() === 0) translate.clear()\n      else translate.to(shift)\n      location.set(shift)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n", "import { Limit, LimitType } from './Limit'\n\nexport type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number, bounds?: SlideBoundType[]) => number[]\n  findSlideBounds: (offsets?: number[], threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  limit: LimitType,\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const { removeOffset, constrain } = limit\n  const roundingSafety = 0.5\n  const cachedOffsets = loop ? [0, contentSize, -contentSize] : [0]\n  const cachedBounds = findSlideBounds(cachedOffsets, inViewThreshold)\n\n  function findSlideThresholds(threshold?: number): number[] {\n    const slideThreshold = threshold || 0\n\n    return slideSizes.map((slideSize) => {\n      const thresholdLimit = Limit(roundingSafety, slideSize - roundingSafety)\n      return thresholdLimit.constrain(slideSize * slideThreshold)\n    })\n  }\n\n  function findSlideBounds(\n    offsets?: number[],\n    threshold?: number,\n  ): SlideBoundType[] {\n    const slideOffsets = offsets || cachedOffsets\n    const slideThresholds = findSlideThresholds(threshold)\n\n    return slideOffsets.reduce((list: SlideBoundType[], offset) => {\n      const bounds = snaps.map((snap, index) => ({\n        start: snap - slideSizes[index] + slideThresholds[index] + offset,\n        end: snap + viewSize - slideThresholds[index] + offset,\n        index,\n      }))\n      return list.concat(bounds)\n    }, [])\n  }\n\n  function check(location: number, bounds?: SlideBoundType[]): number[] {\n    const limitedLocation = loop ? removeOffset(location) : constrain(location)\n    const slideBounds = bounds || cachedBounds\n\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < limitedLocation && end > limitedLocation\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n", "import { AxisType } from './Axis'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slides: HTMLElement[],\n  readEdgeGap: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const withEdgeGap = slideRects[0] && readEdgeGap\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!withEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!withEdgeGap) return 0\n    const style = window.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(rects)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n", "import { arrayKeys, arrayLast, isNumber } from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  viewSize: number,\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollOptionType,\n): SlidesToScrollType {\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    return arrayKeys(array)\n      .reduce((groupSizes: number[], i) => {\n        const chunk = slideSizesWithGaps.slice(arrayLast(groupSizes), i + 1)\n        const chunkSize = chunk.reduce((a, s) => a + s, 0)\n        return !i || chunkSize > viewSize ? groupSizes.concat(i) : groupSizes\n      }, [])\n      .map((start, i, groupSizes) => array.slice(start, groupSizes[i + 1]))\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides,\n  }\n  return self\n}\n", "import { Alignment } from './Alignment'\nimport { Animation, AnimationType } from './Animation'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { Direction, DirectionType } from './Direction'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type EngineType = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  containerRect: DOMRect\n  slideRects: DOMRect[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  eventHandler: EventHandlerType,\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && containScroll !== ''\n  const readEdgeGap = loop || containScroll !== ''\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    readEdgeGap,\n  )\n  const slidesToScroll = SlidesToScroll(\n    viewSize,\n    slideSizesWithGaps,\n    groupSlides,\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slideSizesWithGaps,\n    slidesToScroll,\n    containSnaps,\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown())\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      eventHandler.emit('settle')\n    }\n    if (!settled) {\n      eventHandler.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction())\n      engine.slideLooper.loop()\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    eventHandler,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    limit,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    DragTracker(axis),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    eventHandler,\n    percentOfView,\n    loop,\n    dragFree,\n    skipSnaps,\n  )\n\n  // Engine\n  const engine: EngineType = {\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    eventStore: EventStore(),\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      location,\n      target,\n      scrollBody,\n      percentOfView,\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, location, [\n      location,\n      target,\n    ]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      direction,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n      slides,\n    ),\n    slidesToScroll,\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n", "type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventHandlerType = {\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n}\n\nexport function EventHandler(): EventHandlerType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventHandlerType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n", "import { AlignmentOptionType } from './Alignment'\nimport { AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { DirectionOptionType } from './Direction'\nimport { ScrollContainOptionType } from './ScrollContain'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  container: string | HTMLElement | null\n  slides: string | HTMLElement[] | NodeListOf<HTMLElement> | null\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  draggable: boolean\n  inViewThreshold: number\n  loop: boolean\n  skipSnaps: boolean\n  speed: number\n  startIndex: number\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  container: null,\n  slides: null,\n  containScroll: '',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  breakpoints: {},\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  speed: 10,\n  startIndex: 0,\n  active: true,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n", "import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsAreEqual, objectsMergeDeep } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  merge: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ) => TypeA\n  areEqual: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ) => boolean\n  atMedia: <Type extends OptionsType>(options: Type) => Type\n}\n\nexport function OptionsHandler(): OptionsHandlerType {\n  function merge<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function areEqual<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ): boolean {\n    const breakpointsA = JSON.stringify(objectKeys(optionsA.breakpoints || {}))\n    const breakpointsB = JSON.stringify(objectKeys(optionsB.breakpoints || {}))\n    if (breakpointsA !== breakpointsB) return false\n    return objectsAreEqual(optionsA, optionsB)\n  }\n\n  function atMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => window.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => merge(a, mediaOption), {})\n\n    return merge(options, matchedMediaOptions)\n  }\n\n  const self: OptionsHandlerType = {\n    merge,\n    areEqual,\n    atMedia,\n  }\n  return self\n}\n", "import { EmblaCarouselType } from '.'\nimport { OptionsHandler } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\ntype PluginChangedHandlerType = () => boolean\n\nexport type PluginsHandlerType = {\n  init: (\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ) => EmblaPluginsType\n  destroy: () => void\n  haveChanged: PluginChangedHandlerType\n}\n\nexport function PluginsHandler(): PluginsHandlerType {\n  const { atMedia, areEqual } = OptionsHandler()\n  let activePlugins: EmblaPluginType[] = []\n  let pluginsChanged: PluginChangedHandlerType[] = []\n\n  function haveChanged(): boolean {\n    return pluginsChanged.some((hasChanged) => hasChanged())\n  }\n\n  function hasChanged(plugin: EmblaPluginType): PluginChangedHandlerType {\n    const options = atMedia(plugin.options)\n    return (): boolean => !areEqual(options, atMedia(plugin.options))\n  }\n\n  function init(\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ): EmblaPluginsType {\n    pluginsChanged = plugins.map(hasChanged)\n    activePlugins = plugins.filter((plugin) => atMedia(plugin.options).active)\n    activePlugins.forEach((plugin) => plugin.init(embla))\n\n    return plugins.reduce((map, plugin) => {\n      return Object.assign(map, { [plugin.name]: plugin })\n    }, {})\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy,\n    haveChanged,\n  }\n  return self\n}\n", "import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\nimport { isString } from './utils'\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  root: HTMLElement,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[],\n): EmblaCarouselType {\n  const resizeHandlers = EventStore()\n  const optionsHandler = OptionsHandler()\n  const pluginsHandler = PluginsHandler()\n  const eventHandler = EventHandler()\n  const { on, off } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = optionsHandler.merge(\n    defaultOptions,\n    EmblaCarousel.globalOptions,\n  )\n  let options = optionsHandler.merge(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n  let rootSize = 0\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const { container: userContainer, slides: userSlides } = options\n\n    const customContainer = isString(userContainer)\n      ? root.querySelector(userContainer)\n      : userContainer\n    container = <HTMLElement>(customContainer || root.children[0])\n\n    const customSlides = isString(userSlides)\n      ? container.querySelectorAll(userSlides)\n      : userSlides\n    slides = <HTMLElement[]>[].slice.call(customSlides || container.children)\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    if (destroyed) return\n\n    optionsBase = optionsHandler.merge(optionsBase, withOptions)\n    options = optionsHandler.atMedia(optionsBase)\n\n    storeElements()\n\n    engine = Engine(root, container, slides, options, eventHandler)\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect())\n\n    if (!options.active) return deActivate()\n\n    engine.translate.to(engine.location)\n    pluginList = withPlugins || pluginList\n    pluginApis = pluginsHandler.init(pluginList, self)\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        activate({ loop: false }, withPlugins)\n        optionsBase = optionsHandler.merge(optionsBase, { loop: true })\n        return\n      }\n      engine.slideLooper.loop()\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n    }\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(optionsHandler.merge({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.animation.stop()\n    engine.eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    pluginsHandler.destroy()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    resizeHandlers.removeAll()\n    deActivate()\n    eventHandler.emit('destroy')\n  }\n\n  function resize(): void {\n    const newOptions = optionsHandler.atMedia(optionsBase)\n    const optionsChanged = !optionsHandler.areEqual(newOptions, options)\n    const newRootSize = engine.axis.measureSize(root.getBoundingClientRect())\n    const rootSizeChanged = rootSize !== newRootSize\n    const pluginsChanged = pluginsHandler.haveChanged()\n\n    if (rootSizeChanged || optionsChanged || pluginsChanged) reActivate()\n    eventHandler.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), jump === true, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), jump === true, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n\n  activate(userOptions, userPlugins)\n  resizeHandlers.add(window, 'resize', resize)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\nEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\nEmblaCarousel.optionsHandler = OptionsHandler\n\nexport default EmblaCarousel\n", "import EmblaCarousel, { EmblaPluginType } from 'embla-carousel'\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[],\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[],\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const { areEqual } = EmblaCarousel.optionsHandler()\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areEqual(optionA, optionB)\n  })\n}\n", "import { useRef, useEffect, useState, useCallback } from 'react'\nimport { arePluginsEqual, canUseDOM } from './utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType,\n} from 'embla-carousel'\n\ntype EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined,\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = [],\n): UseEmblaCarouselType {\n  const optionsHandler = useRef(EmblaCarousel.optionsHandler())\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [embla, setEmbla] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (embla) embla.reInit(storedOptions.current, storedPlugins.current)\n  }, [embla])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmbla = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current,\n      )\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, setEmbla])\n\n  useEffect(() => {\n    if (optionsHandler.current.areEqual(storedOptions.current, options)) return\n\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  return [<EmblaViewportRefType>setViewport, embla]\n}\n\nuseEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\n\nexport default useEmblaCarousel\n", "import { createSafeContext, GetStylesApi } from '@mantine/core';\nimport type { CarouselFactory } from './Carousel';\n\ninterface CarouselContextValue {\n  getStyles: GetStylesApi<CarouselFactory>;\n  orientation: 'horizontal' | 'vertical' | undefined;\n}\n\nexport const [CarouselProvider, useCarouselContext] = createSafeContext<CarouselContextValue>(\n  'Carousel component was not found in tree'\n);\n", "'use client';\nvar classes = {\"root\":\"m-17884d0f\",\"viewport\":\"m-a2dae653\",\"container\":\"m-fcd81474\",\"controls\":\"m-39bc3463\",\"control\":\"m-64f58e10\",\"indicators\":\"m-71ea3ab1\",\"indicator\":\"m-eae68602\",\"slide\":\"m-d98df724\"};\n\nexport { classes as default };\n//# sourceMappingURL=Carousel.module.css.mjs.map\n", "import React from 'react';\nimport {\n  Box,\n  BoxProps,\n  CompoundStylesApiProps,\n  ElementProps,\n  factory,\n  Factory,\n  useProps,\n} from '@mantine/core';\nimport { useCarouselContext } from '../Carousel.context';\nimport classes from '../Carousel.module.css';\n\nexport type CarouselSlideStylesNames = 'slide';\n\nexport interface CarouselSlideProps\n  extends BoxProps,\n    CompoundStylesApiProps<CarouselSlideFactory>,\n    ElementProps<'div'> {}\n\nexport type CarouselSlideFactory = Factory<{\n  props: CarouselSlideProps;\n  ref: HTMLDivElement;\n  stylesNames: CarouselSlideStylesNames;\n  compound: true;\n}>;\n\nconst defaultProps: Partial<CarouselSlideProps> = {};\n\nexport const CarouselSlide = factory<CarouselSlideFactory>((props, ref) => {\n  const { classNames, className, style, styles, vars, ...others } = useProps(\n    'CarouselSlide',\n    defaultProps,\n    props\n  );\n\n  const ctx = useCarouselContext();\n\n  return (\n    <Box\n      ref={ref}\n      mod={{ orientation: ctx.orientation }}\n      {...ctx.getStyles('slide', { className, style, classNames, styles })}\n      {...others}\n    />\n  );\n});\n\nCarouselSlide.classes = classes;\nCarouselSlide.displayName = '@mantine/core/CarouselSlide';\n", "import React from 'react';\nimport {\n  filterProps,\n  getBaseValue,\n  getSortedBreakpoints,\n  getSpacing,\n  InlineStyles,\n  keys,\n  MantineBreakpoint,\n  rem,\n  useMantineTheme,\n} from '@mantine/core';\nimport type { CarouselProps } from '../Carousel';\n\ninterface CarouselVariablesProps extends CarouselProps {\n  selector: string;\n}\n\nexport function CarouselVariables({ slideGap, slideSize, selector }: CarouselVariablesProps) {\n  const theme = useMantineTheme();\n\n  const baseStyles: Record<string, string | undefined> = filterProps({\n    '--carousel-slide-gap': getSpacing(getBaseValue(slideGap)),\n    '--carousel-slide-size': rem(getBaseValue(slideSize)),\n  });\n\n  const queries = keys(theme.breakpoints).reduce<Record<string, Record<string, any>>>(\n    (acc, breakpoint) => {\n      if (!acc[breakpoint]) {\n        acc[breakpoint] = {};\n      }\n\n      if (typeof slideGap === 'object' && slideGap[breakpoint] !== undefined) {\n        acc[breakpoint]['--carousel-slide-gap'] = getSpacing(slideGap[breakpoint]);\n      }\n\n      if (typeof slideSize === 'object' && slideSize[breakpoint] !== undefined) {\n        acc[breakpoint]['--carousel-slide-size'] = getSpacing(slideSize[breakpoint]);\n      }\n\n      return acc;\n    },\n    {}\n  );\n\n  const sortedBreakpoints = getSortedBreakpoints(keys(queries), theme).filter(\n    (breakpoint) => keys(queries[breakpoint.value]).length > 0\n  );\n\n  const media = sortedBreakpoints.map((breakpoint) => ({\n    query: `(min-width: ${theme.breakpoints[breakpoint.value as MantineBreakpoint]})`,\n    styles: queries[breakpoint.value],\n  }));\n\n  return <InlineStyles styles={baseStyles} media={media} selector={selector} />;\n}\n", "interface Options {\n  dir: 'rtl' | 'ltr';\n  orientation: 'horizontal' | 'vertical' | undefined;\n  direction: 'next' | 'previous';\n}\n\nexport function getChevronRotation({ dir, orientation, direction }: Options) {\n  if (direction === 'previous') {\n    return orientation === 'horizontal' ? 90 * (dir === 'ltr' ? 1 : -1) : -180;\n  }\n\n  return orientation === 'horizontal' ? 90 * (dir === 'ltr' ? -1 : 1) : 0;\n}\n", "import React, { Children, useCallback, useEffect, useState } from 'react';\nimport useEmblaCarousel, { EmblaCarouselType, EmblaPluginType } from 'embla-carousel-react';\nimport {\n  AccordionChevron,\n  Box,\n  BoxProps,\n  createVarsResolver,\n  ElementProps,\n  factory,\n  Factory,\n  getSpacing,\n  MantineSpacing,\n  rem,\n  StyleProp,\n  StylesApiProps,\n  UnstyledButton,\n  useDirection,\n  useProps,\n  useRandomClassName,\n  useStyles,\n} from '@mantine/core';\nimport { clamp } from '@mantine/hooks';\nimport { CarouselProvider } from './Carousel.context';\nimport { CarouselSlide } from './CarouselSlide/CarouselSlide';\nimport { CarouselVariables } from './CarouselVariables/CarouselVariables';\nimport { getChevronRotation } from './get-chevron-rotation';\nimport classes from './Carousel.module.css';\n\nexport type CarouselStylesNames =\n  | 'slide'\n  | 'root'\n  | 'viewport'\n  | 'container'\n  | 'controls'\n  | 'control'\n  | 'indicators'\n  | 'indicator';\n\nexport type CarouselCssVariables = {\n  root: '--carousel-height' | '--carousel-control-size' | '--carousel-controls-offset';\n};\n\nexport interface CarouselProps\n  extends BoxProps,\n    StylesApiProps<CarouselFactory>,\n    ElementProps<'div'> {\n  /** <Carousel.Slide /> components */\n  children?: React.ReactNode;\n\n  /** Called when next slide is shown */\n  onNextSlide?: () => void;\n\n  /** Called when previous slider is shown */\n  onPreviousSlide?: () => void;\n\n  /** Called with slide index when slide changes */\n  onSlideChange?: (index: number) => void;\n\n  /** Get embla API as ref */\n  getEmblaApi?: (embla: EmblaCarouselType) => void;\n\n  /** Props passed down to next control */\n  nextControlProps?: React.ComponentPropsWithoutRef<'button'>;\n\n  /** Props passed down to previous control */\n  previousControlProps?: React.ComponentPropsWithoutRef<'button'>;\n\n  /** Controls size of the next and previous controls, `26` by default */\n  controlSize?: React.CSSProperties['width'];\n\n  /** Controls position of the next and previous controls, key of `theme.spacing` or any valid CSS value, `'sm'` by default */\n  controlsOffset?: MantineSpacing;\n\n  /** Controls slide width based on viewport width, `'100%'` by default */\n  slideSize?: StyleProp<string | number>;\n\n  /** Key of theme.spacing or number to set gap between slides */\n  slideGap?: StyleProp<MantineSpacing>;\n\n  /** Carousel orientation, `'horizontal'` by default */\n  orientation?: 'horizontal' | 'vertical';\n\n  /** Slides container `height`, required for vertical orientation */\n  height?: React.CSSProperties['height'];\n\n  /** Determines how slides will be aligned relative to the container. Use number between 0-1 to align slides based on percentage, where 0.5 is 50%, `'center'` by default */\n  align?: 'start' | 'center' | 'end' | number;\n\n  /** Number of slides that will be scrolled with next/previous buttons, `1` by default */\n  slidesToScroll?: number | 'auto';\n\n  /** Determines whether gap between slides should be treated as part of the slide size, `true` by default */\n  includeGapInSize?: boolean;\n\n  /** Determines whether the carousel can be scrolled with mouse and touch interactions, `true` by default */\n  draggable?: boolean;\n\n  /** Determines whether momentum scrolling should be enabled, `false` by default */\n  dragFree?: boolean;\n\n  /** Enables infinite looping. `true` by default, automatically falls back to `false` if slide content isn't enough to loop. */\n  loop?: boolean;\n\n  /** Adjusts scroll speed when triggered by any of the methods. Higher numbers enables faster scrolling. */\n  speed?: number;\n\n  /** Index of initial slide */\n  initialSlide?: number;\n\n  /** Choose a fraction representing the percentage portion of a slide that needs to be visible in order to be considered in view. For example, 0.5 equals 50%. */\n  inViewThreshold?: number;\n\n  /** Determines whether next/previous controls should be displayed, true by default */\n  withControls?: boolean;\n\n  /** Determines whether indicators should be displayed, `false` by default */\n  withIndicators?: boolean;\n\n  /** An array of embla plugins */\n  plugins?: EmblaPluginType[];\n\n  /** Icon of the next control */\n  nextControlIcon?: React.ReactNode;\n\n  /** Icon of the previous control */\n  previousControlIcon?: React.ReactNode;\n\n  /** Allow the carousel to skip scroll snaps if it is dragged vigorously. Note that this option will be ignored if the dragFree option is set to `true`, `false` by default */\n  skipSnaps?: boolean;\n\n  /** Clear leading and trailing empty space that causes excessive scrolling. Use `trimSnaps` to only use snap points that trigger scrolling or keepSnaps to keep them. */\n  containScroll?: 'trimSnaps' | 'keepSnaps' | '';\n\n  /** Determines whether arrow key should switch slides, `true` by default */\n  withKeyboardEvents?: boolean;\n}\n\nexport type CarouselFactory = Factory<{\n  props: CarouselProps;\n  ref: HTMLDivElement;\n  stylesNames: CarouselStylesNames;\n  vars: CarouselCssVariables;\n  staticComponents: {\n    Slide: typeof CarouselSlide;\n  };\n}>;\n\nconst defaultProps: Partial<CarouselProps> = {\n  controlSize: 26,\n  controlsOffset: 'sm',\n  slideSize: '100%',\n  slideGap: 0,\n  orientation: 'horizontal',\n  align: 'center',\n  slidesToScroll: 1,\n  includeGapInSize: true,\n  draggable: true,\n  dragFree: false,\n  loop: false,\n  speed: 10,\n  initialSlide: 0,\n  inViewThreshold: 0,\n  withControls: true,\n  withIndicators: false,\n  skipSnaps: false,\n  containScroll: '',\n  withKeyboardEvents: true,\n};\n\nconst varsResolver = createVarsResolver<CarouselFactory>(\n  (_, { height, controlSize, controlsOffset }) => ({\n    root: {\n      '--carousel-height': rem(height),\n      '--carousel-control-size': rem(controlSize),\n      '--carousel-controls-offset': getSpacing(controlsOffset),\n    },\n  })\n);\n\nexport const Carousel = factory<CarouselFactory>((_props, ref) => {\n  const props = useProps('Carousel', defaultProps, _props);\n  const {\n    classNames,\n    className,\n    style,\n    styles,\n    unstyled,\n    vars,\n    children,\n    getEmblaApi,\n    onNextSlide,\n    onPreviousSlide,\n    onSlideChange,\n    nextControlProps,\n    previousControlProps,\n    controlSize,\n    controlsOffset,\n    slideSize,\n    slideGap,\n    orientation,\n    height,\n    align,\n    slidesToScroll,\n    includeGapInSize,\n    draggable,\n    dragFree,\n    loop,\n    speed,\n    initialSlide,\n    inViewThreshold,\n    withControls,\n    withIndicators,\n    plugins,\n    nextControlIcon,\n    previousControlIcon,\n    skipSnaps,\n    containScroll,\n    withKeyboardEvents,\n    ...others\n  } = props;\n\n  const getStyles = useStyles<CarouselFactory>({\n    name: 'Carousel',\n    classes,\n    props,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars,\n    varsResolver,\n  });\n\n  const responsiveClassName = useRandomClassName();\n  const { dir } = useDirection();\n\n  const [emblaRefElement, embla] = useEmblaCarousel(\n    {\n      axis: orientation === 'horizontal' ? 'x' : 'y',\n      direction: orientation === 'horizontal' ? dir : undefined,\n      startIndex: initialSlide,\n      loop,\n      align,\n      slidesToScroll,\n      draggable,\n      dragFree,\n      speed,\n      inViewThreshold,\n      skipSnaps,\n      containScroll,\n    },\n    plugins\n  );\n\n  const [selected, setSelected] = useState(0);\n  const [slidesCount, setSlidesCount] = useState(0);\n\n  const handleScroll = useCallback((index: number) => embla && embla.scrollTo(index), [embla]);\n\n  const handleSelect = useCallback(() => {\n    if (!embla) return;\n    const slide = embla.selectedScrollSnap();\n    setSelected(slide);\n    onSlideChange?.(slide);\n  }, [embla, setSelected]);\n\n  const handlePrevious = useCallback(() => {\n    embla?.scrollPrev();\n    onPreviousSlide?.();\n  }, [embla]);\n\n  const handleNext = useCallback(() => {\n    embla?.scrollNext();\n    onNextSlide?.();\n  }, [embla]);\n\n  const handleKeydown = useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (withKeyboardEvents) {\n        if (event.key === 'ArrowRight') {\n          event.preventDefault();\n          handleNext();\n        }\n\n        if (event.key === 'ArrowLeft') {\n          event.preventDefault();\n          handlePrevious();\n        }\n      }\n    },\n    [embla]\n  );\n\n  useEffect(() => {\n    if (embla) {\n      getEmblaApi?.(embla);\n      handleSelect();\n      setSlidesCount(embla.scrollSnapList().length);\n      embla.on('select', handleSelect);\n\n      return () => {\n        embla.off('select', handleSelect);\n      };\n    }\n\n    return undefined;\n  }, [embla, slidesToScroll]);\n\n  useEffect(() => {\n    if (embla) {\n      embla.reInit();\n      setSlidesCount(embla.scrollSnapList().length);\n      setSelected((currentSelected) =>\n        clamp(currentSelected, 0, Children.toArray(children).length - 1)\n      );\n    }\n  }, [Children.toArray(children).length, slidesToScroll]);\n\n  const canScrollPrev = embla?.canScrollPrev() || false;\n  const canScrollNext = embla?.canScrollNext() || false;\n\n  const indicators = Array(slidesCount)\n    .fill(0)\n    .map((_, index) => (\n      <UnstyledButton\n        {...getStyles('indicator')}\n        key={index}\n        data-active={index === selected || undefined}\n        aria-hidden\n        tabIndex={-1}\n        onClick={() => handleScroll(index)}\n      />\n    ));\n\n  return (\n    <CarouselProvider value={{ getStyles, orientation }}>\n      <CarouselVariables {...props} selector={`.${responsiveClassName}`} />\n      <Box\n        ref={ref}\n        {...getStyles('root', { className: responsiveClassName })}\n        {...others}\n        mod={{ orientation, 'include-gap-in-size': includeGapInSize }}\n        onKeyDownCapture={handleKeydown}\n      >\n        <div {...getStyles('viewport')} ref={emblaRefElement}>\n          <div {...getStyles('container')} data-orientation={orientation}>\n            {children}\n          </div>\n        </div>\n\n        {withIndicators && <div {...getStyles('indicators')}>{indicators}</div>}\n\n        {withControls && (\n          <div {...getStyles('controls')}>\n            <UnstyledButton\n              {...previousControlProps}\n              {...getStyles('control', {\n                className: previousControlProps?.className,\n                style: previousControlProps?.style,\n              })}\n              onClick={(event) => {\n                handlePrevious();\n                previousControlProps?.onClick?.(event);\n              }}\n              data-inactive={!canScrollPrev || undefined}\n              tabIndex={canScrollPrev ? 0 : -1}\n            >\n              {typeof previousControlIcon !== 'undefined' ? (\n                previousControlIcon\n              ) : (\n                <AccordionChevron\n                  style={{\n                    transform: `rotate(${getChevronRotation({\n                      dir,\n                      orientation,\n                      direction: 'previous',\n                    })}deg)`,\n                  }}\n                />\n              )}\n            </UnstyledButton>\n\n            <UnstyledButton\n              {...getStyles('control', {\n                className: nextControlProps?.className,\n                style: nextControlProps?.style,\n              })}\n              {...nextControlProps}\n              onClick={(event) => {\n                handleNext();\n                nextControlProps?.onClick?.(event);\n              }}\n              data-inactive={!canScrollNext || undefined}\n              tabIndex={canScrollNext ? 0 : -1}\n            >\n              {typeof nextControlIcon !== 'undefined' ? (\n                nextControlIcon\n              ) : (\n                <AccordionChevron\n                  style={{\n                    transform: `rotate(${getChevronRotation({\n                      dir,\n                      orientation,\n                      direction: 'next',\n                    })}deg)`,\n                  }}\n                />\n              )}\n            </UnstyledButton>\n          </div>\n        )}\n      </Box>\n    </CarouselProvider>\n  );\n});\n\nCarousel.classes = classes;\nCarousel.displayName = '@mantine/core/Carousel';\nCarousel.Slide = CarouselSlide;\n", "import { useEffect } from 'react';\nimport type { EmblaCarouselType } from 'embla-carousel-react';\n\nexport function useAnimationOffsetEffect(\n  embla: EmblaCarouselType | null | undefined,\n  transitionDuration: number\n) {\n  useEffect(() => {\n    if (embla) {\n      window.setTimeout(() => {\n        embla.reInit();\n      }, transitionDuration);\n    }\n  }, [embla, transitionDuration]);\n}\n"],
  "mappings": "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",
  "names": ["map", "value", "iStart", "iStop", "oStart", "oStop", "isNumber", "subject", "isString", "isObject", "Object", "prototype", "toString", "call", "isArray", "Array", "isRecord", "mathAbs", "n", "Math", "abs", "mathSign", "deltaAbs", "valueB", "valueA", "factorAbs", "diff", "roundToDecimals", "decimalPoints", "pow", "round", "arrayKeys", "array", "objectKeys", "Number", "arrayLast", "arrayLastIndex", "max", "length", "object", "keys", "objectsMergeDeep", "objectA", "objectB", "reduce", "mergedObjects", "currentObject", "forEach", "key", "areObjects", "objectsAreEqual", "objectAKeys", "objectBKeys", "every", "concat", "Alignment", "align", "viewSize", "predefined", "start", "center", "end", "percent", "measure", "self", "Animation", "callback", "animationFrame", "ifAnimating", "active", "cb", "window", "requestAnimationFrame", "stop", "cancelAnimationFrame", "proceed", "Axis", "axis", "direction", "scroll", "cross", "startEdge", "getStartEdge", "endEdge", "getEndEdge", "measureSize", "rect", "width", "height", "Limit", "min", "reachedMin", "reachedMax", "reachedAny", "constrain", "removeOffset", "ceil", "Counter", "loop", "_a", "loopEnd", "counter", "withinLimit", "get", "set", "add", "clone", "Direction", "sign", "apply", "EventStore", "listeners", "node", "type", "handler", "options", "passive", "addEventListener", "push", "removeEventListener", "removeAll", "filter", "remove", "Vector1D", "vector", "readNumber", "subtract", "multiply", "divide", "normalize", "DragHandler", "rootNode", "target", "dragTracker", "location", "animation", "scrollTo", "scrollBody", "scrollTarget", "index", "eventHandler", "percentOfView", "dragFree", "skipSnaps", "crossAxis", "focusNodes", "nonPassiveEvent", "dragStartPoint", "activationEvents", "interactionEvents", "dragThreshold", "snapForceBoost", "mouse", "touch", "freeForceBoost", "baseSpeed", "baseMass", "startScroll", "startCross", "pointerIsDown", "preventScroll", "preventClick", "isMouse", "addActivationEvents", "evt", "preventDefault", "undefined", "down", "up", "click", "addInteractionEvents", "document", "move", "removeAllEvents", "isFocusNode", "name", "nodeName", "indexOf", "forceBoost", "boost", "allowedForce", "force", "targetChanged", "next", "isEdge", "baseForce", "byDistance", "distance", "byIndex", "isTouchEvent", "button", "isMoving", "clearPreventClick", "pointerDown", "useBaseMass", "useSpeed", "readPoint", "emit", "cancelable", "lastScroll", "lastCross", "diffScroll", "diffCross", "pointerMove", "currentLocation", "rawForce", "pointerUp", "forceFactor", "isVigorous", "isBelowThreshold", "speed", "mass", "useMass", "stopPropagation", "clickAllowed", "DragTracker", "logInterval", "startEvent", "lastEvent", "TouchEvent", "readTime", "timeStamp", "evtAxis", "property", "coord", "touches", "expired", "diffDrag", "diffTime", "isFlick", "PercentOfView", "ScrollBody", "roundToTwoDecimals", "velocity", "acceleration", "attraction", "attractionDirection", "update", "applyForce", "seek", "magnitude", "settle", "hasSettled", "useBaseSpeed", "ScrollBounds", "limit", "pullBackThreshold", "edgeOffsetTolerance", "maxFriction", "disabled", "shouldConstrain", "edge", "diffToEdge", "diffToTarget", "friction", "toggleActive", "ScrollContain", "contentSize", "snapsAligned", "containScroll", "scrollBounds", "snapsBounded", "snapsContained", "measureContained", "findDuplicates", "startSnap", "endSnap", "lastIndexOf", "slice", "ScrollLimit", "scrollSnaps", "measureLimit", "ScrollLooper", "vectors", "jointSafety", "shouldLoop", "loopDistance", "v", "ScrollProgress", "scrollLength", "ScrollSnaps", "alignment", "containerRect", "slideRects", "slideSizesWithGaps", "slidesToScroll", "groupSlides", "alignments", "measureSizes", "snaps", "measureUnaligned", "measureAligned", "rects", "snap", "containedStartSnap", "containedEndSnap", "g", "groupedSnaps", "isFirst", "isLast", "ScrollTarget", "targetVector", "minDistance", "distances", "sort", "a", "b", "findTargetSnap", "ascDiffsToSnaps", "scrollSnap", "diffToSnap", "shortcut", "i", "d1", "d2", "targets", "matchingTargets", "t", "targetSnapDistance", "reachedBound", "snapDistance", "ScrollTo", "indexCurrent", "indexPrevious", "distanceDiff", "indexDiff", "targetIndex", "Translate", "container", "translate", "x", "y", "containerStyle", "style", "to", "transform", "clear", "getAttribute", "removeAttribute", "SlideLooper", "slidesInView", "slides", "ascItems", "descItems", "reverse", "loopPoints", "startPoints", "endPoints", "removeSlideSizes", "indexes", "from", "slidesInGap", "gap", "remainingGap", "findLoopPoints", "isStartEdge", "offset", "slideBounds", "findSlideBounds", "initial", "altered", "bounds", "point", "shift", "canLoop", "otherIndexes", "loopPoint", "SlidesInView", "slideSizes", "inViewThreshold", "roundingSafety", "cachedOffsets", "cachedBounds", "findSlideThresholds", "threshold", "slideThreshold", "slideSize", "thresholdLimit", "offsets", "slideOffsets", "slideThresholds", "list", "check", "limitedLocation", "slideBound", "inList", "inView", "SlideSizes", "readEdgeGap", "withEdgeGap", "startGap", "measureStartGap", "endGap", "measureEndGap", "measureWithGaps", "slideRect", "getComputedStyle", "parseFloat", "getPropertyValue", "SlidesToScroll", "groupByNumber", "byNumber", "groupSize", "bySize", "groupSizes", "chunk", "chunkSize", "s", "Engine", "root", "scrollAxis", "contentDirection", "startIndex", "getBoundingClientRect", "slide", "containSnaps", "_b", "slideIndexes", "engine", "dragHandler", "settled", "scrollLooper", "slideLooper", "startLocation", "eventStore", "scrollProgress", "EventHandler", "getListeners", "e", "on", "off", "defaultOptions", "breakpoints", "draggable", "OptionsHandler", "merge", "optionsA", "optionsB", "areEqual", "breakpointsA", "JSON", "stringify", "breakpointsB", "atMedia", "optionsAtMedia", "matchedMediaOptions", "media", "matchMedia", "matches", "mediaOption", "PluginsHandler", "activePlugins", "pluginsChanged", "haveChanged", "some", "hasChanged", "plugin", "init", "plugins", "embla", "assign", "destroy", "EmblaCarousel", "userOptions", "userPlugins", "resizeHandlers", "optionsHandler", "pluginsHandler", "reInit", "reActivate", "destroyed", "optionsBase", "globalOptions", "pluginList", "pluginApis", "rootSize", "storeElements", "userContainer", "userSlides", "customContainer", "querySelector", "children", "customSlides", "querySelectorAll", "activate", "withOptions", "withPlugins", "deActivate", "offsetParent", "selectedScrollSnap", "resize", "newOptions", "optionsChanged", "newRootSize", "rootSizeChanged", "slidesNotInView", "jump", "scrollNext", "scrollPrev", "prev", "canScrollNext", "canScrollPrev", "scrollSnapList", "previousScrollSnap", "internalEngine", "containerNode", "slideNodes", "setTimeout", "canUseDOM", "window", "document", "createElement", "sortAndMapPluginToOptions", "plugins", "concat", "sort", "a", "b", "name", "map", "plugin", "options", "arePluginsEqual", "pluginsA", "pluginsB", "length", "areEqual", "EmblaCarousel", "optionsHandler", "optionsA", "optionsB", "every", "optionA", "index", "optionB", "useEmblaCarousel", "useRef", "storedOptions", "storedPlugins", "_a", "useState", "embla", "setEmbla", "_b", "viewport", "setViewport", "reInit", "useCallback", "current", "useEffect", "globalOptions", "newEmbla_1", "destroy", "undefined", "React", "React", "defaultProps", "React"]
}
