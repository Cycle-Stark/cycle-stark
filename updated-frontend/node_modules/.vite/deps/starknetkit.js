import {
  A,
  A2,
  F,
  N,
  R,
  T,
  U,
  b,
  k,
  q
} from "./chunk-IEXJRT7I.js";
import {
  Account,
  RpcProvider,
  constants_exports
} from "./chunk-VGTBFQ5D.js";
import "./chunk-ROME4SDB.js";

// node_modules/starknetkit/dist/index-d7ebad06.js
var rn = Object.defineProperty;
var nn = (t, e, r) => e in t ? rn(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var ie = (t, e, r) => (nn(t, typeof e != "symbol" ? e + "" : e, r), r);
var ar = "https://web.argent.xyz";
var Dt = `<svg
    width="32"
    height="28"
    viewBox="0 0 18 14"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M1.5 0.4375C0.982233 0.4375 0.5625 0.857233 0.5625 1.375V12C0.5625 12.4144 0.72712 12.8118 1.02015 13.1049C1.31317 13.3979 1.7106 13.5625 2.125 13.5625H15.875C16.2894 13.5625 16.6868 13.3979 16.9799 13.1049C17.2729 12.8118 17.4375 12.4144 17.4375 12V1.375C17.4375 0.857233 17.0178 0.4375 16.5 0.4375H1.5ZM2.4375 3.50616V11.6875H15.5625V3.50616L9.63349 8.94108C9.27507 9.26964 8.72493 9.26964 8.36651 8.94108L2.4375 3.50616ZM14.0899 2.3125H3.91013L9 6.97822L14.0899 2.3125Z"
      fill="currentColor"
    />
  </svg>`;
var Zt = "https://api.hydrogen.argent47.net/v1/starknet/goerli/rpc/v0.5";
var ct = "https://cloud.argent-api.com/v1/starknet/goerli/rpc/v0.5";
function un(t) {
  return t;
}
function ln(t) {
  return t.length === 0 ? un : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function dn(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function Ye(t) {
  const e = {
    subscribe(r) {
      let n = null, s = false, i = false, a = false;
      function o3() {
        if (n === null) {
          a = true;
          return;
        }
        i || (i = true, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          var _a3;
          s || ((_a3 = r.next) == null ? void 0 : _a3.call(r, c));
        },
        error(c) {
          var _a3;
          s || (s = true, (_a3 = r.error) == null ? void 0 : _a3.call(r, c), o3());
        },
        complete() {
          var _a3;
          s || (s = true, (_a3 = r.complete) == null ? void 0 : _a3.call(r), o3());
        }
      }), a && o3(), {
        unsubscribe: o3
      };
    },
    pipe(...r) {
      return ln(r)(e);
    }
  };
  return e;
}
function or(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e.subscribe({
        next(o3) {
          var _a3;
          for (const c of s)
            (_a3 = c.next) == null ? void 0 : _a3.call(c, o3);
        },
        error(o3) {
          var _a3;
          for (const c of s)
            (_a3 = c.error) == null ? void 0 : _a3.call(c, o3);
        },
        complete() {
          var _a3;
          for (const o3 of s)
            (_a3 = o3.complete) == null ? void 0 : _a3.call(o3);
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o3 = n;
        n = null, o3.unsubscribe();
      }
    }
    return {
      subscribe(o3) {
        return r++, s.push(o3), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u2) => u2 === o3);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function fn(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(i) {
          var _a3;
          (_a3 = r.next) == null ? void 0 : _a3.call(r, t(i, n++));
        },
        error(i) {
          var _a3;
          (_a3 = r.error) == null ? void 0 : _a3.call(r, i);
        },
        complete() {
          var _a3;
          (_a3 = r.complete) == null ? void 0 : _a3.call(r);
        }
      });
    }
  });
}
function cr(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          var _a3, _b2;
          (_a3 = t.next) == null ? void 0 : _a3.call(t, n), (_b2 = r.next) == null ? void 0 : _b2.call(r, n);
        },
        error(n) {
          var _a3, _b2;
          (_a3 = t.error) == null ? void 0 : _a3.call(t, n), (_b2 = r.error) == null ? void 0 : _b2.call(r, n);
        },
        complete() {
          var _a3, _b2;
          (_a3 = t.complete) == null ? void 0 : _a3.call(t), (_b2 = r.complete) == null ? void 0 : _b2.call(r);
        }
      });
    }
  });
}
var pn = class ur extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, ur.prototype);
  }
};
function lr(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let i = false;
      function a() {
        i || (i = true, s(new pn("This operation was aborted.")), o3.unsubscribe());
      }
      const o3 = t.subscribe({
        next(c) {
          i = true, n(c), a();
        },
        error(c) {
          i = true, s(c), a();
        },
        complete() {
          i = true, a();
        }
      });
      e = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
var hn = Object.freeze(Object.defineProperty({
  __proto__: null,
  isObservable: dn,
  map: fn,
  observable: Ye,
  observableToPromise: lr,
  share: or,
  tap: cr
}, Symbol.toStringTag, { value: "Module" }));
function dr(t) {
  return Ye((e) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function Ut(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function mn(t) {
  return (e) => {
    const r = Ut(t.true).map((s) => s(e)), n = Ut(t.false).map((s) => s(e));
    return (s) => Ye((i) => {
      const a = t.condition(s.op) ? r : n;
      return dr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
function yn(t) {
  return t instanceof fr || /**
  * @deprecated
  * Delete in next major
  */
  t.name === "TRPCClientError";
}
var fr = class Ae extends Error {
  static from(e, r = {}) {
    return e instanceof Error ? yn(e) ? (r.meta && (e.meta = {
      ...e.meta,
      ...r.meta
    }), e) : new Ae(e.message, {
      ...r,
      cause: e,
      result: null
    }) : new Ae(e.error.message ?? "", {
      ...r,
      cause: void 0,
      result: e
    });
  }
  constructor(e, r) {
    var _a3, _b2;
    const n = r == null ? void 0 : r.cause;
    super(e, {
      cause: n
    }), this.meta = r == null ? void 0 : r.meta, this.cause = n, this.shape = (_a3 = r == null ? void 0 : r.result) == null ? void 0 : _a3.error, this.data = (_b2 = r == null ? void 0 : r.result) == null ? void 0 : _b2.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Ae.prototype);
  }
};
function pr(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const r in t) {
    const n = t[r];
    e[n] = r;
  }
  return e;
}
var Qe = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
pr(Qe);
pr(Qe);
var gn = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  METHOD_NOT_SUPPORTED: 405,
  TIMEOUT: 408,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  CLIENT_CLOSED_REQUEST: 499,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501
};
function _n(t) {
  return gn[t] ?? 500;
}
function hr(t) {
  return _n(t.code);
}
var mr = () => {
};
function yr(t, e) {
  return new Proxy(mr, {
    get(n, s) {
      if (!(typeof s != "string" || s === "then"))
        return yr(t, [
          ...e,
          s
        ]);
    },
    apply(n, s, i) {
      const a = e[e.length - 1] === "apply";
      return t({
        args: a ? i.length >= 2 ? i[1] : [] : i,
        path: a ? e.slice(0, -1) : e
      });
    }
  });
}
var Tt = (t) => yr(t, []);
var Et = (t) => new Proxy(mr, {
  get(e, r) {
    if (!(typeof r != "string" || r === "then"))
      return t(r);
  }
});
function bn(t) {
  const { path: e, error: r, config: n } = t, { code: s } = t.error, i = {
    message: r.message,
    code: Qe[s],
    data: {
      code: s,
      httpStatus: hr(r)
    }
  };
  return n.isDev && typeof t.error.stack == "string" && (i.data.stack = t.error.stack), typeof e == "string" && (i.data.path = e), n.errorFormatter({
    ...t,
    shape: i
  });
}
function Wt(t, e) {
  return "error" in e ? {
    ...e,
    error: t.transformer.output.serialize(e.error)
  } : "data" in e.result ? {
    ...e,
    result: {
      ...e.result,
      data: t.transformer.output.serialize(e.result.data)
    }
  } : e;
}
function vn(t, e) {
  return Array.isArray(e) ? e.map((r) => Wt(t, r)) : Wt(t, e);
}
var wn = Object.freeze(Object.defineProperty({
  __proto__: null,
  createFlatProxy: Et,
  createRecursiveProxy: Tt,
  getErrorShape: bn,
  transformTRPCResponse: vn
}, Symbol.toStringTag, { value: "Module" }));
function xn(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var ut = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function Tn(t) {
  const { direction: e, type: r, path: n, id: s, input: i } = t, a = [], o3 = [];
  if (t.colorMode === "ansi") {
    const [h3, m] = ut.ansi.regular[r], [x, E2] = ut.ansi.bold[r], S2 = "\x1B[0m";
    return a.push(e === "up" ? h3 : m, e === "up" ? ">>" : "<<", r, e === "up" ? x : E2, `#${s}`, n, S2), e === "up" ? o3.push({
      input: t.input
    }) : o3.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o3
    };
  }
  const [c, u2] = ut.css[r], l2 = `
    background-color: #${e === "up" ? c : u2}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o3.push(l2, `${l2}; font-weight: bold;`, `${l2}; font-weight: normal;`), e === "up" ? o3.push({
    input: i,
    context: t.context
  }) : o3.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o3
  };
}
var En = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = xn(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = Tn({
    ...r,
    colorMode: e,
    input: s
  }), o3 = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o3].apply(null, [
    i.join(" ")
  ].concat(a));
};
function kn(t = {}) {
  const { enabled: e = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = En({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => Ye((a) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o3 = Date.now();
    function c(u2) {
      const l2 = Date.now() - o3;
      e({
        ...s,
        direction: "down",
        result: u2
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l2,
        result: u2
      });
    }
    return i(s).pipe(cr({
      next(u2) {
        c(u2);
      },
      error(u2) {
        c(u2);
      }
    })).subscribe(a);
  });
}
var Cn = class {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return dr({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(or());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = lr(r);
    return new Promise((a, o3) => {
      var _a3;
      (_a3 = e.signal) == null ? void 0 : _a3.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o3(fr.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context
    }).subscribe({
      next(i) {
        var _a3, _b2, _c2;
        i.result.type === "started" ? (_a3 = n.onStarted) == null ? void 0 : _a3.call(n) : i.result.type === "stopped" ? (_b2 = n.onStopped) == null ? void 0 : _b2.call(n) : (_c2 = n.onData) == null ? void 0 : _c2.call(n, i.result.data);
      },
      error(i) {
        var _a3;
        (_a3 = n.onError) == null ? void 0 : _a3.call(n, i);
      },
      complete() {
        var _a3;
        (_a3 = n.onComplete) == null ? void 0 : _a3.call(n);
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
};
var Rn = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var On = (t) => Rn[t];
function Pn(t) {
  return Et((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : Tt(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], i = On(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Sn(t) {
  const e = new Cn(t);
  return Pn(e);
}
function Nn(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function Ln(t) {
  if (t instanceof ue)
    return t;
  const e = new ue({
    code: "INTERNAL_SERVER_ERROR",
    cause: t
  });
  return t instanceof Error && t.stack && (e.stack = t.stack), e;
}
var In = class extends Error {
};
function jn(t) {
  if (t instanceof Error)
    return t;
  const e = typeof t;
  if (!(e === "undefined" || e === "function" || t === null)) {
    if (e !== "object")
      return new Error(String(t));
    if (Nn(t)) {
      const r = new In();
      for (const n in t)
        r[n] = t[n];
      return r;
    }
  }
}
var ue = class extends Error {
  constructor(e) {
    const r = jn(e.cause), n = e.message ?? (r == null ? void 0 : r.message) ?? e.code;
    super(n, {
      cause: r
    }), this.code = e.code, this.name = this.constructor.name;
  }
};
function An(t) {
  return "input" in t ? t : {
    input: t,
    output: t
  };
}
var ye = {
  _default: true,
  input: {
    serialize: (t) => t,
    deserialize: (t) => t
  },
  output: {
    serialize: (t) => t,
    deserialize: (t) => t
  }
};
var ge = ({ shape: t }) => t;
function Mn(t) {
  return Object.assign(/* @__PURE__ */ Object.create(null), t);
}
var $n = [
  "query",
  "mutation",
  "subscription"
];
function Dn(t) {
  return "router" in t._def;
}
var Zn = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: ge,
  transformer: ye
};
var Un = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function gr(t) {
  return function(r) {
    const n = new Set(Object.keys(r).filter((c) => Un.includes(c)));
    if (n.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(n).join(", "));
    const s = Mn({});
    function i(c, u2 = "") {
      for (const [l2, h3] of Object.entries(c ?? {})) {
        const m = `${u2}${l2}`;
        if (Dn(h3)) {
          i(h3._def.procedures, `${m}.`);
          continue;
        }
        if (s[m])
          throw new Error(`Duplicate key: ${m}`);
        s[m] = h3;
      }
    }
    i(r);
    const a = {
      _config: t,
      router: true,
      procedures: s,
      ...Zn,
      record: r,
      queries: Object.entries(s).filter((c) => c[1]._def.query).reduce((c, [u2, l2]) => ({
        ...c,
        [u2]: l2
      }), {}),
      mutations: Object.entries(s).filter((c) => c[1]._def.mutation).reduce((c, [u2, l2]) => ({
        ...c,
        [u2]: l2
      }), {}),
      subscriptions: Object.entries(s).filter((c) => c[1]._def.subscription).reduce((c, [u2, l2]) => ({
        ...c,
        [u2]: l2
      }), {})
    };
    return {
      ...r,
      _def: a,
      createCaller(c) {
        return Tt(({ path: l2, args: h3 }) => {
          if (l2.length === 1 && $n.includes(l2[0]))
            return Wn({
              procedures: a.procedures,
              path: h3[0],
              rawInput: h3[1],
              ctx: c,
              type: l2[0]
            });
          const m = l2.join("."), x = a.procedures[m];
          let E2 = "query";
          return x._def.mutation ? E2 = "mutation" : x._def.subscription && (E2 = "subscription"), x({
            path: m,
            rawInput: h3[0],
            ctx: c,
            type: E2
          });
        });
      },
      getErrorShape(c) {
        const { path: u2, error: l2 } = c, { code: h3 } = c.error, m = {
          message: l2.message,
          code: Qe[h3],
          data: {
            code: h3,
            httpStatus: hr(l2)
          }
        };
        return t.isDev && typeof c.error.stack == "string" && (m.data.stack = c.error.stack), typeof u2 == "string" && (m.data.path = u2), this._def._config.errorFormatter({
          ...c,
          shape: m
        });
      }
    };
  };
}
function Wn(t) {
  var _a3;
  const { type: e, path: r } = t;
  if (!(r in t.procedures) || !((_a3 = t.procedures[r]) == null ? void 0 : _a3._def[e]))
    throw new ue({
      code: "NOT_FOUND",
      message: `No "${e}"-procedure on path "${r}"`
    });
  const n = t.procedures[r];
  return n(t);
}
var _a, _b, _c, _d, _e, _f;
var qt = typeof window > "u" || "Deno" in window || ((_b = (_a = globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.NODE_ENV) === "test" || !!((_d = (_c = globalThis.process) == null ? void 0 : _c.env) == null ? void 0 : _d.JEST_WORKER_ID) || !!((_f = (_e = globalThis.process) == null ? void 0 : _e.env) == null ? void 0 : _f.VITEST_WORKER_ID);
function zt(t) {
  const e = t;
  if (typeof e == "function")
    return e;
  if (typeof e.parseAsync == "function")
    return e.parseAsync.bind(e);
  if (typeof e.parse == "function")
    return e.parse.bind(e);
  if (typeof e.validateSync == "function")
    return e.validateSync.bind(e);
  if (typeof e.create == "function")
    return e.create.bind(e);
  if (typeof e.assert == "function")
    return (r) => (e.assert(r), r);
  throw new Error("Could not find a validator fn");
}
function _r(t, ...e) {
  const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
  for (const n of e)
    for (const s in n) {
      if (s in r && r[s] !== n[s])
        throw new Error(`Duplicate key ${s}`);
      r[s] = n[s];
    }
  return r;
}
function qn() {
  function t(r) {
    return {
      _middlewares: r,
      unstable_pipe(n) {
        const s = "_middlewares" in n ? n._middlewares : [
          n
        ];
        return t([
          ...r,
          ...s
        ]);
      }
    };
  }
  function e(r) {
    return t([
      r
    ]);
  }
  return e;
}
function Vt(t) {
  return t && typeof t == "object" && !Array.isArray(t);
}
function zn(t) {
  const e = async ({ next: r, rawInput: n, input: s }) => {
    let i;
    try {
      i = await t(n);
    } catch (o3) {
      throw new ue({
        code: "BAD_REQUEST",
        cause: o3
      });
    }
    const a = Vt(s) && Vt(i) ? {
      ...s,
      ...i
    } : i;
    return r({
      input: a
    });
  };
  return e._type = "input", e;
}
function Vn(t) {
  const e = async ({ next: r }) => {
    const n = await r();
    if (!n.ok)
      return n;
    try {
      const s = await t(n.data);
      return {
        ...n,
        data: s
      };
    } catch (s) {
      throw new ue({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: s
      });
    }
  };
  return e._type = "output", e;
}
var br = "middlewareMarker";
function ae(t, e) {
  const { middlewares: r = [], inputs: n, meta: s, ...i } = e;
  return vr({
    ..._r(t, i),
    inputs: [
      ...t.inputs,
      ...n ?? []
    ],
    middlewares: [
      ...t.middlewares,
      ...r
    ],
    meta: t.meta && s ? {
      ...t.meta,
      ...s
    } : s ?? t.meta
  });
}
function vr(t = {}) {
  const e = {
    inputs: [],
    middlewares: [],
    ...t
  };
  return {
    _def: e,
    input(r) {
      const n = zt(r);
      return ae(e, {
        inputs: [
          r
        ],
        middlewares: [
          zn(n)
        ]
      });
    },
    output(r) {
      const n = zt(r);
      return ae(e, {
        output: r,
        middlewares: [
          Vn(n)
        ]
      });
    },
    meta(r) {
      return ae(e, {
        meta: r
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(r) {
      return ae(e, r._def);
    },
    use(r) {
      const n = "_middlewares" in r ? r._middlewares : [
        r
      ];
      return ae(e, {
        middlewares: n
      });
    },
    query(r) {
      return lt({
        ...e,
        query: true
      }, r);
    },
    mutation(r) {
      return lt({
        ...e,
        mutation: true
      }, r);
    },
    subscription(r) {
      return lt({
        ...e,
        subscription: true
      }, r);
    }
  };
}
function lt(t, e) {
  const r = ae(t, {
    resolver: e,
    middlewares: [
      async function(s) {
        const i = await e(s);
        return {
          marker: br,
          ok: true,
          data: i,
          ctx: s.ctx
        };
      }
    ]
  });
  return Hn(r._def);
}
var Bn = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
function Hn(t) {
  const e = async function(n) {
    if (!n || !("rawInput" in n))
      throw new Error(Bn);
    const s = async (a = {
      index: 0,
      ctx: n.ctx
    }) => {
      try {
        const o3 = t.middlewares[a.index];
        return await o3({
          ctx: a.ctx,
          type: n.type,
          path: n.path,
          rawInput: a.rawInput ?? n.rawInput,
          meta: t.meta,
          input: a.input,
          next(u2) {
            const l2 = u2;
            return s({
              index: a.index + 1,
              ctx: l2 && "ctx" in l2 ? {
                ...a.ctx,
                ...l2.ctx
              } : a.ctx,
              input: l2 && "input" in l2 ? l2.input : a.input,
              rawInput: l2 && "rawInput" in l2 ? l2.rawInput : a.rawInput
            });
          }
        });
      } catch (o3) {
        return {
          ok: false,
          error: Ln(o3),
          marker: br
        };
      }
    }, i = await s();
    if (!i)
      throw new ue({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!i.ok)
      throw i.error;
    return i.data;
  };
  return e._def = t, e.meta = t.meta, e;
}
function Fn(...t) {
  var _a3;
  const e = _r({}, ...t.map((i) => i._def.record)), r = t.reduce((i, a) => {
    if (a._def._config.errorFormatter && a._def._config.errorFormatter !== ge) {
      if (i !== ge && i !== a._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return a._def._config.errorFormatter;
    }
    return i;
  }, ge), n = t.reduce((i, a) => {
    if (a._def._config.transformer && a._def._config.transformer !== ye) {
      if (i !== ye && i !== a._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return a._def._config.transformer;
    }
    return i;
  }, ye);
  return gr({
    errorFormatter: r,
    transformer: n,
    isDev: t.some((i) => i._def._config.isDev),
    allowOutsideOfServer: t.some((i) => i._def._config.allowOutsideOfServer),
    isServer: t.some((i) => i._def._config.isServer),
    $types: (_a3 = t[0]) == null ? void 0 : _a3._def._config.$types
  })(e);
}
var Ze = class _Ze {
  context() {
    return new _Ze();
  }
  meta() {
    return new _Ze();
  }
  create(e) {
    return Gn()(e);
  }
};
var Jn = new Ze();
function Gn() {
  return function(e) {
    var _a3, _b2;
    const r = (e == null ? void 0 : e.errorFormatter) ?? ge, s = {
      transformer: An((e == null ? void 0 : e.transformer) ?? ye),
      isDev: (e == null ? void 0 : e.isDev) ?? ((_b2 = (_a3 = globalThis.process) == null ? void 0 : _a3.env) == null ? void 0 : _b2.NODE_ENV) !== "production",
      allowOutsideOfServer: (e == null ? void 0 : e.allowOutsideOfServer) ?? false,
      errorFormatter: r,
      isServer: (e == null ? void 0 : e.isServer) ?? qt,
      /**
      * @internal
      */
      $types: Et((i) => {
        throw new Error(`Tried to access "$types.${i}" which is not available at runtime`);
      })
    };
    if (!((e == null ? void 0 : e.isServer) ?? qt) && (e == null ? void 0 : e.allowOutsideOfServer) !== true)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: s,
      /**
      * Builder object for creating procedures
      */
      procedure: vr({
        meta: e == null ? void 0 : e.defaultMeta
      }),
      /**
      * Create reusable middlewares
      */
      middleware: qn(),
      /**
      * Create a router
      */
      router: gr(s),
      /**
      * Merge Routers
      */
      mergeRouters: Fn
    };
  };
}
var yt = {};
var Xe = {};
var fe = {};
var O = {};
var pe = k(hn);
var kt = {};
var wr = pe;
function xr(t) {
  return wr.observable((e) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function Bt(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function Yn(t) {
  return (e) => {
    const r = Bt(t.true).map((s) => s(e)), n = Bt(t.false).map((s) => s(e));
    return (s) => wr.observable((i) => {
      const a = t.condition(s.op) ? r : n;
      return xr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
kt.createChain = xr;
kt.splitLink = Yn;
var he = {};
function Qn(t) {
  return t instanceof Tr || /**
  * @deprecated
  * Delete in next major
  */
  t.name === "TRPCClientError";
}
var Tr = class Me extends Error {
  static from(e, r = {}) {
    return e instanceof Error ? Qn(e) ? (r.meta && (e.meta = {
      ...e.meta,
      ...r.meta
    }), e) : new Me(e.message, {
      ...r,
      cause: e,
      result: null
    }) : new Me(e.error.message ?? "", {
      ...r,
      cause: void 0,
      result: e
    });
  }
  constructor(e, r) {
    var _a3, _b2;
    const n = r == null ? void 0 : r.cause;
    super(e, {
      cause: n
    }), this.meta = r == null ? void 0 : r.meta, this.cause = n, this.shape = (_a3 = r == null ? void 0 : r.result) == null ? void 0 : _a3.error, this.data = (_b2 = r == null ? void 0 : r.result) == null ? void 0 : _b2.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Me.prototype);
  }
};
he.TRPCClientError = Tr;
var Xn = k(wn);
var q2 = {};
var Kn = he;
var Ht = (t) => typeof t == "function";
function Er(t) {
  if (t)
    return t;
  if (typeof window < "u" && Ht(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && Ht(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function es(t) {
  return t || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function ts(t) {
  return {
    url: t.url,
    fetch: t.fetch,
    AbortController: es(t.AbortController)
  };
}
function rs(t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    e[r] = n;
  }
  return e;
}
var ns = {
  query: "GET",
  mutation: "POST"
};
function kr(t) {
  return "input" in t ? t.runtime.transformer.serialize(t.input) : rs(t.inputs.map((e) => t.runtime.transformer.serialize(e)));
}
var Cr = (t) => {
  let e = t.url + "/" + t.path;
  const r = [];
  if ("inputs" in t && r.push("batch=1"), t.type === "query") {
    const n = kr(t);
    n !== void 0 && r.push(`input=${encodeURIComponent(JSON.stringify(n))}`);
  }
  return r.length && (e += "?" + r.join("&")), e;
};
var Rr = (t) => {
  if (t.type === "query")
    return;
  const e = kr(t);
  return e !== void 0 ? JSON.stringify(e) : void 0;
};
var ss = (t) => Pr({
  ...t,
  contentTypeHeader: "application/json",
  getUrl: Cr,
  getBody: Rr
});
async function Or(t, e) {
  const r = t.getUrl(t), n = t.getBody(t), { type: s } = t, i = await t.headers();
  if (s === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const a = {
    ...t.contentTypeHeader ? {
      "content-type": t.contentTypeHeader
    } : {},
    ...t.batchModeHeader ? {
      "trpc-batch-mode": t.batchModeHeader
    } : {},
    ...i
  };
  return Er(t.fetch)(r, {
    method: ns[s],
    signal: e == null ? void 0 : e.signal,
    body: n,
    headers: a
  });
}
function Pr(t) {
  const e = t.AbortController ? new t.AbortController() : null, r = {};
  return {
    promise: new Promise((i, a) => {
      Or(t, e).then((o3) => (r.response = o3, o3.json())).then((o3) => {
        r.responseJSON = o3, i({
          json: o3,
          meta: r
        });
      }).catch((o3) => {
        a(Kn.TRPCClientError.from(o3, {
          meta: r
        }));
      });
    }),
    cancel: () => {
      e == null ? void 0 : e.abort();
    }
  };
}
q2.fetchHTTPResponse = Or;
q2.getBody = Rr;
q2.getFetch = Er;
q2.getUrl = Cr;
q2.httpRequest = Pr;
q2.jsonHttpRequester = ss;
q2.resolveHTTPLinkOptions = ts;
var Ct = {};
var Ke = {};
function Ft(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function is(t, e) {
  if ("error" in t) {
    const n = e.transformer.deserialize(t.error);
    return {
      ok: false,
      error: {
        ...t,
        error: n
      }
    };
  }
  return {
    ok: true,
    result: {
      ...t.result,
      ...(!t.result.type || t.result.type === "data") && {
        type: "data",
        data: e.transformer.deserialize(t.result.data)
      }
    }
  };
}
var dt = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function as(t, e) {
  let r;
  try {
    r = is(t, e);
  } catch {
    throw new dt();
  }
  if (!r.ok && (!Ft(r.error.error) || typeof r.error.error.code != "number"))
    throw new dt();
  if (r.ok && !Ft(r.result))
    throw new dt();
  return r;
}
Ke.transformResult = as;
var os = pe;
var cs = Ke;
var Jt = he;
var gt = q2;
var ft = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function pt(t) {
  let e = null, r = null;
  const n = () => {
    clearTimeout(r), r = null, e = null;
  };
  function s(o3) {
    var _a3, _b2;
    const c = [
      []
    ];
    let u2 = 0;
    for (; ; ) {
      const l2 = o3[u2];
      if (!l2)
        break;
      const h3 = c[c.length - 1];
      if (l2.aborted) {
        (_a3 = l2.reject) == null ? void 0 : _a3.call(l2, new Error("Aborted")), u2++;
        continue;
      }
      if (t.validate(h3.concat(l2).map((x) => x.key))) {
        h3.push(l2), u2++;
        continue;
      }
      if (h3.length === 0) {
        (_b2 = l2.reject) == null ? void 0 : _b2.call(l2, new Error("Input is too big for a single dispatch")), u2++;
        continue;
      }
      c.push([]);
    }
    return c;
  }
  function i() {
    const o3 = s(e);
    n();
    for (const c of o3) {
      if (!c.length)
        continue;
      const u2 = {
        items: c,
        cancel: ft
      };
      for (const x of c)
        x.batch = u2;
      const l2 = (x, E2) => {
        var _a3;
        const S2 = u2.items[x];
        (_a3 = S2.resolve) == null ? void 0 : _a3.call(S2, E2), S2.batch = null, S2.reject = null, S2.resolve = null;
      }, { promise: h3, cancel: m } = t.fetch(u2.items.map((x) => x.key), l2);
      u2.cancel = m, h3.then((x) => {
        var _a3;
        for (let E2 = 0; E2 < x.length; E2++) {
          const S2 = x[E2];
          l2(E2, S2);
        }
        for (const E2 of u2.items)
          (_a3 = E2.reject) == null ? void 0 : _a3.call(E2, new Error("Missing result")), E2.batch = null;
      }).catch((x) => {
        var _a3;
        for (const E2 of u2.items)
          (_a3 = E2.reject) == null ? void 0 : _a3.call(E2, x), E2.batch = null;
      });
    }
  }
  function a(o3) {
    const c = {
      aborted: false,
      key: o3,
      batch: null,
      resolve: ft,
      reject: ft
    }, u2 = new Promise((h3, m) => {
      c.reject = m, c.resolve = h3, e || (e = []), e.push(c);
    });
    return r || (r = setTimeout(i)), {
      promise: u2,
      cancel: () => {
        var _a3;
        c.aborted = true, ((_a3 = c.batch) == null ? void 0 : _a3.items.every((h3) => h3.aborted)) && (c.batch.cancel(), c.batch = null);
      }
    };
  }
  return {
    load: a
  };
}
function Sr(t) {
  return function(r) {
    const n = gt.resolveHTTPLinkOptions(r), s = r.maxURLLength ?? 1 / 0;
    return (i) => {
      const a = (h3) => {
        const m = (E2) => {
          if (s === 1 / 0)
            return true;
          const S2 = E2.map((z3) => z3.path).join(","), ne2 = E2.map((z3) => z3.input);
          return gt.getUrl({
            ...n,
            runtime: i,
            type: h3,
            path: S2,
            inputs: ne2
          }).length <= s;
        }, x = t({
          ...n,
          runtime: i,
          type: h3,
          opts: r
        });
        return {
          validate: m,
          fetch: x
        };
      }, o3 = pt(a("query")), c = pt(a("mutation")), u2 = pt(a("subscription")), l2 = {
        query: o3,
        subscription: u2,
        mutation: c
      };
      return ({ op: h3 }) => os.observable((m) => {
        const x = l2[h3.type], { promise: E2, cancel: S2 } = x.load(h3);
        let ne2;
        return E2.then((j2) => {
          ne2 = j2;
          const z3 = cs.transformResult(j2.json, i);
          if (!z3.ok) {
            m.error(Jt.TRPCClientError.from(z3.error, {
              meta: j2.meta
            }));
            return;
          }
          m.next({
            context: j2.meta,
            result: z3.result
          }), m.complete();
        }).catch((j2) => {
          m.error(Jt.TRPCClientError.from(j2, {
            meta: ne2 == null ? void 0 : ne2.meta
          }));
        }), () => {
          S2();
        };
      });
    };
  };
}
var us = (t) => (e) => {
  const r = e.map((a) => a.path).join(","), n = e.map((a) => a.input), { promise: s, cancel: i } = gt.jsonHttpRequester({
    ...t,
    path: r,
    inputs: n,
    headers() {
      return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
        opList: e
      }) : t.opts.headers : {};
    }
  });
  return {
    promise: s.then((a) => (Array.isArray(a.json) ? a.json : e.map(() => a.json)).map((u2) => ({
      meta: a.meta,
      json: u2
    }))),
    cancel: i
  };
};
var ls = Sr(us);
Ct.createHTTPBatchLink = Sr;
Ct.httpBatchLink = ls;
var et = {};
Object.defineProperty(et, "__esModule", { value: true });
var ds = pe;
var fs = Ke;
var Gt = he;
var Nr = q2;
function Lr(t) {
  return (e) => {
    const r = Nr.resolveHTTPLinkOptions(e);
    return (n) => ({ op: s }) => ds.observable((i) => {
      const { path: a, input: o3, type: c } = s, { promise: u2, cancel: l2 } = t.requester({
        ...r,
        runtime: n,
        type: c,
        path: a,
        input: o3,
        headers() {
          return e.headers ? typeof e.headers == "function" ? e.headers({
            op: s
          }) : e.headers : {};
        }
      });
      let h3;
      return u2.then((m) => {
        h3 = m.meta;
        const x = fs.transformResult(m.json, n);
        if (!x.ok) {
          i.error(Gt.TRPCClientError.from(x.error, {
            meta: h3
          }));
          return;
        }
        i.next({
          context: m.meta,
          result: x.result
        }), i.complete();
      }).catch((m) => {
        i.error(Gt.TRPCClientError.from(m, {
          meta: h3
        }));
      }), () => {
        l2();
      };
    });
  };
}
var ps = Lr({
  requester: Nr.jsonHttpRequester
});
et.httpLink = ps;
et.httpLinkFactory = Lr;
var Rt = {};
Object.defineProperty(Rt, "__esModule", { value: true });
var Yt = pe;
function hs(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var ht = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function ms(t) {
  const { direction: e, type: r, path: n, id: s, input: i } = t, a = [], o3 = [];
  if (t.colorMode === "ansi") {
    const [h3, m] = ht.ansi.regular[r], [x, E2] = ht.ansi.bold[r], S2 = "\x1B[0m";
    return a.push(e === "up" ? h3 : m, e === "up" ? ">>" : "<<", r, e === "up" ? x : E2, `#${s}`, n, S2), e === "up" ? o3.push({
      input: t.input
    }) : o3.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o3
    };
  }
  const [c, u2] = ht.css[r], l2 = `
    background-color: #${e === "up" ? c : u2}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o3.push(l2, `${l2}; font-weight: bold;`, `${l2}; font-weight: normal;`), e === "up" ? o3.push({
    input: i,
    context: t.context
  }) : o3.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o3
  };
}
var ys = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = hs(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = ms({
    ...r,
    colorMode: e,
    input: s
  }), o3 = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o3].apply(null, [
    i.join(" ")
  ].concat(a));
};
function gs(t = {}) {
  const { enabled: e = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = ys({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => Yt.observable((a) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o3 = Date.now();
    function c(u2) {
      const l2 = Date.now() - o3;
      e({
        ...s,
        direction: "down",
        result: u2
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l2,
        result: u2
      });
    }
    return i(s).pipe(Yt.tap({
      next(u2) {
        c(u2);
      },
      error(u2) {
        c(u2);
      }
    })).subscribe(a);
  });
}
Rt.loggerLink = gs;
var tt = {};
Object.defineProperty(tt, "__esModule", { value: true });
var _s = pe;
var bs = Ke;
var Ir = he;
var vs = (t) => t === 0 ? 0 : Math.min(1e3 * 2 ** t, 3e4);
function ws(t) {
  const { url: e, WebSocket: r = WebSocket, retryDelayMs: n = vs, onOpen: s, onClose: i } = t;
  if (!r)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let a = [];
  const o3 = /* @__PURE__ */ Object.create(null);
  let c = 0, u2 = null, l2 = null, h3 = jt2(), m = "connecting";
  function x() {
    m !== "open" || u2 || (u2 = setTimeout(() => {
      u2 = null, a.length === 1 ? h3.send(JSON.stringify(a.pop())) : h3.send(JSON.stringify(a)), a = [];
    }));
  }
  function E2() {
    if (l2 !== null || m === "closed")
      return;
    const R3 = n(c++);
    ne2(R3);
  }
  function S2() {
    m = "connecting";
    const R3 = h3;
    h3 = jt2(), j2(R3);
  }
  function ne2(R3) {
    l2 || (m = "connecting", l2 = setTimeout(S2, R3));
  }
  function j2(R3) {
    Object.values(o3).some((se2) => se2.ws === R3) || R3.close();
  }
  function z3() {
    Object.values(o3).forEach((R3) => {
      R3.type === "subscription" && R3.callbacks.complete();
    });
  }
  function It2(R3) {
    a.some((P2) => P2.id === R3.op.id) || At2(R3.op, R3.callbacks);
  }
  function jt2() {
    const R3 = typeof e == "function" ? e() : e, P2 = new r(R3);
    clearTimeout(l2), l2 = null, P2.addEventListener("open", () => {
      P2 === h3 && (c = 0, m = "open", s == null ? void 0 : s(), x());
    }), P2.addEventListener("error", () => {
      P2 === h3 && E2();
    });
    const se2 = (I) => {
      if (I.method === "reconnect" && P2 === h3) {
        m === "open" && (i == null ? void 0 : i()), S2();
        for (const k2 of Object.values(o3))
          k2.type === "subscription" && It2(k2);
      }
    }, ot2 = (I) => {
      var _a3, _b2;
      const k2 = I.id !== null && o3[I.id];
      if (k2) {
        if ((_b2 = (_a3 = k2.callbacks).next) == null ? void 0 : _b2.call(_a3, I), k2.ws !== h3 && P2 === h3) {
          const V2 = k2.ws;
          k2.ws = h3, j2(V2);
        }
        "result" in I && I.result.type === "stopped" && P2 === h3 && k2.callbacks.complete();
      }
    };
    return P2.addEventListener("message", ({ data: I }) => {
      const k2 = JSON.parse(I);
      "method" in k2 ? se2(k2) : ot2(k2), (P2 !== h3 || m === "closed") && j2(P2);
    }), P2.addEventListener("close", ({ code: I }) => {
      var _a3, _b2, _c2, _d2;
      m === "open" && (i == null ? void 0 : i({
        code: I
      })), h3 === P2 && E2();
      for (const [k2, V2] of Object.entries(o3))
        if (V2.ws === P2) {
          if (m === "closed") {
            delete o3[k2], (_b2 = (_a3 = V2.callbacks).complete) == null ? void 0 : _b2.call(_a3);
            continue;
          }
          V2.type === "subscription" ? It2(V2) : (delete o3[k2], (_d2 = (_c2 = V2.callbacks).error) == null ? void 0 : _d2.call(_c2, Ir.TRPCClientError.from(new Ot("WebSocket closed prematurely"))));
        }
    }), P2;
  }
  function At2(R3, P2) {
    const { type: se2, input: ot2, path: I, id: k2 } = R3, V2 = {
      id: k2,
      method: se2,
      params: {
        input: ot2,
        path: I
      }
    };
    return o3[k2] = {
      ws: h3,
      type: se2,
      callbacks: P2,
      op: R3
    }, a.push(V2), x(), () => {
      var _a3, _b2;
      const en = (_a3 = o3[k2]) == null ? void 0 : _a3.callbacks;
      delete o3[k2], a = a.filter((tn) => tn.id !== k2), (_b2 = en == null ? void 0 : en.complete) == null ? void 0 : _b2.call(en), h3.readyState === r.OPEN && R3.type === "subscription" && (a.push({
        id: k2,
        method: "subscription.stop"
      }), x());
    };
  }
  return {
    close: () => {
      m = "closed", i == null ? void 0 : i(), z3(), j2(h3), clearTimeout(l2), l2 = null;
    },
    request: At2,
    getConnection() {
      return h3;
    }
  };
}
var Ot = class _Ot extends Error {
  constructor(e) {
    super(e), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, _Ot.prototype);
  }
};
function xs(t) {
  return (e) => {
    const { client: r } = t;
    return ({ op: n }) => _s.observable((s) => {
      const { type: i, path: a, id: o3, context: c } = n, u2 = e.transformer.serialize(n.input), l2 = r.request({
        type: i,
        path: a,
        input: u2,
        id: o3,
        context: c
      }, {
        error(h3) {
          s.error(h3), l2();
        },
        complete() {
          s.complete();
        },
        next(h3) {
          const m = bs.transformResult(h3, e);
          if (!m.ok) {
            s.error(Ir.TRPCClientError.from(m.error));
            return;
          }
          s.next({
            result: m.result
          }), n.type !== "subscription" && (l2(), s.complete());
        }
      });
      return () => {
        l2();
      };
    });
  };
}
tt.createWSClient = ws;
tt.wsLink = xs;
Object.defineProperty(O, "__esModule", { value: true });
var Qt = pe;
var jr = kt;
var Ar = he;
var Xt = Xn;
var _e2 = q2;
var Mr = Ct;
var Pt = et;
var Ts = Rt;
var $r = tt;
var rt = class {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return jr.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(Qt.share());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = Qt.observableToPromise(r);
    return new Promise((a, o3) => {
      var _a3;
      (_a3 = e.signal) == null ? void 0 : _a3.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o3(Ar.TRPCClientError.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context
    }).subscribe({
      next(i) {
        var _a3, _b2, _c2;
        i.result.type === "started" ? (_a3 = n.onStarted) == null ? void 0 : _a3.call(n) : i.result.type === "stopped" ? (_b2 = n.onStopped) == null ? void 0 : _b2.call(n) : (_c2 = n.onData) == null ? void 0 : _c2.call(n, i.result.data);
      },
      error(i) {
        var _a3;
        (_a3 = n.onError) == null ? void 0 : _a3.call(n, i);
      },
      complete() {
        var _a3;
        (_a3 = n.onComplete) == null ? void 0 : _a3.call(n);
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
};
function Es(t) {
  return new rt(t);
}
function ks(t) {
  return new rt(t);
}
var Cs = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var Dr = (t) => Cs[t];
function Zr(t) {
  return Xt.createFlatProxy((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : Xt.createRecursiveProxy(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], i = Dr(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Rs(t) {
  const e = new rt(t);
  return Zr(e);
}
function Os(t) {
  return t.__untypedClient;
}
function Ps(t) {
  if (t)
    return t;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function Ss(t) {
  const e = t.parse ?? JSON.parse, r = (n) => {
    var _a3;
    if (((_a3 = t.signal) == null ? void 0 : _a3.aborted) || !n || n === "}")
      return;
    const s = n.indexOf(":"), i = n.substring(2, s - 1), a = n.substring(s + 1);
    t.onSingle(Number(i), e(a));
  };
  await Ns(t.readableStream, r, t.textDecoder);
}
async function Ns(t, e, r) {
  let n = "";
  const s = (i) => {
    const o3 = r.decode(i).split(`
`);
    if (o3.length === 1)
      n += o3[0];
    else if (o3.length > 1) {
      e(n + o3[0]);
      for (let c = 1; c < o3.length - 1; c++)
        e(o3[c]);
      n = o3[o3.length - 1];
    }
  };
  "getReader" in t ? await Is(t, s) : await Ls(t, s), e(n);
}
function Ls(t, e) {
  return new Promise((r) => {
    t.on("data", e), t.on("end", r);
  });
}
async function Is(t, e) {
  const r = t.getReader();
  let n = await r.read();
  for (; !n.done; )
    e(n.value), n = await r.read();
}
var js = (t, e) => {
  const r = t.AbortController ? new t.AbortController() : null, n = _e2.fetchHTTPResponse({
    ...t,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: _e2.getUrl,
    getBody: _e2.getBody
  }, r), s = () => r == null ? void 0 : r.abort(), i = n.then(async (a) => {
    if (!a.body)
      throw new Error("Received response without body");
    const o3 = {
      response: a
    };
    return Ss({
      readableStream: a.body,
      onSingle: e,
      parse: (c) => ({
        json: JSON.parse(c),
        meta: o3
      }),
      signal: r == null ? void 0 : r.signal,
      textDecoder: t.textDecoder
    });
  });
  return {
    cancel: s,
    promise: i
  };
};
var As = (t) => {
  const e = Ps(t.opts.textDecoder);
  return (r, n) => {
    const s = r.map((c) => c.path).join(","), i = r.map((c) => c.input), { cancel: a, promise: o3 } = js({
      ...t,
      textDecoder: e,
      path: s,
      inputs: i,
      headers() {
        return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
          opList: r
        }) : t.opts.headers : {};
      }
    }, (c, u2) => {
      n(c, u2);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: o3.then(() => []),
      cancel: a
    };
  };
};
var Ms = Mr.createHTTPBatchLink(As);
var $s = (t) => {
  if ("input" in t) {
    if (!(t.input instanceof FormData))
      throw new Error("Input is not FormData");
    return t.input;
  }
};
var Ds = (t) => {
  if (t.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return _e2.httpRequest({
    ...t,
    getUrl() {
      return `${t.url}/${t.path}`;
    },
    getBody: $s
  });
};
var Zs = Pt.httpLinkFactory({
  requester: Ds
});
O.splitLink = jr.splitLink;
O.TRPCClientError = Ar.TRPCClientError;
O.getFetch = _e2.getFetch;
O.httpBatchLink = Mr.httpBatchLink;
O.httpLink = Pt.httpLink;
O.httpLinkFactory = Pt.httpLinkFactory;
O.loggerLink = Ts.loggerLink;
O.createWSClient = $r.createWSClient;
O.wsLink = $r.wsLink;
O.TRPCUntypedClient = rt;
O.clientCallTypeToProcedureType = Dr;
O.createTRPCClient = ks;
O.createTRPCClientProxy = Zr;
O.createTRPCProxyClient = Rs;
O.createTRPCUntypedClient = Es;
O.experimental_formDataLink = Zs;
O.getUntypedClient = Os;
O.unstable_httpBatchStreamLink = Ms;
var X = {};
var St = {};
function Us(t) {
  return t;
}
function Ws(t) {
  return t.length === 0 ? Us : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function qs(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function zs(t) {
  const e = {
    subscribe(r) {
      let n = null, s = false, i = false, a = false;
      function o3() {
        if (n === null) {
          a = true;
          return;
        }
        i || (i = true, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          var _a3;
          s || ((_a3 = r.next) == null ? void 0 : _a3.call(r, c));
        },
        error(c) {
          var _a3;
          s || (s = true, (_a3 = r.error) == null ? void 0 : _a3.call(r, c), o3());
        },
        complete() {
          var _a3;
          s || (s = true, (_a3 = r.complete) == null ? void 0 : _a3.call(r), o3());
        }
      }), a && o3(), {
        unsubscribe: o3
      };
    },
    pipe(...r) {
      return Ws(r)(e);
    }
  };
  return e;
}
St.isObservable = qs;
St.observable = zs;
Object.defineProperty(X, "__esModule", { value: true });
var Ur = St;
function Vs(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e.subscribe({
        next(o3) {
          var _a3;
          for (const c of s)
            (_a3 = c.next) == null ? void 0 : _a3.call(c, o3);
        },
        error(o3) {
          var _a3;
          for (const c of s)
            (_a3 = c.error) == null ? void 0 : _a3.call(c, o3);
        },
        complete() {
          var _a3;
          for (const o3 of s)
            (_a3 = o3.complete) == null ? void 0 : _a3.call(o3);
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o3 = n;
        n = null, o3.unsubscribe();
      }
    }
    return {
      subscribe(o3) {
        return r++, s.push(o3), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u2) => u2 === o3);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function Bs(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(i) {
          var _a3;
          (_a3 = r.next) == null ? void 0 : _a3.call(r, t(i, n++));
        },
        error(i) {
          var _a3;
          (_a3 = r.error) == null ? void 0 : _a3.call(r, i);
        },
        complete() {
          var _a3;
          (_a3 = r.complete) == null ? void 0 : _a3.call(r);
        }
      });
    }
  });
}
function Hs(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          var _a3, _b2;
          (_a3 = t.next) == null ? void 0 : _a3.call(t, n), (_b2 = r.next) == null ? void 0 : _b2.call(r, n);
        },
        error(n) {
          var _a3, _b2;
          (_a3 = t.error) == null ? void 0 : _a3.call(t, n), (_b2 = r.error) == null ? void 0 : _b2.call(r, n);
        },
        complete() {
          var _a3, _b2;
          (_a3 = t.complete) == null ? void 0 : _a3.call(t), (_b2 = r.complete) == null ? void 0 : _b2.call(r);
        }
      });
    }
  });
}
var Nt = class _Nt extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, _Nt.prototype);
  }
};
function Fs(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let i = false;
      function a() {
        i || (i = true, s(new Nt("This operation was aborted.")), o3.unsubscribe());
      }
      const o3 = t.subscribe({
        next(c) {
          i = true, n(c), a();
        },
        error(c) {
          i = true, s(c), a();
        },
        complete() {
          i = true, a();
        }
      });
      e = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
X.isObservable = Ur.isObservable;
X.observable = Ur.observable;
X.map = Bs;
X.observableToPromise = Fs;
X.share = Vs;
X.tap = Hs;
var Z = {};
Object.defineProperty(Z, "__esModule", { value: true });
Z.isTRPCRequestWithId = Z.isTRPCRequest = Z.isTRPCResponse = Z.isTRPCMessage = void 0;
function Kt(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function Js(t) {
  return t == null;
}
function Wr(t) {
  return !!(Kt(t) && "trpc" in t && Kt(t.trpc));
}
Z.isTRPCMessage = Wr;
function Lt(t) {
  return Wr(t) && "id" in t.trpc && !Js(t.trpc.id);
}
function Gs(t) {
  return Lt(t) && ("error" in t.trpc || "result" in t.trpc);
}
Z.isTRPCResponse = Gs;
function qr(t) {
  return Lt(t) && "method" in t.trpc;
}
Z.isTRPCRequest = qr;
function Ys(t) {
  return qr(t) && Lt(t);
}
Z.isTRPCRequestWithId = Ys;
Object.defineProperty(fe, "__esModule", { value: true });
fe.createBaseLink = void 0;
var mt = O;
var Qs = X;
var Xs = Z;
var Ks = (t) => (e) => ({ op: r }) => (0, Qs.observable)((n) => {
  const s = [], { id: i, type: a, path: o3 } = r;
  try {
    const c = e.transformer.serialize(r.input), u2 = () => {
      n.error(new mt.TRPCClientError("Port disconnected prematurely"));
    };
    t.addCloseListener(u2), s.push(() => t.removeCloseListener(u2));
    const l2 = (h3) => {
      if (!(0, Xs.isTRPCResponse)(h3))
        return;
      const { trpc: m } = h3;
      if (i === m.id) {
        if ("error" in m) {
          const x = e.transformer.deserialize(m.error);
          n.error(mt.TRPCClientError.from(Object.assign(Object.assign({}, m), { error: x })));
          return;
        }
        n.next({
          result: Object.assign(Object.assign({}, m.result), (!m.result.type || m.result.type === "data") && {
            type: "data",
            data: e.transformer.deserialize(m.result.data)
          })
        }), (a !== "subscription" || m.result.type === "stopped") && n.complete();
      }
    };
    t.addMessageListener(l2), s.push(() => t.removeMessageListener(l2)), t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: a,
        params: { path: o3, input: c }
      }
    });
  } catch (c) {
    n.error(new mt.TRPCClientError(c instanceof Error ? c.message : "Unknown error"));
  }
  return () => {
    a === "subscription" && t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), s.forEach((c) => c());
  };
});
fe.createBaseLink = Ks;
Object.defineProperty(Xe, "__esModule", { value: true });
Xe.chromeLink = void 0;
var ei = fe;
var ti = (t) => (0, ei.createBaseLink)({
  postMessage(e) {
    t.port.postMessage(e);
  },
  addMessageListener(e) {
    t.port.onMessage.addListener(e);
  },
  removeMessageListener(e) {
    t.port.onMessage.removeListener(e);
  },
  addCloseListener(e) {
    t.port.onDisconnect.addListener(e);
  },
  removeCloseListener(e) {
    t.port.onDisconnect.removeListener(e);
  }
});
Xe.chromeLink = ti;
var nt = {};
Object.defineProperty(nt, "__esModule", { value: true });
nt.windowLink = void 0;
var ri = fe;
var ni = (t) => {
  var e;
  const r = /* @__PURE__ */ new Map(), n = t.window, s = (e = t.postWindow) !== null && e !== void 0 ? e : n;
  return (0, ri.createBaseLink)({
    postMessage(i) {
      s.postMessage(i, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(i) {
      const a = (o3) => {
        i(o3.data);
      };
      r.set(i, a), n.addEventListener("message", a);
    },
    removeMessageListener(i) {
      const a = r.get(i);
      a && n.removeEventListener("message", a);
    },
    addCloseListener(i) {
      n.addEventListener("beforeunload", i);
    },
    removeCloseListener(i) {
      n.removeEventListener("beforeunload", i);
    }
  });
};
nt.windowLink = ni;
var st = {};
var it = {};
Object.defineProperty(it, "__esModule", { value: true });
it.TRPC_BROWSER_LOADED_EVENT = void 0;
it.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(st, "__esModule", { value: true });
st.popupLink = void 0;
var si = it;
var ii = fe;
var ai = (t) => {
  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();
  let n = null;
  async function s(i) {
    if (!n || n.closed) {
      n = t.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((a) => {
          var o3;
          try {
            (o3 = n == null ? void 0 : n.addEventListener) === null || o3 === void 0 || o3.call(n, "load", a);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((a) => {
          i.addEventListener("message", (o3) => {
            o3.data === si.TRPC_BROWSER_LOADED_EVENT && a();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((a) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(a, 15e3);
        })
      ]);
      try {
        if (!n.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        n.addEventListener("beforeunload", () => {
          n = null;
        });
      } catch {
        const o3 = setInterval(() => {
          n && n.closed && (n = null, r.forEach((c) => {
            c();
          }), clearInterval(o3));
        }, 1e3);
      }
    }
    return n;
  }
  return (0, ii.createBaseLink)({
    async postMessage(i) {
      return (await s(t.listenWindow)).postMessage(i, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(i) {
      const a = (o3) => {
        i(o3.data);
      };
      e.set(i, a), t.listenWindow.addEventListener("message", a);
    },
    removeMessageListener(i) {
      const a = e.get(i);
      a && t.listenWindow.removeEventListener("message", a);
    },
    addCloseListener(i) {
      t.listenWindow.addEventListener("beforeunload", i), r.add(i);
    },
    removeCloseListener(i) {
      t.listenWindow.removeEventListener("beforeunload", i), r.delete(i);
    }
  });
};
st.popupLink = ai;
(function(t) {
  var e = T && T.__createBinding || (Object.create ? function(n, s, i, a) {
    a === void 0 && (a = i);
    var o3 = Object.getOwnPropertyDescriptor(s, i);
    (!o3 || ("get" in o3 ? !s.__esModule : o3.writable || o3.configurable)) && (o3 = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, a, o3);
  } : function(n, s, i, a) {
    a === void 0 && (a = i), n[a] = s[i];
  }), r = T && T.__exportStar || function(n, s) {
    for (var i in n)
      i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(t, "__esModule", { value: true }), r(Xe, t), r(nt, t), r(st, t);
})(yt);
var T2;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function r(s) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (s) => {
    const i = {};
    for (const a of s)
      i[a] = a;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((o3) => typeof s[s[o3]] != "number"), a = {};
    for (const o3 of i)
      a[o3] = s[o3];
    return t.objectValues(a);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const a in s)
      Object.prototype.hasOwnProperty.call(s, a) && i.push(a);
    return i;
  }, t.find = (s, i) => {
    for (const a of s)
      if (i(a))
        return a;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function n(s, i = " | ") {
    return s.map((a) => typeof a == "string" ? `'${a}'` : a).join(i);
  }
  t.joinValues = n, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(T2 || (T2 = {}));
var p = T2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var G = (t) => {
  switch (typeof t) {
    case "undefined":
      return p.undefined;
    case "string":
      return p.string;
    case "number":
      return isNaN(t) ? p.nan : p.number;
    case "boolean":
      return p.boolean;
    case "function":
      return p.function;
    case "bigint":
      return p.bigint;
    case "symbol":
      return p.symbol;
    case "object":
      return Array.isArray(t) ? p.array : t === null ? p.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? p.promise : typeof Map < "u" && t instanceof Map ? p.map : typeof Set < "u" && t instanceof Set ? p.set : typeof Date < "u" && t instanceof Date ? p.date : p.object;
    default:
      return p.unknown;
  }
};
var d = T2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var oi = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
var B = class extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(i) {
      return i.message;
    }, n = { _errors: [] }, s = (i) => {
      for (const a of i.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(s);
        else if (a.code === "invalid_return_type")
          s(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          s(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let o3 = n, c = 0;
          for (; c < a.path.length; ) {
            const u2 = a.path[c];
            c === a.path.length - 1 ? (o3[u2] = o3[u2] || { _errors: [] }, o3[u2]._errors.push(r(a))) : o3[u2] = o3[u2] || { _errors: [] }, o3 = o3[u2], c++;
          }
        }
    };
    return s(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, T2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const s of this.issues)
      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n.push(e(s));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
B.create = (t) => new B(t);
var ve = (t, e) => {
  let r;
  switch (t.code) {
    case d.invalid_type:
      t.received === p.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case d.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, T2.jsonStringifyReplacer)}`;
      break;
    case d.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${T2.joinValues(t.keys, ", ")}`;
      break;
    case d.invalid_union:
      r = "Invalid input";
      break;
    case d.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${T2.joinValues(t.options)}`;
      break;
    case d.invalid_enum_value:
      r = `Invalid enum value. Expected ${T2.joinValues(t.options)}, received '${t.received}'`;
      break;
    case d.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case d.invalid_return_type:
      r = "Invalid function return type";
      break;
    case d.invalid_date:
      r = "Invalid date";
      break;
    case d.invalid_string:
      typeof t.validation == "object" ? "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : T2.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case d.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(t.minimum)}` : r = "Invalid input";
      break;
    case d.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(t.maximum)}` : r = "Invalid input";
      break;
    case d.custom:
      r = "Invalid input";
      break;
    case d.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case d.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case d.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, T2.assertNever(t);
  }
  return { message: r };
};
var zr = ve;
function ci(t) {
  zr = t;
}
function Ue() {
  return zr;
}
var We = (t) => {
  const { data: e, path: r, errorMaps: n, issueData: s } = t, i = [...r, ...s.path || []], a = {
    ...s,
    path: i
  };
  let o3 = "";
  const c = n.filter((u2) => !!u2).slice().reverse();
  for (const u2 of c)
    o3 = u2(a, { data: e, defaultError: o3 }).message;
  return {
    ...s,
    path: i,
    message: s.message || o3
  };
};
var ui = [];
function y(t, e) {
  const r = We({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      Ue(),
      ve
      // then global default map
    ].filter((n) => !!n)
  });
  t.common.issues.push(r);
}
var L = class _L {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n = [];
    for (const s of r) {
      if (s.status === "aborted")
        return _;
      s.status === "dirty" && e.dirty(), n.push(s.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, r) {
    const n = [];
    for (const s of r)
      n.push({
        key: await s.key,
        value: await s.value
      });
    return _L.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, r) {
    const n = {};
    for (const s of r) {
      const { key: i, value: a } = s;
      if (i.status === "aborted" || a.status === "aborted")
        return _;
      i.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), (typeof a.value < "u" || s.alwaysSet) && (n[i.value] = a.value);
    }
    return { status: e.value, value: n };
  }
};
var _ = Object.freeze({
  status: "aborted"
});
var Vr = (t) => ({ status: "dirty", value: t });
var N2 = (t) => ({ status: "valid", value: t });
var _t = (t) => t.status === "aborted";
var bt = (t) => t.status === "dirty";
var qe = (t) => t.status === "valid";
var ze = (t) => typeof Promise < "u" && t instanceof Promise;
var w;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(w || (w = {}));
var U2 = class {
  constructor(e, r, n, s) {
    this.parent = e, this.data = r, this._path = n, this._key = s;
  }
  get path() {
    return this._path.concat(this._key);
  }
};
var er = (t, e) => {
  if (qe(e))
    return { success: true, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return { success: false, error: new B(t.common.issues) };
};
function b2(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: n, description: s } = t;
  if (e && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (a, o3) => a.code !== "invalid_type" ? { message: o3.defaultError } : typeof o3.data > "u" ? { message: n ?? o3.defaultError } : { message: r ?? o3.defaultError }, description: s };
}
var v = class {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return G(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: G(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new L(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: G(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (ze(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n = this.safeParse(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, r) {
    var n;
    const s = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : false,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: G(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return er(s, i);
  }
  async parseAsync(e, r) {
    const n = await this.safeParseAsync(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: true
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: G(e)
    }, s = this._parse({ data: e, path: n.path, parent: n }), i = await (ze(s) ? s : Promise.resolve(s));
    return er(n, i);
  }
  refine(e, r) {
    const n = (s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r;
    return this._refinement((s, i) => {
      const a = e(s), o3 = () => i.addIssue({
        code: d.custom,
        ...n(s)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? true : (o3(), false)) : a ? true : (o3(), false);
    });
  }
  refinement(e, r) {
    return this._refinement((n, s) => e(n) ? true : (s.addIssue(typeof r == "function" ? r(n, s) : r), false));
  }
  _refinement(e) {
    return new D({
      schema: this,
      typeName: g.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return H.create(this, this._def);
  }
  nullable() {
    return re.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return $.create(this, this._def);
  }
  promise() {
    return de.create(this, this._def);
  }
  or(e) {
    return ke.create([this, e], this._def);
  }
  and(e) {
    return Ce.create(this, e, this._def);
  }
  transform(e) {
    return new D({
      ...b2(this._def),
      schema: this,
      typeName: g.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Ne({
      ...b2(this._def),
      innerType: this,
      defaultValue: r,
      typeName: g.ZodDefault
    });
  }
  brand() {
    return new Hr({
      typeName: g.ZodBranded,
      type: this,
      ...b2(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Je({
      ...b2(this._def),
      innerType: this,
      catchValue: r,
      typeName: g.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Le.create(this, e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var li = /^c[^\s-]{8,}$/i;
var di = /^[a-z][a-z0-9]*$/;
var fi = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var pi = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|([^-]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,}))$/;
var hi = (t) => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
var F2 = class _F extends v {
  constructor() {
    super(...arguments), this._regex = (e, r, n) => this.refinement((s) => e.test(s), {
      validation: r,
      code: d.invalid_string,
      ...w.errToObj(n)
    }), this.nonempty = (e) => this.min(1, w.errToObj(e)), this.trim = () => new _F({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== p.string) {
      const i = this._getOrReturnCtx(e);
      return y(
        i,
        {
          code: d.invalid_type,
          expected: p.string,
          received: i.parsedType
        }
        //
      ), _;
    }
    const n = new L();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.too_small,
          minimum: i.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: i.message
        }), n.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.too_big,
          maximum: i.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: i.message
        }), n.dirty());
      else if (i.kind === "length") {
        const a = e.data.length > i.value, o3 = e.data.length < i.value;
        (a || o3) && (s = this._getOrReturnCtx(e, s), a ? y(s, {
          code: d.too_big,
          maximum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }) : o3 && y(s, {
          code: d.too_small,
          minimum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }), n.dirty());
      } else if (i.kind === "email")
        pi.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "email",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "uuid")
        fi.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "uuid",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid")
        li.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "cuid",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid2")
        di.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "cuid2",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), y(s, {
            validation: "url",
            code: d.invalid_string,
            message: i.message
          }), n.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "regex",
          code: d.invalid_string,
          message: i.message
        }), n.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "datetime" ? hi(i).test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.invalid_string,
          validation: "datetime",
          message: i.message
        }), n.dirty()) : T2.assertNever(i);
    return { status: n.value, value: e.data };
  }
  _addCheck(e) {
    return new _F({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...w.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...w.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...w.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...w.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...w.errToObj(e) });
  }
  datetime(e) {
    var r;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (r = e == null ? void 0 : e.offset) !== null && r !== void 0 ? r : false,
      ...w.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...w.errToObj(r)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...w.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...w.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...w.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...w.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...w.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
F2.create = (t) => {
  var e;
  return new F2({
    checks: [],
    typeName: g.ZodString,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : false,
    ...b2(t)
  });
};
function mi(t, e) {
  const r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = r > n ? r : n, i = parseInt(t.toFixed(s).replace(".", "")), a = parseInt(e.toFixed(s).replace(".", ""));
  return i % a / Math.pow(10, s);
}
var Y = class _Y extends v {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== p.number) {
      const i = this._getOrReturnCtx(e);
      return y(i, {
        code: d.invalid_type,
        expected: p.number,
        received: i.parsedType
      }), _;
    }
    let n;
    const s = new L();
    for (const i of this._def.checks)
      i.kind === "int" ? T2.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? mi(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.not_finite,
        message: i.message
      }), s.dirty()) : T2.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, true, w.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, false, w.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, true, w.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, false, w.toString(r));
  }
  setLimit(e, r, n, s) {
    return new _Y({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: w.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _Y({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: w.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: w.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: w.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: w.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: w.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: w.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: w.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && T2.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return true;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
};
Y.create = (t) => new Y({
  checks: [],
  typeName: g.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || false,
  ...b2(t)
});
var we = class extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== p.bigint) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.bigint,
        received: n.parsedType
      }), _;
    }
    return N2(e.data);
  }
};
we.create = (t) => {
  var e;
  return new we({
    typeName: g.ZodBigInt,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : false,
    ...b2(t)
  });
};
var xe = class extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== p.boolean) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.boolean,
        received: n.parsedType
      }), _;
    }
    return N2(e.data);
  }
};
xe.create = (t) => new xe({
  typeName: g.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || false,
  ...b2(t)
});
var ee = class _ee extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== p.date) {
      const i = this._getOrReturnCtx(e);
      return y(i, {
        code: d.invalid_type,
        expected: p.date,
        received: i.parsedType
      }), _;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return y(i, {
        code: d.invalid_date
      }), _;
    }
    const n = new L();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), y(s, {
        code: d.too_small,
        message: i.message,
        inclusive: true,
        exact: false,
        minimum: i.value,
        type: "date"
      }), n.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), y(s, {
        code: d.too_big,
        message: i.message,
        inclusive: true,
        exact: false,
        maximum: i.value,
        type: "date"
      }), n.dirty()) : T2.assertNever(i);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new _ee({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: w.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: w.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
};
ee.create = (t) => new ee({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || false,
  typeName: g.ZodDate,
  ...b2(t)
});
var Ve = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.symbol) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.symbol,
        received: n.parsedType
      }), _;
    }
    return N2(e.data);
  }
};
Ve.create = (t) => new Ve({
  typeName: g.ZodSymbol,
  ...b2(t)
});
var Te = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.undefined) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.undefined,
        received: n.parsedType
      }), _;
    }
    return N2(e.data);
  }
};
Te.create = (t) => new Te({
  typeName: g.ZodUndefined,
  ...b2(t)
});
var Ee = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.null) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.null,
        received: n.parsedType
      }), _;
    }
    return N2(e.data);
  }
};
Ee.create = (t) => new Ee({
  typeName: g.ZodNull,
  ...b2(t)
});
var le = class extends v {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e) {
    return N2(e.data);
  }
};
le.create = (t) => new le({
  typeName: g.ZodAny,
  ...b2(t)
});
var K = class extends v {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e) {
    return N2(e.data);
  }
};
K.create = (t) => new K({
  typeName: g.ZodUnknown,
  ...b2(t)
});
var J = class extends v {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return y(r, {
      code: d.invalid_type,
      expected: p.never,
      received: r.parsedType
    }), _;
  }
};
J.create = (t) => new J({
  typeName: g.ZodNever,
  ...b2(t)
});
var Be = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.undefined) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.void,
        received: n.parsedType
      }), _;
    }
    return N2(e.data);
  }
};
Be.create = (t) => new Be({
  typeName: g.ZodVoid,
  ...b2(t)
});
var $ = class _$ extends v {
  _parse(e) {
    const { ctx: r, status: n } = this._processInputParams(e), s = this._def;
    if (r.parsedType !== p.array)
      return y(r, {
        code: d.invalid_type,
        expected: p.array,
        received: r.parsedType
      }), _;
    if (s.exactLength !== null) {
      const a = r.data.length > s.exactLength.value, o3 = r.data.length < s.exactLength.value;
      (a || o3) && (y(r, {
        code: a ? d.too_big : d.too_small,
        minimum: o3 ? s.exactLength.value : void 0,
        maximum: a ? s.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && r.data.length < s.minLength.value && (y(r, {
      code: d.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && (y(r, {
      code: d.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, o3) => s.type._parseAsync(new U2(r, a, r.path, o3)))).then((a) => L.mergeArray(n, a));
    const i = [...r.data].map((a, o3) => s.type._parseSync(new U2(r, a, r.path, o3)));
    return L.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new _$({
      ...this._def,
      minLength: { value: e, message: w.toString(r) }
    });
  }
  max(e, r) {
    return new _$({
      ...this._def,
      maxLength: { value: e, message: w.toString(r) }
    });
  }
  length(e, r) {
    return new _$({
      ...this._def,
      exactLength: { value: e, message: w.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
$.create = (t, e) => new $({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: g.ZodArray,
  ...b2(e)
});
var He;
(function(t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(He || (He = {}));
function oe(t) {
  if (t instanceof C) {
    const e = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e[r] = H.create(oe(n));
    }
    return new C({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof $ ? $.create(oe(t.element)) : t instanceof H ? H.create(oe(t.unwrap())) : t instanceof re ? re.create(oe(t.unwrap())) : t instanceof W ? W.create(t.items.map((e) => oe(e))) : t;
}
var C = class _C extends v {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = T2.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== p.object) {
      const u2 = this._getOrReturnCtx(e);
      return y(u2, {
        code: d.invalid_type,
        expected: p.object,
        received: u2.parsedType
      }), _;
    }
    const { status: n, ctx: s } = this._processInputParams(e), { shape: i, keys: a } = this._getCached(), o3 = [];
    if (!(this._def.catchall instanceof J && this._def.unknownKeys === "strip"))
      for (const u2 in s.data)
        a.includes(u2) || o3.push(u2);
    const c = [];
    for (const u2 of a) {
      const l2 = i[u2], h3 = s.data[u2];
      c.push({
        key: { status: "valid", value: u2 },
        value: l2._parse(new U2(s, h3, s.path, u2)),
        alwaysSet: u2 in s.data
      });
    }
    if (this._def.catchall instanceof J) {
      const u2 = this._def.unknownKeys;
      if (u2 === "passthrough")
        for (const l2 of o3)
          c.push({
            key: { status: "valid", value: l2 },
            value: { status: "valid", value: s.data[l2] }
          });
      else if (u2 === "strict")
        o3.length > 0 && (y(s, {
          code: d.unrecognized_keys,
          keys: o3
        }), n.dirty());
      else if (u2 !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u2 = this._def.catchall;
      for (const l2 of o3) {
        const h3 = s.data[l2];
        c.push({
          key: { status: "valid", value: l2 },
          value: u2._parse(
            new U2(s, h3, s.path, l2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l2 in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u2 = [];
      for (const l2 of c) {
        const h3 = await l2.key;
        u2.push({
          key: h3,
          value: await l2.value,
          alwaysSet: l2.alwaysSet
        });
      }
      return u2;
    }).then((u2) => L.mergeObjectSync(n, u2)) : L.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return w.errToObj, new _C({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, n) => {
          var s, i, a, o3;
          const c = (a = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o3 = w.errToObj(e).message) !== null && o3 !== void 0 ? o3 : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new _C({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _C({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new _C({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new _C({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => He.mergeShapes(this._def.shape(), e._def.shape()),
      typeName: g.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new _C({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return T2.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return T2.objectKeys(this.shape).forEach((n) => {
      e[n] || (r[n] = this.shape[n]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  deepPartial() {
    return oe(this);
  }
  partial(e) {
    const r = {};
    return T2.objectKeys(this.shape).forEach((n) => {
      const s = this.shape[n];
      e && !e[n] ? r[n] = s : r[n] = s.optional();
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return T2.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        r[n] = this.shape[n];
      else {
        let i = this.shape[n];
        for (; i instanceof H; )
          i = i._def.innerType;
        r[n] = i;
      }
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return Br(T2.objectKeys(this.shape));
  }
};
C.create = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strip",
  catchall: J.create(),
  typeName: g.ZodObject,
  ...b2(e)
});
C.strictCreate = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strict",
  catchall: J.create(),
  typeName: g.ZodObject,
  ...b2(e)
});
C.lazycreate = (t, e) => new C({
  shape: t,
  unknownKeys: "strip",
  catchall: J.create(),
  typeName: g.ZodObject,
  ...b2(e)
});
var ke = class extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.options;
    function s(i) {
      for (const o3 of i)
        if (o3.result.status === "valid")
          return o3.result;
      for (const o3 of i)
        if (o3.result.status === "dirty")
          return r.common.issues.push(...o3.ctx.common.issues), o3.result;
      const a = i.map((o3) => new B(o3.ctx.common.issues));
      return y(r, {
        code: d.invalid_union,
        unionErrors: a
      }), _;
    }
    if (r.common.async)
      return Promise.all(n.map(async (i) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(s);
    {
      let i;
      const a = [];
      for (const c of n) {
        const u2 = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, l2 = c._parseSync({
          data: r.data,
          path: r.path,
          parent: u2
        });
        if (l2.status === "valid")
          return l2;
        l2.status === "dirty" && !i && (i = { result: l2, ctx: u2 }), u2.common.issues.length && a.push(u2.common.issues);
      }
      if (i)
        return r.common.issues.push(...i.ctx.common.issues), i.result;
      const o3 = a.map((c) => new B(c));
      return y(r, {
        code: d.invalid_union,
        unionErrors: o3
      }), _;
    }
  }
  get options() {
    return this._def.options;
  }
};
ke.create = (t, e) => new ke({
  options: t,
  typeName: g.ZodUnion,
  ...b2(e)
});
var $e = (t) => t instanceof Oe ? $e(t.schema) : t instanceof D ? $e(t.innerType()) : t instanceof Pe ? [t.value] : t instanceof Q ? t.options : t instanceof Se ? Object.keys(t.enum) : t instanceof Ne ? $e(t._def.innerType) : t instanceof Te ? [void 0] : t instanceof Ee ? [null] : null;
var at = class _at extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== p.object)
      return y(r, {
        code: d.invalid_type,
        expected: p.object,
        received: r.parsedType
      }), _;
    const n = this.discriminator, s = r.data[n], i = this.optionsMap.get(s);
    return i ? r.common.async ? i._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : i._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (y(r, {
      code: d.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), _);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i of r) {
      const a = $e(i.shape[e]);
      if (!a)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o3 of a) {
        if (s.has(o3))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o3)}`);
        s.set(o3, i);
      }
    }
    return new _at({
      typeName: g.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: s,
      ...b2(n)
    });
  }
};
function vt(t, e) {
  const r = G(t), n = G(e);
  if (t === e)
    return { valid: true, data: t };
  if (r === p.object && n === p.object) {
    const s = T2.objectKeys(e), i = T2.objectKeys(t).filter((o3) => s.indexOf(o3) !== -1), a = { ...t, ...e };
    for (const o3 of i) {
      const c = vt(t[o3], e[o3]);
      if (!c.valid)
        return { valid: false };
      a[o3] = c.data;
    }
    return { valid: true, data: a };
  } else if (r === p.array && n === p.array) {
    if (t.length !== e.length)
      return { valid: false };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const a = t[i], o3 = e[i], c = vt(a, o3);
      if (!c.valid)
        return { valid: false };
      s.push(c.data);
    }
    return { valid: true, data: s };
  } else
    return r === p.date && n === p.date && +t == +e ? { valid: true, data: t } : { valid: false };
}
var Ce = class extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = (i, a) => {
      if (_t(i) || _t(a))
        return _;
      const o3 = vt(i.value, a.value);
      return o3.valid ? ((bt(i) || bt(a)) && r.dirty(), { status: r.value, value: o3.data }) : (y(n, {
        code: d.invalid_intersection_types
      }), _);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([i, a]) => s(i, a)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
Ce.create = (t, e, r) => new Ce({
  left: t,
  right: e,
  typeName: g.ZodIntersection,
  ...b2(r)
});
var W = class _W extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.array)
      return y(n, {
        code: d.invalid_type,
        expected: p.array,
        received: n.parsedType
      }), _;
    if (n.data.length < this._def.items.length)
      return y(n, {
        code: d.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), _;
    !this._def.rest && n.data.length > this._def.items.length && (y(n, {
      code: d.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), r.dirty());
    const i = [...n.data].map((a, o3) => {
      const c = this._def.items[o3] || this._def.rest;
      return c ? c._parse(new U2(n, a, n.path, o3)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(i).then((a) => L.mergeArray(r, a)) : L.mergeArray(r, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new _W({
      ...this._def,
      rest: e
    });
  }
};
W.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new W({
    items: t,
    typeName: g.ZodTuple,
    rest: null,
    ...b2(e)
  });
};
var Re = class _Re extends v {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.object)
      return y(n, {
        code: d.invalid_type,
        expected: p.object,
        received: n.parsedType
      }), _;
    const s = [], i = this._def.keyType, a = this._def.valueType;
    for (const o3 in n.data)
      s.push({
        key: i._parse(new U2(n, o3, n.path, o3)),
        value: a._parse(new U2(n, n.data[o3], n.path, o3))
      });
    return n.common.async ? L.mergeObjectAsync(r, s) : L.mergeObjectSync(r, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n) {
    return r instanceof v ? new _Re({
      keyType: e,
      valueType: r,
      typeName: g.ZodRecord,
      ...b2(n)
    }) : new _Re({
      keyType: F2.create(),
      valueType: e,
      typeName: g.ZodRecord,
      ...b2(r)
    });
  }
};
var Fe = class extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.map)
      return y(n, {
        code: d.invalid_type,
        expected: p.map,
        received: n.parsedType
      }), _;
    const s = this._def.keyType, i = this._def.valueType, a = [...n.data.entries()].map(([o3, c], u2) => ({
      key: s._parse(new U2(n, o3, n.path, [u2, "key"])),
      value: i._parse(new U2(n, c, n.path, [u2, "value"]))
    }));
    if (n.common.async) {
      const o3 = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const u2 = await c.key, l2 = await c.value;
          if (u2.status === "aborted" || l2.status === "aborted")
            return _;
          (u2.status === "dirty" || l2.status === "dirty") && r.dirty(), o3.set(u2.value, l2.value);
        }
        return { status: r.value, value: o3 };
      });
    } else {
      const o3 = /* @__PURE__ */ new Map();
      for (const c of a) {
        const u2 = c.key, l2 = c.value;
        if (u2.status === "aborted" || l2.status === "aborted")
          return _;
        (u2.status === "dirty" || l2.status === "dirty") && r.dirty(), o3.set(u2.value, l2.value);
      }
      return { status: r.value, value: o3 };
    }
  }
};
Fe.create = (t, e, r) => new Fe({
  valueType: e,
  keyType: t,
  typeName: g.ZodMap,
  ...b2(r)
});
var te = class _te extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.set)
      return y(n, {
        code: d.invalid_type,
        expected: p.set,
        received: n.parsedType
      }), _;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (y(n, {
      code: d.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.minSize.message
    }), r.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (y(n, {
      code: d.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.maxSize.message
    }), r.dirty());
    const i = this._def.valueType;
    function a(c) {
      const u2 = /* @__PURE__ */ new Set();
      for (const l2 of c) {
        if (l2.status === "aborted")
          return _;
        l2.status === "dirty" && r.dirty(), u2.add(l2.value);
      }
      return { status: r.value, value: u2 };
    }
    const o3 = [...n.data.values()].map((c, u2) => i._parse(new U2(n, c, n.path, u2)));
    return n.common.async ? Promise.all(o3).then((c) => a(c)) : a(o3);
  }
  min(e, r) {
    return new _te({
      ...this._def,
      minSize: { value: e, message: w.toString(r) }
    });
  }
  max(e, r) {
    return new _te({
      ...this._def,
      maxSize: { value: e, message: w.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
te.create = (t, e) => new te({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: g.ZodSet,
  ...b2(e)
});
var ce = class _ce extends v {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== p.function)
      return y(r, {
        code: d.invalid_type,
        expected: p.function,
        received: r.parsedType
      }), _;
    function n(o3, c) {
      return We({
        data: o3,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Ue(),
          ve
        ].filter((u2) => !!u2),
        issueData: {
          code: d.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(o3, c) {
      return We({
        data: o3,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Ue(),
          ve
        ].filter((u2) => !!u2),
        issueData: {
          code: d.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: r.common.contextualErrorMap }, a = r.data;
    return this._def.returns instanceof de ? N2(async (...o3) => {
      const c = new B([]), u2 = await this._def.args.parseAsync(o3, i).catch((m) => {
        throw c.addIssue(n(o3, m)), c;
      }), l2 = await a(...u2);
      return await this._def.returns._def.type.parseAsync(l2, i).catch((m) => {
        throw c.addIssue(s(l2, m)), c;
      });
    }) : N2((...o3) => {
      const c = this._def.args.safeParse(o3, i);
      if (!c.success)
        throw new B([n(o3, c.error)]);
      const u2 = a(...c.data), l2 = this._def.returns.safeParse(u2, i);
      if (!l2.success)
        throw new B([s(u2, l2.error)]);
      return l2.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new _ce({
      ...this._def,
      args: W.create(e).rest(K.create())
    });
  }
  returns(e) {
    return new _ce({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n) {
    return new _ce({
      args: e || W.create([]).rest(K.create()),
      returns: r || K.create(),
      typeName: g.ZodFunction,
      ...b2(n)
    });
  }
};
var Oe = class extends v {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
};
Oe.create = (t, e) => new Oe({
  getter: t,
  typeName: g.ZodLazy,
  ...b2(e)
});
var Pe = class extends v {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return y(r, {
        received: r.data,
        code: d.invalid_literal,
        expected: this._def.value
      }), _;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
};
Pe.create = (t, e) => new Pe({
  value: t,
  typeName: g.ZodLiteral,
  ...b2(e)
});
function Br(t, e) {
  return new Q({
    values: t,
    typeName: g.ZodEnum,
    ...b2(e)
  });
}
var Q = class _Q extends v {
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return y(r, {
        expected: T2.joinValues(n),
        received: r.parsedType,
        code: d.invalid_type
      }), _;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return y(r, {
        received: r.data,
        code: d.invalid_enum_value,
        options: n
      }), _;
    }
    return N2(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e) {
    return _Q.create(e);
  }
  exclude(e) {
    return _Q.create(this.options.filter((r) => !e.includes(r)));
  }
};
Q.create = Br;
var Se = class extends v {
  _parse(e) {
    const r = T2.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== p.string && n.parsedType !== p.number) {
      const s = T2.objectValues(r);
      return y(n, {
        expected: T2.joinValues(s),
        received: n.parsedType,
        code: d.invalid_type
      }), _;
    }
    if (r.indexOf(e.data) === -1) {
      const s = T2.objectValues(r);
      return y(n, {
        received: n.data,
        code: d.invalid_enum_value,
        options: s
      }), _;
    }
    return N2(e.data);
  }
  get enum() {
    return this._def.values;
  }
};
Se.create = (t, e) => new Se({
  values: t,
  typeName: g.ZodNativeEnum,
  ...b2(e)
});
var de = class extends v {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== p.promise && r.common.async === false)
      return y(r, {
        code: d.invalid_type,
        expected: p.promise,
        received: r.parsedType
      }), _;
    const n = r.parsedType === p.promise ? r.data : Promise.resolve(r.data);
    return N2(n.then((s) => this._def.type.parseAsync(s, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
};
de.create = (t, e) => new de({
  type: t,
  typeName: g.ZodPromise,
  ...b2(e)
});
var D = class extends v {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === g.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = this._def.effect || null;
    if (s.type === "preprocess") {
      const a = s.transform(n.data);
      return n.common.async ? Promise.resolve(a).then((o3) => this._def.schema._parseAsync({
        data: o3,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: a,
        path: n.path,
        parent: n
      });
    }
    const i = {
      addIssue: (a) => {
        y(n, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "refinement") {
      const a = (o3) => {
        const c = s.refinement(o3, i);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o3;
      };
      if (n.common.async === false) {
        const o3 = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o3.status === "aborted" ? _ : (o3.status === "dirty" && r.dirty(), a(o3.value), { status: r.value, value: o3.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o3) => o3.status === "aborted" ? _ : (o3.status === "dirty" && r.dirty(), a(o3.value).then(() => ({ status: r.value, value: o3.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === false) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!qe(a))
          return a;
        const o3 = s.transform(a.value, i);
        if (o3 instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o3 };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => qe(a) ? Promise.resolve(s.transform(a.value, i)).then((o3) => ({ status: r.value, value: o3 })) : a);
    T2.assertNever(s);
  }
};
D.create = (t, e, r) => new D({
  schema: t,
  typeName: g.ZodEffects,
  effect: e,
  ...b2(r)
});
D.createWithPreprocess = (t, e, r) => new D({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: g.ZodEffects,
  ...b2(r)
});
var H = class extends v {
  _parse(e) {
    return this._getType(e) === p.undefined ? N2(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
H.create = (t, e) => new H({
  innerType: t,
  typeName: g.ZodOptional,
  ...b2(e)
});
var re = class extends v {
  _parse(e) {
    return this._getType(e) === p.null ? N2(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
re.create = (t, e) => new re({
  innerType: t,
  typeName: g.ZodNullable,
  ...b2(e)
});
var Ne = class extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n = r.data;
    return r.parsedType === p.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Ne.create = (t, e) => new Ne({
  innerType: t,
  typeName: g.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...b2(e)
});
var Je = class extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r,
        common: {
          ...r.common,
          issues: []
          // don't collect issues from inner type
        }
      }
    });
    return ze(n) ? n.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue()
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue()
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Je.create = (t, e) => new Je({
  innerType: t,
  typeName: g.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...b2(e)
});
var Ge = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.nan) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.nan,
        received: n.parsedType
      }), _;
    }
    return { status: "valid", value: e.data };
  }
};
Ge.create = (t) => new Ge({
  typeName: g.ZodNaN,
  ...b2(t)
});
var yi = Symbol("zod_brand");
var Hr = class extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var Le = class _Le extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? _ : i.status === "dirty" ? (r.dirty(), Vr(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? _ : s.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, r) {
    return new _Le({
      in: e,
      out: r,
      typeName: g.ZodPipeline
    });
  }
};
var Fr = (t, e = {}, r) => t ? le.create().superRefine((n, s) => {
  if (!t(n)) {
    const i = typeof e == "function" ? e(n) : e, a = typeof i == "string" ? { message: i } : i;
    s.addIssue({ code: "custom", ...a, fatal: r });
  }
}) : le.create();
var gi = {
  object: C.lazycreate
};
var g;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline";
})(g || (g = {}));
var _i = (t, e = {
  message: `Input not instance of ${t.name}`
}) => Fr((r) => r instanceof t, e, true);
var Jr = F2.create;
var Gr = Y.create;
var bi = Ge.create;
var vi = we.create;
var Yr = xe.create;
var wi = ee.create;
var xi = Ve.create;
var Ti = Te.create;
var Ei = Ee.create;
var ki = le.create;
var Ci = K.create;
var Ri = J.create;
var Oi = Be.create;
var Pi = $.create;
var Si = C.create;
var Ni = C.strictCreate;
var Li = ke.create;
var Ii = at.create;
var ji = Ce.create;
var Ai = W.create;
var Mi = Re.create;
var $i = Fe.create;
var Di = te.create;
var Zi = ce.create;
var Ui = Oe.create;
var Wi = Pe.create;
var qi = Q.create;
var zi = Se.create;
var Vi = de.create;
var tr = D.create;
var Bi = H.create;
var Hi = re.create;
var Fi = D.createWithPreprocess;
var Ji = Le.create;
var Gi = () => Jr().optional();
var Yi = () => Gr().optional();
var Qi = () => Yr().optional();
var Xi = {
  string: (t) => F2.create({ ...t, coerce: true }),
  number: (t) => Y.create({ ...t, coerce: true }),
  boolean: (t) => xe.create({
    ...t,
    coerce: true
  }),
  bigint: (t) => we.create({ ...t, coerce: true }),
  date: (t) => ee.create({ ...t, coerce: true })
};
var Ki = _;
var f = Object.freeze({
  __proto__: null,
  defaultErrorMap: ve,
  setErrorMap: ci,
  getErrorMap: Ue,
  makeIssue: We,
  EMPTY_PATH: ui,
  addIssueToContext: y,
  ParseStatus: L,
  INVALID: _,
  DIRTY: Vr,
  OK: N2,
  isAborted: _t,
  isDirty: bt,
  isValid: qe,
  isAsync: ze,
  get util() {
    return T2;
  },
  ZodParsedType: p,
  getParsedType: G,
  ZodType: v,
  ZodString: F2,
  ZodNumber: Y,
  ZodBigInt: we,
  ZodBoolean: xe,
  ZodDate: ee,
  ZodSymbol: Ve,
  ZodUndefined: Te,
  ZodNull: Ee,
  ZodAny: le,
  ZodUnknown: K,
  ZodNever: J,
  ZodVoid: Be,
  ZodArray: $,
  get objectUtil() {
    return He;
  },
  ZodObject: C,
  ZodUnion: ke,
  ZodDiscriminatedUnion: at,
  ZodIntersection: Ce,
  ZodTuple: W,
  ZodRecord: Re,
  ZodMap: Fe,
  ZodSet: te,
  ZodFunction: ce,
  ZodLazy: Oe,
  ZodLiteral: Pe,
  ZodEnum: Q,
  ZodNativeEnum: Se,
  ZodPromise: de,
  ZodEffects: D,
  ZodTransformer: D,
  ZodOptional: H,
  ZodNullable: re,
  ZodDefault: Ne,
  ZodCatch: Je,
  ZodNaN: Ge,
  BRAND: yi,
  ZodBranded: Hr,
  ZodPipeline: Le,
  custom: Fr,
  Schema: v,
  ZodSchema: v,
  late: gi,
  get ZodFirstPartyTypeKind() {
    return g;
  },
  coerce: Xi,
  any: ki,
  array: Pi,
  bigint: vi,
  boolean: Yr,
  date: wi,
  discriminatedUnion: Ii,
  effect: tr,
  enum: qi,
  function: Zi,
  instanceof: _i,
  intersection: ji,
  lazy: Ui,
  literal: Wi,
  map: $i,
  nan: bi,
  nativeEnum: zi,
  never: Ri,
  null: Ei,
  nullable: Hi,
  number: Gr,
  object: Si,
  oboolean: Qi,
  onumber: Yi,
  optional: Bi,
  ostring: Gi,
  pipeline: Ji,
  preprocess: Fi,
  promise: Vi,
  record: Mi,
  set: Di,
  strictObject: Ni,
  string: Jr,
  symbol: xi,
  transformer: tr,
  tuple: Ai,
  undefined: Ti,
  union: Li,
  unknown: Ci,
  void: Oi,
  NEVER: Ki,
  ZodIssueCode: d,
  quotelessJson: oi,
  ZodError: B
});
var Qr = /^0x[0-9a-f]+$/i;
var Xr = /^\d+$/;
var ea = f.string().nonempty("The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (t) => !Qr.test(t),
  "The shortString should not be a hex string"
).refine(
  (t) => !Xr.test(t),
  "The shortString should not be an integer string"
);
var De = f.union([
  f.string().regex(
    Qr,
    "Only hex, integers and bigint are supported in calldata"
  ),
  f.string().regex(
    Xr,
    "Only hex, integers and bigint are supported in calldata"
  ),
  ea,
  f.number().int("Only hex, integers and bigint are supported in calldata"),
  f.bigint()
]);
var rr = f.object({
  contractAddress: f.string(),
  entrypoint: f.string(),
  calldata: f.array(De).optional()
});
var ta = f.object({
  types: f.record(
    f.array(
      f.union([
        f.object({
          name: f.string(),
          type: f.string()
        }),
        f.object({
          name: f.string(),
          type: f.literal("merkletree"),
          contains: f.string()
        })
      ])
    )
  ),
  primaryType: f.string(),
  domain: f.record(f.unknown()),
  message: f.record(f.unknown())
});
var nr = {
  enable: f.tuple([
    f.object({
      starknetVersion: f.union([f.literal("v4"), f.literal("v5")]).optional()
    }).optional()
  ]).or(f.tuple([])),
  addStarknetChain: f.tuple([
    f.object({
      id: f.string(),
      chainId: f.string(),
      chainName: f.string(),
      rpcUrls: f.array(f.string()).optional(),
      nativeCurrency: f.object({
        name: f.string(),
        symbol: f.string(),
        decimals: f.number()
      }).optional(),
      blockExplorerUrls: f.array(f.string()).optional()
    })
  ]),
  switchStarknetChain: f.tuple([
    f.object({
      chainId: f.string()
    })
  ]),
  watchAsset: f.tuple([
    f.object({
      type: f.literal("ERC20"),
      options: f.object({
        address: f.string(),
        symbol: f.string().optional(),
        decimals: f.number().optional(),
        image: f.string().optional(),
        name: f.string().optional()
      })
    })
  ]),
  execute: f.tuple([
    f.array(rr).nonempty().or(rr),
    f.array(f.any()).optional(),
    f.object({
      nonce: De.optional(),
      maxFee: De.optional(),
      version: De.optional()
    }).optional()
  ]),
  signMessage: f.tuple([ta])
};
var M = Jn.create({
  isServer: false,
  allowOutsideOfServer: true
});
var wt = ar;
var xt = "";
var Kr = "";
var be = ({
  width: t = 775,
  height: e = 385,
  origin: r,
  location: n,
  atLeftBottom: s = false
}) => {
  const i = (window == null ? void 0 : window.outerWidth) ?? (window == null ? void 0 : window.innerWidth) ?? (window == null ? void 0 : window.screen.width) ?? 0, a = (window == null ? void 0 : window.outerHeight) ?? (window == null ? void 0 : window.innerHeight) ?? (window == null ? void 0 : window.screen.height) ?? 0, o3 = (window == null ? void 0 : window.screenLeft) ?? (window == null ? void 0 : window.screenX) ?? 0, c = (window == null ? void 0 : window.screenTop) ?? (window == null ? void 0 : window.screenY) ?? 0, u2 = s ? 0 : o3 + i / 2 - t / 2, l2 = s ? window.screen.availHeight + 10 : c + a / 2 - e / 2;
  wt = r ?? wt, xt = n ?? xt, Kr = `width=${t},height=${e},top=${l2},left=${u2},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`;
};
M.router({
  authorize: M.procedure.output(f.boolean()).mutation(async () => true),
  connect: M.procedure.mutation(async () => ""),
  enable: M.procedure.output(f.string()).mutation(async () => ""),
  execute: M.procedure.input(nr.execute).output(f.string()).mutation(async () => ""),
  signMessage: M.procedure.input(nr.signMessage).output(f.string().array()).mutation(async () => []),
  getLoginStatus: M.procedure.output(
    f.object({
      isLoggedIn: f.boolean(),
      hasSession: f.boolean().optional(),
      isPreauthorized: f.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: true
  })),
  addStarknetChain: M.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: M.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  watchAsset: M.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  updateModal: M.procedure.subscription(async () => {
  })
});
var ra = ({
  iframe: t
}) => Sn({
  links: [
    kn({
      enabled: (e) => typeof window < "u" || e.direction === "down" && e.result instanceof Error
    }),
    mn({
      condition(e) {
        if (!t && e.type === "subscription")
          throw new Error(
            "subscription is not supported without an iframe window"
          );
        return !!t;
      },
      true: yt.windowLink({
        window,
        postWindow: t,
        postOrigin: "*"
      }),
      false: yt.popupLink({
        listenWindow: window,
        createPopup: () => {
          let e = null;
          const r = document.createElement("button");
          if (r.style.display = "none", r.addEventListener("click", () => {
            e = window.open(
              `${wt}${xt}`,
              "popup",
              Kr
            );
          }), r.click(), (async () => {
            for (; !e; )
              await new Promise((n) => setTimeout(n, 100));
          })(), !e)
            throw new Error("Could not open popup");
          return e;
        },
        postOrigin: "*"
      })
    })
  ]
});
function na(t) {
  try {
    const { origin: e } = new URL(t);
    if (e.includes("localhost") || e.includes("127.0.0.1") || e.includes("hydrogen"))
      return Zt;
    if (e.includes("staging") || e.includes("argent.xyz"))
      return ct;
  } catch {
    console.warn(
      "Could not determine rpc nodeUrl from target URL, defaulting to mainnet"
    );
  }
  return ct;
}
var sa = 385;
var ia = 775;
var aa = 385;
var oa = 440;
var ca = 886;
var ua = 562;
var sr = class {
  async getPubKey() {
    throw new Error("Method not implemented");
  }
  async signMessage() {
    throw new Error("Method not implemented");
  }
  async signTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeclareTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeployAccountTransaction() {
    throw new Error("Method not implemented");
  }
};
var la = class extends Account {
  constructor(r, n, s) {
    super(r, n, new sr());
    ie(this, "signer", new sr());
    ie(this, "execute", async (r2, n2, s2) => {
      try {
        return be({
          width: sa,
          height: ia,
          location: "/review"
        }), Array.isArray(r2) && r2[0] && r2[0].entrypoint === "use_offchain_session" && be({
          width: 1,
          height: 1,
          location: "/executeSessionTx",
          atLeftBottom: true
        }), {
          transaction_hash: await this.proxyLink.execute.mutate([
            r2,
            n2,
            s2
          ])
        };
      } catch (i) {
        throw i instanceof Error ? new Error(i.message) : new Error("Error while execute a transaction");
      }
    });
    ie(this, "signMessage", async (r2) => {
      try {
        return be({
          width: aa,
          height: oa,
          location: "/signMessage"
        }), await this.proxyLink.signMessage.mutate([r2]);
      } catch (n2) {
        throw n2 instanceof Error ? new Error(n2.message) : new Error("Error while sign a message");
      }
    });
    this.address = n, this.proxyLink = s;
  }
};
var je = [];
var da = (t, e, r) => {
  const n = {
    ...t,
    isConnected: false,
    provider: e,
    getLoginStatus: () => r.getLoginStatus.mutate(),
    async request(s) {
      switch (s.type) {
        case "wallet_addStarknetChain":
          return await r.addStarknetChain.mutate();
        case "wallet_switchStarknetChain":
          return await r.switchStarknetChain.mutate();
        case "wallet_watchAsset":
          return await r.watchAsset.mutate();
        default:
          throw new Error("not implemented");
      }
    },
    async enable(s) {
      if ((s == null ? void 0 : s.starknetVersion) !== "v4")
        throw Error("not implemented");
      try {
        be({
          width: ca,
          height: ua,
          location: "/interstitialLogin"
        });
        const a = await r.enable.mutate();
        return await fa(
          n,
          e,
          r,
          a
        ), [a];
      } catch (i) {
        throw i instanceof Error ? new Error(i.message) : new Error("Unknow error on enable wallet");
      }
    },
    async isPreauthorized() {
      const { isLoggedIn: s, isPreauthorized: i } = await r.getLoginStatus.mutate();
      return !!(s && i);
    },
    on: (s, i) => {
      if (s === "accountsChanged")
        je.push({
          type: s,
          handler: i
        });
      else if (s === "networkChanged")
        je.push({
          type: s,
          handler: i
        });
      else
        throw new Error(`Unknwown event: ${s}`);
    },
    off: (s, i) => {
      if (s !== "accountsChanged" && s !== "networkChanged")
        throw new Error(`Unknwown event: ${s}`);
      const a = je.findIndex(
        (o3) => o3.type === s && o3.handler === i
      );
      a >= 0 && je.splice(a, 1);
    }
  };
  return n;
};
async function fa(t, e, r, n) {
  if (t.isConnected)
    return t;
  const i = {
    isConnected: true,
    chainId: await e.getChainId(),
    selectedAddress: n,
    account: new la(e, n, r),
    provider: e
  };
  return Object.assign(t, i);
}
var pa = async (t, e) => {
  const r = typeof window < "u" ? window : void 0;
  if (!r)
    throw new Error("window is not defined");
  const n = na(t), s = new RpcProvider({ nodeUrl: n });
  return da(
    {
      host: r.location.origin,
      id: "argentWebWallet",
      icon: "https://www.argent.xyz/favicon.ico",
      name: "Argent Web Wallet",
      version: "1.0.0"
    },
    s,
    e
  );
};
var A3 = null;
var _a2 = class extends q {
  constructor(r = {}) {
    super();
    ie(this, "_wallet", null);
    ie(this, "_options");
    this._options = r;
  }
  available() {
    return true;
  }
  async ready() {
    return A3 ? (this._wallet = A3, this._wallet.isPreauthorized()) : (this._wallet = null, false);
  }
  get id() {
    var _a3;
    return this._wallet = A3, ((_a3 = this._wallet) == null ? void 0 : _a3.id) || "argentWebWallet";
  }
  get name() {
    var _a3;
    return this._wallet = A3, ((_a3 = this._wallet) == null ? void 0 : _a3.name) || "Argent Web Wallet";
  }
  get icon() {
    return {
      light: Dt,
      dark: Dt
    };
  }
  get wallet() {
    if (!this._wallet)
      throw new U();
    return this._wallet;
  }
  get title() {
    return "Email";
  }
  get subtitle() {
    return "Powered by Argent";
  }
  async connect() {
    if (await this.ensureWallet(), !this._wallet)
      throw new A();
    try {
      await this._wallet.enable({ starknetVersion: "v4" });
    } catch {
      throw new F();
    }
    if (!this._wallet.isConnected)
      throw new F();
    const r = this._wallet.account, n = await this.chainId();
    return {
      account: r.address,
      chainId: n
    };
  }
  async disconnect() {
    var _a3;
    if (!this.available() && !this._wallet)
      throw new A();
    if (!((_a3 = this._wallet) == null ? void 0 : _a3.isConnected))
      throw new R();
    A3 = null, this._wallet = A3;
  }
  async account() {
    if (this._wallet = A3, !this._wallet || !this._wallet.account)
      throw new U();
    return this._wallet.account;
  }
  async chainId() {
    if (!this._wallet || !this.wallet.account || !this._wallet.provider)
      throw new U();
    const r = await this._wallet.provider.getChainId();
    return BigInt(r);
  }
  async initEventListener(r) {
    if (this._wallet = A3, !this._wallet)
      throw new U();
    this._wallet.on("accountsChanged", r);
  }
  async removeEventListener(r) {
    if (this._wallet = A3, !this._wallet)
      throw new U();
    this._wallet.off("accountsChanged", r), A3 = null, this._wallet = null;
  }
  async ensureWallet() {
    const r = this._options.url || ar;
    be({
      origin: r,
      location: "/interstitialLogin"
    }), A3 = await pa(r, ra({})) ?? null, this._wallet = A3;
  }
};

// node_modules/starknetkit/dist/index-75c5e31c.js
var g2 = Object.defineProperty;
var u = (e, M2, t) => M2 in e ? g2(e, M2, { enumerable: true, configurable: true, writable: true, value: t }) : e[M2] = t;
var N3 = (e, M2, t) => (u(e, typeof M2 != "symbol" ? M2 + "" : M2, t), t);
var T3 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iYmxhY2siLz4KPHBhdGggZD0iTTE4LjQwMTggNy41NTU1NkgxMy41OTgyQzEzLjQzNzcgNy41NTU1NiAxMy4zMDkxIDcuNjg3NDcgMTMuMzA1NiA3Ljg1MTQzQzEzLjIwODUgMTIuNDYwMyAxMC44NDg0IDE2LjgzNDcgNi43ODYwOCAxOS45MzMxQzYuNjU3MTEgMjAuMDMxNCA2LjYyNzczIDIwLjIxNjIgNi43MjIwMiAyMC4zNDkzTDkuNTMyNTMgMjQuMzE5NkM5LjYyODE1IDI0LjQ1NDggOS44MTQ0NCAyNC40ODUzIDkuOTQ1NTggMjQuMzg2QzEyLjQ4NTYgMjIuNDYxMyAxNC41Mjg3IDIwLjEzOTUgMTYgMTcuNTY2QzE3LjQ3MTMgMjAuMTM5NSAxOS41MTQ1IDIyLjQ2MTMgMjIuMDU0NSAyNC4zODZDMjIuMTg1NiAyNC40ODUzIDIyLjM3MTkgMjQuNDU0OCAyMi40Njc2IDI0LjMxOTZMMjUuMjc4MSAyMC4zNDkzQzI1LjM3MjMgMjAuMjE2MiAyNS4zNDI5IDIwLjAzMTQgMjUuMjE0IDE5LjkzMzFDMjEuMTUxNiAxNi44MzQ3IDE4Ljc5MTUgMTIuNDYwMyAxOC42OTQ2IDcuODUxNDNDMTguNjkxMSA3LjY4NzQ3IDE4LjU2MjMgNy41NTU1NiAxOC40MDE4IDcuNTU1NTZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjQuNzIzNiAxMC40OTJMMjQuMjIzMSA4LjkyNDM5QzI0LjEyMTMgOC42MDYxNCAyMy44NzM0IDguMzU4MjQgMjMuNTU3NyA4LjI2MDIzTDIyLjAwMzkgNy43NzU5NUMyMS43ODk1IDcuNzA5MDYgMjEuNzg3MyA3LjQwMTc3IDIyLjAwMTEgNy4zMzIwMUwyMy41NDY5IDYuODI0NjZDMjMuODYwOSA2LjcyMTQ2IDI0LjEwNiA2LjQ2OTUyIDI0LjIwMjcgNi4xNTAxMUwyNC42Nzk4IDQuNTc1MDJDMjQuNzQ1OCA0LjM1NzA5IDI1LjA0ODkgNC4zNTQ3NyAyNS4xMTgzIDQuNTcxNTZMMjUuNjE4OCA2LjEzOTE1QzI1LjcyMDYgNi40NTc0IDI1Ljk2ODYgNi43MDUzMSAyNi4yODQyIDYuODAzOUwyNy44MzggNy4yODc2MUMyOC4wNTI0IDcuMzU0NSAyOC4wNTQ3IDcuNjYxNzkgMjcuODQwOCA3LjczMjEzTDI2LjI5NSA4LjIzOTQ4QzI1Ljk4MTEgOC4zNDIxIDI1LjczNiA4LjU5NDA0IDI1LjYzOTMgOC45MTQwMkwyNS4xNjIxIDEwLjQ4ODVDMjUuMDk2MSAxMC43MDY1IDI0Ljc5MyAxMC43MDg4IDI0LjcyMzYgMTAuNDkyWiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==";
var o = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+";
var l = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==";
var d2 = class extends q {
  constructor({ options: t }) {
    super();
    N3(this, "_wallet");
    N3(this, "_options");
    this._options = t;
  }
  available() {
    return this.ensureWallet(), this._wallet !== void 0;
  }
  async ready() {
    return this.ensureWallet(), this._wallet ? await this._wallet.isPreauthorized() : false;
  }
  async chainId() {
    if (this.ensureWallet(), !this._wallet)
      throw new U();
    const t = await this._wallet.provider.getChainId();
    return BigInt(t);
  }
  async onAccountsChanged(t) {
    let i;
    if (typeof t == "string" ? i = t : i = t[0], i) {
      const I = await this.chainId();
      this.emit("change", { account: i, chainId: I });
    } else
      this.emit("disconnect");
  }
  onNetworkChanged(t) {
    switch (t) {
      case "SN_MAIN":
        this.emit("change", {
          chainId: BigInt(constants_exports.StarknetChainId.SN_MAIN)
        });
        break;
      case "SN_GOERLI":
        this.emit("change", {
          chainId: BigInt(constants_exports.StarknetChainId.SN_GOERLI)
        });
        break;
      case "mainnet-alpha":
        this.emit("change", {
          chainId: BigInt(constants_exports.StarknetChainId.SN_MAIN)
        });
        break;
      case "goerli-alpha":
        this.emit("change", {
          chainId: BigInt(constants_exports.StarknetChainId.SN_GOERLI)
        });
        break;
      default:
        this.emit("change", {});
        break;
    }
  }
  async connect() {
    if (this.ensureWallet(), !this._wallet)
      throw new A();
    let t;
    try {
      t = await this._wallet.enable({ starknetVersion: "v5" });
    } catch {
      throw new F();
    }
    if (!this._wallet.isConnected || !t)
      throw new F();
    this._wallet.on("accountsChanged", async (c) => {
      await this.onAccountsChanged(c);
    }), this._wallet.on("networkChanged", (c) => {
      this.onNetworkChanged(c);
    }), await this.onAccountsChanged(t);
    const i = this._wallet.account.address, I = await this.chainId();
    return this.emit("connect", { account: i, chainId: I }), {
      account: i,
      chainId: I
    };
  }
  async disconnect() {
    var _a3;
    if (this.ensureWallet(), !this.available())
      throw new A();
    if (!((_a3 = this._wallet) == null ? void 0 : _a3.isConnected))
      throw new R();
  }
  async account() {
    if (this.ensureWallet(), !this._wallet || !this._wallet.account)
      throw new U();
    return this._wallet.account;
  }
  get id() {
    return this._options.id;
  }
  get name() {
    if (!this._wallet)
      throw new U();
    return this._wallet.name;
  }
  get icon() {
    var _a3;
    return this._options.icon ? this._options.icon : ((_a3 = this._wallet) == null ? void 0 : _a3.icon) ? {
      dark: this._wallet.icon,
      light: this._wallet.icon
    } : {
      dark: l,
      light: o
    };
  }
  get wallet() {
    if (!this._wallet)
      throw new U();
    return this._wallet;
  }
  ensureWallet() {
    const i = h(globalThis).filter((I) => I.id === this._options.id)[0];
    i && (this._wallet = i);
  }
};
function h(e) {
  return Object.values(
    Object.getOwnPropertyNames(e).reduce((M2, t) => {
      if (t.startsWith("starknet")) {
        const i = e[t];
        z(i) && !M2[i.id] && (M2[i.id] = i);
      }
      return M2;
    }, {})
  );
}
function z(e) {
  try {
    return e && [
      // wallet's must have methods/members, see IStarknetWindowObject
      "request",
      "isConnected",
      "provider",
      "enable",
      "isPreauthorized",
      "on",
      "off",
      "version",
      "id",
      "name",
      "icon"
    ].every((M2) => M2 in e);
  } catch {
  }
  return false;
}

// node_modules/starknetkit/dist/starknetkit.js
var Ve2 = Object.defineProperty;
var Ze2 = (t, e, r) => e in t ? Ve2(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var ae2 = (t, e, r) => (Ze2(t, typeof e != "symbol" ? e + "" : e, r), r);
var $e2 = Object.defineProperty;
var et2 = (t, e, r) => e in t ? $e2(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var tt2 = (t, e, r) => (et2(t, typeof e != "symbol" ? e + "" : e, r), r);
var be2 = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
};
var z2 = (t, e, r) => (be2(t, e, "read from private field"), r ? r.call(t) : e.get(t));
var V = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
};
var ne = (t, e, r, n) => (be2(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r);
var $2 = (t, e, r) => (be2(t, e, "access private method"), r);
var rt2 = [
  {
    id: "argentX",
    name: "Argent X",
    icon: "data:image/svg+xml;base64,Cjxzdmcgd2lkdGg9IjQwIiBoZWlnaHQ9IjM2IiB2aWV3Qm94PSIwIDAgNDAgMzYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0yNC43NTgyIC0zLjk3MzY0ZS0wN0gxNC42MjM4QzE0LjI4NTEgLTMuOTczNjRlLTA3IDE0LjAxMzggMC4yODExNzggMTQuMDA2NCAwLjYzMDY4M0MxMy44MDE3IDEwLjQ1NDkgOC44MjIzNCAxOS43NzkyIDAuMjUxODkzIDI2LjM4MzdDLTAuMDIwMjA0NiAyNi41OTMzIC0wLjA4MjE5NDYgMjYuOTg3MiAwLjExNjczNCAyNy4yNzA5TDYuMDQ2MjMgMzUuNzM0QzYuMjQ3OTYgMzYuMDIyIDYuNjQwOTkgMzYuMDg3IDYuOTE3NjYgMzUuODc1NEMxMi4yNzY1IDMxLjc3MjggMTYuNTg2OSAyNi44MjM2IDE5LjY5MSAyMS4zMzhDMjIuNzk1MSAyNi44MjM2IDI3LjEwNTcgMzEuNzcyOCAzMi40NjQ2IDM1Ljg3NTRDMzIuNzQxIDM2LjA4NyAzMy4xMzQxIDM2LjAyMiAzMy4zMzYxIDM1LjczNEwzOS4yNjU2IDI3LjI3MDlDMzkuNDY0MiAyNi45ODcyIDM5LjQwMjIgMjYuNTkzMyAzOS4xMzA0IDI2LjM4MzdDMzAuNTU5NyAxOS43NzkyIDI1LjU4MDQgMTAuNDU0OSAyNS4zNzU5IDAuNjMwNjgzQzI1LjM2ODUgMC4yODExNzggMjUuMDk2OSAtMy45NzM2NGUtMDcgMjQuNzU4MiAtMy45NzM2NGUtMDdaIiBmaWxsPSIjRkY4NzVCIi8+Cjwvc3ZnPgo=",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/argent-x-starknet-wallet/dlcobpjiigpikoobohmabehhmhfoodbb",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/argent-x"
    }
  },
  {
    id: "braavos",
    name: "Braavos",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aAogICAgICAgIGQ9Ik02Mi43MDUgMTMuOTExNkM2Mi44MzU5IDE0LjEzMzMgNjIuNjYyMSAxNC40MDcgNjIuNDAzOSAxNC40MDdDNTcuMTgwNyAxNC40MDcgNTIuOTM0OCAxOC41NDI3IDUyLjgzNTEgMjMuNjgxN0M1MS4wNDY1IDIzLjM0NzcgNDkuMTkzMyAyMy4zMjI2IDQ3LjM2MjYgMjMuNjMxMUM0Ny4yMzYxIDE4LjUxNTYgNDMuMDAwOSAxNC40MDcgMzcuNzk0OCAxNC40MDdDMzcuNTM2NSAxNC40MDcgMzcuMzYyNSAxNC4xMzMxIDM3LjQ5MzUgMTMuOTExMkM0MC4wMjE3IDkuNjI4MDkgNDQuNzIwNCA2Ljc1IDUwLjA5OTEgNi43NUM1NS40NzgxIDYuNzUgNjAuMTc2OSA5LjYyODI2IDYyLjcwNSAxMy45MTE2WiIKICAgICAgICBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMzcyXzQwMjU5KSIgLz4KICAgIDxwYXRoCiAgICAgICAgZD0iTTc4Ljc2MDYgNDUuODcxOEM4MC4yNzI1IDQ2LjMyOTcgODEuNzAyNSA0NS4wMDU1IDgxLjE3MTQgNDMuNTIyMkM3Ni40MTM3IDMwLjIzMzQgNjEuMzkxMSAyNC44MDM5IDUwLjAyNzcgMjQuODAzOUMzOC42NDQyIDI0LjgwMzkgMjMuMjg2OCAzMC40MDcgMTguODc1NCA0My41OTEyQzE4LjM4MjQgNDUuMDY0NSAxOS44MDgzIDQ2LjM0NDYgMjEuMjk3OCA0NS44ODgxTDQ4Ljg3MiAzNy40MzgxQzQ5LjUzMzEgMzcuMjM1NSA1MC4yMzk5IDM3LjIzNDQgNTAuOTAxNyAzNy40MzQ4TDc4Ljc2MDYgNDUuODcxOFoiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8cGF0aAogICAgICAgIGQ9Ik0xOC44MTMyIDQ4LjE3MDdMNDguODkzNSAzOS4wNDcyQzQ5LjU1MDYgMzguODQ3OCA1MC4yNTI0IDM4Ljg0NzMgNTAuOTA5OCAzOS4wNDU2TDgxLjE3ODEgNDguMTc1MkM4My42OTEyIDQ4LjkzMzIgODUuNDExIDUxLjI0ODMgODUuNDExIDUzLjg3MzVWODEuMjIzM0M4NS4yOTQ0IDg3Ljg5OTEgNzkuMjk3NyA5My4yNSA3Mi42MjQ1IDkzLjI1SDYxLjU0MDZDNjAuNDQ0OSA5My4yNSA1OS41NTc3IDkyLjM2MzcgNTkuNTU3NyA5MS4yNjhWODEuNjc4OUM1OS41NTc3IDc3LjkwMzEgNjEuNzkyMSA3NC40ODU1IDY1LjI0OTggNzIuOTcyOUM2OS44ODQ5IDcwLjk0NTQgNzUuMzY4MSA2OC4yMDI4IDc2LjM5OTQgNjIuNjk5MkM3Ni43MzIzIDYwLjkyMjkgNzUuNTc0MSA1OS4yMDk0IDczLjgwMjQgNTguODU3M0M2OS4zMjI2IDU3Ljk2NjcgNjQuMzU2MiA1OC4zMTA3IDYwLjE1NjQgNjAuMTg5M0M1NS4zODg3IDYyLjMyMTkgNTQuMTQxNSA2NS44Njk0IDUzLjY3OTcgNzAuNjMzN0w1My4xMjAxIDc1Ljc2NjJDNTIuOTQ5MSA3Ny4zMzQ5IDUxLjQ3ODUgNzguNTM2NiA0OS45MDE0IDc4LjUzNjZDNDguMjY5OSA3OC41MzY2IDQ3LjA0NjUgNzcuMjk0IDQ2Ljg2OTYgNzUuNjcxMkw0Ni4zMjA0IDcwLjYzMzdDNDUuOTI0OSA2Ni41NTI5IDQ1LjIwNzkgNjIuNTg4NyA0MC45ODk1IDYwLjcwMThDMzYuMTc3NiA1OC41NDk0IDMxLjM0MTkgNTcuODM0NyAyNi4xOTc2IDU4Ljg1NzNDMjQuNDI2IDU5LjIwOTQgMjMuMjY3OCA2MC45MjI5IDIzLjYwMDcgNjIuNjk5MkMyNC42NDEgNjguMjUwNyAzMC4wODEyIDcwLjkzMDUgMzQuNzUwMyA3Mi45NzI5QzM4LjIwOCA3NC40ODU1IDQwLjQ0MjQgNzcuOTAzMSA0MC40NDI0IDgxLjY3ODlWOTEuMjY2M0M0MC40NDI0IDkyLjM2MiAzOS41NTU1IDkzLjI1IDM4LjQ1OTkgOTMuMjVIMjcuMzc1NkMyMC43MDI0IDkzLjI1IDE0LjcwNTcgODcuODk5MSAxNC41ODkxIDgxLjIyMzNWNTMuODY2M0MxNC41ODkxIDUxLjI0NDYgMTYuMzA0NSA0OC45MzE2IDE4LjgxMzIgNDguMTcwN1oiCiAgICAgICAgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzM3Ml80MDI1OSkiIC8+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMzcyXzQwMjU5IiB4MT0iNDkuMzA1NyIgeTE9IjIuMDc5IiB4Mj0iODAuMzYyNyIgeTI9IjkzLjY1OTciCiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIgLz4KICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5NjAwIiAvPgogICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3Ml80MDI1OSIgeDE9IjQ5LjMwNTciIHkxPSIyLjA3OSIgeDI9IjgwLjM2MjciIHkyPSI5My42NTk3IgogICAgICAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGNUQ0NUUiIC8+CiAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTYwMCIgLz4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl8zNzJfNDAyNTkiIHgxPSI0OS4zMDU3IiB5MT0iMi4wNzkiIHgyPSI4MC4zNjI3IiB5Mj0iOTMuNjU5NyIKICAgICAgICAgICAgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRjVENDVFIiAvPgogICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiIC8+CiAgICAgICAgPC9saW5lYXJHcmFkaWVudD4KICAgIDwvZGVmcz4KPC9zdmc+",
    downloads: {
      chrome: "https://chrome.google.com/webstore/detail/braavos-wallet/jnlgamecbpmbajjfhmmmlhejkemejdma",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/braavos-wallet",
      edge: "https://microsoftedge.microsoft.com/addons/detail/braavos-wallet/hkkpjehhcnhgefhbdcgfkeegglpjchdc"
    }
  }
];
var nt2 = () => `${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;
var ye2 = (t) => {
  for (let e = t.length - 1; e > 0; e--) {
    const r = Math.floor(Math.random() * (e + 1));
    [t[e], t[r]] = [t[r], t[e]];
  }
  return t;
};
function ce2(...t) {
  return (e) => t.reduce((r, n) => r.then(n), Promise.resolve(e));
}
var B2;
var S;
var H2;
var fe2;
var Oe2;
var X2;
var te2;
var it2 = class {
  constructor(e) {
    V(this, fe2), V(this, X2), V(this, B2, false), V(this, S, void 0), V(this, H2, void 0), tt2(this, "value"), ne(this, H2, e), $2(this, X2, te2).call(this);
  }
  set(e) {
    return !z2(this, B2) && !$2(this, X2, te2).call(this) ? false : (this.delete(), this.value = e, e && (ne(this, S, `${z2(this, H2)}-${nt2()}`), localStorage.setItem(z2(this, S), e)), true);
  }
  get() {
    return $2(this, fe2, Oe2).call(this), this.value;
  }
  delete() {
    return !z2(this, B2) && !$2(this, X2, te2).call(this) ? false : (this.value = null, z2(this, S) && localStorage.removeItem(z2(this, S)), true);
  }
};
B2 = /* @__PURE__ */ new WeakMap(), S = /* @__PURE__ */ new WeakMap(), H2 = /* @__PURE__ */ new WeakMap(), fe2 = /* @__PURE__ */ new WeakSet(), Oe2 = function() {
  this.value && this.set(this.value);
}, X2 = /* @__PURE__ */ new WeakSet(), te2 = function() {
  try {
    !z2(this, B2) && typeof window < "u" && (ne(this, S, Object.keys(localStorage).find(
      (t) => t.startsWith(z2(this, H2))
    )), ne(this, B2, true), z2(this, S) && this.set(localStorage.getItem(z2(this, S))));
  } catch (t) {
    console.warn(t);
  }
  return z2(this, B2);
};
function le2(t, e) {
  var r, n;
  if ((r = e == null ? void 0 : e.include) != null && r.length) {
    const i = new Set(e.include);
    return t.filter((s) => i.has(s.id));
  }
  if ((n = e == null ? void 0 : e.exclude) != null && n.length) {
    const i = new Set(e.exclude);
    return t.filter((s) => !i.has(s.id));
  }
  return t;
}
var ve2 = async (t) => {
  const e = await Promise.all(
    t.map((r) => r.isPreauthorized().catch(() => false))
  );
  return t.filter((r, n) => e[n]);
};
var ot = (t) => {
  try {
    return t && [
      "request",
      "isConnected",
      "provider",
      "enable",
      "isPreauthorized",
      "on",
      "off",
      "version",
      "id",
      "name",
      "icon"
    ].every((e) => e in t);
  } catch {
  }
  return false;
};
function de2(t, e) {
  return Object.values(
    Object.getOwnPropertyNames(t).reduce((r, n) => {
      if (n.startsWith("starknet")) {
        const i = t[n];
        e(i) && !r[i.id] && (r[i.id] = i);
      }
      return r;
    }, {})
  );
}
var ue2 = (t, e) => {
  if (e && Array.isArray(e)) {
    t.sort((n, i) => e.indexOf(n.id) - e.indexOf(i.id));
    const r = t.length - e.length;
    return [
      ...t.slice(r),
      ...ye2(t.slice(0, r))
    ];
  } else
    return ye2(t);
};
var st2 = typeof window < "u" ? window : {};
var at2 = {
  windowObject: st2,
  isWalletObject: ot,
  storageFactoryImplementation: (t) => new it2(t)
};
function ct2(t = {}) {
  const { storageFactoryImplementation: e, windowObject: r, isWalletObject: n } = {
    ...at2,
    ...t
  }, i = e("gsw-last");
  return {
    getAvailableWallets: async (s = {}) => {
      const a = de2(
        r,
        n
      );
      return ce2(
        (l2) => le2(l2, s),
        (l2) => ue2(l2, s.sort)
      )(a);
    },
    getPreAuthorizedWallets: async (s = {}) => {
      const a = de2(
        r,
        n
      );
      return ce2(
        (l2) => ve2(l2),
        (l2) => le2(l2, s),
        (l2) => ue2(l2, s.sort)
      )(a);
    },
    getDiscoveryWallets: async (s = {}) => ce2(
      (a) => le2(a, s),
      (a) => ue2(a, s.sort)
    )(rt2),
    getLastConnectedWallet: async () => {
      const s = i.get(), a = de2(r, n).find(
        (d3) => d3.id === s
      ), [l2] = await ve2(
        a ? [a] : []
      );
      return l2 || (i.delete(), null);
    },
    enable: async (s, a) => {
      if (await s.enable(a ?? { starknetVersion: "v5" }), !s.isConnected)
        throw new Error("Failed to connect to wallet");
      return i.set(s.id), s;
    },
    disconnect: async ({ clearLastWallet: s } = {}) => {
      s && i.delete();
    }
  };
}
var q3 = ct2();
var lt2 = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var _e3 = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var N4 = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
var j = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var L2 = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
var o2 = class _o {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(e, r) {
    const n = r.match(e);
    return n && n.length > 0 && n[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(e, r) {
    const n = r.match(e);
    return n && n.length > 1 && n[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(e, r, n) {
    if (e.test(r))
      return n;
  }
  static getWindowsVersionName(e) {
    switch (e) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(e) {
    const r = e.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), r[0] === 10)
      switch (r[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(e) {
    const r = e.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), !(r[0] === 1 && r[1] < 5)) {
      if (r[0] === 1 && r[1] < 6)
        return "Cupcake";
      if (r[0] === 1 && r[1] >= 6)
        return "Donut";
      if (r[0] === 2 && r[1] < 2)
        return "Eclair";
      if (r[0] === 2 && r[1] === 2)
        return "Froyo";
      if (r[0] === 2 && r[1] > 2)
        return "Gingerbread";
      if (r[0] === 3)
        return "Honeycomb";
      if (r[0] === 4 && r[1] < 1)
        return "Ice Cream Sandwich";
      if (r[0] === 4 && r[1] < 4)
        return "Jelly Bean";
      if (r[0] === 4 && r[1] >= 4)
        return "KitKat";
      if (r[0] === 5)
        return "Lollipop";
      if (r[0] === 6)
        return "Marshmallow";
      if (r[0] === 7)
        return "Nougat";
      if (r[0] === 8)
        return "Oreo";
      if (r[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(e) {
    return e.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(e, r, n = false) {
    const i = _o.getVersionPrecision(e), s = _o.getVersionPrecision(r);
    let a = Math.max(i, s), l2 = 0;
    const d3 = _o.map([e, r], (c) => {
      const f2 = a - _o.getVersionPrecision(c), b3 = c + new Array(f2 + 1).join(".0");
      return _o.map(b3.split("."), (M2) => new Array(20 - M2.length).join("0") + M2).reverse();
    });
    for (n && (l2 = a - Math.min(i, s)), a -= 1; a >= l2; ) {
      if (d3[0][a] > d3[1][a])
        return 1;
      if (d3[0][a] === d3[1][a]) {
        if (a === l2)
          return 0;
        a -= 1;
      } else if (d3[0][a] < d3[1][a])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(e, r) {
    const n = [];
    let i;
    if (Array.prototype.map)
      return Array.prototype.map.call(e, r);
    for (i = 0; i < e.length; i += 1)
      n.push(r(e[i]));
    return n;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(e, r) {
    let n, i;
    if (Array.prototype.find)
      return Array.prototype.find.call(e, r);
    for (n = 0, i = e.length; n < i; n += 1) {
      const s = e[n];
      if (r(s, n))
        return s;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(e, ...r) {
    const n = e;
    let i, s;
    if (Object.assign)
      return Object.assign(e, ...r);
    for (i = 0, s = r.length; i < s; i += 1) {
      const a = r[i];
      typeof a == "object" && a !== null && Object.keys(a).forEach((d3) => {
        n[d3] = a[d3];
      });
    }
    return e;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(e) {
    return lt2[e];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(e) {
    return _e3[e] || "";
  }
};
var y2 = /version\/(\d+(\.?_?\d+)+)/i;
var dt2 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(t) {
      const e = {
        name: "Googlebot"
      }, r = o2.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(t) {
      const e = {
        name: "Opera"
      }, r = o2.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(t) {
      const e = {
        name: "Samsung Internet for Android"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/Whale/i],
    describe(t) {
      const e = {
        name: "NAVER Whale Browser"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(t) {
      const e = {
        name: "MZ Browser"
      }, r = o2.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/focus/i],
    describe(t) {
      const e = {
        name: "Focus"
      }, r = o2.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/swing/i],
    describe(t) {
      const e = {
        name: "Swing"
      }, r = o2.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/coast/i],
    describe(t) {
      const e = {
        name: "Opera Coast"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(t) {
      const e = {
        name: "Opera Touch"
      }, r = o2.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/yabrowser/i],
    describe(t) {
      const e = {
        name: "Yandex Browser"
      }, r = o2.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(t) {
      const e = {
        name: "UC Browser"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(t) {
      const e = {
        name: "Maxthon"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/epiphany/i],
    describe(t) {
      const e = {
        name: "Epiphany"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/puffin/i],
    describe(t) {
      const e = {
        name: "Puffin"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/sleipnir/i],
    describe(t) {
      const e = {
        name: "Sleipnir"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/k-meleon/i],
    describe(t) {
      const e = {
        name: "K-Meleon"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/micromessenger/i],
    describe(t) {
      const e = {
        name: "WeChat"
      }, r = o2.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(t) {
      const e = {
        name: /qqbrowserlite/i.test(t) ? "QQ Browser Lite" : "QQ Browser"
      }, r = o2.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/msie|trident/i],
    describe(t) {
      const e = {
        name: "Internet Explorer"
      }, r = o2.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/\sedg\//i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, r = o2.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(t) {
      const e = {
        name: "Microsoft Edge"
      }, r = o2.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/vivaldi/i],
    describe(t) {
      const e = {
        name: "Vivaldi"
      }, r = o2.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/seamonkey/i],
    describe(t) {
      const e = {
        name: "SeaMonkey"
      }, r = o2.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/sailfish/i],
    describe(t) {
      const e = {
        name: "Sailfish"
      }, r = o2.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/silk/i],
    describe(t) {
      const e = {
        name: "Amazon Silk"
      }, r = o2.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/phantom/i],
    describe(t) {
      const e = {
        name: "PhantomJS"
      }, r = o2.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/slimerjs/i],
    describe(t) {
      const e = {
        name: "SlimerJS"
      }, r = o2.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = {
        name: "BlackBerry"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = {
        name: "WebOS Browser"
      }, r = o2.getFirstMatch(y2, t) || o2.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/bada/i],
    describe(t) {
      const e = {
        name: "Bada"
      }, r = o2.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/tizen/i],
    describe(t) {
      const e = {
        name: "Tizen"
      }, r = o2.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/qupzilla/i],
    describe(t) {
      const e = {
        name: "QupZilla"
      }, r = o2.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(t) {
      const e = {
        name: "Firefox"
      }, r = o2.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/electron/i],
    describe(t) {
      const e = {
        name: "Electron"
      }, r = o2.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(t) {
      const e = {
        name: "Miui"
      }, r = o2.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/chromium/i],
    describe(t) {
      const e = {
        name: "Chromium"
      }, r = o2.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, t) || o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(t) {
      const e = {
        name: "Chrome"
      }, r = o2.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  {
    test: [/GSA/i],
    describe(t) {
      const e = {
        name: "Google Search"
      }, r = o2.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Android Browser */
  {
    test(t) {
      const e = !t.test(/like android/i), r = t.test(/android/i);
      return e && r;
    },
    describe(t) {
      const e = {
        name: "Android Browser"
      }, r = o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(t) {
      const e = {
        name: "PlayStation 4"
      }, r = o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(t) {
      const e = {
        name: "Safari"
      }, r = o2.getFirstMatch(y2, t);
      return r && (e.version = r), e;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(t) {
      const e = /^(.*)\/(.*) /, r = /^(.*)\/(.*)[ \t]\((.*)/, i = t.search("\\(") !== -1 ? r : e;
      return {
        name: o2.getFirstMatch(i, t),
        version: o2.getSecondMatch(i, t)
      };
    }
  }
];
var ut2 = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(t) {
      const e = o2.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, t);
      return {
        name: j.Roku,
        version: e
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(t) {
      const e = o2.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, t);
      return {
        name: j.WindowsPhone,
        version: e
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(t) {
      const e = o2.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, t), r = o2.getWindowsVersionName(e);
      return {
        name: j.Windows,
        version: e,
        versionName: r
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(t) {
      const e = {
        name: j.iOS
      }, r = o2.getSecondMatch(/(Version\/)(\d[\d.]+)/, t);
      return r && (e.version = r), e;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(t) {
      const e = o2.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, t).replace(/[_\s]/g, "."), r = o2.getMacOSVersionName(e), n = {
        name: j.MacOS,
        version: e
      };
      return r && (n.versionName = r), n;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(t) {
      const e = o2.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, t).replace(/[_\s]/g, ".");
      return {
        name: j.iOS,
        version: e
      };
    }
  },
  /* Android */
  {
    test(t) {
      const e = !t.test(/like android/i), r = t.test(/android/i);
      return e && r;
    },
    describe(t) {
      const e = o2.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, t), r = o2.getAndroidVersionName(e), n = {
        name: j.Android,
        version: e
      };
      return r && (n.versionName = r), n;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(t) {
      const e = o2.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, t), r = {
        name: j.WebOS
      };
      return e && e.length && (r.version = e), r;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(t) {
      const e = o2.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, t) || o2.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, t) || o2.getFirstMatch(/\bbb(\d+)/i, t);
      return {
        name: j.BlackBerry,
        version: e
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(t) {
      const e = o2.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, t);
      return {
        name: j.Bada,
        version: e
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(t) {
      const e = o2.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: j.Tizen,
        version: e
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: j.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: j.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(t) {
      const e = o2.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, t);
      return {
        name: j.PlayStation4,
        version: e
      };
    }
  }
];
var gt2 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(t) {
      const e = o2.getFirstMatch(/(can-l01)/i, t) && "Nova", r = {
        type: N4.mobile,
        vendor: "Huawei"
      };
      return e && (r.model = e), r;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: N4.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: N4.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: N4.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: N4.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: N4.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: N4.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(t) {
      const e = t.test(/ipod|iphone/i), r = t.test(/like (ipod|iphone)/i);
      return e && !r;
    },
    describe(t) {
      const e = o2.getFirstMatch(/(ipod|iphone)/i, t);
      return {
        type: N4.mobile,
        vendor: "Apple",
        model: e
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: N4.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: N4.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(t) {
      return t.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: N4.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(t) {
      return t.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: N4.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(t) {
      return t.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: N4.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(t) {
      const e = Number(String(t.getOSVersion()).split(".")[0]);
      return t.getOSName(true) === "android" && e >= 3;
    },
    describe() {
      return {
        type: N4.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(t) {
      return t.getOSName(true) === "android";
    },
    describe() {
      return {
        type: N4.mobile
      };
    }
  },
  /* desktop */
  {
    test(t) {
      return t.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: N4.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(t) {
      return t.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: N4.desktop
      };
    }
  },
  /* Linux */
  {
    test(t) {
      return t.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: N4.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(t) {
      return t.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: N4.tv
      };
    }
  },
  /* Roku */
  {
    test(t) {
      return t.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: N4.tv
      };
    }
  }
];
var ft2 = [
  /* EdgeHTML */
  {
    test(t) {
      return t.getBrowserName(true) === "microsoft edge";
    },
    describe(t) {
      if (/\sedg\//i.test(t))
        return {
          name: L2.Blink
        };
      const r = o2.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, t);
      return {
        name: L2.EdgeHTML,
        version: r
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(t) {
      const e = {
        name: L2.Trident
      }, r = o2.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Presto */
  {
    test(t) {
      return t.test(/presto/i);
    },
    describe(t) {
      const e = {
        name: L2.Presto
      }, r = o2.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Gecko */
  {
    test(t) {
      const e = t.test(/gecko/i), r = t.test(/like gecko/i);
      return e && !r;
    },
    describe(t) {
      const e = {
        name: L2.Gecko
      }, r = o2.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: L2.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(t) {
      const e = {
        name: L2.WebKit
      }, r = o2.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, t);
      return r && (e.version = r), e;
    }
  }
];
var ke2 = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(e, r = false) {
    if (e == null || e === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = e, this.parsedResult = {}, r !== true && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(e) {
    return e.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const e = o2.find(dt2, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.browser = e.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(e) {
    return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const e = o2.find(ut2, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.os = e.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS — macOS, Windows, Linux, etc.
   */
  getOSName(e) {
    const { name: r } = this.getOS();
    return e ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(e = false) {
    const { type: r } = this.getPlatform();
    return e ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const e = o2.find(gt2, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.platform = e.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(e) {
    return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const e = o2.find(ft2, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return e && (this.parsedResult.engine = e.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return o2.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(e) {
    const r = {};
    let n = 0;
    const i = {};
    let s = 0;
    if (Object.keys(e).forEach((l2) => {
      const d3 = e[l2];
      typeof d3 == "string" ? (i[l2] = d3, s += 1) : typeof d3 == "object" && (r[l2] = d3, n += 1);
    }), n > 0) {
      const l2 = Object.keys(r), d3 = o2.find(l2, (f2) => this.isOS(f2));
      if (d3) {
        const f2 = this.satisfies(r[d3]);
        if (f2 !== void 0)
          return f2;
      }
      const c = o2.find(
        l2,
        (f2) => this.isPlatform(f2)
      );
      if (c) {
        const f2 = this.satisfies(r[c]);
        if (f2 !== void 0)
          return f2;
      }
    }
    if (s > 0) {
      const l2 = Object.keys(i), d3 = o2.find(l2, (c) => this.isBrowser(c, true));
      if (d3 !== void 0)
        return this.compareVersion(i[d3]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(e, r = false) {
    const n = this.getBrowserName().toLowerCase();
    let i = e.toLowerCase();
    const s = o2.getBrowserTypeByAlias(i);
    return r && s && (i = s.toLowerCase()), i === n;
  }
  compareVersion(e) {
    let r = [0], n = e, i = false;
    const s = this.getBrowserVersion();
    if (typeof s == "string")
      return e[0] === ">" || e[0] === "<" ? (n = e.substr(1), e[1] === "=" ? (i = true, n = e.substr(2)) : r = [], e[0] === ">" ? r.push(1) : r.push(-1)) : e[0] === "=" ? n = e.substr(1) : e[0] === "~" && (i = true, n = e.substr(1)), r.indexOf(
        o2.compareVersions(s, n, i)
      ) > -1;
  }
  isOS(e) {
    return this.getOSName(true) === String(e).toLowerCase();
  }
  isPlatform(e) {
    return this.getPlatformType(true) === String(e).toLowerCase();
  }
  isEngine(e) {
    return this.getEngineName(true) === String(e).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(e, r = false) {
    return this.isBrowser(e, r) || this.isOS(e) || this.isPlatform(e);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(e = []) {
    return e.some((r) => this.is(r));
  }
};
var wt2 = class {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(e, r = false) {
    if (typeof e != "string")
      throw new Error("UserAgent should be a string");
    return new ke2(e, r);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(e) {
    return new ke2(e).getResult();
  }
  static get BROWSER_MAP() {
    return _e3;
  }
  static get ENGINE_MAP() {
    return L2;
  }
  static get OS_MAP() {
    return j;
  }
  static get PLATFORMS_MAP() {
    return N4;
  }
};
var Ne2 = typeof window < "u" ? window : null;
function ht2() {
  var _a3;
  if (!Ne2)
    return null;
  switch ((_a3 = wt2.getParser(Ne2.navigator.userAgent).getBrowserName()) == null ? void 0 : _a3.toLowerCase()) {
    case "firefox":
      return "firefox";
    case "microsoft edge":
      return "edge";
    case "android browser":
    case "chrome":
    case "chromium":
    case "electron":
    case "opera":
    case "vivaldi":
      return "chrome";
    default:
      return null;
  }
}
var bt2 = ({
  argentMobileOptions: t,
  webWalletUrl: e
}) => {
  const r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), n = [];
  return r || (n.push(
    new d2({ options: { id: "argentX" } })
  ), n.push(
    new d2({ options: { id: "braavos" } })
  )), n.push(new N(t)), n.push(new _a2({ url: e })), n;
};
var pt2 = typeof global == "object" && global && global.Object === Object && global;
var mt2 = pt2;
var Mt = typeof self == "object" && self && self.Object === Object && self;
var yt2 = mt2 || Mt || Function("return this")();
var vt2 = yt2;
var kt2 = vt2.Symbol;
var ie2 = kt2;
var Le2 = Object.prototype;
var Nt2 = Le2.hasOwnProperty;
var It = Le2.toString;
var Z2 = ie2 ? ie2.toStringTag : void 0;
function At(t) {
  var e = Nt2.call(t, Z2), r = t[Z2];
  try {
    t[Z2] = void 0;
    var n = true;
  } catch {
  }
  var i = It.call(t);
  return n && (e ? t[Z2] = r : delete t[Z2]), i;
}
var xt2 = Object.prototype;
var jt = xt2.toString;
function Dt2(t) {
  return jt.call(t);
}
var zt2 = "[object Null]";
var Ct2 = "[object Undefined]";
var Ie = ie2 ? ie2.toStringTag : void 0;
function St2(t) {
  return t == null ? t === void 0 ? Ct2 : zt2 : Ie && Ie in Object(t) ? At(t) : Dt2(t);
}
function Ot2(t) {
  return t != null && typeof t == "object";
}
var _t2 = Array.isArray;
var Lt2 = _t2;
var Tt2 = "[object String]";
function Ae2(t) {
  return typeof t == "string" || !Lt2(t) && Ot2(t) && St2(t) == Tt2;
}
var Et2 = ({
  availableConnectors: t,
  installedWallets: e,
  discoveryWallets: r,
  storeVersion: n
}) => {
  var _a3;
  return ((_a3 = window == null ? void 0 : window.starknet_argentX) == null ? void 0 : _a3.isInAppBrowser) ? [] : t.map((a) => {
    const l2 = e.find((c) => c.id === a.id);
    if (l2) {
      const c = l2.id === "argentX" ? T3 : l2.icon;
      return {
        name: l2.name,
        id: l2.id,
        icon: { light: c, dark: c },
        connector: a
      };
    }
    const d3 = r.filter(
      (c) => !!c.downloads[n]
    ).find((c) => c.id === a.id);
    if (d3) {
      const { downloads: c } = d3, f2 = d3.id === "argentX" ? T3 : d3.icon;
      return {
        name: d3.name,
        id: d3.id,
        icon: { light: f2, dark: f2 },
        connector: a,
        download: c[n]
      };
    }
    return !a || !a.id || !a.name ? null : {
      name: a.name,
      id: a.id,
      icon: a.icon,
      connector: a,
      title: "title" in a && Ae2(a.title) ? a.title : void 0,
      subtitle: "subtitle" in a && Ae2(a.subtitle) ? a.subtitle : void 0
    };
  }).filter((a) => a !== null);
};
function P() {
}
function Te2(t) {
  return t();
}
function xe2() {
  return /* @__PURE__ */ Object.create(null);
}
function E(t) {
  t.forEach(Te2);
}
function Ee2(t) {
  return typeof t == "function";
}
function Fe2(t, e) {
  return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
}
var ee2;
function Be2(t, e) {
  return ee2 || (ee2 = document.createElement("a")), ee2.href = e, t === ee2.href;
}
function Ft2(t) {
  return Object.keys(t).length === 0;
}
function v2(t, e) {
  t.appendChild(e);
}
function F3(t, e, r) {
  t.insertBefore(e, r || null);
}
function _2(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function Bt2(t, e) {
  for (let r = 0; r < t.length; r += 1)
    t[r] && t[r].d(e);
}
function A4(t) {
  return document.createElement(t);
}
function Q2(t) {
  return document.createTextNode(t);
}
function T4() {
  return Q2(" ");
}
function We2() {
  return Q2("");
}
function C2(t, e, r, n) {
  return t.addEventListener(e, r, n), () => t.removeEventListener(e, r, n);
}
function h2(t, e, r) {
  r == null ? t.removeAttribute(e) : t.getAttribute(e) !== r && t.setAttribute(e, r);
}
function Wt2(t) {
  return Array.from(t.childNodes);
}
function oe2(t, e) {
  e = "" + e, t.data !== e && (t.data = /** @type {string} */
  e);
}
function Pe2(t, e, r, n) {
  r == null ? t.style.removeProperty(e) : t.style.setProperty(e, r, n ? "important" : "");
}
var K2;
function J2(t) {
  K2 = t;
}
function Pt2() {
  if (!K2)
    throw new Error("Function called outside component initialization");
  return K2;
}
function Qt2(t) {
  Pt2().$$.on_mount.push(t);
}
var Y2 = [];
var je2 = [];
var R2 = [];
var De2 = [];
var Ut2 = Promise.resolve();
var we2 = false;
function Yt2() {
  we2 || (we2 = true, Ut2.then(Qe2));
}
function he2(t) {
  R2.push(t);
}
var ge2 = /* @__PURE__ */ new Set();
var U3 = 0;
function Qe2() {
  if (U3 !== 0)
    return;
  const t = K2;
  do {
    try {
      for (; U3 < Y2.length; ) {
        const e = Y2[U3];
        U3++, J2(e), Rt2(e.$$);
      }
    } catch (e) {
      throw Y2.length = 0, U3 = 0, e;
    }
    for (J2(null), Y2.length = 0, U3 = 0; je2.length; )
      je2.pop()();
    for (let e = 0; e < R2.length; e += 1) {
      const r = R2[e];
      ge2.has(r) || (ge2.add(r), r());
    }
    R2.length = 0;
  } while (Y2.length);
  for (; De2.length; )
    De2.pop()();
  we2 = false, ge2.clear(), J2(t);
}
function Rt2(t) {
  if (t.fragment !== null) {
    t.update(), E(t.before_update);
    const e = t.dirty;
    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(he2);
  }
}
function Gt2(t) {
  const e = [], r = [];
  R2.forEach((n) => t.indexOf(n) === -1 ? e.push(n) : r.push(n)), r.forEach((n) => n()), R2 = e;
}
var re2 = /* @__PURE__ */ new Set();
var W2;
function Vt2() {
  W2 = {
    r: 0,
    c: [],
    p: W2
    // parent group
  };
}
function Zt2() {
  W2.r || E(W2.c), W2 = W2.p;
}
function G2(t, e) {
  t && t.i && (re2.delete(t), t.i(e));
}
function se(t, e, r, n) {
  if (t && t.o) {
    if (re2.has(t))
      return;
    re2.add(t), W2.c.push(() => {
      re2.delete(t), n && (r && t.d(1), n());
    }), t.o(e);
  } else
    n && n();
}
function ze2(t) {
  return (t == null ? void 0 : t.length) !== void 0 ? t : Array.from(t);
}
function Xt2(t) {
  t && t.c();
}
function Ue2(t, e, r) {
  const { fragment: n, after_update: i } = t.$$;
  n && n.m(e, r), he2(() => {
    const s = t.$$.on_mount.map(Te2).filter(Ee2);
    t.$$.on_destroy ? t.$$.on_destroy.push(...s) : E(s), t.$$.on_mount = [];
  }), i.forEach(he2);
}
function Ye2(t, e) {
  const r = t.$$;
  r.fragment !== null && (Gt2(r.after_update), E(r.on_destroy), r.fragment && r.fragment.d(e), r.on_destroy = r.fragment = null, r.ctx = []);
}
function Ht2(t, e) {
  t.$$.dirty[0] === -1 && (Y2.push(t), Yt2(), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function Re2(t, e, r, n, i, s, a, l2 = [-1]) {
  const d3 = K2;
  J2(t);
  const c = t.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: s,
    update: P,
    not_equal: i,
    bound: xe2(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (d3 ? d3.$$.context : [])),
    // everything else
    callbacks: xe2(),
    dirty: l2,
    skip_bound: false,
    root: e.target || d3.$$.root
  };
  a && a(c.root);
  let f2 = false;
  if (c.ctx = r ? r(t, e.props || {}, (b3, M2, ...w2) => {
    const k2 = w2.length ? w2[0] : M2;
    return c.ctx && i(c.ctx[b3], c.ctx[b3] = k2) && (!c.skip_bound && c.bound[b3] && c.bound[b3](k2), f2 && Ht2(t, b3)), M2;
  }) : [], c.update(), f2 = true, E(c.before_update), c.fragment = n ? n(c.ctx) : false, e.target) {
    if (e.hydrate) {
      const b3 = Wt2(e.target);
      c.fragment && c.fragment.l(b3), b3.forEach(_2);
    } else
      c.fragment && c.fragment.c();
    e.intro && G2(t.$$.fragment), Ue2(t, e.target, e.anchor), Qe2();
  }
  J2(d3);
}
var Ge2 = class {
  constructor() {
    ae2(this, "$$");
    ae2(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    Ye2(this, 1), this.$destroy = P;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(e, r) {
    if (!Ee2(r))
      return P;
    const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return n.push(r), () => {
      const i = n.indexOf(r);
      i !== -1 && n.splice(i, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(e) {
    this.$$set && !Ft2(e) && (this.$$.skip_bound = true, this.$$set(e), this.$$.skip_bound = false);
  }
};
var qt2 = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(qt2);
function Jt2(t) {
  let e, r, n, i, s, a = (
    /*wallet*/
    (t[0].title ?? /*wallet*/
    t[0].name) + ""
  ), l2, d3, c, f2 = (
    /*wallet*/
    (t[0].subtitle ?? "") + ""
  ), b3, M2, w2, k2;
  function x(u2, p2) {
    var _a3;
    return (
      /*loadingItem*/
      u2[2] === /*wallet*/
      ((_a3 = u2[0]) == null ? void 0 : _a3.id) ? tr2 : (
        /*isSvg*/
        u2[4] ? er2 : $t
      )
    );
  }
  let m = x(t), g3 = m(t);
  return {
    c() {
      e = A4("li"), r = A4("span"), n = T4(), i = A4("div"), s = A4("p"), l2 = Q2(a), d3 = T4(), c = A4("p"), b3 = Q2(f2), M2 = T4(), g3.c(), h2(r, "class", "w-8 h-8"), h2(s, "class", "font-semibold text-base p"), h2(c, "class", "l2 p"), Pe2(c, "text-align", "center"), h2(i, "class", "flex flex-col justify-center items-center"), h2(e, "class", `flex flex-row-reverse justify-between items-center 
            p-3 rounded-md cursor-pointer shadow-list-item 
            dark:shadow-none dark:bg-neutral-800 dark:text-white 
          hover:bg-neutral-100 dark:hover:bg-neutral-700 
          focus:outline-none focus:ring-2 
        focus:ring-neutral-200 dark:focus:ring-neutral-700 
          transition-colors`), h2(e, "role", "button"), h2(e, "tabindex", "0");
    },
    m(u2, p2) {
      F3(u2, e, p2), v2(e, r), v2(e, n), v2(e, i), v2(i, s), v2(s, l2), v2(i, d3), v2(i, c), v2(c, b3), v2(e, M2), g3.m(e, null), w2 || (k2 = [
        C2(
          e,
          "click",
          /*click_handler_1*/
          t[8]
        ),
        C2(
          e,
          "keyup",
          /*keyup_handler_1*/
          t[9]
        )
      ], w2 = true);
    },
    p(u2, p2) {
      p2 & /*wallet*/
      1 && a !== (a = /*wallet*/
      (u2[0].title ?? /*wallet*/
      u2[0].name) + "") && oe2(l2, a), p2 & /*wallet*/
      1 && f2 !== (f2 = /*wallet*/
      (u2[0].subtitle ?? "") + "") && oe2(b3, f2), m === (m = x(u2)) && g3 ? g3.p(u2, p2) : (g3.d(1), g3 = m(u2), g3 && (g3.c(), g3.m(e, null)));
    },
    d(u2) {
      u2 && _2(e), g3.d(), w2 = false, E(k2);
    }
  };
}
function Kt2(t) {
  let e, r, n, i, s, a, l2 = (
    /*wallet*/
    t[0].name + ""
  ), d3, c, f2, b3, M2, w2, k2, x, m;
  return {
    c() {
      e = A4("a"), r = A4("li"), n = A4("span"), i = T4(), s = A4("p"), a = Q2("Install "), d3 = Q2(l2), c = T4(), f2 = A4("img"), h2(n, "class", "w-8 h-8"), h2(s, "class", "font-semibold text-base p"), h2(f2, "alt", b3 = /*wallet*/
      t[0].name), Be2(f2.src, M2 = /*icon*/
      t[3]) || h2(f2, "src", M2), h2(f2, "class", "w-8 h-8 rounded-full"), h2(r, "class", `flex flex-row-reverse justify-between items-center 
              p-3 rounded-md cursor-pointer shadow-list-item 
              dark:shadow-none dark:bg-neutral-800 dark:text-white 
            hover:bg-neutral-100 dark:hover:bg-neutral-700`), h2(e, "aria-label", w2 = /*wallet*/
      t[0].name + " download link"), h2(e, "href", k2 = /*wallet*/
      t[0].download), h2(e, "target", "_blank"), h2(e, "rel", "noopener noreferrer"), h2(e, "class", `rounded-md focus:outline-none  focus:ring-2 
    focus:ring-neutral-200  dark:focus:ring-neutral-700 transition-colors`);
    },
    m(g3, u2) {
      F3(g3, e, u2), v2(e, r), v2(r, n), v2(r, i), v2(r, s), v2(s, a), v2(s, d3), v2(r, c), v2(r, f2), x || (m = [
        C2(
          r,
          "click",
          /*click_handler*/
          t[6]
        ),
        C2(
          r,
          "keyup",
          /*keyup_handler*/
          t[7]
        )
      ], x = true);
    },
    p(g3, u2) {
      u2 & /*wallet*/
      1 && l2 !== (l2 = /*wallet*/
      g3[0].name + "") && oe2(d3, l2), u2 & /*wallet*/
      1 && b3 !== (b3 = /*wallet*/
      g3[0].name) && h2(f2, "alt", b3), u2 & /*wallet*/
      1 && w2 !== (w2 = /*wallet*/
      g3[0].name + " download link") && h2(e, "aria-label", w2), u2 & /*wallet*/
      1 && k2 !== (k2 = /*wallet*/
      g3[0].download) && h2(e, "href", k2);
    },
    d(g3) {
      g3 && _2(e), x = false, E(m);
    }
  };
}
function $t(t) {
  let e, r, n;
  return {
    c() {
      var _a3;
      e = A4("img"), h2(e, "alt", r = /*wallet*/
      (_a3 = t[0]) == null ? void 0 : _a3.name), Be2(e.src, n = /*icon*/
      t[3]) || h2(e, "src", n), h2(e, "class", "w-8 h-8 rounded");
    },
    m(i, s) {
      F3(i, e, s);
    },
    p(i, s) {
      var _a3;
      s & /*wallet*/
      1 && r !== (r = /*wallet*/
      (_a3 = i[0]) == null ? void 0 : _a3.name) && h2(e, "alt", r);
    },
    d(i) {
      i && _2(e);
    }
  };
}
function er2(t) {
  let e;
  return {
    c() {
      e = A4("div"), Pe2(e, "position", "relative");
    },
    m(r, n) {
      F3(r, e, n), e.innerHTML = /*icon*/
      t[3];
    },
    p: P,
    d(r) {
      r && _2(e);
    }
  };
}
function tr2(t) {
  let e;
  return {
    c() {
      e = A4("div"), e.innerHTML = '<svg aria-hidden="true" class="w-8 h-8 text-neutral-300 animate-spin dark:text-neutral-600 fill-neutral-600 dark:fill-neutral-300" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z" fill="currentColor"></path><path d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z" fill="currentFill"></path></svg> <span class="sr-only">Loading...</span>', h2(e, "role", "status");
    },
    m(r, n) {
      F3(r, e, n);
    },
    p: P,
    d(r) {
      r && _2(e);
    }
  };
}
function rr2(t) {
  let e;
  function r(s, a) {
    return (
      /*wallet*/
      s[0].download ? Kt2 : Jt2
    );
  }
  let n = r(t), i = n(t);
  return {
    c() {
      i.c(), e = We2();
    },
    m(s, a) {
      i.m(s, a), F3(s, e, a);
    },
    p(s, [a]) {
      n === (n = r(s)) && i ? i.p(s, a) : (i.d(1), i = n(s), i && (i.c(), i.m(e.parentNode, e)));
    },
    i: P,
    o: P,
    d(s) {
      s && _2(e), i.d(s);
    }
  };
}
function nr2(t, e, r) {
  let { wallet: n } = e, { theme: i = null } = e, { cb: s = async () => {
  } } = e, { loadingItem: a = false } = e;
  const l2 = i === "dark" ? n.icon.dark : n.icon.light, d3 = l2 == null ? void 0 : l2.startsWith("<svg"), c = () => {
    s(null);
  }, f2 = (w2) => {
    w2.key === "Enter" && s(null);
  }, b3 = async () => {
    s(n.connector);
  }, M2 = async (w2) => {
    w2.key === "Enter" && s(n.connector);
  };
  return t.$$set = (w2) => {
    "wallet" in w2 && r(0, n = w2.wallet), "theme" in w2 && r(5, i = w2.theme), "cb" in w2 && r(1, s = w2.cb), "loadingItem" in w2 && r(2, a = w2.loadingItem);
  }, [
    n,
    s,
    a,
    l2,
    d3,
    i,
    c,
    f2,
    b3,
    M2
  ];
}
var ir = class extends Ge2 {
  constructor(e) {
    super(), Re2(this, e, nr2, rr2, Fe2, {
      wallet: 0,
      theme: 5,
      cb: 1,
      loadingItem: 2
    });
  }
};
function Ce2(t, e, r) {
  const n = t.slice();
  return n[15] = e[r], n;
}
function or2(t) {
  let e, r, n, i, s, a, l2, d3, c, f2, b3, M2, w2, k2, x, m = ze2(
    /*modalWallets*/
    t[1]
  ), g3 = [];
  for (let p2 = 0; p2 < m.length; p2 += 1)
    g3[p2] = Se2(Ce2(t, m, p2));
  const u2 = (p2) => se(g3[p2], 1, 1, () => {
    g3[p2] = null;
  });
  return {
    c() {
      e = A4("div"), r = A4("main"), n = A4("header"), i = A4("h2"), i.textContent = "Connect to", s = T4(), a = A4("h1"), l2 = Q2(
        /*dappName*/
        t[0]
      ), d3 = T4(), c = A4("span"), c.innerHTML = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.77275 3.02275C9.99242 2.80308 9.99242 2.44692 9.77275 2.22725C9.55308 2.00758 9.19692 2.00758 8.97725 2.22725L6 5.20451L3.02275 2.22725C2.80308 2.00758 2.44692 2.00758 2.22725 2.22725C2.00758 2.44692 2.00758 2.80308 2.22725 3.02275L5.20451 6L2.22725 8.97725C2.00758 9.19692 2.00758 9.55308 2.22725 9.77275C2.44692 9.99242 2.80308 9.99242 3.02275 9.77275L6 6.79549L8.97725 9.77275C9.19692 9.99242 9.55308 9.99242 9.77275 9.77275C9.99242 9.55308 9.99242 9.19692 9.77275 8.97725L6.79549 6L9.77275 3.02275Z" fill="currentColor"></path></svg>', f2 = T4(), b3 = A4("ul");
      for (let p2 = 0; p2 < g3.length; p2 += 1)
        g3[p2].c();
      h2(i, "class", "text-sm text-gray-400 font-semibold"), h2(a, "class", `text-xl font-semibold mb-6 
                  max-w-[240px] overflow-hidden 
                  whitespace-nowrap text-ellipsis`), h2(c, "class", `absolute top-0 right-0 p-2 cursor-pointer
                  rounded-full bg-neutral-100 dark:bg-neutral-800
                  text-neutral-400 dark:text-white
                  hover:bg-neutral-100 dark:hover:bg-neutral-700
                  focus:outline-none focus:ring-2
                focus:ring-neutral-200 dark:focus:ring-neutral-700
                  transition-colors`), h2(c, "role", "button"), h2(c, "tabindex", "0"), h2(c, "aria-label", "Close"), h2(n, "class", "flex items-center justify-center flex-col mb-2 relative"), h2(b3, "class", "flex flex-col gap-3"), h2(r, "role", "dialog"), h2(r, "class", `rounded-3xl shadow-modal dark:shadow-none 
              w-full max-w-[380px] z-50 
              mx-6 p-6 pb-8 text-center 
              bg-slate-50 dark:bg-neutral-900 
            text-neutral-900 dark:text-white`), h2(e, "class", M2 = `modal-font backdrop-blur-sm fixed inset-0 flex items-center 
            justify-center bg-black/25 z-[9999] ${/*darkModeControlClass*/
      t[4]}`);
    },
    m(p2, D2) {
      F3(p2, e, D2), v2(e, r), v2(r, n), v2(n, i), v2(n, s), v2(n, a), v2(a, l2), v2(n, d3), v2(n, c), v2(r, f2), v2(r, b3);
      for (let I = 0; I < g3.length; I += 1)
        g3[I] && g3[I].m(b3, null);
      w2 = true, k2 || (x = [
        C2(
          c,
          "click",
          /*click_handler*/
          t[9]
        ),
        C2(
          c,
          "keyup",
          /*keyup_handler*/
          t[10]
        ),
        C2(r, "click", ar2),
        C2(r, "keyup", cr2),
        C2(
          e,
          "click",
          /*click_handler_2*/
          t[11]
        ),
        C2(
          e,
          "keyup",
          /*keyup_handler_2*/
          t[12]
        )
      ], k2 = true);
    },
    p(p2, D2) {
      if ((!w2 || D2 & /*dappName*/
      1) && oe2(
        l2,
        /*dappName*/
        p2[0]
      ), D2 & /*modalWallets, loadingItem, cb, theme*/
      142) {
        m = ze2(
          /*modalWallets*/
          p2[1]
        );
        let I;
        for (I = 0; I < m.length; I += 1) {
          const pe2 = Ce2(p2, m, I);
          g3[I] ? (g3[I].p(pe2, D2), G2(g3[I], 1)) : (g3[I] = Se2(pe2), g3[I].c(), G2(g3[I], 1), g3[I].m(b3, null));
        }
        for (Vt2(), I = m.length; I < g3.length; I += 1)
          u2(I);
        Zt2();
      }
      (!w2 || D2 & /*darkModeControlClass*/
      16 && M2 !== (M2 = `modal-font backdrop-blur-sm fixed inset-0 flex items-center 
            justify-center bg-black/25 z-[9999] ${/*darkModeControlClass*/
      p2[4]}`)) && h2(e, "class", M2);
    },
    i(p2) {
      if (!w2) {
        for (let D2 = 0; D2 < m.length; D2 += 1)
          G2(g3[D2]);
        w2 = true;
      }
    },
    o(p2) {
      g3 = g3.filter(Boolean);
      for (let D2 = 0; D2 < g3.length; D2 += 1)
        se(g3[D2]);
      w2 = false;
    },
    d(p2) {
      p2 && _2(e), Bt2(g3, p2), k2 = false, E(x);
    }
  };
}
function Se2(t) {
  let e, r;
  return e = new ir({
    props: {
      wallet: (
        /*wallet*/
        t[15]
      ),
      loadingItem: (
        /*loadingItem*/
        t[3]
      ),
      cb: (
        /*cb*/
        t[7]
      ),
      theme: (
        /*theme*/
        t[2]
      )
    }
  }), {
    c() {
      Xt2(e.$$.fragment);
    },
    m(n, i) {
      Ue2(e, n, i), r = true;
    },
    p(n, i) {
      const s = {};
      i & /*modalWallets*/
      2 && (s.wallet = /*wallet*/
      n[15]), i & /*loadingItem*/
      8 && (s.loadingItem = /*loadingItem*/
      n[3]), i & /*theme*/
      4 && (s.theme = /*theme*/
      n[2]), e.$set(s);
    },
    i(n) {
      r || (G2(e.$$.fragment, n), r = true);
    },
    o(n) {
      se(e.$$.fragment, n), r = false;
    },
    d(n) {
      Ye2(e, n);
    }
  };
}
function sr2(t) {
  let e, r, n = !/*isInAppBrowser*/
  t[6] && !/*emailOnly*/
  t[5] && or2(t);
  return {
    c() {
      n && n.c(), e = We2();
    },
    m(i, s) {
      n && n.m(i, s), F3(i, e, s), r = true;
    },
    p(i, [s]) {
      !/*isInAppBrowser*/
      i[6] && !/*emailOnly*/
      i[5] && n.p(i, s);
    },
    i(i) {
      r || (G2(n), r = true);
    },
    o(i) {
      se(n), r = false;
    },
    d(i) {
      i && _2(e), n && n.d(i);
    }
  };
}
var ar2 = (t) => t.stopPropagation();
var cr2 = (t) => {
  t.stopPropagation();
};
function lr2(t, e, r) {
  var _a3;
  let { dappName: n = (window == null ? void 0 : window.document.title) ?? "" } = e, { modalWallets: i } = e, { callback: s = async () => {
  } } = e, { theme: a = null } = e, l2 = false, d3 = i.length === 1 && i[0].id.toLowerCase().includes("webwallet"), f2 = (_a3 = window == null ? void 0 : window.starknet_argentX) == null ? void 0 : _a3.isInAppBrowser;
  const b3 = (u2) => {
    r(3, l2 = u2);
  };
  let M2 = async (u2) => {
    b3((u2 == null ? void 0 : u2.id) ?? false);
    try {
      await (u2 == null ? void 0 : u2.connect()), await s((u2 == null ? void 0 : u2.wallet) ?? null);
    } catch (p2) {
      console.error(p2);
    } finally {
      b3(false);
    }
  }, w2 = a === "dark" ? "dark" : "";
  Qt2(async () => {
    var _a4;
    if (a === "dark" || a === null && window.matchMedia("(prefers-color-scheme: dark)").matches ? r(4, w2 = "dark") : r(4, w2 = ""), f2 && (window == null ? void 0 : window.starknet_argentX)) {
      try {
        const u2 = await q3.enable(window == null ? void 0 : window.starknet_argentX);
        s(u2 ?? (window == null ? void 0 : window.starknet_argentX));
      } catch {
      }
      return;
    }
    if (d3)
      try {
        const [u2] = i;
        await ((_a4 = u2.connector) == null ? void 0 : _a4.connect()), s(u2.connector.wallet);
      } catch (u2) {
        console.error(u2);
      }
  });
  const k2 = () => M2(null), x = (u2) => {
    u2.key === "Enter" && M2(null);
  }, m = () => M2(null), g3 = (u2) => {
    u2.key === "Escape" && M2(null);
  };
  return t.$$set = (u2) => {
    "dappName" in u2 && r(0, n = u2.dappName), "modalWallets" in u2 && r(1, i = u2.modalWallets), "callback" in u2 && r(8, s = u2.callback), "theme" in u2 && r(2, a = u2.theme);
  }, [
    n,
    i,
    a,
    l2,
    w2,
    d3,
    f2,
    M2,
    s,
    k2,
    x,
    m,
    g3
  ];
}
var dr2 = class extends Ge2 {
  constructor(e) {
    super(), Re2(this, e, lr2, sr2, Fe2, {
      dappName: 0,
      modalWallets: 1,
      callback: 8,
      theme: 2
    });
  }
};
var ur2 = `@import"https://fonts.googleapis.com/css2?family=Barlow:wght@500;600&display=swap";.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{inset:0}.top-0{top:0}.right-0{right:0}.z-\\[9999\\]{z-index:9999}.z-50{z-index:50}.mx-6{margin-left:1.5rem;margin-right:1.5rem}.mb-2{margin-bottom:.5rem}.mb-6{margin-bottom:1.5rem}.inline{display:inline}.flex{display:flex}.h-8{height:2rem}.w-8{width:2rem}.w-full{width:100%}.max-w-\\[380px\\]{max-width:380px}.max-w-\\[240px\\]{max-width:240px}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}@keyframes spin{to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite}.cursor-pointer{cursor:pointer}.flex-row-reverse{flex-direction:row-reverse}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-3{gap:.75rem}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.rounded-md{border-radius:.375rem}.rounded-full{border-radius:9999px}.rounded{border-radius:.25rem}.rounded-3xl{border-radius:1.5rem}.border{border-width:1px}.bg-black\\/25{background-color:#00000040}.bg-slate-50{--tw-bg-opacity: 1;background-color:rgb(248 250 252 / var(--tw-bg-opacity))}.bg-neutral-100{--tw-bg-opacity: 1;background-color:rgb(245 245 245 / var(--tw-bg-opacity))}.fill-neutral-600{fill:#525252}.p-3{padding:.75rem}.p-6{padding:1.5rem}.p-2{padding:.5rem}.pb-8{padding-bottom:2rem}.text-center{text-align:center}.text-base{font-size:1rem;line-height:1.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-semibold{font-weight:600}.text-neutral-300{--tw-text-opacity: 1;color:rgb(212 212 212 / var(--tw-text-opacity))}.text-neutral-900{--tw-text-opacity: 1;color:rgb(23 23 23 / var(--tw-text-opacity))}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity))}.text-neutral-400{--tw-text-opacity: 1;color:rgb(163 163 163 / var(--tw-text-opacity))}.shadow-list-item{--tw-shadow: 0px 2px 12px rgba(0, 0, 0, .12);--tw-shadow-colored: 0px 2px 12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-modal{--tw-shadow: 0px 4px 20px rgba(0, 0, 0, .5);--tw-shadow-colored: 0px 4px 20px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline{outline-style:solid}.blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop-blur-sm{--tw-backdrop-blur: blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-colors{transition-property:color,background-color,border-color,fill,stroke,-webkit-text-decoration-color;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,-webkit-text-decoration-color;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji"}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.modal-font{font-family:Barlow,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;text-size-adjust:100%;font-feature-settings:"kern"}.l2{color:#8c8c8c;font-size:12px;font-weight:500;line-height:14px;letter-spacing:0em;text-align:left}.p{margin:0}.hover\\:bg-neutral-100:hover{--tw-bg-opacity: 1;background-color:rgb(245 245 245 / var(--tw-bg-opacity))}.focus\\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\\:ring-2:focus{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.focus\\:ring-neutral-200:focus{--tw-ring-opacity: 1;--tw-ring-color: rgb(229 229 229 / var(--tw-ring-opacity))}.dark .dark\\:bg-neutral-800{--tw-bg-opacity: 1;background-color:rgb(38 38 38 / var(--tw-bg-opacity))}.dark .dark\\:bg-neutral-900{--tw-bg-opacity: 1;background-color:rgb(23 23 23 / var(--tw-bg-opacity))}.dark .dark\\:fill-neutral-300{fill:#d4d4d4}.dark .dark\\:text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.dark .dark\\:text-neutral-600{--tw-text-opacity: 1;color:rgb(82 82 82 / var(--tw-text-opacity))}.dark .dark\\:shadow-none{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.dark .dark\\:hover\\:bg-neutral-700:hover{--tw-bg-opacity: 1;background-color:rgb(64 64 64 / var(--tw-bg-opacity))}.dark .dark\\:focus\\:ring-neutral-700:focus{--tw-ring-opacity: 1;--tw-ring-color: rgb(64 64 64 / var(--tw-ring-opacity))}
`;
var O2 = null;
var mr2 = async ({
  modalMode: t = "canAsk",
  storeVersion: e = ht2(),
  modalTheme: r,
  dappName: n,
  webWalletUrl: i = ar,
  argentMobileOptions: s,
  connectors: a = [],
  ...l2
} = {}) => {
  O2 = null;
  const d3 = !a || a.length === 0 ? bt2({
    argentMobileOptions: s,
    webWalletUrl: i
  }) : a, c = localStorage.getItem("starknetLastConnectedWallet");
  if (t === "neverAsk") {
    const k2 = d3.find((x) => x.id === c);
    return await (k2 == null ? void 0 : k2.connect()), O2 = k2 ?? null, (k2 == null ? void 0 : k2.wallet) ?? null;
  }
  const f2 = await q3.getAvailableWallets(l2);
  if (t === "canAsk" && c) {
    const x = (await q3.getPreAuthorizedWallets({
      ...l2
    })).find((m) => m.id === c) ?? f2.length === 1 ? f2[0] : void 0;
    if (x) {
      const m = d3.find((g3) => g3.id === c);
      return await (m == null ? void 0 : m.connect()), m && (O2 = m), x;
    }
  }
  const b3 = Et2({
    availableConnectors: d3,
    installedWallets: f2,
    discoveryWallets: await q3.getDiscoveryWallets(l2),
    storeVersion: e
  }), M2 = document.createElement("div");
  document.body.appendChild(M2);
  const w2 = M2.attachShadow({ mode: "open" });
  return w2.innerHTML = `<style>${ur2}</style>`, new Promise((k2) => {
    const x = new dr2({
      target: w2,
      props: {
        dappName: n,
        callback: async (m) => {
          try {
            m !== null && m.id !== "argentWebWallet" && A2(m.id), O2 = d3.find(
              (g3) => m !== null && g3.id === m.id
            ) ?? null, k2(m);
          } finally {
            setTimeout(() => x.$destroy());
          }
        },
        theme: r === "system" ? null : r ?? null,
        modalWallets: b3
      }
    });
  });
};
var Mr2 = () => O2 ? O2.wallet : null;
var yr2 = async (t = {}) => (b(), O2 && await O2.disconnect(), O2 = null, q3.disconnect(t));
export {
  mr2 as connect,
  yr2 as disconnect,
  Mr2 as getSelectedConnectorWallet
};
/*! Bundled license information:

starknetkit/dist/index-d7ebad06.js:
  (* istanbul ignore if -- @preserve *)
  (* istanbul ignore next -- @preserve *)

starknetkit/dist/starknetkit.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=starknetkit.js.map
