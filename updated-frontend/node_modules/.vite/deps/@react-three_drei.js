import {
  require_client
} from "./chunk-JWMKNOOS.js";
import {
  require_prop_types
} from "./chunk-CV4XM2G4.js";
import {
  ArcballControls,
  AsciiEffect,
  DRACOLoader,
  DecalGeometry,
  DeviceOrientationControls,
  EXRLoader,
  EffectComposer,
  FBXLoader,
  FirstPersonControls,
  Flow,
  FlyControls,
  FontLoader,
  FullScreenQuad,
  GLTFLoader,
  GammaCorrectionShader,
  GroundProjectedEnv,
  HorizontalBlurShader,
  KTX2Loader,
  Line2,
  LineGeometry,
  LineMaterial,
  LineSegments2,
  LineSegmentsGeometry,
  MapControls,
  MarchingCubes,
  MeshSurfaceSampler,
  MeshoptDecoder,
  OrbitControls,
  PointerLockControls,
  RGBELoader,
  RenderPass,
  SVGLoader,
  SelectionBox,
  ShaderPass,
  SimplexNoise,
  SkeletonUtils,
  Sky,
  TextGeometry,
  TrackballControls,
  TransformControls,
  VerticalBlurShader,
  easing,
  mergeVertices,
  toCreasedNormals
} from "./chunk-XCP3ZYUY.js";
import {
  addAfterEffect,
  addEffect,
  applyProps,
  clear,
  context,
  create,
  createPortal,
  extend,
  preload,
  suspend,
  useFrame,
  useLoader,
  useThree
} from "./chunk-QTEJDNRN.js";
import {
  AdditiveBlending,
  AlwaysStencilFunc,
  AnimationMixer,
  AudioListener,
  AudioLoader,
  BackSide,
  Box3,
  BufferAttribute,
  BufferGeometry,
  ByteType,
  Camera,
  CameraHelper,
  CanvasTexture,
  CatmullRomCurve3,
  Color,
  CubeCamera,
  CubeReflectionMapping,
  CubeTextureLoader,
  CubicBezierCurve3,
  CustomBlending,
  CylinderGeometry,
  DataTexture,
  DefaultLoadingManager,
  DepthFormat,
  DepthTexture,
  DoubleSide,
  DynamicDrawUsage,
  EdgesGeometry,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  Euler,
  EventDispatcher,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Frustum,
  Group,
  HalfFloatType,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  IntType,
  KeepStencilOp,
  Line3,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshLambertMaterial,
  MeshNormalMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  NearestFilter,
  NoBlending,
  NoToneMapping,
  NotEqualStencilFunc,
  Object3D,
  OneFactor,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointsMaterial,
  QuadraticBezierCurve3,
  Quaternion,
  RGBADepthPacking,
  RGBAFormat,
  RGBAIntegerFormat,
  RGFormat,
  RGIntegerFormat,
  Ray,
  Raycaster,
  RedFormat,
  RedIntegerFormat,
  RepeatWrapping,
  ReplaceStencilOp,
  Scene,
  ShaderChunk,
  ShaderMaterial,
  Shape,
  ShortType,
  Sphere,
  Spherical,
  SrcAlphaFactor,
  Texture,
  TextureLoader,
  Triangle,
  Uniform,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedIntType,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  VideoTexture,
  WebGLCubeRenderTarget,
  WebGLRenderTarget,
  three_module_exports
} from "./chunk-VPB4DWXZ.js";
import "./chunk-FXQPI6ME.js";
import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/lodash.pick/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.pick/index.js"(exports3, module) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function baseRest(func, start2) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = array;
        return apply(func, this, otherArgs);
      };
    }
    function isFlattenable(value) {
      return isArray3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray3 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction3(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var pick3 = baseRest(function(object, props) {
      return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
    });
    module.exports = pick3;
  }
});

// node_modules/lodash.omit/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.omit/index.js"(exports3, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeMax = Math.max;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arrayLikeKeys(value, inherited) {
      var result = isArray3(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray3(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function baseRest(func, start2) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = array;
        return apply(func, this, otherArgs);
      };
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    function isFlattenable(value) {
      return isArray3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto2;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray3 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction3(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var omit2 = baseRest(function(object, props) {
      if (object == null) {
        return {};
      }
      props = arrayMap(baseFlatten(props, 1), toKey);
      return basePick(object, baseDifference(getAllKeysIn(object), props));
    });
    function stubArray() {
      return [];
    }
    module.exports = omit2;
  }
});

// node_modules/stats.js/build/stats.min.js
var require_stats_min = __commonJS({
  "node_modules/stats.js/build/stats.min.js"(exports3, module) {
    (function(f2, e2) {
      "object" === typeof exports3 && "undefined" !== typeof module ? module.exports = e2() : "function" === typeof define && define.amd ? define(e2) : f2.Stats = e2();
    })(exports3, function() {
      var f2 = function() {
        function e2(a4) {
          c6.appendChild(a4.dom);
          return a4;
        }
        function u(a4) {
          for (var d2 = 0; d2 < c6.children.length; d2++)
            c6.children[d2].style.display = d2 === a4 ? "block" : "none";
          l2 = a4;
        }
        var l2 = 0, c6 = document.createElement("div");
        c6.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
        c6.addEventListener("click", function(a4) {
          a4.preventDefault();
          u(++l2 % c6.children.length);
        }, false);
        var k = (performance || Date).now(), g = k, a3 = 0, r2 = e2(new f2.Panel("FPS", "#0ff", "#002")), h = e2(new f2.Panel("MS", "#0f0", "#020"));
        if (self.performance && self.performance.memory)
          var t2 = e2(new f2.Panel("MB", "#f08", "#201"));
        u(0);
        return { REVISION: 16, dom: c6, addPanel: e2, showPanel: u, begin: function() {
          k = (performance || Date).now();
        }, end: function() {
          a3++;
          var c7 = (performance || Date).now();
          h.update(c7 - k, 200);
          if (c7 > g + 1e3 && (r2.update(1e3 * a3 / (c7 - g), 100), g = c7, a3 = 0, t2)) {
            var d2 = performance.memory;
            t2.update(d2.usedJSHeapSize / 1048576, d2.jsHeapSizeLimit / 1048576);
          }
          return c7;
        }, update: function() {
          k = this.end();
        }, domElement: c6, setMode: u };
      };
      f2.Panel = function(e2, f3, l2) {
        var c6 = Infinity, k = 0, g = Math.round, a3 = g(window.devicePixelRatio || 1), r2 = 80 * a3, h = 48 * a3, t2 = 3 * a3, v4 = 2 * a3, d2 = 3 * a3, m = 15 * a3, n2 = 74 * a3, p = 30 * a3, q = document.createElement("canvas");
        q.width = r2;
        q.height = h;
        q.style.cssText = "width:80px;height:48px";
        var b = q.getContext("2d");
        b.font = "bold " + 9 * a3 + "px Helvetica,Arial,sans-serif";
        b.textBaseline = "top";
        b.fillStyle = l2;
        b.fillRect(0, 0, r2, h);
        b.fillStyle = f3;
        b.fillText(e2, t2, v4);
        b.fillRect(d2, m, n2, p);
        b.fillStyle = l2;
        b.globalAlpha = 0.9;
        b.fillRect(d2, m, n2, p);
        return { dom: q, update: function(h2, w) {
          c6 = Math.min(c6, h2);
          k = Math.max(k, h2);
          b.fillStyle = l2;
          b.globalAlpha = 1;
          b.fillRect(0, 0, r2, m);
          b.fillStyle = f3;
          b.fillText(g(h2) + " " + e2 + " (" + g(c6) + "-" + g(k) + ")", t2, v4);
          b.drawImage(q, d2 + a3, m, n2 - a3, p, d2, m, n2 - a3, p);
          b.fillRect(d2 + n2 - a3, m, a3, p);
          b.fillStyle = l2;
          b.globalAlpha = 0.9;
          b.fillRect(d2 + n2 - a3, m, a3, g((1 - h2 / w) * p));
        } };
      };
      return f2;
    });
  }
});

// node_modules/lodash.clamp/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.clamp/index.js"(exports3, module) {
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== void 0) {
          number = number <= upper ? number : upper;
        }
        if (lower !== void 0) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function clamp5(number, lower, upper) {
      if (upper === void 0) {
        upper = lower;
        lower = void 0;
      }
      if (upper !== void 0) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== void 0) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }
    module.exports = clamp5;
  }
});

// node_modules/@react-three/drei/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target2) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@react-three/drei/web/Html.js
var React = __toESM(require_react());
var ReactDOM = __toESM(require_client());
var v1 = new Vector3();
var v2 = new Vector3();
var v3 = new Vector3();
function defaultCalculatePosition(el, camera, size) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
}
function isObjectBehindCamera(el, camera) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
}
function isObjectVisible(el, camera, raycaster, occlude) {
  const elPos = v1.setFromMatrixPosition(el.matrixWorld);
  const screenPos = elPos.clone();
  screenPos.project(camera);
  raycaster.setFromCamera(screenPos, camera);
  const intersects = raycaster.intersectObjects(occlude, true);
  if (intersects.length) {
    const intersectionDistance = intersects[0].distance;
    const pointDistance = elPos.distanceTo(raycaster.ray.origin);
    return pointDistance < intersectionDistance;
  }
  return true;
}
function objectScale(el, camera) {
  if (camera instanceof OrthographicCamera) {
    return camera.zoom;
  } else if (camera instanceof PerspectiveCamera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
    return 1 / scaleFOV;
  } else {
    return 1;
  }
}
function objectZIndex(el, camera, zIndexRange) {
  if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const dist = objectPos.distanceTo(cameraPos);
    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    const B = zIndexRange[1] - A * camera.far;
    return Math.round(A * dist + B);
  }
  return void 0;
}
var epsilon = (value) => Math.abs(value) < 1e-10 ? 0 : value;
function getCSSMatrix(matrix2, multipliers, prepend = "") {
  let matrix3d = "matrix3d(";
  for (let i3 = 0; i3 !== 16; i3++) {
    matrix3d += epsilon(multipliers[i3] * matrix2.elements[i3]) + (i3 !== 15 ? "," : ")");
  }
  return prepend + matrix3d;
}
var getCameraCSSMatrix = ((multipliers) => {
  return (matrix2) => getCSSMatrix(matrix2, multipliers);
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);
var getObjectCSSMatrix = ((scaleMultipliers) => {
  return (matrix2, factor) => getCSSMatrix(matrix2, scaleMultipliers(factor), "translate(-50%,-50%)");
})((f2) => [1 / f2, 1 / f2, 1 / f2, 1, -1 / f2, -1 / f2, -1 / f2, -1, 1 / f2, 1 / f2, 1 / f2, 1, 1, 1, 1, 1]);
function isRefObject(ref) {
  return ref && typeof ref === "object" && "current" in ref;
}
var Html = React.forwardRef(({
  children,
  eps: eps2 = 1e-3,
  style,
  className,
  prepend,
  center,
  fullscreen,
  portal,
  distanceFactor,
  sprite = false,
  transform = false,
  occlude,
  onOcclude,
  castShadow,
  receiveShadow,
  material,
  geometry,
  zIndexRange = [16777271, 0],
  calculatePosition = defaultCalculatePosition,
  as = "div",
  wrapperClass,
  pointerEvents = "auto",
  ...props
}, ref) => {
  const {
    gl,
    camera,
    scene,
    size,
    raycaster,
    events,
    viewport
  } = useThree();
  const [el] = React.useState(() => document.createElement(as));
  const root = React.useRef();
  const group = React.useRef(null);
  const oldZoom = React.useRef(0);
  const oldPosition = React.useRef([0, 0]);
  const transformOuterRef = React.useRef(null);
  const transformInnerRef = React.useRef(null);
  const target2 = (portal == null ? void 0 : portal.current) || events.connected || gl.domElement.parentNode;
  const occlusionMeshRef = React.useRef(null);
  const isMeshSizeSet = React.useRef(false);
  const isRayCastOcclusion = React.useMemo(() => {
    return occlude && occlude !== "blending" || Array.isArray(occlude) && occlude.length && isRefObject(occlude[0]);
  }, [occlude]);
  React.useLayoutEffect(() => {
    const el2 = gl.domElement;
    if (occlude && occlude === "blending") {
      el2.style.zIndex = `${Math.floor(zIndexRange[0] / 2)}`;
      el2.style.position = "absolute";
      el2.style.pointerEvents = "none";
    } else {
      el2.style.zIndex = null;
      el2.style.position = null;
      el2.style.pointerEvents = null;
    }
  }, [occlude]);
  React.useLayoutEffect(() => {
    if (group.current) {
      const currentRoot = root.current = ReactDOM.createRoot(el);
      scene.updateMatrixWorld();
      if (transform) {
        el.style.cssText = `position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;`;
      } else {
        const vec = calculatePosition(group.current, camera, size);
        el.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${vec[0]}px,${vec[1]}px,0);transform-origin:0 0;`;
      }
      if (target2) {
        if (prepend)
          target2.prepend(el);
        else
          target2.appendChild(el);
      }
      return () => {
        if (target2)
          target2.removeChild(el);
        currentRoot.unmount();
      };
    }
  }, [target2, transform]);
  React.useLayoutEffect(() => {
    if (wrapperClass)
      el.className = wrapperClass;
  }, [wrapperClass]);
  const styles2 = React.useMemo(() => {
    if (transform) {
      return {
        position: "absolute",
        top: 0,
        left: 0,
        width: size.width,
        height: size.height,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
      };
    } else {
      return {
        position: "absolute",
        transform: center ? "translate3d(-50%,-50%,0)" : "none",
        ...fullscreen && {
          top: -size.height / 2,
          left: -size.width / 2,
          width: size.width,
          height: size.height
        },
        ...style
      };
    }
  }, [style, center, fullscreen, size, transform]);
  const transformInnerStyles = React.useMemo(() => ({
    position: "absolute",
    pointerEvents
  }), [pointerEvents]);
  React.useLayoutEffect(() => {
    isMeshSizeSet.current = false;
    if (transform) {
      var _root$current;
      (_root$current = root.current) == null ? void 0 : _root$current.render(React.createElement("div", {
        ref: transformOuterRef,
        style: styles2
      }, React.createElement("div", {
        ref: transformInnerRef,
        style: transformInnerStyles
      }, React.createElement("div", {
        ref,
        className,
        style,
        children
      }))));
    } else {
      var _root$current2;
      (_root$current2 = root.current) == null ? void 0 : _root$current2.render(React.createElement("div", {
        ref,
        style: styles2,
        className,
        children
      }));
    }
  });
  const visible = React.useRef(true);
  useFrame((gl2) => {
    if (group.current) {
      camera.updateMatrixWorld();
      group.current.updateWorldMatrix(true, false);
      const vec = transform ? oldPosition.current : calculatePosition(group.current, camera, size);
      if (transform || Math.abs(oldZoom.current - camera.zoom) > eps2 || Math.abs(oldPosition.current[0] - vec[0]) > eps2 || Math.abs(oldPosition.current[1] - vec[1]) > eps2) {
        const isBehindCamera = isObjectBehindCamera(group.current, camera);
        let raytraceTarget = false;
        if (isRayCastOcclusion) {
          if (occlude !== "blending") {
            raytraceTarget = [scene];
          } else if (Array.isArray(occlude)) {
            raytraceTarget = occlude.map((item) => item.current);
          }
        }
        const previouslyVisible = visible.current;
        if (raytraceTarget) {
          const isvisible = isObjectVisible(group.current, camera, raycaster, raytraceTarget);
          visible.current = isvisible && !isBehindCamera;
        } else {
          visible.current = !isBehindCamera;
        }
        if (previouslyVisible !== visible.current) {
          if (onOcclude)
            onOcclude(!visible.current);
          else
            el.style.display = visible.current ? "block" : "none";
        }
        const halfRange = Math.floor(zIndexRange[0] / 2);
        const zRange = occlude ? isRayCastOcclusion ? [zIndexRange[0], halfRange] : [halfRange - 1, 0] : zIndexRange;
        el.style.zIndex = `${objectZIndex(group.current, camera, zRange)}`;
        if (transform) {
          const [widthHalf, heightHalf] = [size.width / 2, size.height / 2];
          const fov = camera.projectionMatrix.elements[5] * heightHalf;
          const {
            isOrthographicCamera: isOrthographicCamera3,
            top,
            left,
            bottom,
            right
          } = camera;
          const cameraMatrix = getCameraCSSMatrix(camera.matrixWorldInverse);
          const cameraTransform = isOrthographicCamera3 ? `scale(${fov})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;
          let matrix2 = group.current.matrixWorld;
          if (sprite) {
            matrix2 = camera.matrixWorldInverse.clone().transpose().copyPosition(matrix2).scale(group.current.scale);
            matrix2.elements[3] = matrix2.elements[7] = matrix2.elements[11] = 0;
            matrix2.elements[15] = 1;
          }
          el.style.width = size.width + "px";
          el.style.height = size.height + "px";
          el.style.perspective = isOrthographicCamera3 ? "" : `${fov}px`;
          if (transformOuterRef.current && transformInnerRef.current) {
            transformOuterRef.current.style.transform = `${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`;
            transformInnerRef.current.style.transform = getObjectCSSMatrix(matrix2, 1 / ((distanceFactor || 10) / 400));
          }
        } else {
          const scale2 = distanceFactor === void 0 ? 1 : objectScale(group.current, camera) * distanceFactor;
          el.style.transform = `translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale2})`;
        }
        oldPosition.current = vec;
        oldZoom.current = camera.zoom;
      }
    }
    if (!isRayCastOcclusion && occlusionMeshRef.current && !isMeshSizeSet.current) {
      if (transform) {
        if (transformOuterRef.current) {
          const el2 = transformOuterRef.current.children[0];
          if (el2 != null && el2.clientWidth && el2 != null && el2.clientHeight) {
            const {
              isOrthographicCamera: isOrthographicCamera3
            } = camera;
            if (isOrthographicCamera3 || geometry) {
              if (props.scale) {
                if (!Array.isArray(props.scale)) {
                  occlusionMeshRef.current.scale.setScalar(1 / props.scale);
                } else if (props.scale instanceof Vector3) {
                  occlusionMeshRef.current.scale.copy(props.scale.clone().divideScalar(1));
                } else {
                  occlusionMeshRef.current.scale.set(1 / props.scale[0], 1 / props.scale[1], 1 / props.scale[2]);
                }
              }
            } else {
              const ratio = (distanceFactor || 10) / 400;
              const w = el2.clientWidth * ratio;
              const h = el2.clientHeight * ratio;
              occlusionMeshRef.current.scale.set(w, h, 1);
            }
            isMeshSizeSet.current = true;
          }
        }
      } else {
        const ele = el.children[0];
        if (ele != null && ele.clientWidth && ele != null && ele.clientHeight) {
          const ratio = 1 / viewport.factor;
          const w = ele.clientWidth * ratio;
          const h = ele.clientHeight * ratio;
          occlusionMeshRef.current.scale.set(w, h, 1);
          isMeshSizeSet.current = true;
        }
        occlusionMeshRef.current.lookAt(gl2.camera.position);
      }
    }
  });
  const shaders = React.useMemo(() => ({
    vertexShader: !transform ? (
      /* glsl */
      `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `
    ) : void 0,
    fragmentShader: (
      /* glsl */
      `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    )
  }), [transform]);
  return React.createElement("group", _extends({}, props, {
    ref: group
  }), occlude && !isRayCastOcclusion && React.createElement("mesh", {
    castShadow,
    receiveShadow,
    ref: occlusionMeshRef
  }, geometry || React.createElement("planeGeometry", null), material || React.createElement("shaderMaterial", {
    side: DoubleSide,
    vertexShader: shaders.vertexShader,
    fragmentShader: shaders.fragmentShader
  })));
});

// node_modules/@react-three/drei/web/CycleRaycast.js
var React2 = __toESM(require_react());
function CycleRaycast({
  onChanged,
  portal,
  preventDefault = true,
  scroll = true,
  keyCode = 9
}) {
  const cycle = React2.useRef(0);
  const setEvents = useThree((state) => state.setEvents);
  const get = useThree((state) => state.get);
  const gl = useThree((state) => state.gl);
  React2.useEffect(() => {
    var _portal$current;
    let hits = [];
    let lastEvent = void 0;
    const prev = get().events.filter;
    const target2 = (_portal$current = portal == null ? void 0 : portal.current) !== null && _portal$current !== void 0 ? _portal$current : gl.domElement.parentNode;
    const renderStatus = () => target2 && onChanged && onChanged(hits, Math.round(cycle.current) % hits.length);
    setEvents({
      filter: (intersections, state) => {
        let clone = [...intersections];
        if (clone.length !== hits.length || !hits.every((hit) => clone.map((e2) => e2.object.uuid).includes(hit.object.uuid))) {
          cycle.current = 0;
          hits = clone;
          renderStatus();
        }
        if (prev)
          clone = prev(clone, state);
        for (let i3 = 0; i3 < Math.round(cycle.current) % clone.length; i3++) {
          const first2 = clone.shift();
          clone = [...clone, first2];
        }
        return clone;
      }
    });
    const refresh = (fn) => {
      var _get$events$handlers, _get$events$handlers2;
      cycle.current = fn(cycle.current);
      (_get$events$handlers = get().events.handlers) == null ? void 0 : _get$events$handlers.onPointerCancel(void 0);
      (_get$events$handlers2 = get().events.handlers) == null ? void 0 : _get$events$handlers2.onPointerMove(lastEvent);
      renderStatus();
    };
    const tabEvent = (event) => {
      if (event.keyCode || event.which === keyCode) {
        if (preventDefault)
          event.preventDefault();
        if (hits.length > 1)
          refresh((current) => current + 1);
      }
    };
    const wheelEvent = (event) => {
      if (preventDefault)
        event.preventDefault();
      let delta = 0;
      if (!event)
        event = window.event;
      if (event.wheelDelta)
        delta = event.wheelDelta / 120;
      else if (event.detail)
        delta = -event.detail / 3;
      if (hits.length > 1)
        refresh((current) => Math.abs(current - delta));
    };
    const moveEvent = (event) => lastEvent = event;
    document.addEventListener("pointermove", moveEvent, {
      passive: true
    });
    if (scroll)
      document.addEventListener("wheel", wheelEvent);
    if (keyCode !== void 0)
      document.addEventListener("keydown", tabEvent);
    return () => {
      setEvents({
        filter: prev
      });
      if (keyCode !== void 0)
        document.removeEventListener("keydown", tabEvent);
      if (scroll)
        document.removeEventListener("wheel", wheelEvent);
      document.removeEventListener("pointermove", moveEvent);
    };
  }, [gl, get, setEvents, preventDefault, scroll, keyCode]);
  return null;
}

// node_modules/@react-three/drei/web/useCursor.js
var React3 = __toESM(require_react());
function useCursor(hovered, onPointerOver = "pointer", onPointerOut = "auto") {
  React3.useEffect(() => {
    if (hovered) {
      document.body.style.cursor = onPointerOver;
      return () => void (document.body.style.cursor = onPointerOut);
    }
  }, [hovered]);
}

// node_modules/@react-three/drei/web/Loader.js
var React4 = __toESM(require_react());

// node_modules/@react-three/drei/core/useProgress.js
var saveLastTotalLoaded = 0;
var useProgress = create((set) => {
  DefaultLoadingManager.onStart = (item, loaded, total) => {
    set({
      active: true,
      item,
      loaded,
      total,
      progress: (loaded - saveLastTotalLoaded) / (total - saveLastTotalLoaded) * 100
    });
  };
  DefaultLoadingManager.onLoad = () => {
    set({
      active: false
    });
  };
  DefaultLoadingManager.onError = (item) => set((state) => ({
    errors: [...state.errors, item]
  }));
  DefaultLoadingManager.onProgress = (item, loaded, total) => {
    if (loaded === total) {
      saveLastTotalLoaded = total;
    }
    set({
      active: true,
      item,
      loaded,
      total,
      progress: (loaded - saveLastTotalLoaded) / (total - saveLastTotalLoaded) * 100 || 100
    });
  };
  return {
    errors: [],
    active: false,
    progress: 0,
    item: "",
    loaded: 0,
    total: 0
  };
});

// node_modules/@react-three/drei/web/Loader.js
var defaultDataInterpolation = (p) => `Loading ${p.toFixed(2)}%`;
function Loader({
  containerStyles,
  innerStyles,
  barStyles,
  dataStyles,
  dataInterpolation = defaultDataInterpolation,
  initialState = (active) => active
}) {
  const {
    active,
    progress
  } = useProgress();
  const progressRef = React4.useRef(0);
  const rafRef = React4.useRef(0);
  const progressSpanRef = React4.useRef(null);
  const [shown, setShown] = React4.useState(initialState(active));
  React4.useEffect(() => {
    let t2;
    if (active !== shown)
      t2 = setTimeout(() => setShown(active), 300);
    return () => clearTimeout(t2);
  }, [shown, active]);
  const updateProgress = React4.useCallback(() => {
    if (!progressSpanRef.current)
      return;
    progressRef.current += (progress - progressRef.current) / 2;
    if (progressRef.current > 0.95 * progress || progress === 100)
      progressRef.current = progress;
    progressSpanRef.current.innerText = dataInterpolation(progressRef.current);
    if (progressRef.current < progress)
      rafRef.current = requestAnimationFrame(updateProgress);
  }, [dataInterpolation, progress]);
  React4.useEffect(() => {
    updateProgress();
    return () => cancelAnimationFrame(rafRef.current);
  }, [updateProgress]);
  return shown ? React4.createElement("div", {
    style: {
      ...styles.container,
      opacity: active ? 1 : 0,
      ...containerStyles
    }
  }, React4.createElement("div", null, React4.createElement("div", {
    style: {
      ...styles.inner,
      ...innerStyles
    }
  }, React4.createElement("div", {
    style: {
      ...styles.bar,
      transform: `scaleX(${progress / 100})`,
      ...barStyles
    }
  }), React4.createElement("span", {
    ref: progressSpanRef,
    style: {
      ...styles.data,
      ...dataStyles
    }
  })))) : null;
}
var styles = {
  container: {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    background: "#171717",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: "opacity 300ms ease",
    zIndex: 1e3
  },
  inner: {
    width: 100,
    height: 3,
    background: "#272727",
    textAlign: "center"
  },
  bar: {
    height: 3,
    width: "100%",
    background: "white",
    transition: "transform 200ms",
    transformOrigin: "left center"
  },
  data: {
    display: "inline-block",
    position: "relative",
    fontVariantNumeric: "tabular-nums",
    marginTop: "0.8em",
    color: "#f0f0f0",
    fontSize: "0.6em",
    fontFamily: `-apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", "Helvetica Neue", Helvetica, Arial, Roboto, Ubuntu, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    whiteSpace: "nowrap"
  }
};

// node_modules/@react-three/drei/web/ScrollControls.js
var React5 = __toESM(require_react());
var ReactDOM2 = __toESM(require_client());

// node_modules/react-merge-refs/dist/react-merge-refs.esm.js
function mergeRefs(refs) {
  return function(value) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var react_merge_refs_esm_default = mergeRefs;

// node_modules/@react-three/drei/web/ScrollControls.js
var context2 = React5.createContext(null);
function useScroll() {
  return React5.useContext(context2);
}
function ScrollControls({
  eps: eps2 = 1e-5,
  enabled = true,
  infinite,
  horizontal,
  pages = 1,
  distance = 1,
  damping = 0.25,
  maxSpeed = Infinity,
  style = {},
  children
}) {
  const {
    get,
    setEvents,
    gl,
    size,
    invalidate,
    events
  } = useThree();
  const [el] = React5.useState(() => document.createElement("div"));
  const [fill] = React5.useState(() => document.createElement("div"));
  const [fixed] = React5.useState(() => document.createElement("div"));
  const target2 = gl.domElement.parentNode;
  const scroll = React5.useRef(0);
  const state = React5.useMemo(() => {
    const state2 = {
      el,
      eps: eps2,
      fill,
      fixed,
      horizontal,
      damping,
      offset: 0,
      delta: 0,
      scroll,
      pages,
      // 0-1 for a range between from -> from + distance
      range(from, distance2, margin = 0) {
        const start2 = from - margin;
        const end = start2 + distance2 + margin * 2;
        return this.offset < start2 ? 0 : this.offset > end ? 1 : (this.offset - start2) / (end - start2);
      },
      // 0-1-0 for a range between from -> from + distance
      curve(from, distance2, margin = 0) {
        return Math.sin(this.range(from, distance2, margin) * Math.PI);
      },
      // true/false for a range between from -> from + distance
      visible(from, distance2, margin = 0) {
        const start2 = from - margin;
        const end = start2 + distance2 + margin * 2;
        return this.offset >= start2 && this.offset <= end;
      }
    };
    return state2;
  }, [eps2, damping, horizontal, pages]);
  React5.useEffect(() => {
    el.style.position = "absolute";
    el.style.width = "100%";
    el.style.height = "100%";
    el.style[horizontal ? "overflowX" : "overflowY"] = "auto";
    el.style[horizontal ? "overflowY" : "overflowX"] = "hidden";
    el.style.top = "0px";
    el.style.left = "0px";
    for (const key in style) {
      el.style[key] = style[key];
    }
    fixed.style.position = "sticky";
    fixed.style.top = "0px";
    fixed.style.left = "0px";
    fixed.style.width = "100%";
    fixed.style.height = "100%";
    fixed.style.overflow = "hidden";
    el.appendChild(fixed);
    fill.style.height = horizontal ? "100%" : `${pages * distance * 100}%`;
    fill.style.width = horizontal ? `${pages * distance * 100}%` : "100%";
    fill.style.pointerEvents = "none";
    el.appendChild(fill);
    target2.appendChild(el);
    el[horizontal ? "scrollLeft" : "scrollTop"] = 1;
    const oldTarget = events.connected || gl.domElement;
    requestAnimationFrame(() => events.connect == null ? void 0 : events.connect(el));
    const oldCompute = get().events.compute;
    setEvents({
      compute(event, state2) {
        const {
          left,
          top
        } = target2.getBoundingClientRect();
        const offsetX = event.clientX - left;
        const offsetY = event.clientY - top;
        state2.pointer.set(offsetX / state2.size.width * 2 - 1, -(offsetY / state2.size.height) * 2 + 1);
        state2.raycaster.setFromCamera(state2.pointer, state2.camera);
      }
    });
    return () => {
      target2.removeChild(el);
      setEvents({
        compute: oldCompute
      });
      events.connect == null ? void 0 : events.connect(oldTarget);
    };
  }, [pages, distance, horizontal, el, fill, fixed, target2]);
  React5.useEffect(() => {
    if (events.connected === el) {
      const containerLength = size[horizontal ? "width" : "height"];
      const scrollLength = el[horizontal ? "scrollWidth" : "scrollHeight"];
      const scrollThreshold = scrollLength - containerLength;
      let current = 0;
      let disableScroll = true;
      let firstRun = true;
      const onScroll2 = () => {
        if (!enabled || firstRun)
          return;
        invalidate();
        current = el[horizontal ? "scrollLeft" : "scrollTop"];
        scroll.current = current / scrollThreshold;
        if (infinite) {
          if (!disableScroll) {
            if (current >= scrollThreshold) {
              const damp = 1 - state.offset;
              el[horizontal ? "scrollLeft" : "scrollTop"] = 1;
              scroll.current = state.offset = -damp;
              disableScroll = true;
            } else if (current <= 0) {
              const damp = 1 + state.offset;
              el[horizontal ? "scrollLeft" : "scrollTop"] = scrollLength;
              scroll.current = state.offset = damp;
              disableScroll = true;
            }
          }
          if (disableScroll)
            setTimeout(() => disableScroll = false, 40);
        }
      };
      el.addEventListener("scroll", onScroll2, {
        passive: true
      });
      requestAnimationFrame(() => firstRun = false);
      const onWheel = (e2) => el.scrollLeft += e2.deltaY / 2;
      if (horizontal)
        el.addEventListener("wheel", onWheel, {
          passive: true
        });
      return () => {
        el.removeEventListener("scroll", onScroll2);
        if (horizontal)
          el.removeEventListener("wheel", onWheel);
      };
    }
  }, [el, events, size, infinite, state, invalidate, horizontal, enabled]);
  let last = 0;
  useFrame((_, delta) => {
    last = state.offset;
    easing.damp(state, "offset", scroll.current, damping, delta, maxSpeed, void 0, eps2);
    easing.damp(state, "delta", Math.abs(last - state.offset), damping, delta, maxSpeed, void 0, eps2);
    if (state.delta > eps2)
      invalidate();
  });
  return React5.createElement(context2.Provider, {
    value: state
  }, children);
}
var ScrollCanvas = React5.forwardRef(({
  children
}, ref) => {
  const group = React5.useRef(null);
  const state = useScroll();
  const {
    width,
    height
  } = useThree((state2) => state2.viewport);
  useFrame(() => {
    group.current.position.x = state.horizontal ? -width * (state.pages - 1) * state.offset : 0;
    group.current.position.y = state.horizontal ? 0 : height * (state.pages - 1) * state.offset;
  });
  return React5.createElement("group", {
    ref: react_merge_refs_esm_default([ref, group])
  }, children);
});
var ScrollHtml = React5.forwardRef(({
  children,
  style,
  ...props
}, ref) => {
  const state = useScroll();
  const group = React5.useRef(null);
  const {
    width,
    height
  } = useThree((state2) => state2.size);
  const fiberState = React5.useContext(context);
  const root = React5.useMemo(() => ReactDOM2.createRoot(state.fixed), [state.fixed]);
  useFrame(() => {
    if (state.delta > state.eps) {
      group.current.style.transform = `translate3d(${state.horizontal ? -width * (state.pages - 1) * state.offset : 0}px,${state.horizontal ? 0 : height * (state.pages - 1) * -state.offset}px,0)`;
    }
  });
  root.render(React5.createElement("div", _extends({
    ref: react_merge_refs_esm_default([ref, group]),
    style: {
      ...style,
      position: "absolute",
      top: 0,
      left: 0,
      willChange: "transform"
    }
  }, props), React5.createElement(context2.Provider, {
    value: state
  }, React5.createElement(context.Provider, {
    value: fiberState
  }, children))));
  return null;
});
var Scroll = React5.forwardRef(({
  html,
  ...props
}, ref) => {
  const El = html ? ScrollHtml : ScrollCanvas;
  return React5.createElement(El, _extends({
    ref
  }, props));
});

// node_modules/@react-three/drei/web/PresentationControls.js
var React9 = __toESM(require_react());

// node_modules/@react-spring/rafz/dist/react-spring-rafz.esm.js
var updateQueue = makeQueue();
var raf = (fn) => schedule(fn, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn) => schedule(fn, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn) => schedule(fn, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn) => schedule(fn, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn) => schedule(fn, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  let time = raf.now() + ms;
  let cancel = () => {
    let i3 = timeouts.findIndex((t2) => t2.cancel == cancel);
    if (~i3)
      timeouts.splice(i3, 1);
    pendingCount -= ~i3 ? 1 : 0;
  };
  let timeout = {
    time,
    handler,
    cancel
  };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t2) => t2.time > time) || ~timeouts.length);
raf.cancel = (fn) => {
  onStartQueue.delete(fn);
  onFrameQueue.delete(fn);
  onFinishQueue.delete(fn);
  updateQueue.delete(fn);
  writeQueue.delete(fn);
};
raf.sync = (fn) => {
  sync = true;
  raf.batchedUpdates(fn);
  sync = false;
};
raf.throttle = (fn) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
};
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn) => fn();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn, queue2) {
  if (sync) {
    queue2.delete(fn);
    fn(0);
  } else {
    queue2.add(fn);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  let prevTs = ts;
  ts = raf.now();
  let count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t2) => t2.handler());
    pendingCount -= count;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn) {
      pendingCount += current == next && !next.has(fn) ? 1 : 0;
      next.add(fn);
    },
    delete(fn) {
      pendingCount -= current == next && next.has(fn) ? 1 : 0;
      return next.delete(fn);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn) => fn(arg) && next.add(fn));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e2) {
      raf.catch(e2);
    }
  });
}

// node_modules/@react-spring/shared/dist/react-spring-shared.esm.js
var import_react = __toESM(require_react());
function noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {
  value,
  writable: true,
  configurable: true
});
var is = {
  arr: Array.isArray,
  obj: (a3) => !!a3 && a3.constructor.name === "Object",
  fun: (a3) => typeof a3 === "function",
  str: (a3) => typeof a3 === "string",
  num: (a3) => typeof a3 === "number",
  und: (a3) => a3 === void 0
};
function isEqual(a3, b) {
  if (is.arr(a3)) {
    if (!is.arr(b) || a3.length !== b.length)
      return false;
    for (let i3 = 0; i3 < a3.length; i3++) {
      if (a3[i3] !== b[i3])
        return false;
    }
    return true;
  }
  return a3 === b;
}
var each = (obj, fn) => obj.forEach(fn);
function eachProp(obj, fn, ctx2) {
  if (is.arr(obj)) {
    for (let i3 = 0; i3 < obj.length; i3++) {
      fn.call(ctx2, obj[i3], `${i3}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx2, obj[key], key);
    }
  }
}
var toArray = (a3) => is.und(a3) ? [] : is.arr(a3) ? a3 : [a3];
function flush(queue2, iterator) {
  if (queue2.size) {
    const items = Array.from(queue2);
    queue2.clear();
    each(items, iterator);
  }
}
var flushCalls = (queue2, ...args) => flush(queue2, (fn) => fn(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var createStringInterpolator$1;
var to;
var colors$1 = null;
var skipAnimation = false;
var willAdvance = noop;
var assign = (globals2) => {
  if (globals2.to)
    to = globals2.to;
  if (globals2.now)
    raf.now = globals2.now;
  if (globals2.colors !== void 0)
    colors$1 = globals2.colors;
  if (globals2.skipAnimation != null)
    skipAnimation = globals2.skipAnimation;
  if (globals2.createStringInterpolator)
    createStringInterpolator$1 = globals2.createStringInterpolator;
  if (globals2.requestAnimationFrame)
    raf.use(globals2.requestAnimationFrame);
  if (globals2.batchedUpdates)
    raf.batchedUpdates = globals2.batchedUpdates;
  if (globals2.willAdvance)
    willAdvance = globals2.willAdvance;
  if (globals2.frameLoop)
    raf.frameLoop = globals2.frameLoop;
};
var globals = Object.freeze({
  __proto__: null,
  get createStringInterpolator() {
    return createStringInterpolator$1;
  },
  get to() {
    return to;
  },
  get colors() {
    return colors$1;
  },
  get skipAnimation() {
    return skipAnimation;
  },
  get willAdvance() {
    return willAdvance;
  },
  assign
});
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  advance,
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
}
function advance(dt) {
  const nextFrame = prevFrame;
  for (let i3 = 0; i3 < currentFrame.length; i3++) {
    const animation = currentFrame[i3];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}
var clamp = (min, max, v4) => Math.min(Math.max(v4, min), max);
var colors = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors$1 && colors$1[color] !== void 0) {
    return colors$1[color];
  }
  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
  }
  if (match = hex8.exec(color))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
  }
  return null;
}
function hue2rgb(p, q, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p + (q - p) * 6 * t2;
  if (t2 < 1 / 2)
    return q;
  if (t2 < 2 / 3)
    return p + (q - p) * (2 / 3 - t2) * 6;
  return p;
}
function hslToRgb(h, s2, l2) {
  const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
  const p = 2 * l2 - q;
  const r2 = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r2 * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  let r2 = (int32Color & 4278190080) >>> 24;
  let g = (int32Color & 16711680) >>> 16;
  let b = (int32Color & 65280) >>> 8;
  let a3 = (int32Color & 255) / 255;
  return `rgba(${r2}, ${g}, ${b}, ${a3})`;
}
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator$1(range);
  }
  const config2 = range;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing2 = config2.easing || ((t2) => t2);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(input, inputRange[range2], inputRange[range2 + 1], outputRange[range2], outputRange[range2 + 1], easing2, extrapolateLeft, extrapolateRight, config2.map);
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing2, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing2(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i3 = 1; i3 < inputRange.length - 1; ++i3)
    if (inputRange[i3] >= input)
      break;
  return i3 - 1;
}
var steps = (steps2, direction = "end") => (progress) => {
  progress = direction === "end" ? Math.min(progress, 0.999) : Math.max(progress, 1e-3);
  const expanded = progress * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return clamp(0, 1, rounded / steps2);
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x < 1 / d1) {
    return n1 * x * x;
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75;
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375;
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375;
  }
};
var easings = {
  linear: (x) => x,
  easeInQuad: (x) => x * x,
  easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
  easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
  easeInCubic: (x) => x * x * x,
  easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
  easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
  easeInQuart: (x) => x * x * x * x,
  easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
  easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
  easeInQuint: (x) => x * x * x * x * x,
  easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
  easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
  easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
  easeOutSine: (x) => Math.sin(x * Math.PI / 2),
  easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
  easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
  easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
  easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
  easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
  easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
  easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
  easeInBack: (x) => c3 * x * x * x - c1 * x * x,
  easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
  easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
  easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
  easeInBounce: (x) => 1 - bounceOut(1 - x),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
  steps
};
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target2) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends2.apply(this, arguments);
}
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target2) => target2[$observers] || null;
function callFluidObserver(observer, event) {
  if (observer.eventObserved) {
    observer.eventObserved(event);
  } else {
    observer(event);
  }
}
function callFluidObservers(target2, event) {
  let observers = target2[$observers];
  if (observers) {
    observers.forEach((observer) => {
      callFluidObserver(observer, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    this[$get] = void 0;
    this[$observers] = void 0;
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
var setFluidGetter = (target2, get) => setHidden(target2, $get, get);
function addFluidObserver(target2, observer) {
  if (target2[$get]) {
    let observers = target2[$observers];
    if (!observers) {
      setHidden(target2, $observers, observers = /* @__PURE__ */ new Set());
    }
    if (!observers.has(observer)) {
      observers.add(observer);
      if (target2.observerAdded) {
        target2.observerAdded(observers.size, observer);
      }
    }
  }
  return observer;
}
function removeFluidObserver(target2, observer) {
  let observers = target2[$observers];
  if (observers && observers.has(observer)) {
    const count = observers.size - 1;
    if (count) {
      observers.delete(observer);
    } else {
      target2[$observers] = null;
    }
    if (target2.observerRemoved) {
      target2.observerRemoved(count, observer);
    }
  }
}
var setHidden = (target2, key, value) => Object.defineProperty(target2, key, {
  value,
  writable: true,
  configurable: true
});
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (_value) {
      return _value;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};
var namedColorRegex;
var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator = (config2) => {
  if (!namedColorRegex)
    namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
  const output = config2.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map((_, i3) => keyframes.map((values) => {
    if (!(i3 in values)) {
      throw Error('The arity of each "output" value must be equal');
    }
    return values[i3];
  }));
  const interpolators = outputRanges.map((output2) => createInterpolator(_extends2({}, config2, {
    output: output2
  })));
  return (input) => {
    var _output$find;
    const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find((value) => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ""));
    let i3 = 0;
    return output[0].replace(numberRegex, () => `${interpolators[i3++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
  };
};
var prefix = "react-spring: ";
var once = (fn) => {
  const func = fn;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`);
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
}
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));
}
var useIsomorphicLayoutEffect = isSSR() ? import_react.useEffect : import_react.useLayoutEffect;
var useIsMounted = () => {
  const isMounted = (0, import_react.useRef)(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};
function useForceUpdate() {
  const update3 = (0, import_react.useState)()[1];
  const isMounted = useIsMounted();
  return () => {
    if (isMounted.current) {
      update3(Math.random());
    }
  };
}
function useMemoOne(getResult, inputs) {
  const [initial] = (0, import_react.useState)(() => ({
    inputs,
    result: getResult()
  }));
  const committed = (0, import_react.useRef)();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  (0, import_react.useEffect)(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i3 = 0; i3 < next.length; i3++) {
    if (next[i3] !== prev[i3]) {
      return false;
    }
  }
  return true;
}
var useOnce = (effect) => (0, import_react.useEffect)(effect, emptyDeps);
var emptyDeps = [];
function usePrev(value) {
  const prevRef = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}

// node_modules/@react-spring/core/dist/react-spring-core.esm.js
var React7 = __toESM(require_react());
var import_react3 = __toESM(require_react());

// node_modules/@react-spring/animated/dist/react-spring-animated.esm.js
var React6 = __toESM(require_react());
var import_react2 = __toESM(require_react());
var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    this.payload = void 0;
    setAnimated(this, this);
  }
  getPayload() {
    return this.payload || [];
  }
};
var AnimatedValue = class _AnimatedValue extends Animated {
  constructor(_value) {
    super();
    this.done = true;
    this.elapsedTime = void 0;
    this.lastPosition = void 0;
    this.lastVelocity = void 0;
    this.v0 = void 0;
    this.durationProgress = 0;
    this._value = _value;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  static create(value) {
    return new _AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const {
      done
    } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};
var AnimatedString = class _AnimatedString extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = void 0;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  static create(value) {
    return new _AnimatedString(value);
  }
  getValue() {
    let value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};
var TreeContext = {
  dependencies: null
};
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated2) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated2);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated2) {
        values[key] = source;
      }
    });
    return values;
  }
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      each(this.payload, (node) => node.reset());
    }
  }
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      each(payload, (node) => this.add(node));
    }
  }
};
var AnimatedArray = class _AnimatedArray extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  static create(source) {
    return new _AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i3) => node.setValue(source[i3])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}
function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target2) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends3.apply(this, arguments);
}
var withAnimated = (Component, host2) => {
  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
  return (0, import_react2.forwardRef)((givenProps, givenRef) => {
    const instanceRef = (0, import_react2.useRef)(null);
    const ref = hasInstance && (0, import_react2.useCallback)((value) => {
      instanceRef.current = updateRef(givenRef, value);
    }, [givenRef]);
    const [props, deps] = getAnimatedState(givenProps, host2);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0, import_react2.useRef)();
    useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          each(observerRef.current.deps, (dep) => removeFluidObserver(dep, observerRef.current));
          raf.cancel(observerRef.current.update);
        }
      };
    });
    (0, import_react2.useEffect)(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host2.getComponentProps(props.getValue());
    return React6.createElement(Component, _extends3({}, usedProps, {
      ref
    }));
  });
};
var PropsObserver = class {
  constructor(update3, deps) {
    this.update = update3;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host2) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = _extends3({}, props, {
      style: host2.createAnimatedStyle(props.style)
    });
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref))
      ref(value);
    else
      ref.current = value;
  }
  return value;
}
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues: _applyAnimatedValues = () => false,
  createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps: _getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues: _applyAnimatedValues,
    createAnimatedStyle: _createAnimatedStyle,
    getComponentProps: _getComponentProps
  };
  const animated2 = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated2[key] = animated2(Component);
  });
  return {
    animated: animated2
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

// node_modules/@react-spring/core/dist/react-spring-core.esm.js
function _extends4() {
  _extends4 = Object.assign ? Object.assign.bind() : function(target2) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends4.apply(this, arguments);
}
function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults3 = {};
  for (const key of keys) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults3[key] = value;
    }
  }
  return defaults3;
};
var DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to2 = getForwardProps(props);
  if (to2) {
    const out = {
      to: to2
    };
    eachProp(props, (val, key) => key in to2 || (out[key] = val));
    return out;
  }
  return _extends4({}, props);
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _ in props)
    return true;
  return false;
}
function isAsyncTo(to2) {
  return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
}
function detachRefs(ctrl, ref) {
  var _ctrl$ref;
  (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);
  ref == null ? void 0 : ref.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  if (ref && ctrl.ref !== ref) {
    var _ctrl$ref2;
    (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}
var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};
var defaults = _extends4({}, config.default, {
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
});
var AnimationConfig = class {
  constructor() {
    this.tension = void 0;
    this.friction = void 0;
    this.frequency = void 0;
    this.damping = void 0;
    this.mass = void 0;
    this.velocity = 0;
    this.restVelocity = void 0;
    this.precision = void 0;
    this.progress = void 0;
    this.duration = void 0;
    this.easing = void 0;
    this.clamp = void 0;
    this.bounce = void 0;
    this.decay = void 0;
    this.round = void 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = _extends4({}, defaultConfig);
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = _extends4({}, defaultConfig, newConfig);
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let {
    mass,
    frequency,
    damping
  } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.to = void 0;
    this.from = void 0;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};
function scheduleProps(callId, {
  key,
  props,
  defaultProps,
  state,
  actions
}) {
  return new Promise((resolve2, reject) => {
    var _props$cancel;
    let delay;
    let timeout;
    let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps == null ? void 0 : defaultProps.cancel, key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps == null ? void 0 : defaultProps.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start(_extends4({}, props, {
          callId,
          cancel
        }), resolve2);
      } catch (err) {
        reject(err);
      }
    }
  });
}
var getCombinedResult = (target2, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target2.get()) : results.every((result) => result.noop) ? getNoopResult(target2.get()) : getFinishedResult(target2.get(), results.every((result) => result.finished));
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});
function runAsync(to2, props, state, target2) {
  const {
    callId,
    parentId,
    onRest
  } = props;
  const {
    asyncTo: prevTo,
    promise: prevPromise
  } = state;
  if (!parentId && to2 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to2;
    const defaultProps = getDefaultProps(props, (value, key) => key === "onRest" ? void 0 : value);
    let preventBail;
    let bail;
    const bailPromise = new Promise((resolve2, reject) => (preventBail = resolve2, bail = reject));
    const bailIfEnded = (bailSignal) => {
      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target2) || callId !== state.asyncId && getFinishedResult(target2, false);
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAnimationSignal();
      return (async () => {
        if (globals.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target2, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? _extends4({}, arg1) : _extends4({}, arg2, {
          to: arg1
        });
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target2.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target2, false);
    }
    try {
      let animating;
      if (is.arr(to2)) {
        animating = (async (queue2) => {
          for (const props2 of queue2) {
            await animate(props2);
          }
        })(to2);
      } else {
        animating = Promise.resolve(to2(animate, target2.stop.bind(target2)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target2.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAnimationSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target2, target2.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t2) => t2.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
    this.result = void 0;
  }
};
var SkipAnimationSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
    this.result = void 0;
  }
};
var isFrameValue = (value) => value instanceof FrameValue;
var nextId$1 = 1;
var FrameValue = class extends FluidValue {
  constructor(...args) {
    super(...args);
    this.id = nextId$1++;
    this.key = void 0;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority2) {
    if (this._priority != priority2) {
      this._priority = priority2;
      this._onPriorityChange(priority2);
    }
  }
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  to(...args) {
    return globals.to(this, args);
  }
  interpolate(...args) {
    deprecateInterpolate();
    return globals.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1)
      this._attach();
  }
  observerRemoved(count) {
    if (count == 0)
      this._detach();
  }
  _attach() {
  }
  _detach() {
  }
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  _onPriorityChange(priority2) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority: priority2
    });
  }
};
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target2) => (target2[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target2) => (target2[$P] & IS_ANIMATING) > 0;
var isPaused = (target2) => (target2[$P] & IS_PAUSED) > 0;
var setActiveBit = (target2, active) => active ? target2[$P] |= IS_ANIMATING | HAS_ANIMATED : target2[$P] &= ~IS_ANIMATING;
var setPausedBit = (target2, paused) => paused ? target2[$P] |= IS_PAUSED : target2[$P] &= ~IS_PAUSED;
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    this.key = void 0;
    this.animation = new Animation();
    this.queue = void 0;
    this.defaultProps = {};
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._pendingCalls = /* @__PURE__ */ new Set();
    this._lastCallId = 0;
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? _extends4({}, arg1) : _extends4({}, arg2, {
        from: arg1
      });
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  get hasAnimated() {
    return hasAnimated(this);
  }
  get isAnimating() {
    return isAnimating(this);
  }
  get isPaused() {
    return isPaused(this);
  }
  get isDelayed() {
    return this._state.delayed;
  }
  advance(dt) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let {
      config: config2,
      toValues
    } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i3) => {
      if (node2.done)
        return;
      const to2 = node2.constructor == AnimatedString ? 1 : payload ? payload[i3].lastPosition : toValues[i3];
      let finished = anim.immediate;
      let position2 = to2;
      if (!finished) {
        position2 = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt;
        const from = anim.fromValues[i3];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i3] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
        if (!is.und(config2.duration)) {
          let p = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt;
              }
            }
            p = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p = p > 1 ? 1 : p < 0 ? 0 : p;
            node2.durationProgress = p;
          }
          position2 = from + config2.easing(p) * (to2 - from);
          velocity = (position2 - node2.lastPosition) / dt;
          finished = p == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e2 = Math.exp(-(1 - decay) * elapsed);
          position2 = from + v0 / (1 - decay) * (1 - e2);
          finished = Math.abs(node2.lastPosition - position2) <= precision;
          velocity = v0 * e2;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt / step);
          for (let n2 = 0; n2 < numSteps; ++n2) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to2 - position2) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position2 == to2 || position2 > to2 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position2 = to2;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position2 - to2);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position2 = position2 + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position2)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i3].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position2, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  pause() {
    this._update({
      pause: true
    });
  }
  resume() {
    this._update({
      pause: false
    });
  }
  finish() {
    if (isAnimating(this)) {
      const {
        to: to2,
        config: config2
      } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to2, false);
        }
        this._stop();
      });
    }
    return this;
  }
  update(props) {
    const queue2 = this.queue || (this.queue = []);
    queue2.push(props);
    return this;
  }
  start(to2, arg2) {
    let queue2;
    if (!is.und(to2)) {
      queue2 = [is.obj(to2) ? to2 : _extends4({}, arg2, {
        to: to2
      })];
    } else {
      queue2 = this.queue || [];
      this.queue = [];
    }
    return Promise.all(queue2.map((props) => {
      const up = this._update(props);
      return up;
    })).then((results) => getCombinedResult(this, results));
  }
  stop(cancel) {
    const {
      to: to2
    } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to2, cancel));
    return this;
  }
  reset() {
    this._update({
      reset: true
    });
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  _prepareNode(props) {
    const key = this.key || "";
    let {
      to: to2,
      from
    } = props;
    to2 = is.obj(to2) ? to2[key] : to2;
    if (to2 == null || isAsyncTo(to2)) {
      to2 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = {
      to: to2,
      from
    };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to2, from] = [from, to2];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to2);
      }
    }
    return range;
  }
  _update(_ref, isLoop) {
    let props = _extends4({}, _ref);
    const {
      key,
      defaultProps
    } = this;
    if (props.default)
      Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  _merge(range, props, resolve2) {
    if (props.cancel) {
      this.stop(true);
      return resolve2(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve2(getCancelledResult(this));
      }
    }
    const {
      key,
      defaultProps,
      animation: anim
    } = this;
    const {
      to: prevTo,
      from: prevFrom
    } = anim;
    let {
      to: to2 = prevTo,
      from = prevFrom
    } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
      to2 = from;
    }
    if (props.reverse)
      [to2, from] = [from, to2];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to2, prevTo);
    if (hasToChanged) {
      this._focus(to2);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const {
      config: config2
    } = anim;
    const {
      decay,
      velocity
    } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(config2, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);
    }
    let node = getAnimated(this);
    if (!node || is.und(to2)) {
      return resolve2(getFinishedResult(this, true));
    }
    const reset2 = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);
    const value = reset2 ? from : this.get();
    const goal = computeGoal(to2);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to2);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to2);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset2 || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset2) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset2) {
          this._set(prevTo);
        }
      }
      if (started) {
        const {
          onRest
        } = anim;
        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve2);
        if (anim.changed)
          raf.batchedUpdates(() => {
            anim.changed = !reset2;
            onRest == null ? void 0 : onRest(result, this);
            if (reset2) {
              callProp(defaultProps.onRest, result);
            } else {
              anim.onStart == null ? void 0 : anim.onStart(result, this);
            }
          });
      }
    }
    if (reset2) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve2(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve2);
    } else {
      resolve2(getNoopResult(value));
    }
  }
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority2 = 0;
    const {
      to: to2
    } = this.animation;
    if (hasFluidValue(to2)) {
      addFluidObserver(to2, this);
      if (isFrameValue(to2)) {
        priority2 = to2.priority + 1;
      }
    }
    this.priority = priority2;
  }
  _detach() {
    const {
      to: to2
    } = this.animation;
    if (hasFluidValue(to2)) {
      removeFluidObserver(to2, this);
    }
  }
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target2, to2) {
  const goal = computeGoal(to2);
  const value = computeGoal(target2.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
  let loopRet = callProp(loop2);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset2 = !overrides || overrides.reset;
    return createUpdate(_extends4({}, props, {
      loop: loop2,
      default: false,
      pause: void 0,
      to: !reverse || isAsyncTo(to2) ? to2 : void 0,
      from: reset2 ? props.from : void 0,
      reset: reset2
    }, overrides));
  }
}
function createUpdate(props) {
  const {
    to: to2,
    from
  } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to2))
    findDefined(to2, keys);
  if (is.obj(from))
    findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update3 = createUpdate(props);
  if (is.und(update3.default)) {
    update3.default = getDefaultProps(update3);
  }
  return update3;
}
function findDefined(values, keys) {
  eachProp(values, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function mergeActiveFn(target2, props, type) {
  target2.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target2.key) : void 0;
}
function sendEvent(target2, type, ...args) {
  var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
  (_target$animation$typ = (_target$animation = target2.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
  (_target$defaultProps$ = (_target$defaultProps = target2.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
}
var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId = 1;
var Controller = class {
  constructor(props, flush2) {
    this.id = nextId++;
    this.springs = {};
    this.queue = [];
    this.ref = void 0;
    this._flush = void 0;
    this._initialProps = void 0;
    this._lastAsyncId = 0;
    this._active = /* @__PURE__ */ new Set();
    this._changed = /* @__PURE__ */ new Set();
    this._started = false;
    this._item = void 0;
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush2) {
      this._flush = flush2;
    }
    if (props) {
      this.start(_extends4({
        default: true
      }, props));
    }
  }
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  start(props) {
    let {
      queue: queue2
    } = this;
    if (props) {
      queue2 = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue2);
    }
    prepareKeys(this, queue2);
    return flushUpdateQueue(this, queue2);
  }
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  pause(keys) {
    if (is.und(keys)) {
      this.start({
        pause: true
      });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  resume(keys) {
    if (is.und(keys)) {
      this.start({
        pause: false
      });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  _onFrame() {
    const {
      onStart,
      onChange,
      onRest
    } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue2) {
  return Promise.all(queue2.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
}
async function flushUpdate(ctrl, props, isLoop) {
  const {
    keys,
    to: to2,
    from,
    loop: loop2,
    onRest,
    onResolve
  } = props;
  const defaults3 = is.obj(props.default) && props.default;
  if (loop2) {
    props.loop = false;
  }
  if (to2 === false)
    props.to = null;
  if (from === false)
    props.from = null;
  const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults3) {
      defaults3.onRest = void 0;
    }
  } else {
    each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue2 = ctrl["_events"][key];
        props[key] = ({
          finished,
          cancelled
        }) => {
          const result2 = queue2.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue2.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults3) {
          defaults3[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
      props,
      state,
      actions: {
        pause: noop,
        resume: noop,
        start(props2, resolve2) {
          if (cancel) {
            stopAsync(state, ctrl["_lastAsyncId"]);
            resolve2(getCancelledResult(ctrl));
          } else {
            props2.onRest = onRest;
            resolve2(runAsync(asyncTo, props2, state, ctrl));
          }
        }
      }
    }));
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop2 && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop2, to2);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = _extends4({}, ctrl.springs);
  if (props) {
    each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = _extends4({}, props2, {
          to: void 0
        });
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create3) {
  if (props.keys) {
    each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create3(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue2) {
  each(queue2, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
var _excluded$6 = ["children"];
var SpringContext = (_ref) => {
  let {
    children
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded$6);
  const inherited = (0, import_react3.useContext)(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({
    pause,
    immediate
  }), [pause, immediate]);
  const {
    Provider
  } = ctx;
  return React7.createElement(Provider, {
    value: props
  }, children);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target2, init) {
  Object.assign(target2, React7.createContext(init));
  target2.Provider._context = target2;
  target2.Consumer._context = target2;
  return target2;
}
var SpringRef = () => {
  const current = [];
  const SpringRef2 = function SpringRef3(props) {
    deprecateDirectCall();
    const results = [];
    each(current, (ctrl, i3) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update3 = _getProps(props, ctrl, i3);
        if (update3) {
          results.push(ctrl.start(update3));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i3 = current.indexOf(ctrl);
    if (~i3)
      current.splice(i3, 1);
  };
  SpringRef2.pause = function() {
    each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    each(current, (ctrl) => ctrl.set(values));
  };
  SpringRef2.start = function(props) {
    const results = [];
    each(current, (ctrl, i3) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update3 = this._getProps(props, ctrl, i3);
        if (update3) {
          results.push(ctrl.start(update3));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each(current, (ctrl, i3) => ctrl.update(this._getProps(props, ctrl, i3)));
    return this;
  };
  const _getProps = function _getProps2(arg, ctrl, index) {
    return is.fun(arg) ? arg(index, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref = (0, import_react3.useMemo)(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
  const layoutId = (0, import_react3.useRef)(0);
  const forceUpdate = useForceUpdate();
  const state = (0, import_react3.useMemo)(() => ({
    ctrls: [],
    queue: [],
    flush(ctrl, updates2) {
      const springs2 = getSprings(ctrl, updates2);
      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
      return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve2) => {
        setSprings(ctrl, springs2);
        state.queue.push(() => {
          resolve2(flushUpdateQueue(ctrl, updates2));
        });
        forceUpdate();
      });
    }
  }), []);
  const ctrls = (0, import_react3.useRef)([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  (0, import_react3.useMemo)(() => {
    each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  (0, import_react3.useMemo)(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i3 = startIndex; i3 < endIndex; i3++) {
      const ctrl = ctrls.current[i3] || (ctrls.current[i3] = new Controller(null, state.flush));
      const update3 = propsFn ? propsFn(i3, ctrl) : props[i3];
      if (update3) {
        updates[i3] = declareUpdate(update3);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i3) => getSprings(ctrl, updates[i3]));
  const context10 = (0, import_react3.useContext)(SpringContext);
  const prevContext = usePrev(context10);
  const hasContext = context10 !== prevContext && hasProps(context10);
  useIsomorphicLayoutEffect(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const {
      queue: queue2
    } = state;
    if (queue2.length) {
      state.queue = [];
      each(queue2, (cb) => cb());
    }
    each(ctrls.current, (ctrl, i3) => {
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext) {
        ctrl.start({
          default: context10
        });
      }
      const update3 = updates[i3];
      if (update3) {
        replaceRef(ctrl, update3.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update3);
        } else {
          ctrl.start(update3);
        }
      }
    });
  });
  useOnce(() => () => {
    each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x) => _extends4({}, x));
  return ref ? [values, ref] : values;
}
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);
  return isFn || arguments.length == 2 ? [values, ref] : values;
}
var TransitionPhase;
(function(TransitionPhase2) {
  TransitionPhase2["MOUNT"] = "mount";
  TransitionPhase2["ENTER"] = "enter";
  TransitionPhase2["UPDATE"] = "update";
  TransitionPhase2["LEAVE"] = "leave";
})(TransitionPhase || (TransitionPhase = {}));
var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.key = void 0;
    this.idle = true;
    this.calc = void 0;
    this._active = /* @__PURE__ */ new Set();
    this.source = source;
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  _attach() {
    let priority2 = 1;
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority2 = Math.max(priority2, source.priority + 1);
      }
    });
    this.priority = priority2;
    this._start();
  }
  _detach() {
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self2) {
  if (!self2.idle) {
    self2.idle = true;
    each(getPayload(self2), (node) => {
      node.done = true;
    });
    callFluidObservers(self2, {
      type: "idle",
      parent: self2
    });
  }
}
globals.assign({
  createStringInterpolator,
  to: (source, args) => new Interpolation(source, args)
});
var update2 = frameLoop.advance;

// node_modules/@react-spring/three/dist/react-spring-three.esm.js
var primitives = ["primitive"].concat(Object.keys(three_module_exports).filter((key) => /^[A-Z]/.test(key)).map((key) => key[0].toLowerCase() + key.slice(1)));
globals.assign({
  createStringInterpolator,
  colors,
  frameLoop: "demand"
});
addEffect(() => {
  raf.advance();
});
var host = createHost(primitives, {
  applyAnimatedValues: applyProps
});
var animated = host.animated;

// node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js
function clamp2(v4, min, max) {
  return Math.max(min, Math.min(v4, max));
}
var V = {
  toVector(v4, fallback) {
    if (v4 === void 0)
      v4 = fallback;
    return Array.isArray(v4) ? v4 : [v4, v4];
  },
  add(v12, v22) {
    return [v12[0] + v22[0], v12[1] + v22[1]];
  },
  sub(v12, v22) {
    return [v12[0] - v22[0], v12[1] - v22[1]];
  },
  addTo(v12, v22) {
    v12[0] += v22[0];
    v12[1] += v22[1];
  },
  subTo(v12, v22) {
    v12[0] -= v22[0];
    v12[1] -= v22[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity)
    return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position2, min, max, constant = 0.15) {
  if (constant === 0)
    return clamp2(position2, min, max);
  if (position2 < min)
    return -rubberband(min - position2, max - min, constant) + min;
  if (position2 > max)
    return +rubberband(position2 - max, max - min, constant) + max;
  return position2;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target2) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target2, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target2;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string)
    return "";
  return string[0].toUpperCase() + string.slice(1);
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive)
    eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture)
    eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event))
    return "touch";
  if ("pointerType" in event)
    return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e2) => {
    var _event$currentTarget, _event$currentTarget$;
    return e2.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e2.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin2 = [cx, cy];
    return {
      angle,
      distance,
      origin: origin2
    };
  } catch (_unused) {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event)
    payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call2(v4, ...args) {
  if (typeof v4 === "function") {
    return v4(...args);
  } else {
    return v4;
  }
}
function noop2() {
}
function chain(...fns) {
  if (fns.length === 0)
    return noop2;
  if (fns.length === 1)
    return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init)
        this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config2 = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config2.from ? call2(config2.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config: config2,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config2.preventDefault && event.cancelable)
        state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent)
      this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config2.threshold;
    const {
      _step,
      values
    } = state;
    if (config2.hasCustomTransform) {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional)
      return;
    const movement = [0, 0];
    if (config2.hasCustomTransform) {
      const [v0, v12] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v12 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked)
      this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config2)
            state._bounds = call2(config2.bounds, state);
          if (this.setup)
            this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config2.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config2 = this.config;
    if (!state._active)
      this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config2.triggerAllEvents)
      return;
    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo !== void 0)
      state.memo = memo;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config2 = this.config;
    if (!state.axis && event) {
      const threshold = typeof config2.axisThreshold === "object" ? config2.axisThreshold[getPointerType(event)] : config2.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config2.lockDirection || !!config2.axis) && !state.axis || !!config2.axis && config2.axis !== state.axis;
  }
  restrictToAxis(v4) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v4[1] = 0;
          break;
        case "y":
          v4[0] = 0;
          break;
      }
    }
  }
};
var identity = (v4) => v4;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config2) {
    return _objectSpread2(_objectSpread2({}, config2.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function")
      return value;
    if (value != null)
      return V.toVector(value);
  },
  transform(value, _k, config2) {
    const transform = value || config2.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity;
      return (v4) => {
        const r2 = originalTransform(v4);
        if (!isFinite(r2[0]) || !isFinite(r2[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r2[0]},${[1]}]`);
        }
        return r2;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var DEFAULT_AXIS_THRESHOLD = 0;
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection)
      return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});
var KEYS_DELTA_MAP = {
  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],
  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],
  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],
  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config2 = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config2.pointerButtons) ? !config2.pointerButtons.includes(event.buttons) : config2.pointerButtons !== -1 && config2.pointerButtons !== event.buttons))
      return;
    const ctrlIds = this.ctrl.setEventIds(event);
    if (config2.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive)
      return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config2.preventScrollAxis && getPointerType(event) !== "mouse") {
      state._active = false;
      this.setupScrollPrevention(event);
    } else if (config2.delay > 0) {
      this.setupDelayTrigger(event);
      if (config2.triggerAllEvents) {
        this.compute(event);
        this.emit();
      }
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config2 = this.config;
    if (!state._pointerActive)
      return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId)
      return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed && state.intentional) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config2.preventScrollAxis && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config2.preventScrollAxis || config2.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (true) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config2 = this.config;
    if (!state._active || !state._pointerActive)
      return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId)
      return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= config2.tapsThreshold && dy <= config2.tapsThreshold;
    if (state.tap && config2.filterTaps) {
      state._force = true;
    } else {
      const [_dx, _dy] = state._delta;
      const [_mx, _my] = state._movement;
      const [svx, svy] = config2.swipe.velocity;
      const [sx, sy] = config2.swipe.distance;
      const sdt = config2.swipe.duration;
      if (state.elapsedTime < sdt) {
        const _vx = Math.abs(_dx / state.timeDelta);
        const _vy = Math.abs(_dy / state.timeDelta);
        if (_vx > svx && Math.abs(_mx) > sx)
          state.swipe[0] = Math.sign(_dx);
        if (_vy > svy && Math.abs(_my) > sy)
          state.swipe[1] = Math.sign(_dy);
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap && event.detail > 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config2 = this.config;
    const device = config2.device;
    if (true) {
      try {
        if (device === "pointer" && config2.preventScrollDelay === void 0) {
          const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {
      }
    }
    if (config2.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config2.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    this.state._preventScroll = false;
    persistEvent(event);
    const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0];
      this.startPointerDrag(event);
    }, this.config.delay);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      this.start(event);
      state._delta = deltaFn(this.config.keyboardDisplacement, factor);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP))
      return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
      bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
    }
    if (this.config.keys) {
      bindFunction("key", "down", this.keyDown.bind(this));
      bindFunction("key", "up", this.keyUp.bind(this));
    }
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true,
        passive: false
      });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e2) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: isTouchScreen(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_KEYBOARD_DISPLACEMENT = 10;
var DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch)
      return "touch";
    if (this.pointerLock)
      return "mouse";
    if (SUPPORT.pointer && !mouse)
      return "pointer";
    if (SUPPORT.touch)
      return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false)
      return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value)
      return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 100;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset,
      lastOffset
    } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0)
        state.axis = "angle";
      else if (axisMovementDifference > 0)
        state.axis = "scale";
    }
  }
  restrictToAxis(v4) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale")
        v4[1] = 0;
      else if (this.state.axis === "angle")
        v4[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id)))
        return;
    }
    if (ctrlTouchIds.size < 2)
      return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload)
      return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1)
      return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))
        return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2)
      return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload)
      return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active)
      return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload)
      return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active)
      return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload)
      return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270)
      delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active)
      return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active)
      return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    if (state._active)
      return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable)
      event.preventDefault();
    if (!this.state._active)
      return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && !event[modifierKey])
      return;
    if (!this.state._active)
      this.wheelStart(event);
    else
      this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
      return "gesture";
    if (SUPPORT.touch && touch)
      return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call2(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call2(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
      return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config2) {
    this.lockDirection = config2.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0)
      return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
var MoveEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    if (!this.state._active)
      this.moveStart(event);
    else
      this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active)
      return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var ScrollEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active)
      this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};
var scrollConfigResolver = coordinatesConfigResolver;
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active)
      this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var HoverEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    const state = this.state;
    if (!state._active)
      return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react4 = __toESM(require_react());

// node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target2 = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i3;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
      key = sourceSymbolKeys[i3];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target2[key] = source[key];
    }
  }
  return target2;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config2 = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (true) {
          const r2 = resolver.call(result, config2[key], key, config2);
          if (!Number.isNaN(r2))
            result[key] = r2;
        } else {
          result[key] = resolver.call(result, config2[key], key, config2);
        }
        break;
      case "object":
        result[key] = resolveWith(config2[key], resolver);
        break;
      case "boolean":
        if (resolver)
          result[key] = config2[key];
        break;
    }
  }
  return result;
}
function parse(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target: target2,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target: target2,
    eventOptions,
    window: window2,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove);
    };
    listeners.add(remove);
    return remove;
  }
  clean() {
    this._listeners.forEach((remove) => remove());
    this._listeners.clear();
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout)
      window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller2 = class {
  constructor(handlers) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel")
        this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown")
        this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config2, gestureKey) {
    this.config = parse(config2, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target)
      this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target2;
    if (sharedConfig.target) {
      target2 = sharedConfig.target();
      if (!target2)
        return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target2);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target2);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target2)
      return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target2, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag)
    setupGesture(ctrl, "drag");
  if (internalHandlers.wheel)
    setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll)
    setupGesture(ctrl, "scroll");
  if (internalHandlers.move)
    setupGesture(ctrl, "move");
  if (internalHandlers.pinch)
    setupGesture(ctrl, "pinch");
  if (internalHandlers.hover)
    setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive)
    handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers) {
  const native = {};
  const handlers = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers[key];
    } else {
      native[key] = _handlers[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config2) {
  if (!actions.has(handlerKey))
    return;
  if (!EngineMap.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo = void 0;
    if (state.first && startKey in handlers)
      handlers[startKey](state);
    if (handlerKey in handlers)
      memo = handlers[handlerKey](state);
    if (state.last && endKey in handlers)
      handlers[endKey](state);
    return memo;
  };
  internalHandlers[key] = fn;
  config2[key] = config2[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers, config2 = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react4.default.useMemo(() => new Controller2(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config2, gestureKey);
  import_react4.default.useEffect(ctrl.effect.bind(ctrl));
  import_react4.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config2.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers, _config) {
    const {
      handlers,
      nativeHandlers,
      config: config2
    } = parseMergedHandlers(_handlers, _config || {});
    return useRecognizers(handlers, config2, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config2) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config2 || {});
}

// node_modules/@react-three/drei/web/PresentationControls.js
function PresentationControls({
  enabled = true,
  snap,
  global: global2,
  domElement,
  cursor = true,
  children,
  speed = 1,
  rotation: rotation2 = [0, 0, 0],
  zoom = 1,
  polar = [0, Math.PI / 2],
  azimuth = [-Infinity, Infinity],
  config: config2 = {
    mass: 1,
    tension: 170,
    friction: 26
  }
}) {
  const events = useThree((state) => state.events);
  const gl = useThree((state) => state.gl);
  const explDomElement = domElement || events.connected || gl.domElement;
  const {
    size
  } = useThree();
  const rPolar = React9.useMemo(() => [rotation2[0] + polar[0], rotation2[0] + polar[1]], [rotation2[0], polar[0], polar[1]]);
  const rAzimuth = React9.useMemo(() => [rotation2[1] + azimuth[0], rotation2[1] + azimuth[1]], [rotation2[1], azimuth[0], azimuth[1]]);
  const rInitial = React9.useMemo(() => [MathUtils.clamp(rotation2[0], ...rPolar), MathUtils.clamp(rotation2[1], ...rAzimuth), rotation2[2]], [rotation2[0], rotation2[1], rotation2[2], rPolar, rAzimuth]);
  const [spring, api] = useSpring(() => ({
    scale: 1,
    rotation: rInitial,
    config: config2
  }));
  React9.useEffect(() => void api.start({
    scale: 1,
    rotation: rInitial,
    config: config2
  }), [rInitial]);
  React9.useEffect(() => {
    if (global2 && cursor && enabled) {
      explDomElement.style.cursor = "grab";
      gl.domElement.style.cursor = "";
      return () => {
        explDomElement.style.cursor = "default";
        gl.domElement.style.cursor = "default";
      };
    }
  }, [global2, cursor, explDomElement, enabled]);
  const bind = useGesture({
    onHover: ({
      last
    }) => {
      if (cursor && !global2 && enabled)
        explDomElement.style.cursor = last ? "auto" : "grab";
    },
    onDrag: ({
      down,
      delta: [x, y],
      memo: [oldY, oldX] = spring.rotation.animation.to || rInitial
    }) => {
      if (!enabled)
        return [y, x];
      if (cursor)
        explDomElement.style.cursor = down ? "grabbing" : "grab";
      x = MathUtils.clamp(oldX + x / size.width * Math.PI * speed, ...rAzimuth);
      y = MathUtils.clamp(oldY + y / size.height * Math.PI * speed, ...rPolar);
      const sConfig = snap && !down && typeof snap !== "boolean" ? snap : config2;
      api.start({
        scale: down && y > rPolar[1] / 2 ? zoom : 1,
        rotation: snap && !down ? rInitial : [y, x, 0],
        config: (n2) => n2 === "scale" ? {
          ...sConfig,
          friction: sConfig.friction * 3
        } : sConfig
      });
      return [y, x];
    }
  }, {
    target: global2 ? explDomElement : void 0
  });
  return React9.createElement(animated.group, _extends({}, bind == null ? void 0 : bind(), spring), children);
}

// node_modules/@react-three/drei/web/KeyboardControls.js
var React10 = __toESM(require_react());

// node_modules/zustand/esm/middleware.js
var subscribeWithSelector = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get, api);
  return initialState;
};

// node_modules/@react-three/drei/web/KeyboardControls.js
var context3 = React10.createContext(null);
function KeyboardControls({
  map,
  children,
  onChange,
  domElement
}) {
  const key = map.map((item) => item.name + item.keys).join("-");
  const useControls = React10.useMemo(() => {
    return create(subscribeWithSelector(() => map.reduce((prev, cur) => ({
      ...prev,
      [cur.name]: false
    }), {})));
  }, [key]);
  const api = React10.useMemo(() => [useControls.subscribe, useControls.getState, useControls], [key]);
  const set = useControls.setState;
  React10.useEffect(() => {
    const config2 = map.map(({
      name,
      keys,
      up
    }) => ({
      keys,
      up,
      fn: (value) => {
        set({
          [name]: value
        });
        if (onChange)
          onChange(name, value, api[1]());
      }
    }));
    const keyMap = config2.reduce((out, {
      keys,
      fn,
      up = true
    }) => {
      keys.forEach((key2) => out[key2] = {
        fn,
        pressed: false,
        up
      });
      return out;
    }, {});
    const downHandler = ({
      key: key2,
      code
    }) => {
      const obj = keyMap[key2] || keyMap[code];
      if (!obj)
        return;
      const {
        fn,
        pressed,
        up
      } = obj;
      obj.pressed = true;
      if (up || !pressed)
        fn(true);
    };
    const upHandler = ({
      key: key2,
      code
    }) => {
      const obj = keyMap[key2] || keyMap[code];
      if (!obj)
        return;
      const {
        fn,
        up
      } = obj;
      obj.pressed = false;
      if (up)
        fn(false);
    };
    const source = domElement || window;
    source.addEventListener("keydown", downHandler, {
      passive: true
    });
    source.addEventListener("keyup", upHandler, {
      passive: true
    });
    return () => {
      source.removeEventListener("keydown", downHandler);
      source.removeEventListener("keyup", upHandler);
    };
  }, [domElement, key]);
  return React10.createElement(context3.Provider, {
    value: api,
    children
  });
}
function useKeyboardControls(sel) {
  const [sub, get, store] = React10.useContext(context3);
  if (sel)
    return store(sel);
  else
    return [sub, get];
}

// node_modules/@react-three/drei/web/Select.js
var React11 = __toESM(require_react());

// node_modules/zustand/esm/shallow.js
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i3 = 0; i3 < keysA.length; i3++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i3]) || !Object.is(objA[keysA[i3]], objB[keysA[i3]])) {
      return false;
    }
  }
  return true;
}

// node_modules/@react-three/drei/web/Select.js
var context4 = React11.createContext([]);
function Select({
  box,
  multiple,
  children,
  onChange,
  onChangePointerUp,
  border = "1px solid #55aaff",
  backgroundColor = "rgba(75, 160, 255, 0.1)",
  filter: customFilter = (item) => item,
  ...props
}) {
  const [downed, down] = React11.useState(false);
  const {
    setEvents,
    camera,
    raycaster,
    gl,
    controls,
    size,
    get
  } = useThree();
  const [hovered, hover] = React11.useState(false);
  const [active, dispatch] = React11.useReducer((state, {
    object,
    shift
  }) => {
    if (object === void 0)
      return [];
    else if (Array.isArray(object))
      return object;
    else if (!shift)
      return state[0] === object ? [] : [object];
    else if (state.includes(object))
      return state.filter((o2) => o2 !== object);
    else
      return [object, ...state];
  }, []);
  React11.useEffect(() => {
    if (downed)
      onChange == null ? void 0 : onChange(active);
    else
      onChangePointerUp == null ? void 0 : onChangePointerUp(active);
  }, [active, downed]);
  const onClick = React11.useCallback((e2) => {
    e2.stopPropagation();
    dispatch({
      object: customFilter([e2.object])[0],
      shift: multiple && e2.shiftKey
    });
  }, []);
  const onPointerMissed = React11.useCallback((e2) => !hovered && dispatch({}), [hovered]);
  const ref = React11.useRef(null);
  React11.useEffect(() => {
    if (!box || !multiple)
      return;
    const selBox = new SelectionBox(camera, ref.current);
    const element = document.createElement("div");
    element.style.pointerEvents = "none";
    element.style.border = border;
    element.style.backgroundColor = backgroundColor;
    element.style.position = "fixed";
    const startPoint = new Vector2();
    const pointTopLeft = new Vector2();
    const pointBottomRight = new Vector2();
    const oldRaycasterEnabled = get().events.enabled;
    const oldControlsEnabled = controls == null ? void 0 : controls.enabled;
    let isDown = false;
    function prepareRay(event, vec) {
      const {
        offsetX,
        offsetY
      } = event;
      const {
        width,
        height
      } = size;
      vec.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);
    }
    function onSelectStart(event) {
      var _gl$domElement$parent;
      if (controls)
        controls.enabled = false;
      setEvents({
        enabled: false
      });
      down(isDown = true);
      (_gl$domElement$parent = gl.domElement.parentElement) == null ? void 0 : _gl$domElement$parent.appendChild(element);
      element.style.left = `${event.clientX}px`;
      element.style.top = `${event.clientY}px`;
      element.style.width = "0px";
      element.style.height = "0px";
      startPoint.x = event.clientX;
      startPoint.y = event.clientY;
    }
    function onSelectMove(event) {
      pointBottomRight.x = Math.max(startPoint.x, event.clientX);
      pointBottomRight.y = Math.max(startPoint.y, event.clientY);
      pointTopLeft.x = Math.min(startPoint.x, event.clientX);
      pointTopLeft.y = Math.min(startPoint.y, event.clientY);
      element.style.left = `${pointTopLeft.x}px`;
      element.style.top = `${pointTopLeft.y}px`;
      element.style.width = `${pointBottomRight.x - pointTopLeft.x}px`;
      element.style.height = `${pointBottomRight.y - pointTopLeft.y}px`;
    }
    function onSelectOver() {
      if (isDown) {
        var _element$parentElemen;
        if (controls)
          controls.enabled = oldControlsEnabled;
        setEvents({
          enabled: oldRaycasterEnabled
        });
        down(isDown = false);
        (_element$parentElemen = element.parentElement) == null ? void 0 : _element$parentElemen.removeChild(element);
      }
    }
    function pointerDown(event) {
      if (event.shiftKey) {
        onSelectStart(event);
        prepareRay(event, selBox.startPoint);
      }
    }
    let previous = [];
    function pointerMove(event) {
      if (isDown) {
        onSelectMove(event);
        prepareRay(event, selBox.endPoint);
        const allSelected = selBox.select().sort((o2) => o2.uuid).filter((o2) => o2.isMesh);
        if (!shallow(allSelected, previous)) {
          previous = allSelected;
          dispatch({
            object: customFilter(allSelected)
          });
        }
      }
    }
    function pointerUp(event) {
      if (isDown)
        onSelectOver();
    }
    document.addEventListener("pointerdown", pointerDown, {
      passive: true
    });
    document.addEventListener("pointermove", pointerMove, {
      passive: true,
      capture: true
    });
    document.addEventListener("pointerup", pointerUp, {
      passive: true
    });
    return () => {
      document.removeEventListener("pointerdown", pointerDown);
      document.removeEventListener("pointermove", pointerMove);
      document.removeEventListener("pointerup", pointerUp);
    };
  }, [size.width, size.height, raycaster, camera, controls, gl]);
  return React11.createElement("group", _extends({
    ref,
    onClick,
    onPointerOver: () => hover(true),
    onPointerOut: () => hover(false),
    onPointerMissed
  }, props), React11.createElement(context4.Provider, {
    value: active
  }, children));
}
function useSelect() {
  return React11.useContext(context4);
}

// node_modules/@react-three/drei/core/Billboard.js
var React12 = __toESM(require_react());
var Billboard = React12.forwardRef(function Billboard2({
  follow = true,
  lockX = false,
  lockY = false,
  lockZ = false,
  ...props
}, ref) {
  const localRef = React12.useRef();
  useFrame(({
    camera
  }) => {
    if (!follow || !localRef.current)
      return;
    const prevRotation = localRef.current.rotation.clone();
    camera.getWorldQuaternion(localRef.current.quaternion);
    if (lockX)
      localRef.current.rotation.x = prevRotation.x;
    if (lockY)
      localRef.current.rotation.y = prevRotation.y;
    if (lockZ)
      localRef.current.rotation.z = prevRotation.z;
  });
  return React12.createElement("group", _extends({
    ref: react_merge_refs_esm_default([localRef, ref])
  }, props));
});

// node_modules/@react-three/drei/core/ScreenSpace.js
var React13 = __toESM(require_react());
var ScreenSpace = React13.forwardRef(({
  children,
  depth = -1,
  ...rest
}, ref) => {
  const localRef = React13.useRef(null);
  useFrame(({
    camera
  }) => {
    localRef.current.quaternion.copy(camera.quaternion);
    localRef.current.position.copy(camera.position);
  });
  return React13.createElement("group", _extends({
    ref: react_merge_refs_esm_default([ref, localRef])
  }, rest), React13.createElement("group", {
    "position-z": -depth
  }, children));
});

// node_modules/@react-three/drei/core/QuadraticBezierLine.js
var React15 = __toESM(require_react());

// node_modules/@react-three/drei/core/Line.js
var React14 = __toESM(require_react());
var Line = React14.forwardRef(function Line4({
  points,
  color = "black",
  vertexColors,
  linewidth,
  lineWidth,
  segments,
  dashed,
  ...rest
}, ref) {
  const size = useThree((state) => state.size);
  const line2 = React14.useMemo(() => segments ? new LineSegments2() : new Line2(), [segments]);
  const [lineMaterial] = React14.useState(() => new LineMaterial());
  const lineGeom = React14.useMemo(() => {
    const geom = segments ? new LineSegmentsGeometry() : new LineGeometry();
    const pValues = points.map((p) => {
      const isArray3 = Array.isArray(p);
      return p instanceof Vector3 ? [p.x, p.y, p.z] : p instanceof Vector2 ? [p.x, p.y, 0] : isArray3 && p.length === 3 ? [p[0], p[1], p[2]] : isArray3 && p.length === 2 ? [p[0], p[1], 0] : p;
    });
    geom.setPositions(pValues.flat());
    if (vertexColors) {
      const cValues = vertexColors.map((c6) => c6 instanceof Color ? c6.toArray() : c6);
      geom.setColors(cValues.flat());
    }
    return geom;
  }, [points, segments, vertexColors]);
  React14.useLayoutEffect(() => {
    line2.computeLineDistances();
  }, [points, line2]);
  React14.useLayoutEffect(() => {
    if (dashed) {
      lineMaterial.defines.USE_DASH = "";
    } else {
      delete lineMaterial.defines.USE_DASH;
    }
    lineMaterial.needsUpdate = true;
  }, [dashed, lineMaterial]);
  React14.useEffect(() => {
    return () => lineGeom.dispose();
  }, [lineGeom]);
  return React14.createElement("primitive", _extends({
    object: line2,
    ref
  }, rest), React14.createElement("primitive", {
    object: lineGeom,
    attach: "geometry"
  }), React14.createElement("primitive", _extends({
    object: lineMaterial,
    attach: "material",
    color,
    vertexColors: Boolean(vertexColors),
    resolution: [size.width, size.height],
    linewidth: linewidth !== null && linewidth !== void 0 ? linewidth : lineWidth,
    dashed
  }, rest)));
});

// node_modules/@react-three/drei/core/QuadraticBezierLine.js
var v = new Vector3();
var QuadraticBezierLine = React15.forwardRef(function QuadraticBezierLine2({
  start: start2 = [0, 0, 0],
  end = [0, 0, 0],
  mid,
  segments = 20,
  ...rest
}, forwardref) {
  const ref = React15.useRef(null);
  const [curve] = React15.useState(() => new QuadraticBezierCurve3(void 0, void 0, void 0));
  const getPoints = React15.useCallback((start3, end2, mid2, segments2 = 20) => {
    if (start3 instanceof Vector3)
      curve.v0.copy(start3);
    else
      curve.v0.set(...start3);
    if (end2 instanceof Vector3)
      curve.v2.copy(end2);
    else
      curve.v2.set(...end2);
    if (mid2 instanceof Vector3) {
      curve.v1.copy(mid2);
    } else if (Array.isArray(mid2)) {
      curve.v1.set(...mid2);
    } else {
      curve.v1.copy(curve.v0.clone().add(curve.v2.clone().sub(curve.v0)).add(v.set(0, curve.v0.y - curve.v2.y, 0)));
    }
    return curve.getPoints(segments2);
  }, []);
  React15.useLayoutEffect(() => {
    ref.current.setPoints = (start3, end2, mid2) => {
      const points2 = getPoints(start3, end2, mid2);
      if (ref.current.geometry)
        ref.current.geometry.setPositions(points2.map((p) => p.toArray()).flat());
    };
  }, []);
  const points = React15.useMemo(() => getPoints(start2, end, mid, segments), [start2, end, mid, segments]);
  return React15.createElement(Line, _extends({
    ref: react_merge_refs_esm_default([ref, forwardref]),
    points
  }, rest));
});

// node_modules/@react-three/drei/core/CubicBezierLine.js
var React16 = __toESM(require_react());
var CubicBezierLine = React16.forwardRef(function CubicBezierLine2({
  start: start2,
  end,
  midA,
  midB,
  segments = 20,
  ...rest
}, ref) {
  const points = React16.useMemo(() => {
    const startV = start2 instanceof Vector3 ? start2 : new Vector3(...start2);
    const endV = end instanceof Vector3 ? end : new Vector3(...end);
    const midAV = midA instanceof Vector3 ? midA : new Vector3(...midA);
    const midBV = midB instanceof Vector3 ? midB : new Vector3(...midB);
    const interpolatedV = new CubicBezierCurve3(startV, midAV, midBV, endV).getPoints(segments);
    return interpolatedV;
  }, [start2, end, midA, midB, segments]);
  return React16.createElement(Line, _extends({
    ref,
    points
  }, rest));
});

// node_modules/@react-three/drei/core/CatmullRomLine.js
var React17 = __toESM(require_react());
var CatmullRomLine = React17.forwardRef(function CatmullRomLine2({
  points,
  closed = false,
  curveType = "centripetal",
  tension = 0.5,
  segments = 20,
  vertexColors,
  ...rest
}, ref) {
  const curve = React17.useMemo(() => {
    const mappedPoints = points.map((pt) => pt instanceof Vector3 ? pt : new Vector3(...pt));
    return new CatmullRomCurve3(mappedPoints, closed, curveType, tension);
  }, [points, closed, curveType, tension]);
  const segmentedPoints = React17.useMemo(() => curve.getPoints(segments), [curve, segments]);
  const interpolatedVertexColors = React17.useMemo(() => {
    if (!vertexColors || vertexColors.length < 2)
      return void 0;
    if (vertexColors.length === segments + 1)
      return vertexColors;
    const mappedColors = vertexColors.map((color) => color instanceof Color ? color : new Color(...color));
    if (closed)
      mappedColors.push(mappedColors[0].clone());
    const iColors = [mappedColors[0]];
    const divisions = segments / (mappedColors.length - 1);
    for (let i3 = 1; i3 < segments; i3++) {
      const alpha = i3 % divisions / divisions;
      const colorIndex = Math.floor(i3 / divisions);
      iColors.push(mappedColors[colorIndex].clone().lerp(mappedColors[colorIndex + 1], alpha));
    }
    iColors.push(mappedColors[mappedColors.length - 1]);
    return iColors;
  }, [vertexColors, segments]);
  return React17.createElement(Line, _extends({
    ref,
    points: segmentedPoints,
    vertexColors: interpolatedVertexColors
  }, rest));
});

// node_modules/@react-three/drei/core/PositionalAudio.js
var React18 = __toESM(require_react());
var PositionalAudio = React18.forwardRef(({
  url,
  distance = 1,
  loop: loop2 = true,
  autoplay,
  ...props
}, ref) => {
  const sound = React18.useRef();
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const [listener] = React18.useState(() => new AudioListener());
  const buffer = useLoader(AudioLoader, url);
  React18.useEffect(() => {
    const _sound = sound.current;
    if (_sound) {
      _sound.setBuffer(buffer);
      _sound.setRefDistance(distance);
      _sound.setLoop(loop2);
      if (autoplay && !_sound.isPlaying)
        _sound.play();
    }
  }, [buffer, camera, distance, loop2]);
  React18.useEffect(() => {
    const _sound = sound.current;
    camera.add(listener);
    return () => {
      camera.remove(listener);
      if (_sound) {
        if (_sound.isPlaying)
          _sound.stop();
        if (_sound.source && _sound.source._connected)
          _sound.disconnect();
      }
    };
  }, []);
  return React18.createElement("positionalAudio", _extends({
    ref: react_merge_refs_esm_default([sound, ref]),
    args: [listener]
  }, props));
});

// node_modules/@react-three/drei/core/Text.js
var React19 = __toESM(require_react());

// node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js
function workerBootstrap() {
  var modules = /* @__PURE__ */ Object.create(null);
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0)
      dependencies = [];
    var init = ref.init;
    if (init === void 0)
      init = function() {
      };
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0)
      getTransferables = null;
    if (modules[id]) {
      return;
    }
    try {
      dependencies = dependencies.map(function(dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function(depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });
      init = rehydrate("<" + name + ">.init", init);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }
      var value = null;
      if (typeof init === "function") {
        value = init.apply(void 0, dependencies);
      } else {
        console.error("worker module init function failed to rehydrate");
      }
      modules[id] = {
        id,
        value,
        getTransferables
      };
      callback(value);
    } catch (err) {
      if (!(err && err.noLog)) {
        console.error(err);
      }
      callback(err);
    }
  }
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== "function") {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === "function") {
        result.then(handleResult, function(rej) {
          return callback(rej instanceof Error ? rej : new Error("" + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err) {
      callback(err);
    }
    function handleResult(result2) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result2);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = void 0;
        }
        callback(result2, tx);
      } catch (err) {
        console.error(err);
        callback(err);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function(r2) {
      return result = r2;
    };
    var url = URL.createObjectURL(
      new Blob(
        ["/** " + name.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + str + "\n)"],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(url);
    } catch (err) {
      console.error(err);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }
  self.addEventListener("message", function(e2) {
    var ref = e2.data;
    var messageId = ref.messageId;
    var action = ref.action;
    var data = ref.data;
    try {
      if (action === "registerModule") {
        registerModule(data, function(result) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result: { isCallable: typeof result === "function" }
            });
          }
        });
      }
      if (action === "callModule") {
        callModule(data, function(result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result
            }, transferables || void 0);
          }
        });
      }
    } catch (err) {
      postMessage({
        messageId,
        success: false,
        error: err.stack
      });
    }
  });
}
function defineMainThreadModule(options) {
  var moduleFunc = function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function(initResult) {
      if (typeof initResult === "function") {
        return initResult.apply(void 0, args);
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  };
  moduleFunc._getInitResult = function() {
    var dependencies = options.dependencies;
    var init = options.init;
    dependencies = Array.isArray(dependencies) ? dependencies.map(
      function(dep) {
        return dep && dep._getInitResult ? dep._getInitResult() : dep;
      }
    ) : [];
    var initPromise = Promise.all(dependencies).then(function(deps) {
      return init.apply(null, deps);
    });
    moduleFunc._getInitResult = function() {
      return initPromise;
    };
    return initPromise;
  };
  return moduleFunc;
}
var supportsWorkers = function() {
  var supported = false;
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    try {
      var worker = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      worker.terminate();
      supported = true;
    } catch (err) {
      if (typeof process !== "undefined" && false)
        ;
      else {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err.message + "]"
        );
      }
    }
  }
  supportsWorkers = function() {
    return supported;
  };
  return supported;
};
var _workerModuleId = 0;
var _messageId = 0;
var _allowInitAsString = false;
var workers = /* @__PURE__ */ Object.create(null);
var registeredModules = /* @__PURE__ */ Object.create(null);
var openRequests = /* @__PURE__ */ Object.create(null);
function defineWorkerModule(options) {
  if ((!options || typeof options.init !== "function") && !_allowInitAsString) {
    throw new Error("requires `options.init` function");
  }
  var dependencies = options.dependencies;
  var init = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  if (!supportsWorkers()) {
    return defineMainThreadModule(options);
  }
  if (workerId == null) {
    workerId = "#default";
  }
  var id = "workerModule" + ++_workerModuleId;
  var name = options.name || id;
  var registrationPromise = null;
  dependencies = dependencies && dependencies.map(function(dep) {
    if (typeof dep === "function" && !dep.workerModuleData) {
      _allowInitAsString = true;
      dep = defineWorkerModule({
        workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction(dep) + "\n)}"
      });
      _allowInitAsString = false;
    }
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (!registrationPromise) {
      registrationPromise = callWorker(workerId, "registerModule", moduleFunc.workerModuleData);
      var unregister = function() {
        registrationPromise = null;
        registeredModules[workerId].delete(unregister);
      };
      (registeredModules[workerId] || (registeredModules[workerId] = /* @__PURE__ */ new Set())).add(unregister);
    }
    return registrationPromise.then(function(ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker(workerId, "callModule", { id, args });
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id,
    name,
    dependencies,
    init: stringifyFunction(init),
    getTransferables: getTransferables && stringifyFunction(getTransferables)
  };
  return moduleFunc;
}
function terminateWorker(workerId) {
  if (registeredModules[workerId]) {
    registeredModules[workerId].forEach(function(unregister) {
      unregister();
    });
  }
  if (workers[workerId]) {
    workers[workerId].terminate();
    delete workers[workerId];
  }
}
function stringifyFunction(fn) {
  var str = fn.toString();
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = "function " + str;
  }
  return str;
}
function getWorker(workerId) {
  var worker = workers[workerId];
  if (!worker) {
    var bootstrap = stringifyFunction(workerBootstrap);
    worker = workers[workerId] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, "") + " **/\n\n;(" + bootstrap + ")()"],
          { type: "application/javascript" }
        )
      )
    );
    worker.onmessage = function(e2) {
      var response = e2.data;
      var msgId = response.messageId;
      var callback = openRequests[msgId];
      if (!callback) {
        throw new Error("WorkerModule response with empty or unknown messageId");
      }
      delete openRequests[msgId];
      callback(response);
    };
  }
  return worker;
}
function callWorker(workerId, action, data) {
  return new Promise(function(resolve2, reject) {
    var messageId = ++_messageId;
    openRequests[messageId] = function(response) {
      if (response.success) {
        resolve2(response.result);
      } else {
        reject(new Error("Error in worker " + action + " call: " + response.error));
      }
    };
    getWorker(workerId).postMessage({
      messageId,
      action,
      data
    });
  });
}

// node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs
function SDFGenerator() {
  var exports3 = function(exports4) {
    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * x0 + 2 * t22 * t2 * x1 + t2 * t2 * x2;
      pointOut.y = t22 * t22 * y0 + 2 * t22 * t2 * y1 + t2 * t2 * y2;
    }
    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * t22 * x0 + 3 * t22 * t22 * t2 * x1 + 3 * t22 * t2 * t2 * x2 + t2 * t2 * t2 * x3;
      pointOut.y = t22 * t22 * t22 * y0 + 3 * t22 * t22 * t2 * y1 + 3 * t22 * t2 * t2 * y2 + t2 * t2 * t2 * y3;
    }
    function forEachPathCommand(pathString, commandCallback) {
      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
      var match, firstX, firstY, prevX, prevY;
      while (match = segmentRE.exec(pathString)) {
        var args = match[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(v4) {
          return parseFloat(v4);
        });
        switch (match[1]) {
          case "M":
            prevX = firstX = args[0];
            prevY = firstY = args[1];
            break;
          case "L":
            if (args[0] !== prevX || args[1] !== prevY) {
              commandCallback("L", prevX, prevY, prevX = args[0], prevY = args[1]);
            }
            break;
          case "Q": {
            commandCallback("Q", prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);
            break;
          }
          case "C": {
            commandCallback("C", prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);
            break;
          }
          case "Z":
            if (prevX !== firstX || prevY !== firstY) {
              commandCallback("L", prevX, prevY, firstX, firstY);
            }
            break;
        }
      }
    }
    function pathToLineSegments(pathString, segmentCallback, curvePoints) {
      if (curvePoints === void 0)
        curvePoints = 16;
      var tempPoint = { x: 0, y: 0 };
      forEachPathCommand(pathString, function(command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {
        switch (command) {
          case "L":
            segmentCallback(startX, startY, endX, endY);
            break;
          case "Q": {
            var prevCurveX = startX;
            var prevCurveY = startY;
            for (var i3 = 1; i3 < curvePoints; i3++) {
              pointOnQuadraticBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                endX,
                endY,
                i3 / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);
              prevCurveX = tempPoint.x;
              prevCurveY = tempPoint.y;
            }
            break;
          }
          case "C": {
            var prevCurveX$1 = startX;
            var prevCurveY$1 = startY;
            for (var i$1 = 1; i$1 < curvePoints; i$1++) {
              pointOnCubicBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                ctrl2X,
                ctrl2Y,
                endX,
                endY,
                i$1 / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);
              prevCurveX$1 = tempPoint.x;
              prevCurveY$1 = tempPoint.y;
            }
            break;
          }
        }
      });
    }
    var viewportQuadVertex = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var copyTexFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}";
    var cache = /* @__PURE__ */ new WeakMap();
    var glContextParams = {
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      antialias: false,
      depth: false
    };
    function withWebGLContext(glOrCanvas, callback) {
      var gl = glOrCanvas.getContext ? glOrCanvas.getContext("webgl", glContextParams) : glOrCanvas;
      var wrapper = cache.get(gl);
      if (!wrapper) {
        let getExtension = function(name) {
          var ext = extensions2[name];
          if (!ext) {
            ext = extensions2[name] = gl.getExtension(name);
            if (!ext) {
              throw new Error(name + " not supported");
            }
          }
          return ext;
        }, compileShader = function(src, type) {
          var shader = gl.createShader(type);
          gl.shaderSource(shader, src);
          gl.compileShader(shader);
          return shader;
        }, withProgram = function(name, vert, frag, func) {
          if (!programs[name]) {
            var attributes = {};
            var uniforms = {};
            var program = gl.createProgram();
            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));
            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));
            gl.linkProgram(program);
            programs[name] = {
              program,
              transaction: function transaction(func2) {
                gl.useProgram(program);
                func2({
                  setUniform: function setUniform(type, name2) {
                    var values = [], len = arguments.length - 2;
                    while (len-- > 0)
                      values[len] = arguments[len + 2];
                    var uniformLoc = uniforms[name2] || (uniforms[name2] = gl.getUniformLocation(program, name2));
                    gl["uniform" + type].apply(gl, [uniformLoc].concat(values));
                  },
                  setAttribute: function setAttribute(name2, size, usage, instancingDivisor, data) {
                    var attr = attributes[name2];
                    if (!attr) {
                      attr = attributes[name2] = {
                        buf: gl.createBuffer(),
                        // TODO should we destroy our buffers?
                        loc: gl.getAttribLocation(program, name2),
                        data: null
                      };
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);
                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(attr.loc);
                    if (isWebGL2) {
                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);
                    } else {
                      getExtension("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attr.loc, instancingDivisor);
                    }
                    if (data !== attr.data) {
                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);
                      attr.data = data;
                    }
                  }
                });
              }
            };
          }
          programs[name].transaction(func);
        }, withTexture = function(name, func) {
          textureUnit++;
          try {
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            var texture = textures[name];
            if (!texture) {
              texture = textures[name] = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
            func(texture, textureUnit);
          } finally {
            textureUnit--;
          }
        }, withTextureFramebuffer = function(texture, textureUnit2, func) {
          var framebuffer = gl.createFramebuffer();
          framebufferStack.push(framebuffer);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.activeTexture(gl.TEXTURE0 + textureUnit2);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          try {
            func(framebuffer);
          } finally {
            gl.deleteFramebuffer(framebuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);
          }
        }, handleContextLoss = function() {
          extensions2 = {};
          programs = {};
          textures = {};
          textureUnit = -1;
          framebufferStack.length = 0;
        };
        var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
        var extensions2 = {};
        var programs = {};
        var textures = {};
        var textureUnit = -1;
        var framebufferStack = [];
        gl.canvas.addEventListener("webglcontextlost", function(e2) {
          handleContextLoss();
          e2.preventDefault();
        }, false);
        cache.set(gl, wrapper = {
          gl,
          isWebGL2,
          getExtension,
          withProgram,
          withTexture,
          withTextureFramebuffer,
          handleContextLoss
        });
      }
      callback(wrapper);
    }
    function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {
      if (channels === void 0)
        channels = 15;
      if (framebuffer === void 0)
        framebuffer = null;
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        withTexture("copy", function(tex, texUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
          withProgram("copy", viewportQuadVertex, copyTexFragment, function(ref2) {
            var setUniform = ref2.setUniform;
            var setAttribute = ref2.setAttribute;
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));
            setUniform("1i", "image", texUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);
            gl.disable(gl.BLEND);
            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);
            gl.viewport(x, y, width, height);
            gl.scissor(x, y, width, height);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function resizeWebGLCanvasWithoutClearing2(canvas, newWidth, newHeight) {
      var width = canvas.width;
      var height = canvas.height;
      withWebGLContext(canvas, function(ref) {
        var gl = ref.gl;
        var data = new Uint8Array(width * height * 4);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        canvas.width = newWidth;
        canvas.height = newHeight;
        renderImageData(gl, data, 0, 0, width, height);
      });
    }
    var webglUtils = Object.freeze({
      __proto__: null,
      withWebGLContext,
      renderImageData,
      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing2
    });
    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      var textureData = new Uint8Array(sdfWidth * sdfHeight);
      var viewBoxWidth = viewBox[2] - viewBox[0];
      var viewBoxHeight = viewBox[3] - viewBox[1];
      var segments = [];
      pathToLineSegments(path, function(x1, y1, x2, y2) {
        segments.push({
          x1,
          y1,
          x2,
          y2,
          minX: Math.min(x1, x2),
          minY: Math.min(y1, y2),
          maxX: Math.max(x1, x2),
          maxY: Math.max(y1, y2)
        });
      });
      segments.sort(function(a3, b) {
        return a3.maxX - b.maxX;
      });
      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {
        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {
          var signedDist = findNearestSignedDistance(
            viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,
            viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight
          );
          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;
          if (signedDist < 0) {
            alpha = 1 - alpha;
          }
          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255)));
          textureData[sdfY * sdfWidth + sdfX] = alpha;
        }
      }
      return textureData;
      function findNearestSignedDistance(x, y) {
        var closestDistSq = Infinity;
        var closestDist = Infinity;
        for (var i3 = segments.length; i3--; ) {
          var seg = segments[i3];
          if (seg.maxX + closestDist <= x) {
            break;
          }
          if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {
            var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);
            if (distSq < closestDistSq) {
              closestDistSq = distSq;
              closestDist = Math.sqrt(closestDistSq);
            }
          }
        }
        if (isPointInPoly(x, y)) {
          closestDist = -closestDist;
        }
        return closestDist;
      }
      function isPointInPoly(x, y) {
        var winding = 0;
        for (var i3 = segments.length; i3--; ) {
          var seg = segments[i3];
          if (seg.maxX <= x) {
            break;
          }
          var intersects = seg.y1 > y !== seg.y2 > y && x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1;
          if (intersects) {
            winding += seg.y1 < seg.y2 ? 1 : -1;
          }
        }
        return winding !== 0;
      }
    }
    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
    }
    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);
      var rgbaData = new Uint8Array(data.length * 4);
      for (var i3 = 0; i3 < data.length; i3++) {
        rgbaData[i3 * 4 + channel] = data[i3];
      }
      renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);
    }
    function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {
      var ldx = lineX1 - lineX0;
      var ldy = lineY1 - lineY0;
      var lengthSq = ldx * ldx + ldy * ldy;
      var t2 = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;
      var dx = x - (lineX0 + t2 * ldx);
      var dy = y - (lineY0 + t2 * ldy);
      return dx * dx + dy * dy;
    }
    var javascript = Object.freeze({
      __proto__: null,
      generate: generate$2,
      generateIntoCanvas: generateIntoCanvas$2,
      generateIntoFramebuffer: generateIntoFramebuffer$1
    });
    var mainVertex = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var mainFragment = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}";
    var postFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}";
    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);
    var implicitContext = null;
    var isTestingSupport = false;
    var NULL_OBJECT = {};
    var supportByCanvas = /* @__PURE__ */ new WeakMap();
    function validateSupport(glOrCanvas) {
      if (!isTestingSupport && !isSupported(glOrCanvas)) {
        throw new Error("WebGL generation not supported");
      }
    }
    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (glOrCanvas === void 0)
        glOrCanvas = null;
      if (!glOrCanvas) {
        glOrCanvas = implicitContext;
        if (!glOrCanvas) {
          var canvas = typeof OffscreenCanvas === "function" ? new OffscreenCanvas(1, 1) : typeof document !== "undefined" ? document.createElement("canvas") : null;
          if (!canvas) {
            throw new Error("OffscreenCanvas or DOM canvas not supported");
          }
          glOrCanvas = implicitContext = canvas.getContext("webgl", { depth: false });
        }
      }
      validateSupport(glOrCanvas);
      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        withTexture("readable", function(texture, textureUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          withTextureFramebuffer(texture, textureUnit, function(framebuffer) {
            generateIntoFramebuffer(
              sdfWidth,
              sdfHeight,
              path,
              viewBox,
              maxDistance,
              sdfExponent,
              gl,
              framebuffer,
              0,
              0,
              0
              // red channel
            );
            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);
          });
        });
      });
      var data = new Uint8Array(sdfWidth * sdfHeight);
      for (var i3 = 0, j = 0; i3 < rgbaData.length; i3 += 4) {
        data[j++] = rgbaData[i3];
      }
      return data;
    }
    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);
    }
    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      validateSupport(glOrCanvas);
      var lineSegmentCoords = [];
      pathToLineSegments(path, function(x1, y1, x2, y2) {
        lineSegmentCoords.push(x1, y1, x2, y2);
      });
      lineSegmentCoords = new Float32Array(lineSegmentCoords);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var isWebGL2 = ref.isWebGL2;
        var getExtension = ref.getExtension;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        var handleContextLoss = ref.handleContextLoss;
        withTexture("rawDistances", function(intermediateTexture, intermediateTextureUnit) {
          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.RGBA,
              intermediateTexture._lastWidth = sdfWidth,
              intermediateTexture._lastHeight = sdfHeight,
              0,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              null
            );
          }
          withProgram("main", mainVertex, mainFragment, function(ref2) {
            var setAttribute = ref2.setAttribute;
            var setUniform = ref2.setUniform;
            var instancingExtension = !isWebGL2 && getExtension("ANGLE_instanced_arrays");
            var blendMinMaxExtension = !isWebGL2 && getExtension("EXT_blend_minmax");
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            setAttribute("aLineSegment", 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);
            setUniform.apply(void 0, ["4f", "uGlyphBounds"].concat(viewBox));
            setUniform("1f", "uMaxDistance", maxDistance);
            setUniform("1f", "uExponent", sdfExponent);
            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function(framebuffer2) {
              gl.enable(gl.BLEND);
              gl.colorMask(true, true, true, true);
              gl.viewport(0, 0, sdfWidth, sdfHeight);
              gl.scissor(0, 0, sdfWidth, sdfHeight);
              gl.blendFunc(gl.ONE, gl.ONE);
              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);
              gl.clear(gl.COLOR_BUFFER_BIT);
              if (isWebGL2) {
                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              } else {
                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              }
            });
          });
          withProgram("post", viewportQuadVertex, postFragment, function(program) {
            program.setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            program.setUniform("1i", "tex", intermediateTextureUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.disable(gl.BLEND);
            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);
            gl.viewport(x, y, sdfWidth, sdfHeight);
            gl.scissor(x, y, sdfWidth, sdfHeight);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
        if (gl.isContextLost()) {
          handleContextLoss();
          throw new Error("webgl context lost");
        }
      });
    }
    function isSupported(glOrCanvas) {
      var key = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;
      var supported = supportByCanvas.get(key);
      if (supported === void 0) {
        isTestingSupport = true;
        var failReason = null;
        try {
          var expectedResult = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ];
          var testResult = generate$1(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            glOrCanvas
          );
          supported = testResult && expectedResult.length === testResult.length && testResult.every(function(val, i3) {
            return val === expectedResult[i3];
          });
          if (!supported) {
            failReason = "bad trial run results";
            console.info(expectedResult, testResult);
          }
        } catch (err) {
          supported = false;
          failReason = err.message;
        }
        if (failReason) {
          console.warn("WebGL SDF generation not supported:", failReason);
        }
        isTestingSupport = false;
        supportByCanvas.set(key, supported);
      }
      return supported;
    }
    var webgl = Object.freeze({
      __proto__: null,
      generate: generate$1,
      generateIntoCanvas: generateIntoCanvas$1,
      generateIntoFramebuffer,
      isSupported
    });
    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (maxDistance === void 0)
        maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0)
        sdfExponent = 1;
      try {
        return generate$1.apply(webgl, arguments);
      } catch (e2) {
        console.info("WebGL SDF generation failed, falling back to JS", e2);
        return generate$2.apply(javascript, arguments);
      }
    }
    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {
      if (maxDistance === void 0)
        maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x === void 0)
        x = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      try {
        return generateIntoCanvas$1.apply(webgl, arguments);
      } catch (e2) {
        console.info("WebGL SDF generation failed, falling back to JS", e2);
        return generateIntoCanvas$2.apply(javascript, arguments);
      }
    }
    exports4.forEachPathCommand = forEachPathCommand;
    exports4.generate = generate;
    exports4.generateIntoCanvas = generateIntoCanvas;
    exports4.javascript = javascript;
    exports4.pathToLineSegments = pathToLineSegments;
    exports4.webgl = webgl;
    exports4.webglUtils = webglUtils;
    Object.defineProperty(exports4, "__esModule", { value: true });
    return exports4;
  }({});
  return exports3;
}

// node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi = function(exports3) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i3) {
      TYPES[type] = 1 << i3 + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop2 = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range) {
              var ref = range.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type2]);
              for (var i3 = 0; i3 < step; i3++) {
                map.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA)
          loop2(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i3 = +entry; i3--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a3 = ref[0];
          var b = ref[1];
          a3 = String.fromCodePoint(lastCode += parseInt(a3, radix));
          b = String.fromCodePoint(lastCode += parseInt(b, radix));
          map2.set(a3, b);
          includeReverse && reverseMap.set(b, a3);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$1() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$1();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$1();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$1();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i3 = 0; i3 < string.length; i3++) {
        charTypes[i3] = getBidiCharType(string[i3]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i4, type2) {
        var oldType = charTypes[i4];
        charTypes[i4] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n2) {
        return n2 + (n2 & 1 ? 1 : 2);
      };
      var nextOdd = function(n2) {
        return n2 + (n2 & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES); sj$5++) {
                  changeCharType(seqIndices$1[sj$5], TYPE_EN);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$6 = si$5 - 1; sj$6 >= 0 && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6--) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
                for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES; sj$7++) {
                  changeCharType(seqIndices$1[sj$7], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a3, b) {
                return a3[0] - b[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === getEmbedDirection(i$15)) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== getEmbedDirection(i$16)) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = getEmbedDirection(i$16);
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {
                  charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start2, isFSI) {
        for (var i4 = start2; i4 < string.length; i4++) {
          var charType2 = charTypes[i4];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i4);
            i4 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i4 = isolateStart + 1; i4 < string.length; i4++) {
          var charType2 = charTypes[i4];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i4;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
      function getEmbedDirection(i4) {
        return embedLevels[i4] & 1 ? TYPE_R : TYPE_L;
      }
    }
    var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse2() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value, key) {
          map2.set(key, value);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse2();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start2, end) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var map2 = /* @__PURE__ */ new Map();
      for (var i3 = start2; i3 <= end; i3++) {
        if (embeddingLevels[i3] & 1) {
          var mirror = getMirroredCharacter(string[i3]);
          if (mirror !== null) {
            map2.set(i3, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start2, end) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start2, paragraph.start);
        var lineEnd = Math.min(end, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i3 = lineEnd; i3 >= lineStart && getBidiCharType(string[i3]) & TRAILING_TYPES; i3--) {
            lineLevels[i3] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + start2, i$2 + start2]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start2, end) {
      var indices = getReorderedIndices(string, embedLevelsResult, start2, end);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i3) {
        chars[i3] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices(string, embedLevelsResult, start2, end) {
      var segments = getReorderSegments(string, embedLevelsResult, start2, end);
      var indices = [];
      for (var i3 = 0; i3 < string.length; i3++) {
        indices[i3] = i3;
      }
      segments.forEach(function(ref) {
        var start3 = ref[0];
        var end2 = ref[1];
        var slice = indices.slice(start3, end2 + 1);
        for (var i4 = slice.length; i4--; ) {
          indices[end2 - i4] = slice[i4];
        }
      });
      return indices;
    }
    exports3.closingToOpeningBracket = closingToOpeningBracket;
    exports3.getBidiCharType = getBidiCharType;
    exports3.getBidiCharTypeName = getBidiCharTypeName;
    exports3.getCanonicalBracket = getCanonicalBracket;
    exports3.getEmbeddingLevels = getEmbeddingLevels;
    exports3.getMirroredCharacter = getMirroredCharacter;
    exports3.getMirroredCharactersMap = getMirroredCharactersMap;
    exports3.getReorderSegments = getReorderSegments;
    exports3.getReorderedIndices = getReorderedIndices;
    exports3.getReorderedString = getReorderedString;
    exports3.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports3, "__esModule", { value: true });
    return exports3;
  }({});
  return bidi;
}
var bidi_default = bidiFactory;

// node_modules/troika-three-utils/dist/troika-three-utils.esm.js
var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}
var _lut = [];
for (let i3 = 0; i3 < 256; i3++) {
  _lut[i3] = (i3 < 16 ? "0" : "") + i3.toString(16);
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
var assign2 = Object.assign || function() {
  let target2 = arguments[0];
  for (let i3 = 1, len = arguments.length; i3 < len; i3++) {
    let source = arguments[i3];
    if (source) {
      for (let prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          target2[prop] = source[prop];
        }
      }
    }
  }
  return target2;
};
var epoch = Date.now();
var CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap();
var SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
var materialInstanceId = 1e10;
function createDerivedMaterial(baseMaterial, options) {
  const optionsKey = getKeyForOptions(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = /* @__PURE__ */ Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo, renderer) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);
    const cacheKey2 = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey2];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey2] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign2(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function(base) {
    const derived = Object.create(base, descriptor);
    Object.defineProperty(derived, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived, "id", { value: materialInstanceId++ });
    derived.uuid = generateUUID();
    derived.uniforms = assign2({}, base.uniforms, options.uniforms);
    derived.defines = assign2({}, base.defines, options.defines);
    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived.extensions = assign2({}, base.extensions, options.extensions);
    derived._listeners = void 0;
    return derived;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return baseMaterial.customProgramCacheKey() + "|" + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign2(this.extensions, source.extensions);
          assign2(this.defines, source.defines);
          assign2(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
            options
          );
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(),
            options
          );
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial)
          _depthMaterial.dispose();
        if (_distanceMaterial)
          _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders(material, { vertexShader: vertexShader2, fragmentShader: fragmentShader2 }, options, key) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs = fragmentDefs || "";
  fragmentMainIntro = fragmentMainIntro || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform || customRewriter) {
    vertexShader2 = expandShaderIncludes(vertexShader2);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader2 = fragmentShader2.replace(
      /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
      "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
    );
    fragmentShader2 = expandShaderIncludes(fragmentShader2);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader: vertexShader2, fragmentShader: fragmentShader2 });
    vertexShader2 = res.vertexShader;
    fragmentShader2 = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader2 = fragmentShader2.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (match) => {
        postChunks.push(match);
        return "";
      }
    );
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }
  if (vertexTransform) {
    vertexShader2 = `vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader2}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`;
    vertexShader2 = vertexShader2.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;
    });
    if (!(material.map && material.map.channel > 0)) {
      vertexShader2 = vertexShader2.replace(/\bMAP_UV\b/g, `troika_uv_${key}`);
    }
  }
  vertexShader2 = injectIntoShaderCode(vertexShader2, key, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader2 = injectIntoShaderCode(fragmentShader2, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader: vertexShader2,
    fragmentShader: fragmentShader2
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(
      voidMainRegExp,
      `
${defs}
void troikaOrigMain${id}() {`
    );
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key, value) {
  return key === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
var _idCtr = 0;
var optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}
var defaultBaseMaterial = new MeshStandardMaterial({ color: 16777215, side: DoubleSide });

// node_modules/troika-three-text/dist/troika-three-text.esm.js
function createTypesetter(fontParser, bidi, config2) {
  const {
    defaultFontURL
  } = config2;
  const fonts = /* @__PURE__ */ Object.create(null);
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const lineBreakingWhiteSpace = `[^\\S\\u00A0]`;
  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function doLoadFont(url, callback) {
    function tryLoad() {
      const onError = (err) => {
        console.error(`Failure loading font ${url}${url === defaultFontURL ? "" : "; trying fallback"}`, err);
        if (url !== defaultFontURL) {
          url = defaultFontURL;
          tryLoad();
        }
      };
      try {
        const request = new XMLHttpRequest();
        request.open("get", url, true);
        request.responseType = "arraybuffer";
        request.onload = function() {
          if (request.status >= 400) {
            onError(new Error(request.statusText));
          } else if (request.status > 0) {
            try {
              const fontObj = fontParser(request.response);
              callback(fontObj);
            } catch (e2) {
              onError(e2);
            }
          }
        };
        request.onerror = onError;
        request.send();
      } catch (err) {
        onError(err);
      }
    }
    tryLoad();
  }
  function loadFont(fontUrl, callback) {
    if (!fontUrl)
      fontUrl = defaultFontURL;
    let font = fonts[fontUrl];
    if (font) {
      if (font.pending) {
        font.pending.push(callback);
      } else {
        callback(font);
      }
    } else {
      fonts[fontUrl] = { pending: [callback] };
      doLoadFont(fontUrl, (fontObj) => {
        let callbacks = fonts[fontUrl].pending;
        fonts[fontUrl] = fontObj;
        callbacks.forEach((cb) => cb(fontObj));
      });
    }
  }
  function typeset({
    text = "",
    font = defaultFontURL,
    sdfGlyphSize = 64,
    fontSize = 1,
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback, metricsOnly = false) {
    const mainStart = now2();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    loadFont(font, (fontObj) => {
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;
      timings.fontLoad = now2() - mainStart;
      const typesetStart = now2();
      const fontSizeMult = fontSize / unitsPerEm;
      if (lineHeight === "normal") {
        lineHeight = (ascender - descender + lineGap) / unitsPerEm;
      }
      lineHeight = lineHeight * fontSize;
      const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;
      const topBaseline = -(ascender * fontSizeMult + halfLeading);
      const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);
      const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;
      let lineXOffset = textIndent;
      let currentLine = new TextLine();
      const lines = [currentLine];
      fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex) => {
        const char = text.charAt(charIndex);
        const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
        const curLineCount = currentLine.count;
        let nextLine;
        if (!("isEmpty" in glyphObj)) {
          glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);
          glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
          glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
        }
        if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
          renderableGlyphCount++;
        }
        if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
          if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
            nextLine = new TextLine();
            lineXOffset = -glyphX;
          } else {
            for (let i3 = curLineCount; i3--; ) {
              if (i3 === 0 && overflowWrap === "break-word") {
                nextLine = new TextLine();
                lineXOffset = -glyphX;
                break;
              } else if (currentLine.glyphAt(i3).glyphObj.canBreakAfter) {
                nextLine = currentLine.splitAt(i3 + 1);
                const adjustX = nextLine.glyphAt(0).x;
                lineXOffset -= adjustX;
                for (let j = nextLine.count; j--; ) {
                  nextLine.glyphAt(j).x -= adjustX;
                }
                break;
              }
            }
          }
          if (nextLine) {
            currentLine.isSoftWrapped = true;
            currentLine = nextLine;
            lines.push(currentLine);
            maxLineWidth = maxWidth;
          }
        }
        let fly = currentLine.glyphAt(currentLine.count);
        fly.glyphObj = glyphObj;
        fly.x = glyphX + lineXOffset;
        fly.width = glyphWidth;
        fly.charIndex = charIndex;
        if (char === "\n") {
          currentLine = new TextLine();
          lines.push(currentLine);
          lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
        }
      });
      lines.forEach((line) => {
        for (let i3 = line.count; i3--; ) {
          let { glyphObj, x, width } = line.glyphAt(i3);
          if (!glyphObj.isWhitespace) {
            line.width = x + width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            return;
          }
        }
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          let height = lines.length * lineHeight;
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -topBaseline : anchorY === "top-cap" ? -topBaseline - capHeight * fontSizeMult : anchorY === "top-ex" ? -topBaseline - xHeight * fontSizeMult : anchorY === "middle" ? height / 2 : anchorY === "bottom" ? height : anchorY === "bottom-baseline" ? height - halfLeading + descender * fontSizeMult : parsePercent(anchorY) * height;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        let lineYOffset = topBaseline;
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 3);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i3 = lineGlyphCount; i3-- && line.glyphAt(i3).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i3 = lineGlyphCount - trailingWhitespaceCount; i3--; ) {
                if (line.glyphAt(i3).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i3 = 0; i3 < lineGlyphCount; i3++) {
                let glyphInfo = line.glyphAt(i3);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i3 < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(
              text,
              bidiLevelsResult,
              line.glyphAt(0).charIndex,
              line.glyphAt(line.count - 1).charIndex
            );
            for (let fi = 0; fi < flips.length; fi++) {
              const [start2, end] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i3 = 0; i3 < lineGlyphCount; i3++) {
                if (line.glyphAt(i3).charIndex >= start2) {
                  let startInLine = i3, endInLine = i3;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j = startInLine; j < endInLine; j++) {
                    const glyphInfo = line.glyphAt(j);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g) => glyphObj = g;
            for (let i3 = 0; i3 < lineGlyphCount; i3++) {
              let glyphInfo = line.glyphAt(i3);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                if (!glyphData[glyphId]) {
                  glyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = lineYOffset + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0])
                  visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1])
                  visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2])
                  visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3])
                  visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0])
                  chunkRect[0] = visX0;
                if (visY0 < chunkRect[1])
                  chunkRect[1] = visY0;
                if (visX1 > chunkRect[2])
                  chunkRect[2] = visX1;
                if (visY1 > chunkRect[3])
                  chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                if (colorRanges) {
                  const start2 = idx * 3;
                  glyphColors[start2] = currentColor >> 16 & 255;
                  glyphColors[start2 + 1] = currentColor >> 8 & 255;
                  glyphColors[start2 + 2] = currentColor & 255;
                }
              }
            }
          }
          lineYOffset -= lineHeight;
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      timings.typesetting = now2() - typesetStart;
      callback({
        glyphIds,
        //font indices for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        caretHeight,
        //height of cursor from bottom to top
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        unitsPerEm,
        //font units per em
        ascender: ascender * fontSizeMult,
        //font ascender
        descender: descender * fontSizeMult,
        //font descender
        capHeight: capHeight * fontSizeMult,
        //font cap-height
        xHeight: xHeight * fontSizeMult,
        //font x-height
        lineHeight,
        //computed line height
        topBaseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          anchorXOffset,
          anchorYOffset - lines.length * lineHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset(args, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    }, { metricsOnly: true });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 3];
    const ligEndX = caretPositions[ligStartIndex * 3 + 1];
    const ligY = caretPositions[ligStartIndex * 3 + 2];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i3 = 0; i3 < ligCount; i3++) {
      const startIndex = (ligStartIndex + i3) * 3;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i3;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i3 + 1);
      caretPositions[startIndex + 2] = ligY;
    }
  }
  function now2() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "width", "charIndex"];
  TextLine.prototype = {
    width: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i3) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i3;
      return fly;
    },
    splitAt(i3) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i3 * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop, i3, all) => {
    Object.defineProperty(obj, prop, {
      get() {
        return this.data[this.index * textLineProps.length + i3];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i3] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure,
    loadFont
  };
}
var now = () => (self.performance || Date).now();
var mainThreadGenerator = SDFGenerator();
var warned;
function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {
  if (!useWebGL) {
    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);
  }
  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(
    null,
    (err) => {
      if (!warned) {
        console.warn(`WebGL SDF generation failed, falling back to JS`, err);
        warned = true;
      }
      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel);
    }
  );
}
var queue = [];
var chunkTimeBudget = 5;
var timer = 0;
function nextChunk() {
  const start2 = now();
  while (queue.length && now() - start2 < chunkTimeBudget) {
    queue.shift()();
  }
  timer = queue.length ? setTimeout(nextChunk, 0) : 0;
}
var generateSDF_GL = (...args) => {
  return new Promise((resolve2, reject) => {
    queue.push(() => {
      const start2 = now();
      try {
        mainThreadGenerator.webgl.generateIntoCanvas(...args);
        resolve2({ timing: now() - start2 });
      } catch (err) {
        reject(err);
      }
    });
    if (!timer) {
      timer = setTimeout(nextChunk, 0);
    }
  });
};
var threadCount = 4;
var idleTimeout = 2e3;
var threads = {};
var callNum = 0;
function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {
  const workerId = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
  let thread = threads[workerId];
  if (!thread) {
    thread = threads[workerId] = {
      workerModule: defineWorkerModule({
        name: workerId,
        workerId,
        dependencies: [
          SDFGenerator,
          now
        ],
        init(_createSDFGenerator, now2) {
          const generate = _createSDFGenerator().javascript.generate;
          return function(...args) {
            const start2 = now2();
            const textureData = generate(...args);
            return {
              textureData,
              timing: now2() - start2
            };
          };
        },
        getTransferables(result) {
          return [result.textureData.buffer];
        }
      }),
      requests: 0,
      idleTimer: null
    };
  }
  thread.requests++;
  clearTimeout(thread.idleTimer);
  return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({ textureData, timing }) => {
    const start2 = now();
    const imageData = new Uint8Array(textureData.length * 4);
    for (let i3 = 0; i3 < textureData.length; i3++) {
      imageData[i3 * 4 + channel] = textureData[i3];
    }
    mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << 3 - channel);
    timing += now() - start2;
    if (--thread.requests === 0) {
      thread.idleTimer = setTimeout(() => {
        terminateWorker(workerId);
      }, idleTimeout);
    }
    return { timing };
  });
}
function warmUpSDFCanvas(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
var resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
function typrFactory() {
  return "undefined" == typeof window && (self.window = self), function(r2) {
    var e2 = { parse: function(r3) {
      var t3 = e2._bin, a4 = new Uint8Array(r3);
      if ("ttcf" == t3.readASCII(a4, 0, 4)) {
        var n2 = 4;
        t3.readUshort(a4, n2), n2 += 2, t3.readUshort(a4, n2), n2 += 2;
        var o2 = t3.readUint(a4, n2);
        n2 += 4;
        for (var s2 = [], i3 = 0; i3 < o2; i3++) {
          var h = t3.readUint(a4, n2);
          n2 += 4, s2.push(e2._readFont(a4, h));
        }
        return s2;
      }
      return [e2._readFont(a4, 0)];
    }, _readFont: function(r3, t3) {
      var a4 = e2._bin, n2 = t3;
      a4.readFixed(r3, t3), t3 += 4;
      var o2 = a4.readUshort(r3, t3);
      t3 += 2, a4.readUshort(r3, t3), t3 += 2, a4.readUshort(r3, t3), t3 += 2, a4.readUshort(r3, t3), t3 += 2;
      for (var s2 = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], i3 = { _data: r3, _offset: n2 }, h = {}, f2 = 0; f2 < o2; f2++) {
        var d2 = a4.readASCII(r3, t3, 4);
        t3 += 4, a4.readUint(r3, t3), t3 += 4;
        var u = a4.readUint(r3, t3);
        t3 += 4;
        var l2 = a4.readUint(r3, t3);
        t3 += 4, h[d2] = { offset: u, length: l2 };
      }
      for (f2 = 0; f2 < s2.length; f2++) {
        var v4 = s2[f2];
        h[v4] && (i3[v4.trim()] = e2[v4.trim()].parse(r3, h[v4].offset, h[v4].length, i3));
      }
      return i3;
    }, _tabOffset: function(r3, t3, a4) {
      for (var n2 = e2._bin, o2 = n2.readUshort(r3, a4 + 4), s2 = a4 + 12, i3 = 0; i3 < o2; i3++) {
        var h = n2.readASCII(r3, s2, 4);
        s2 += 4, n2.readUint(r3, s2), s2 += 4;
        var f2 = n2.readUint(r3, s2);
        if (s2 += 4, n2.readUint(r3, s2), s2 += 4, h == t3)
          return f2;
      }
      return 0;
    } };
    e2._bin = { readFixed: function(r3, e3) {
      return (r3[e3] << 8 | r3[e3 + 1]) + (r3[e3 + 2] << 8 | r3[e3 + 3]) / 65540;
    }, readF2dot14: function(r3, t3) {
      return e2._bin.readShort(r3, t3) / 16384;
    }, readInt: function(r3, t3) {
      return e2._bin._view(r3).getInt32(t3);
    }, readInt8: function(r3, t3) {
      return e2._bin._view(r3).getInt8(t3);
    }, readShort: function(r3, t3) {
      return e2._bin._view(r3).getInt16(t3);
    }, readUshort: function(r3, t3) {
      return e2._bin._view(r3).getUint16(t3);
    }, readUshorts: function(r3, t3, a4) {
      for (var n2 = [], o2 = 0; o2 < a4; o2++)
        n2.push(e2._bin.readUshort(r3, t3 + 2 * o2));
      return n2;
    }, readUint: function(r3, t3) {
      return e2._bin._view(r3).getUint32(t3);
    }, readUint64: function(r3, t3) {
      return 4294967296 * e2._bin.readUint(r3, t3) + e2._bin.readUint(r3, t3 + 4);
    }, readASCII: function(r3, e3, t3) {
      for (var a4 = "", n2 = 0; n2 < t3; n2++)
        a4 += String.fromCharCode(r3[e3 + n2]);
      return a4;
    }, readUnicode: function(r3, e3, t3) {
      for (var a4 = "", n2 = 0; n2 < t3; n2++) {
        var o2 = r3[e3++] << 8 | r3[e3++];
        a4 += String.fromCharCode(o2);
      }
      return a4;
    }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r3, t3, a4) {
      var n2 = e2._bin._tdec;
      return n2 && 0 == t3 && a4 == r3.length ? n2.decode(r3) : e2._bin.readASCII(r3, t3, a4);
    }, readBytes: function(r3, e3, t3) {
      for (var a4 = [], n2 = 0; n2 < t3; n2++)
        a4.push(r3[e3 + n2]);
      return a4;
    }, readASCIIArray: function(r3, e3, t3) {
      for (var a4 = [], n2 = 0; n2 < t3; n2++)
        a4.push(String.fromCharCode(r3[e3 + n2]));
      return a4;
    }, _view: function(r3) {
      return r3._dataView || (r3._dataView = r3.buffer ? new DataView(r3.buffer, r3.byteOffset, r3.byteLength) : new DataView(new Uint8Array(r3).buffer));
    } }, e2._lctf = {}, e2._lctf.parse = function(r3, t3, a4, n2, o2) {
      var s2 = e2._bin, i3 = {}, h = t3;
      s2.readFixed(r3, t3), t3 += 4;
      var f2 = s2.readUshort(r3, t3);
      t3 += 2;
      var d2 = s2.readUshort(r3, t3);
      t3 += 2;
      var u = s2.readUshort(r3, t3);
      return t3 += 2, i3.scriptList = e2._lctf.readScriptList(r3, h + f2), i3.featureList = e2._lctf.readFeatureList(r3, h + d2), i3.lookupList = e2._lctf.readLookupList(r3, h + u, o2), i3;
    }, e2._lctf.readLookupList = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = t3, s2 = [], i3 = n2.readUshort(r3, t3);
      t3 += 2;
      for (var h = 0; h < i3; h++) {
        var f2 = n2.readUshort(r3, t3);
        t3 += 2;
        var d2 = e2._lctf.readLookupTable(r3, o2 + f2, a4);
        s2.push(d2);
      }
      return s2;
    }, e2._lctf.readLookupTable = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = t3, s2 = { tabs: [] };
      s2.ltype = n2.readUshort(r3, t3), t3 += 2, s2.flag = n2.readUshort(r3, t3), t3 += 2;
      var i3 = n2.readUshort(r3, t3);
      t3 += 2;
      for (var h = s2.ltype, f2 = 0; f2 < i3; f2++) {
        var d2 = n2.readUshort(r3, t3);
        t3 += 2;
        var u = a4(r3, h, o2 + d2, s2);
        s2.tabs.push(u);
      }
      return s2;
    }, e2._lctf.numOfOnes = function(r3) {
      for (var e3 = 0, t3 = 0; t3 < 32; t3++)
        0 != (r3 >>> t3 & 1) && e3++;
      return e3;
    }, e2._lctf.readClassDef = function(r3, t3) {
      var a4 = e2._bin, n2 = [], o2 = a4.readUshort(r3, t3);
      if (t3 += 2, 1 == o2) {
        var s2 = a4.readUshort(r3, t3);
        t3 += 2;
        var i3 = a4.readUshort(r3, t3);
        t3 += 2;
        for (var h = 0; h < i3; h++)
          n2.push(s2 + h), n2.push(s2 + h), n2.push(a4.readUshort(r3, t3)), t3 += 2;
      }
      if (2 == o2) {
        var f2 = a4.readUshort(r3, t3);
        t3 += 2;
        for (h = 0; h < f2; h++)
          n2.push(a4.readUshort(r3, t3)), t3 += 2, n2.push(a4.readUshort(r3, t3)), t3 += 2, n2.push(a4.readUshort(r3, t3)), t3 += 2;
      }
      return n2;
    }, e2._lctf.getInterval = function(r3, e3) {
      for (var t3 = 0; t3 < r3.length; t3 += 3) {
        var a4 = r3[t3], n2 = r3[t3 + 1];
        if (r3[t3 + 2], a4 <= e3 && e3 <= n2)
          return t3;
      }
      return -1;
    }, e2._lctf.readCoverage = function(r3, t3) {
      var a4 = e2._bin, n2 = {};
      n2.fmt = a4.readUshort(r3, t3), t3 += 2;
      var o2 = a4.readUshort(r3, t3);
      return t3 += 2, 1 == n2.fmt && (n2.tab = a4.readUshorts(r3, t3, o2)), 2 == n2.fmt && (n2.tab = a4.readUshorts(r3, t3, 3 * o2)), n2;
    }, e2._lctf.coverageIndex = function(r3, t3) {
      var a4 = r3.tab;
      if (1 == r3.fmt)
        return a4.indexOf(t3);
      if (2 == r3.fmt) {
        var n2 = e2._lctf.getInterval(a4, t3);
        if (-1 != n2)
          return a4[n2 + 2] + (t3 - a4[n2]);
      }
      return -1;
    }, e2._lctf.readFeatureList = function(r3, t3) {
      var a4 = e2._bin, n2 = t3, o2 = [], s2 = a4.readUshort(r3, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s2; i3++) {
        var h = a4.readASCII(r3, t3, 4);
        t3 += 4;
        var f2 = a4.readUshort(r3, t3);
        t3 += 2;
        var d2 = e2._lctf.readFeatureTable(r3, n2 + f2);
        d2.tag = h.trim(), o2.push(d2);
      }
      return o2;
    }, e2._lctf.readFeatureTable = function(r3, t3) {
      var a4 = e2._bin, n2 = t3, o2 = {}, s2 = a4.readUshort(r3, t3);
      t3 += 2, s2 > 0 && (o2.featureParams = n2 + s2);
      var i3 = a4.readUshort(r3, t3);
      t3 += 2, o2.tab = [];
      for (var h = 0; h < i3; h++)
        o2.tab.push(a4.readUshort(r3, t3 + 2 * h));
      return o2;
    }, e2._lctf.readScriptList = function(r3, t3) {
      var a4 = e2._bin, n2 = t3, o2 = {}, s2 = a4.readUshort(r3, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s2; i3++) {
        var h = a4.readASCII(r3, t3, 4);
        t3 += 4;
        var f2 = a4.readUshort(r3, t3);
        t3 += 2, o2[h.trim()] = e2._lctf.readScriptTable(r3, n2 + f2);
      }
      return o2;
    }, e2._lctf.readScriptTable = function(r3, t3) {
      var a4 = e2._bin, n2 = t3, o2 = {}, s2 = a4.readUshort(r3, t3);
      t3 += 2, o2.default = e2._lctf.readLangSysTable(r3, n2 + s2);
      var i3 = a4.readUshort(r3, t3);
      t3 += 2;
      for (var h = 0; h < i3; h++) {
        var f2 = a4.readASCII(r3, t3, 4);
        t3 += 4;
        var d2 = a4.readUshort(r3, t3);
        t3 += 2, o2[f2.trim()] = e2._lctf.readLangSysTable(r3, n2 + d2);
      }
      return o2;
    }, e2._lctf.readLangSysTable = function(r3, t3) {
      var a4 = e2._bin, n2 = {};
      a4.readUshort(r3, t3), t3 += 2, n2.reqFeature = a4.readUshort(r3, t3), t3 += 2;
      var o2 = a4.readUshort(r3, t3);
      return t3 += 2, n2.features = a4.readUshorts(r3, t3, o2), n2;
    }, e2.CFF = {}, e2.CFF.parse = function(r3, t3, a4) {
      var n2 = e2._bin;
      (r3 = new Uint8Array(r3.buffer, t3, a4))[t3 = 0], r3[++t3], r3[++t3], r3[++t3], t3++;
      var o2 = [];
      t3 = e2.CFF.readIndex(r3, t3, o2);
      for (var s2 = [], i3 = 0; i3 < o2.length - 1; i3++)
        s2.push(n2.readASCII(r3, t3 + o2[i3], o2[i3 + 1] - o2[i3]));
      t3 += o2[o2.length - 1];
      var h = [];
      t3 = e2.CFF.readIndex(r3, t3, h);
      var f2 = [];
      for (i3 = 0; i3 < h.length - 1; i3++)
        f2.push(e2.CFF.readDict(r3, t3 + h[i3], t3 + h[i3 + 1]));
      t3 += h[h.length - 1];
      var d2 = f2[0], u = [];
      t3 = e2.CFF.readIndex(r3, t3, u);
      var l2 = [];
      for (i3 = 0; i3 < u.length - 1; i3++)
        l2.push(n2.readASCII(r3, t3 + u[i3], u[i3 + 1] - u[i3]));
      if (t3 += u[u.length - 1], e2.CFF.readSubrs(r3, t3, d2), d2.CharStrings) {
        t3 = d2.CharStrings;
        u = [];
        t3 = e2.CFF.readIndex(r3, t3, u);
        var v4 = [];
        for (i3 = 0; i3 < u.length - 1; i3++)
          v4.push(n2.readBytes(r3, t3 + u[i3], u[i3 + 1] - u[i3]));
        d2.CharStrings = v4;
      }
      if (d2.ROS) {
        t3 = d2.FDArray;
        var c6 = [];
        t3 = e2.CFF.readIndex(r3, t3, c6), d2.FDArray = [];
        for (i3 = 0; i3 < c6.length - 1; i3++) {
          var p = e2.CFF.readDict(r3, t3 + c6[i3], t3 + c6[i3 + 1]);
          e2.CFF._readFDict(r3, p, l2), d2.FDArray.push(p);
        }
        t3 += c6[c6.length - 1], t3 = d2.FDSelect, d2.FDSelect = [];
        var U = r3[t3];
        if (t3++, 3 != U)
          throw U;
        var g = n2.readUshort(r3, t3);
        t3 += 2;
        for (i3 = 0; i3 < g + 1; i3++)
          d2.FDSelect.push(n2.readUshort(r3, t3), r3[t3 + 2]), t3 += 3;
      }
      return d2.Encoding && (d2.Encoding = e2.CFF.readEncoding(r3, d2.Encoding, d2.CharStrings.length)), d2.charset && (d2.charset = e2.CFF.readCharset(r3, d2.charset, d2.CharStrings.length)), e2.CFF._readFDict(r3, d2, l2), d2;
    }, e2.CFF._readFDict = function(r3, t3, a4) {
      var n2;
      for (var o2 in t3.Private && (n2 = t3.Private[1], t3.Private = e2.CFF.readDict(r3, n2, n2 + t3.Private[0]), t3.Private.Subrs && e2.CFF.readSubrs(r3, n2 + t3.Private.Subrs, t3.Private)), t3)
        -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o2) && (t3[o2] = a4[t3[o2] - 426 + 35]);
    }, e2.CFF.readSubrs = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = [];
      t3 = e2.CFF.readIndex(r3, t3, o2);
      var s2, i3 = o2.length;
      s2 = i3 < 1240 ? 107 : i3 < 33900 ? 1131 : 32768, a4.Bias = s2, a4.Subrs = [];
      for (var h = 0; h < o2.length - 1; h++)
        a4.Subrs.push(n2.readBytes(r3, t3 + o2[h], o2[h + 1] - o2[h]));
    }, e2.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e2.CFF.glyphByUnicode = function(r3, e3) {
      for (var t3 = 0; t3 < r3.charset.length; t3++)
        if (r3.charset[t3] == e3)
          return t3;
      return -1;
    }, e2.CFF.glyphBySE = function(r3, t3) {
      return t3 < 0 || t3 > 255 ? -1 : e2.CFF.glyphByUnicode(r3, e2.CFF.tableSE[t3]);
    }, e2.CFF.readEncoding = function(r3, t3, a4) {
      e2._bin;
      var n2 = [".notdef"], o2 = r3[t3];
      if (t3++, 0 != o2)
        throw "error: unknown encoding format: " + o2;
      var s2 = r3[t3];
      t3++;
      for (var i3 = 0; i3 < s2; i3++)
        n2.push(r3[t3 + i3]);
      return n2;
    }, e2.CFF.readCharset = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = [".notdef"], s2 = r3[t3];
      if (t3++, 0 == s2)
        for (var i3 = 0; i3 < a4; i3++) {
          var h = n2.readUshort(r3, t3);
          t3 += 2, o2.push(h);
        }
      else {
        if (1 != s2 && 2 != s2)
          throw "error: format: " + s2;
        for (; o2.length < a4; ) {
          h = n2.readUshort(r3, t3);
          t3 += 2;
          var f2 = 0;
          1 == s2 ? (f2 = r3[t3], t3++) : (f2 = n2.readUshort(r3, t3), t3 += 2);
          for (i3 = 0; i3 <= f2; i3++)
            o2.push(h), h++;
        }
      }
      return o2;
    }, e2.CFF.readIndex = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = n2.readUshort(r3, t3) + 1, s2 = r3[t3 += 2];
      if (t3++, 1 == s2)
        for (var i3 = 0; i3 < o2; i3++)
          a4.push(r3[t3 + i3]);
      else if (2 == s2)
        for (i3 = 0; i3 < o2; i3++)
          a4.push(n2.readUshort(r3, t3 + 2 * i3));
      else if (3 == s2)
        for (i3 = 0; i3 < o2; i3++)
          a4.push(16777215 & n2.readUint(r3, t3 + 3 * i3 - 1));
      else if (1 != o2)
        throw "unsupported offset size: " + s2 + ", count: " + o2;
      return (t3 += o2 * s2) - 1;
    }, e2.CFF.getCharString = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = r3[t3], s2 = r3[t3 + 1];
      r3[t3 + 2], r3[t3 + 3], r3[t3 + 4];
      var i3 = 1, h = null, f2 = null;
      o2 <= 20 && (h = o2, i3 = 1), 12 == o2 && (h = 100 * o2 + s2, i3 = 2), 21 <= o2 && o2 <= 27 && (h = o2, i3 = 1), 28 == o2 && (f2 = n2.readShort(r3, t3 + 1), i3 = 3), 29 <= o2 && o2 <= 31 && (h = o2, i3 = 1), 32 <= o2 && o2 <= 246 && (f2 = o2 - 139, i3 = 1), 247 <= o2 && o2 <= 250 && (f2 = 256 * (o2 - 247) + s2 + 108, i3 = 2), 251 <= o2 && o2 <= 254 && (f2 = 256 * -(o2 - 251) - s2 - 108, i3 = 2), 255 == o2 && (f2 = n2.readInt(r3, t3 + 1) / 65535, i3 = 5), a4.val = null != f2 ? f2 : "o" + h, a4.size = i3;
    }, e2.CFF.readCharString = function(r3, t3, a4) {
      for (var n2 = t3 + a4, o2 = e2._bin, s2 = []; t3 < n2; ) {
        var i3 = r3[t3], h = r3[t3 + 1];
        r3[t3 + 2], r3[t3 + 3], r3[t3 + 4];
        var f2 = 1, d2 = null, u = null;
        i3 <= 20 && (d2 = i3, f2 = 1), 12 == i3 && (d2 = 100 * i3 + h, f2 = 2), 19 != i3 && 20 != i3 || (d2 = i3, f2 = 2), 21 <= i3 && i3 <= 27 && (d2 = i3, f2 = 1), 28 == i3 && (u = o2.readShort(r3, t3 + 1), f2 = 3), 29 <= i3 && i3 <= 31 && (d2 = i3, f2 = 1), 32 <= i3 && i3 <= 246 && (u = i3 - 139, f2 = 1), 247 <= i3 && i3 <= 250 && (u = 256 * (i3 - 247) + h + 108, f2 = 2), 251 <= i3 && i3 <= 254 && (u = 256 * -(i3 - 251) - h - 108, f2 = 2), 255 == i3 && (u = o2.readInt(r3, t3 + 1) / 65535, f2 = 5), s2.push(null != u ? u : "o" + d2), t3 += f2;
      }
      return s2;
    }, e2.CFF.readDict = function(r3, t3, a4) {
      for (var n2 = e2._bin, o2 = {}, s2 = []; t3 < a4; ) {
        var i3 = r3[t3], h = r3[t3 + 1];
        r3[t3 + 2], r3[t3 + 3], r3[t3 + 4];
        var f2 = 1, d2 = null, u = null;
        if (28 == i3 && (u = n2.readShort(r3, t3 + 1), f2 = 3), 29 == i3 && (u = n2.readInt(r3, t3 + 1), f2 = 5), 32 <= i3 && i3 <= 246 && (u = i3 - 139, f2 = 1), 247 <= i3 && i3 <= 250 && (u = 256 * (i3 - 247) + h + 108, f2 = 2), 251 <= i3 && i3 <= 254 && (u = 256 * -(i3 - 251) - h - 108, f2 = 2), 255 == i3)
          throw u = n2.readInt(r3, t3 + 1) / 65535, f2 = 5, "unknown number";
        if (30 == i3) {
          var l2 = [];
          for (f2 = 1; ; ) {
            var v4 = r3[t3 + f2];
            f2++;
            var c6 = v4 >> 4, p = 15 & v4;
            if (15 != c6 && l2.push(c6), 15 != p && l2.push(p), 15 == p)
              break;
          }
          for (var U = "", g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < l2.length; S++)
            U += g[l2[S]];
          u = parseFloat(U);
        }
        if (i3 <= 21) {
          if (d2 = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i3], f2 = 1, 12 == i3)
            d2 = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], f2 = 2;
        }
        null != d2 ? (o2[d2] = 1 == s2.length ? s2[0] : s2, s2 = []) : s2.push(u), t3 += f2;
      }
      return o2;
    }, e2.cmap = {}, e2.cmap.parse = function(r3, t3, a4) {
      r3 = new Uint8Array(r3.buffer, t3, a4), t3 = 0;
      var n2 = e2._bin, o2 = {};
      n2.readUshort(r3, t3), t3 += 2;
      var s2 = n2.readUshort(r3, t3);
      t3 += 2;
      var i3 = [];
      o2.tables = [];
      for (var h = 0; h < s2; h++) {
        var f2 = n2.readUshort(r3, t3);
        t3 += 2;
        var d2 = n2.readUshort(r3, t3);
        t3 += 2;
        var u = n2.readUint(r3, t3);
        t3 += 4;
        var l2 = "p" + f2 + "e" + d2, v4 = i3.indexOf(u);
        if (-1 == v4) {
          var c6;
          v4 = o2.tables.length, i3.push(u);
          var p = n2.readUshort(r3, u);
          0 == p ? c6 = e2.cmap.parse0(r3, u) : 4 == p ? c6 = e2.cmap.parse4(r3, u) : 6 == p ? c6 = e2.cmap.parse6(r3, u) : 12 == p ? c6 = e2.cmap.parse12(r3, u) : console.debug("unknown format: " + p, f2, d2, u), o2.tables.push(c6);
        }
        if (null != o2[l2])
          throw "multiple tables for one platform+encoding";
        o2[l2] = v4;
      }
      return o2;
    }, e2.cmap.parse0 = function(r3, t3) {
      var a4 = e2._bin, n2 = {};
      n2.format = a4.readUshort(r3, t3), t3 += 2;
      var o2 = a4.readUshort(r3, t3);
      t3 += 2, a4.readUshort(r3, t3), t3 += 2, n2.map = [];
      for (var s2 = 0; s2 < o2 - 6; s2++)
        n2.map.push(r3[t3 + s2]);
      return n2;
    }, e2.cmap.parse4 = function(r3, t3) {
      var a4 = e2._bin, n2 = t3, o2 = {};
      o2.format = a4.readUshort(r3, t3), t3 += 2;
      var s2 = a4.readUshort(r3, t3);
      t3 += 2, a4.readUshort(r3, t3), t3 += 2;
      var i3 = a4.readUshort(r3, t3);
      t3 += 2;
      var h = i3 / 2;
      o2.searchRange = a4.readUshort(r3, t3), t3 += 2, o2.entrySelector = a4.readUshort(r3, t3), t3 += 2, o2.rangeShift = a4.readUshort(r3, t3), t3 += 2, o2.endCount = a4.readUshorts(r3, t3, h), t3 += 2 * h, t3 += 2, o2.startCount = a4.readUshorts(r3, t3, h), t3 += 2 * h, o2.idDelta = [];
      for (var f2 = 0; f2 < h; f2++)
        o2.idDelta.push(a4.readShort(r3, t3)), t3 += 2;
      for (o2.idRangeOffset = a4.readUshorts(r3, t3, h), t3 += 2 * h, o2.glyphIdArray = []; t3 < n2 + s2; )
        o2.glyphIdArray.push(a4.readUshort(r3, t3)), t3 += 2;
      return o2;
    }, e2.cmap.parse6 = function(r3, t3) {
      var a4 = e2._bin, n2 = {};
      n2.format = a4.readUshort(r3, t3), t3 += 2, a4.readUshort(r3, t3), t3 += 2, a4.readUshort(r3, t3), t3 += 2, n2.firstCode = a4.readUshort(r3, t3), t3 += 2;
      var o2 = a4.readUshort(r3, t3);
      t3 += 2, n2.glyphIdArray = [];
      for (var s2 = 0; s2 < o2; s2++)
        n2.glyphIdArray.push(a4.readUshort(r3, t3)), t3 += 2;
      return n2;
    }, e2.cmap.parse12 = function(r3, t3) {
      var a4 = e2._bin, n2 = {};
      n2.format = a4.readUshort(r3, t3), t3 += 2, t3 += 2, a4.readUint(r3, t3), t3 += 4, a4.readUint(r3, t3), t3 += 4;
      var o2 = a4.readUint(r3, t3);
      t3 += 4, n2.groups = [];
      for (var s2 = 0; s2 < o2; s2++) {
        var i3 = t3 + 12 * s2, h = a4.readUint(r3, i3 + 0), f2 = a4.readUint(r3, i3 + 4), d2 = a4.readUint(r3, i3 + 8);
        n2.groups.push([h, f2, d2]);
      }
      return n2;
    }, e2.glyf = {}, e2.glyf.parse = function(r3, e3, t3, a4) {
      for (var n2 = [], o2 = 0; o2 < a4.maxp.numGlyphs; o2++)
        n2.push(null);
      return n2;
    }, e2.glyf._parseGlyf = function(r3, t3) {
      var a4 = e2._bin, n2 = r3._data, o2 = e2._tabOffset(n2, "glyf", r3._offset) + r3.loca[t3];
      if (r3.loca[t3] == r3.loca[t3 + 1])
        return null;
      var s2 = {};
      if (s2.noc = a4.readShort(n2, o2), o2 += 2, s2.xMin = a4.readShort(n2, o2), o2 += 2, s2.yMin = a4.readShort(n2, o2), o2 += 2, s2.xMax = a4.readShort(n2, o2), o2 += 2, s2.yMax = a4.readShort(n2, o2), o2 += 2, s2.xMin >= s2.xMax || s2.yMin >= s2.yMax)
        return null;
      if (s2.noc > 0) {
        s2.endPts = [];
        for (var i3 = 0; i3 < s2.noc; i3++)
          s2.endPts.push(a4.readUshort(n2, o2)), o2 += 2;
        var h = a4.readUshort(n2, o2);
        if (o2 += 2, n2.length - o2 < h)
          return null;
        s2.instructions = a4.readBytes(n2, o2, h), o2 += h;
        var f2 = s2.endPts[s2.noc - 1] + 1;
        s2.flags = [];
        for (i3 = 0; i3 < f2; i3++) {
          var d2 = n2[o2];
          if (o2++, s2.flags.push(d2), 0 != (8 & d2)) {
            var u = n2[o2];
            o2++;
            for (var l2 = 0; l2 < u; l2++)
              s2.flags.push(d2), i3++;
          }
        }
        s2.xs = [];
        for (i3 = 0; i3 < f2; i3++) {
          var v4 = 0 != (2 & s2.flags[i3]), c6 = 0 != (16 & s2.flags[i3]);
          v4 ? (s2.xs.push(c6 ? n2[o2] : -n2[o2]), o2++) : c6 ? s2.xs.push(0) : (s2.xs.push(a4.readShort(n2, o2)), o2 += 2);
        }
        s2.ys = [];
        for (i3 = 0; i3 < f2; i3++) {
          v4 = 0 != (4 & s2.flags[i3]), c6 = 0 != (32 & s2.flags[i3]);
          v4 ? (s2.ys.push(c6 ? n2[o2] : -n2[o2]), o2++) : c6 ? s2.ys.push(0) : (s2.ys.push(a4.readShort(n2, o2)), o2 += 2);
        }
        var p = 0, U = 0;
        for (i3 = 0; i3 < f2; i3++)
          p += s2.xs[i3], U += s2.ys[i3], s2.xs[i3] = p, s2.ys[i3] = U;
      } else {
        var g;
        s2.parts = [];
        do {
          g = a4.readUshort(n2, o2), o2 += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s2.parts.push(S), S.glyphIndex = a4.readUshort(n2, o2), o2 += 2, 1 & g) {
            var m = a4.readShort(n2, o2);
            o2 += 2;
            var b = a4.readShort(n2, o2);
            o2 += 2;
          } else {
            m = a4.readInt8(n2, o2);
            o2++;
            b = a4.readInt8(n2, o2);
            o2++;
          }
          2 & g ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g ? (S.m.a = S.m.d = a4.readF2dot14(n2, o2), o2 += 2) : 64 & g ? (S.m.a = a4.readF2dot14(n2, o2), o2 += 2, S.m.d = a4.readF2dot14(n2, o2), o2 += 2) : 128 & g && (S.m.a = a4.readF2dot14(n2, o2), o2 += 2, S.m.b = a4.readF2dot14(n2, o2), o2 += 2, S.m.c = a4.readF2dot14(n2, o2), o2 += 2, S.m.d = a4.readF2dot14(n2, o2), o2 += 2);
        } while (32 & g);
        if (256 & g) {
          var y = a4.readUshort(n2, o2);
          o2 += 2, s2.instr = [];
          for (i3 = 0; i3 < y; i3++)
            s2.instr.push(n2[o2]), o2++;
        }
      }
      return s2;
    }, e2.GPOS = {}, e2.GPOS.parse = function(r3, t3, a4, n2) {
      return e2._lctf.parse(r3, t3, a4, n2, e2.GPOS.subt);
    }, e2.GPOS.subt = function(r3, t3, a4, n2) {
      var o2 = e2._bin, s2 = a4, i3 = {};
      if (i3.fmt = o2.readUshort(r3, a4), a4 += 2, 1 == t3 || 2 == t3 || 3 == t3 || 7 == t3 || 8 == t3 && i3.fmt <= 2) {
        var h = o2.readUshort(r3, a4);
        a4 += 2, i3.coverage = e2._lctf.readCoverage(r3, h + s2);
      }
      if (1 == t3 && 1 == i3.fmt) {
        var f2 = o2.readUshort(r3, a4);
        a4 += 2;
        var d2 = e2._lctf.numOfOnes(f2);
        0 != f2 && (i3.pos = e2.GPOS.readValueRecord(r3, a4, f2));
      } else if (2 == t3 && i3.fmt >= 1 && i3.fmt <= 2) {
        f2 = o2.readUshort(r3, a4);
        a4 += 2;
        var u = o2.readUshort(r3, a4);
        a4 += 2;
        d2 = e2._lctf.numOfOnes(f2);
        var l2 = e2._lctf.numOfOnes(u);
        if (1 == i3.fmt) {
          i3.pairsets = [];
          var v4 = o2.readUshort(r3, a4);
          a4 += 2;
          for (var c6 = 0; c6 < v4; c6++) {
            var p = s2 + o2.readUshort(r3, a4);
            a4 += 2;
            var U = o2.readUshort(r3, p);
            p += 2;
            for (var g = [], S = 0; S < U; S++) {
              var m = o2.readUshort(r3, p);
              p += 2, 0 != f2 && (x = e2.GPOS.readValueRecord(r3, p, f2), p += 2 * d2), 0 != u && (P = e2.GPOS.readValueRecord(r3, p, u), p += 2 * l2), g.push({ gid2: m, val1: x, val2: P });
            }
            i3.pairsets.push(g);
          }
        }
        if (2 == i3.fmt) {
          var b = o2.readUshort(r3, a4);
          a4 += 2;
          var y = o2.readUshort(r3, a4);
          a4 += 2;
          var F = o2.readUshort(r3, a4);
          a4 += 2;
          var _ = o2.readUshort(r3, a4);
          a4 += 2, i3.classDef1 = e2._lctf.readClassDef(r3, s2 + b), i3.classDef2 = e2._lctf.readClassDef(r3, s2 + y), i3.matrix = [];
          for (c6 = 0; c6 < F; c6++) {
            var C = [];
            for (S = 0; S < _; S++) {
              var x = null, P = null;
              0 != f2 && (x = e2.GPOS.readValueRecord(r3, a4, f2), a4 += 2 * d2), 0 != u && (P = e2.GPOS.readValueRecord(r3, a4, u), a4 += 2 * l2), C.push({ val1: x, val2: P });
            }
            i3.matrix.push(C);
          }
        }
      } else {
        if (9 == t3 && 1 == i3.fmt) {
          var I = o2.readUshort(r3, a4);
          a4 += 2;
          var w = o2.readUint(r3, a4);
          if (a4 += 4, 9 == n2.ltype)
            n2.ltype = I;
          else if (n2.ltype != I)
            throw "invalid extension substitution";
          return e2.GPOS.subt(r3, n2.ltype, s2 + w);
        }
        console.debug("unsupported GPOS table LookupType", t3, "format", i3.fmt);
      }
      return i3;
    }, e2.GPOS.readValueRecord = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = [];
      return o2.push(1 & a4 ? n2.readShort(r3, t3) : 0), t3 += 1 & a4 ? 2 : 0, o2.push(2 & a4 ? n2.readShort(r3, t3) : 0), t3 += 2 & a4 ? 2 : 0, o2.push(4 & a4 ? n2.readShort(r3, t3) : 0), t3 += 4 & a4 ? 2 : 0, o2.push(8 & a4 ? n2.readShort(r3, t3) : 0), t3 += 8 & a4 ? 2 : 0, o2;
    }, e2.GSUB = {}, e2.GSUB.parse = function(r3, t3, a4, n2) {
      return e2._lctf.parse(r3, t3, a4, n2, e2.GSUB.subt);
    }, e2.GSUB.subt = function(r3, t3, a4, n2) {
      var o2 = e2._bin, s2 = a4, i3 = {};
      if (i3.fmt = o2.readUshort(r3, a4), a4 += 2, 1 != t3 && 4 != t3 && 5 != t3 && 6 != t3)
        return null;
      if (1 == t3 || 4 == t3 || 5 == t3 && i3.fmt <= 2 || 6 == t3 && i3.fmt <= 2) {
        var h = o2.readUshort(r3, a4);
        a4 += 2, i3.coverage = e2._lctf.readCoverage(r3, s2 + h);
      }
      if (1 == t3 && i3.fmt >= 1 && i3.fmt <= 2) {
        if (1 == i3.fmt)
          i3.delta = o2.readShort(r3, a4), a4 += 2;
        else if (2 == i3.fmt) {
          var f2 = o2.readUshort(r3, a4);
          a4 += 2, i3.newg = o2.readUshorts(r3, a4, f2), a4 += 2 * i3.newg.length;
        }
      } else if (4 == t3) {
        i3.vals = [];
        f2 = o2.readUshort(r3, a4);
        a4 += 2;
        for (var d2 = 0; d2 < f2; d2++) {
          var u = o2.readUshort(r3, a4);
          a4 += 2, i3.vals.push(e2.GSUB.readLigatureSet(r3, s2 + u));
        }
      } else if (5 == t3 && 2 == i3.fmt) {
        if (2 == i3.fmt) {
          var l2 = o2.readUshort(r3, a4);
          a4 += 2, i3.cDef = e2._lctf.readClassDef(r3, s2 + l2), i3.scset = [];
          var v4 = o2.readUshort(r3, a4);
          a4 += 2;
          for (d2 = 0; d2 < v4; d2++) {
            var c6 = o2.readUshort(r3, a4);
            a4 += 2, i3.scset.push(0 == c6 ? null : e2.GSUB.readSubClassSet(r3, s2 + c6));
          }
        }
      } else if (6 == t3 && 3 == i3.fmt) {
        if (3 == i3.fmt) {
          for (d2 = 0; d2 < 3; d2++) {
            f2 = o2.readUshort(r3, a4);
            a4 += 2;
            for (var p = [], U = 0; U < f2; U++)
              p.push(e2._lctf.readCoverage(r3, s2 + o2.readUshort(r3, a4 + 2 * U)));
            a4 += 2 * f2, 0 == d2 && (i3.backCvg = p), 1 == d2 && (i3.inptCvg = p), 2 == d2 && (i3.ahedCvg = p);
          }
          f2 = o2.readUshort(r3, a4);
          a4 += 2, i3.lookupRec = e2.GSUB.readSubstLookupRecords(r3, a4, f2);
        }
      } else {
        if (7 == t3 && 1 == i3.fmt) {
          var g = o2.readUshort(r3, a4);
          a4 += 2;
          var S = o2.readUint(r3, a4);
          if (a4 += 4, 9 == n2.ltype)
            n2.ltype = g;
          else if (n2.ltype != g)
            throw "invalid extension substitution";
          return e2.GSUB.subt(r3, n2.ltype, s2 + S);
        }
        console.debug("unsupported GSUB table LookupType", t3, "format", i3.fmt);
      }
      return i3;
    }, e2.GSUB.readSubClassSet = function(r3, t3) {
      var a4 = e2._bin.readUshort, n2 = t3, o2 = [], s2 = a4(r3, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s2; i3++) {
        var h = a4(r3, t3);
        t3 += 2, o2.push(e2.GSUB.readSubClassRule(r3, n2 + h));
      }
      return o2;
    }, e2.GSUB.readSubClassRule = function(r3, t3) {
      var a4 = e2._bin.readUshort, n2 = {}, o2 = a4(r3, t3), s2 = a4(r3, t3 += 2);
      t3 += 2, n2.input = [];
      for (var i3 = 0; i3 < o2 - 1; i3++)
        n2.input.push(a4(r3, t3)), t3 += 2;
      return n2.substLookupRecords = e2.GSUB.readSubstLookupRecords(r3, t3, s2), n2;
    }, e2.GSUB.readSubstLookupRecords = function(r3, t3, a4) {
      for (var n2 = e2._bin.readUshort, o2 = [], s2 = 0; s2 < a4; s2++)
        o2.push(n2(r3, t3), n2(r3, t3 + 2)), t3 += 4;
      return o2;
    }, e2.GSUB.readChainSubClassSet = function(r3, t3) {
      var a4 = e2._bin, n2 = t3, o2 = [], s2 = a4.readUshort(r3, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s2; i3++) {
        var h = a4.readUshort(r3, t3);
        t3 += 2, o2.push(e2.GSUB.readChainSubClassRule(r3, n2 + h));
      }
      return o2;
    }, e2.GSUB.readChainSubClassRule = function(r3, t3) {
      for (var a4 = e2._bin, n2 = {}, o2 = ["backtrack", "input", "lookahead"], s2 = 0; s2 < o2.length; s2++) {
        var i3 = a4.readUshort(r3, t3);
        t3 += 2, 1 == s2 && i3--, n2[o2[s2]] = a4.readUshorts(r3, t3, i3), t3 += 2 * n2[o2[s2]].length;
      }
      i3 = a4.readUshort(r3, t3);
      return t3 += 2, n2.subst = a4.readUshorts(r3, t3, 2 * i3), t3 += 2 * n2.subst.length, n2;
    }, e2.GSUB.readLigatureSet = function(r3, t3) {
      var a4 = e2._bin, n2 = t3, o2 = [], s2 = a4.readUshort(r3, t3);
      t3 += 2;
      for (var i3 = 0; i3 < s2; i3++) {
        var h = a4.readUshort(r3, t3);
        t3 += 2, o2.push(e2.GSUB.readLigature(r3, n2 + h));
      }
      return o2;
    }, e2.GSUB.readLigature = function(r3, t3) {
      var a4 = e2._bin, n2 = { chain: [] };
      n2.nglyph = a4.readUshort(r3, t3), t3 += 2;
      var o2 = a4.readUshort(r3, t3);
      t3 += 2;
      for (var s2 = 0; s2 < o2 - 1; s2++)
        n2.chain.push(a4.readUshort(r3, t3)), t3 += 2;
      return n2;
    }, e2.head = {}, e2.head.parse = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = {};
      return n2.readFixed(r3, t3), t3 += 4, o2.fontRevision = n2.readFixed(r3, t3), t3 += 4, n2.readUint(r3, t3), t3 += 4, n2.readUint(r3, t3), t3 += 4, o2.flags = n2.readUshort(r3, t3), t3 += 2, o2.unitsPerEm = n2.readUshort(r3, t3), t3 += 2, o2.created = n2.readUint64(r3, t3), t3 += 8, o2.modified = n2.readUint64(r3, t3), t3 += 8, o2.xMin = n2.readShort(r3, t3), t3 += 2, o2.yMin = n2.readShort(r3, t3), t3 += 2, o2.xMax = n2.readShort(r3, t3), t3 += 2, o2.yMax = n2.readShort(r3, t3), t3 += 2, o2.macStyle = n2.readUshort(r3, t3), t3 += 2, o2.lowestRecPPEM = n2.readUshort(r3, t3), t3 += 2, o2.fontDirectionHint = n2.readShort(r3, t3), t3 += 2, o2.indexToLocFormat = n2.readShort(r3, t3), t3 += 2, o2.glyphDataFormat = n2.readShort(r3, t3), t3 += 2, o2;
    }, e2.hhea = {}, e2.hhea.parse = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = {};
      return n2.readFixed(r3, t3), t3 += 4, o2.ascender = n2.readShort(r3, t3), t3 += 2, o2.descender = n2.readShort(r3, t3), t3 += 2, o2.lineGap = n2.readShort(r3, t3), t3 += 2, o2.advanceWidthMax = n2.readUshort(r3, t3), t3 += 2, o2.minLeftSideBearing = n2.readShort(r3, t3), t3 += 2, o2.minRightSideBearing = n2.readShort(r3, t3), t3 += 2, o2.xMaxExtent = n2.readShort(r3, t3), t3 += 2, o2.caretSlopeRise = n2.readShort(r3, t3), t3 += 2, o2.caretSlopeRun = n2.readShort(r3, t3), t3 += 2, o2.caretOffset = n2.readShort(r3, t3), t3 += 2, t3 += 8, o2.metricDataFormat = n2.readShort(r3, t3), t3 += 2, o2.numberOfHMetrics = n2.readUshort(r3, t3), t3 += 2, o2;
    }, e2.hmtx = {}, e2.hmtx.parse = function(r3, t3, a4, n2) {
      for (var o2 = e2._bin, s2 = { aWidth: [], lsBearing: [] }, i3 = 0, h = 0, f2 = 0; f2 < n2.maxp.numGlyphs; f2++)
        f2 < n2.hhea.numberOfHMetrics && (i3 = o2.readUshort(r3, t3), t3 += 2, h = o2.readShort(r3, t3), t3 += 2), s2.aWidth.push(i3), s2.lsBearing.push(h);
      return s2;
    }, e2.kern = {}, e2.kern.parse = function(r3, t3, a4, n2) {
      var o2 = e2._bin, s2 = o2.readUshort(r3, t3);
      if (t3 += 2, 1 == s2)
        return e2.kern.parseV1(r3, t3 - 2, a4, n2);
      var i3 = o2.readUshort(r3, t3);
      t3 += 2;
      for (var h = { glyph1: [], rval: [] }, f2 = 0; f2 < i3; f2++) {
        t3 += 2;
        a4 = o2.readUshort(r3, t3);
        t3 += 2;
        var d2 = o2.readUshort(r3, t3);
        t3 += 2;
        var u = d2 >>> 8;
        if (0 != (u &= 15))
          throw "unknown kern table format: " + u;
        t3 = e2.kern.readFormat0(r3, t3, h);
      }
      return h;
    }, e2.kern.parseV1 = function(r3, t3, a4, n2) {
      var o2 = e2._bin;
      o2.readFixed(r3, t3), t3 += 4;
      var s2 = o2.readUint(r3, t3);
      t3 += 4;
      for (var i3 = { glyph1: [], rval: [] }, h = 0; h < s2; h++) {
        o2.readUint(r3, t3), t3 += 4;
        var f2 = o2.readUshort(r3, t3);
        t3 += 2, o2.readUshort(r3, t3), t3 += 2;
        var d2 = f2 >>> 8;
        if (0 != (d2 &= 15))
          throw "unknown kern table format: " + d2;
        t3 = e2.kern.readFormat0(r3, t3, i3);
      }
      return i3;
    }, e2.kern.readFormat0 = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = -1, s2 = n2.readUshort(r3, t3);
      t3 += 2, n2.readUshort(r3, t3), t3 += 2, n2.readUshort(r3, t3), t3 += 2, n2.readUshort(r3, t3), t3 += 2;
      for (var i3 = 0; i3 < s2; i3++) {
        var h = n2.readUshort(r3, t3);
        t3 += 2;
        var f2 = n2.readUshort(r3, t3);
        t3 += 2;
        var d2 = n2.readShort(r3, t3);
        t3 += 2, h != o2 && (a4.glyph1.push(h), a4.rval.push({ glyph2: [], vals: [] }));
        var u = a4.rval[a4.rval.length - 1];
        u.glyph2.push(f2), u.vals.push(d2), o2 = h;
      }
      return t3;
    }, e2.loca = {}, e2.loca.parse = function(r3, t3, a4, n2) {
      var o2 = e2._bin, s2 = [], i3 = n2.head.indexToLocFormat, h = n2.maxp.numGlyphs + 1;
      if (0 == i3)
        for (var f2 = 0; f2 < h; f2++)
          s2.push(o2.readUshort(r3, t3 + (f2 << 1)) << 1);
      if (1 == i3)
        for (f2 = 0; f2 < h; f2++)
          s2.push(o2.readUint(r3, t3 + (f2 << 2)));
      return s2;
    }, e2.maxp = {}, e2.maxp.parse = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = {}, s2 = n2.readUint(r3, t3);
      return t3 += 4, o2.numGlyphs = n2.readUshort(r3, t3), t3 += 2, 65536 == s2 && (o2.maxPoints = n2.readUshort(r3, t3), t3 += 2, o2.maxContours = n2.readUshort(r3, t3), t3 += 2, o2.maxCompositePoints = n2.readUshort(r3, t3), t3 += 2, o2.maxCompositeContours = n2.readUshort(r3, t3), t3 += 2, o2.maxZones = n2.readUshort(r3, t3), t3 += 2, o2.maxTwilightPoints = n2.readUshort(r3, t3), t3 += 2, o2.maxStorage = n2.readUshort(r3, t3), t3 += 2, o2.maxFunctionDefs = n2.readUshort(r3, t3), t3 += 2, o2.maxInstructionDefs = n2.readUshort(r3, t3), t3 += 2, o2.maxStackElements = n2.readUshort(r3, t3), t3 += 2, o2.maxSizeOfInstructions = n2.readUshort(r3, t3), t3 += 2, o2.maxComponentElements = n2.readUshort(r3, t3), t3 += 2, o2.maxComponentDepth = n2.readUshort(r3, t3), t3 += 2), o2;
    }, e2.name = {}, e2.name.parse = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = {};
      n2.readUshort(r3, t3), t3 += 2;
      var s2 = n2.readUshort(r3, t3);
      t3 += 2, n2.readUshort(r3, t3);
      for (var i3, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], f2 = t3 += 2, d2 = 0; d2 < s2; d2++) {
        var u = n2.readUshort(r3, t3);
        t3 += 2;
        var l2 = n2.readUshort(r3, t3);
        t3 += 2;
        var v4 = n2.readUshort(r3, t3);
        t3 += 2;
        var c6 = n2.readUshort(r3, t3);
        t3 += 2;
        var p = n2.readUshort(r3, t3);
        t3 += 2;
        var U = n2.readUshort(r3, t3);
        t3 += 2;
        var g, S = h[c6], m = f2 + 12 * s2 + U;
        if (0 == u)
          g = n2.readUnicode(r3, m, p / 2);
        else if (3 == u && 0 == l2)
          g = n2.readUnicode(r3, m, p / 2);
        else if (0 == l2)
          g = n2.readASCII(r3, m, p);
        else if (1 == l2)
          g = n2.readUnicode(r3, m, p / 2);
        else if (3 == l2)
          g = n2.readUnicode(r3, m, p / 2);
        else {
          if (1 != u)
            throw "unknown encoding " + l2 + ", platformID: " + u;
          g = n2.readASCII(r3, m, p), console.debug("reading unknown MAC encoding " + l2 + " as ASCII");
        }
        var b = "p" + u + "," + v4.toString(16);
        null == o2[b] && (o2[b] = {}), o2[b][void 0 !== S ? S : c6] = g, o2[b]._lang = v4;
      }
      for (var y in o2)
        if (null != o2[y].postScriptName && 1033 == o2[y]._lang)
          return o2[y];
      for (var y in o2)
        if (null != o2[y].postScriptName && 0 == o2[y]._lang)
          return o2[y];
      for (var y in o2)
        if (null != o2[y].postScriptName && 3084 == o2[y]._lang)
          return o2[y];
      for (var y in o2)
        if (null != o2[y].postScriptName)
          return o2[y];
      for (var y in o2) {
        i3 = y;
        break;
      }
      return console.debug("returning name table with languageID " + o2[i3]._lang), o2[i3];
    }, e2["OS/2"] = {}, e2["OS/2"].parse = function(r3, t3, a4) {
      var n2 = e2._bin.readUshort(r3, t3);
      t3 += 2;
      var o2 = {};
      if (0 == n2)
        e2["OS/2"].version0(r3, t3, o2);
      else if (1 == n2)
        e2["OS/2"].version1(r3, t3, o2);
      else if (2 == n2 || 3 == n2 || 4 == n2)
        e2["OS/2"].version2(r3, t3, o2);
      else {
        if (5 != n2)
          throw "unknown OS/2 table version: " + n2;
        e2["OS/2"].version5(r3, t3, o2);
      }
      return o2;
    }, e2["OS/2"].version0 = function(r3, t3, a4) {
      var n2 = e2._bin;
      return a4.xAvgCharWidth = n2.readShort(r3, t3), t3 += 2, a4.usWeightClass = n2.readUshort(r3, t3), t3 += 2, a4.usWidthClass = n2.readUshort(r3, t3), t3 += 2, a4.fsType = n2.readUshort(r3, t3), t3 += 2, a4.ySubscriptXSize = n2.readShort(r3, t3), t3 += 2, a4.ySubscriptYSize = n2.readShort(r3, t3), t3 += 2, a4.ySubscriptXOffset = n2.readShort(r3, t3), t3 += 2, a4.ySubscriptYOffset = n2.readShort(r3, t3), t3 += 2, a4.ySuperscriptXSize = n2.readShort(r3, t3), t3 += 2, a4.ySuperscriptYSize = n2.readShort(r3, t3), t3 += 2, a4.ySuperscriptXOffset = n2.readShort(r3, t3), t3 += 2, a4.ySuperscriptYOffset = n2.readShort(r3, t3), t3 += 2, a4.yStrikeoutSize = n2.readShort(r3, t3), t3 += 2, a4.yStrikeoutPosition = n2.readShort(r3, t3), t3 += 2, a4.sFamilyClass = n2.readShort(r3, t3), t3 += 2, a4.panose = n2.readBytes(r3, t3, 10), t3 += 10, a4.ulUnicodeRange1 = n2.readUint(r3, t3), t3 += 4, a4.ulUnicodeRange2 = n2.readUint(r3, t3), t3 += 4, a4.ulUnicodeRange3 = n2.readUint(r3, t3), t3 += 4, a4.ulUnicodeRange4 = n2.readUint(r3, t3), t3 += 4, a4.achVendID = [n2.readInt8(r3, t3), n2.readInt8(r3, t3 + 1), n2.readInt8(r3, t3 + 2), n2.readInt8(r3, t3 + 3)], t3 += 4, a4.fsSelection = n2.readUshort(r3, t3), t3 += 2, a4.usFirstCharIndex = n2.readUshort(r3, t3), t3 += 2, a4.usLastCharIndex = n2.readUshort(r3, t3), t3 += 2, a4.sTypoAscender = n2.readShort(r3, t3), t3 += 2, a4.sTypoDescender = n2.readShort(r3, t3), t3 += 2, a4.sTypoLineGap = n2.readShort(r3, t3), t3 += 2, a4.usWinAscent = n2.readUshort(r3, t3), t3 += 2, a4.usWinDescent = n2.readUshort(r3, t3), t3 += 2;
    }, e2["OS/2"].version1 = function(r3, t3, a4) {
      var n2 = e2._bin;
      return t3 = e2["OS/2"].version0(r3, t3, a4), a4.ulCodePageRange1 = n2.readUint(r3, t3), t3 += 4, a4.ulCodePageRange2 = n2.readUint(r3, t3), t3 += 4;
    }, e2["OS/2"].version2 = function(r3, t3, a4) {
      var n2 = e2._bin;
      return t3 = e2["OS/2"].version1(r3, t3, a4), a4.sxHeight = n2.readShort(r3, t3), t3 += 2, a4.sCapHeight = n2.readShort(r3, t3), t3 += 2, a4.usDefault = n2.readUshort(r3, t3), t3 += 2, a4.usBreak = n2.readUshort(r3, t3), t3 += 2, a4.usMaxContext = n2.readUshort(r3, t3), t3 += 2;
    }, e2["OS/2"].version5 = function(r3, t3, a4) {
      var n2 = e2._bin;
      return t3 = e2["OS/2"].version2(r3, t3, a4), a4.usLowerOpticalPointSize = n2.readUshort(r3, t3), t3 += 2, a4.usUpperOpticalPointSize = n2.readUshort(r3, t3), t3 += 2;
    }, e2.post = {}, e2.post.parse = function(r3, t3, a4) {
      var n2 = e2._bin, o2 = {};
      return o2.version = n2.readFixed(r3, t3), t3 += 4, o2.italicAngle = n2.readFixed(r3, t3), t3 += 4, o2.underlinePosition = n2.readShort(r3, t3), t3 += 2, o2.underlineThickness = n2.readShort(r3, t3), t3 += 2, o2;
    }, null == e2 && (e2 = {}), null == e2.U && (e2.U = {}), e2.U.codeToGlyph = function(r3, e3) {
      var t3 = r3.cmap, a4 = -1;
      if (null != t3.p0e4 ? a4 = t3.p0e4 : null != t3.p3e1 ? a4 = t3.p3e1 : null != t3.p1e0 ? a4 = t3.p1e0 : null != t3.p0e3 && (a4 = t3.p0e3), -1 == a4)
        throw "no familiar platform and encoding!";
      var n2 = t3.tables[a4];
      if (0 == n2.format)
        return e3 >= n2.map.length ? 0 : n2.map[e3];
      if (4 == n2.format) {
        for (var o2 = -1, s2 = 0; s2 < n2.endCount.length; s2++)
          if (e3 <= n2.endCount[s2]) {
            o2 = s2;
            break;
          }
        if (-1 == o2)
          return 0;
        if (n2.startCount[o2] > e3)
          return 0;
        return 65535 & (0 != n2.idRangeOffset[o2] ? n2.glyphIdArray[e3 - n2.startCount[o2] + (n2.idRangeOffset[o2] >> 1) - (n2.idRangeOffset.length - o2)] : e3 + n2.idDelta[o2]);
      }
      if (12 == n2.format) {
        if (e3 > n2.groups[n2.groups.length - 1][1])
          return 0;
        for (s2 = 0; s2 < n2.groups.length; s2++) {
          var i3 = n2.groups[s2];
          if (i3[0] <= e3 && e3 <= i3[1])
            return i3[2] + (e3 - i3[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n2.format;
    }, e2.U.glyphToPath = function(r3, t3) {
      var a4 = { cmds: [], crds: [] };
      if (r3.SVG && r3.SVG.entries[t3]) {
        var n2 = r3.SVG.entries[t3];
        return null == n2 ? a4 : ("string" == typeof n2 && (n2 = e2.SVG.toPath(n2), r3.SVG.entries[t3] = n2), n2);
      }
      if (r3.CFF) {
        var o2 = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r3.CFF.Private ? r3.CFF.Private.defaultWidthX : 0, open: false }, s2 = r3.CFF, i3 = r3.CFF.Private;
        if (s2.ROS) {
          for (var h = 0; s2.FDSelect[h + 2] <= t3; )
            h += 2;
          i3 = s2.FDArray[s2.FDSelect[h + 1]].Private;
        }
        e2.U._drawCFF(r3.CFF.CharStrings[t3], o2, s2, i3, a4);
      } else
        r3.glyf && e2.U._drawGlyf(t3, r3, a4);
      return a4;
    }, e2.U._drawGlyf = function(r3, t3, a4) {
      var n2 = t3.glyf[r3];
      null == n2 && (n2 = t3.glyf[r3] = e2.glyf._parseGlyf(t3, r3)), null != n2 && (n2.noc > -1 ? e2.U._simpleGlyph(n2, a4) : e2.U._compoGlyph(n2, t3, a4));
    }, e2.U._simpleGlyph = function(r3, t3) {
      for (var a4 = 0; a4 < r3.noc; a4++) {
        for (var n2 = 0 == a4 ? 0 : r3.endPts[a4 - 1] + 1, o2 = r3.endPts[a4], s2 = n2; s2 <= o2; s2++) {
          var i3 = s2 == n2 ? o2 : s2 - 1, h = s2 == o2 ? n2 : s2 + 1, f2 = 1 & r3.flags[s2], d2 = 1 & r3.flags[i3], u = 1 & r3.flags[h], l2 = r3.xs[s2], v4 = r3.ys[s2];
          if (s2 == n2)
            if (f2) {
              if (!d2) {
                e2.U.P.moveTo(t3, l2, v4);
                continue;
              }
              e2.U.P.moveTo(t3, r3.xs[i3], r3.ys[i3]);
            } else
              d2 ? e2.U.P.moveTo(t3, r3.xs[i3], r3.ys[i3]) : e2.U.P.moveTo(t3, (r3.xs[i3] + l2) / 2, (r3.ys[i3] + v4) / 2);
          f2 ? d2 && e2.U.P.lineTo(t3, l2, v4) : u ? e2.U.P.qcurveTo(t3, l2, v4, r3.xs[h], r3.ys[h]) : e2.U.P.qcurveTo(t3, l2, v4, (l2 + r3.xs[h]) / 2, (v4 + r3.ys[h]) / 2);
        }
        e2.U.P.closePath(t3);
      }
    }, e2.U._compoGlyph = function(r3, t3, a4) {
      for (var n2 = 0; n2 < r3.parts.length; n2++) {
        var o2 = { cmds: [], crds: [] }, s2 = r3.parts[n2];
        e2.U._drawGlyf(s2.glyphIndex, t3, o2);
        for (var i3 = s2.m, h = 0; h < o2.crds.length; h += 2) {
          var f2 = o2.crds[h], d2 = o2.crds[h + 1];
          a4.crds.push(f2 * i3.a + d2 * i3.b + i3.tx), a4.crds.push(f2 * i3.c + d2 * i3.d + i3.ty);
        }
        for (h = 0; h < o2.cmds.length; h++)
          a4.cmds.push(o2.cmds[h]);
      }
    }, e2.U._getGlyphClass = function(r3, t3) {
      var a4 = e2._lctf.getInterval(t3, r3);
      return -1 == a4 ? 0 : t3[a4 + 2];
    }, e2.U.getPairAdjustment = function(r3, t3, a4) {
      var n2 = false;
      if (r3.GPOS)
        for (var o2 = r3.GPOS, s2 = o2.lookupList, i3 = o2.featureList, h = [], f2 = 0; f2 < i3.length; f2++) {
          var d2 = i3[f2];
          if ("kern" == d2.tag) {
            n2 = true;
            for (var u = 0; u < d2.tab.length; u++)
              if (!h[d2.tab[u]]) {
                h[d2.tab[u]] = true;
                for (var l2 = s2[d2.tab[u]], v4 = 0; v4 < l2.tabs.length; v4++)
                  if (null != l2.tabs[v4]) {
                    var c6, p = l2.tabs[v4];
                    if (!p.coverage || -1 != (c6 = e2._lctf.coverageIndex(p.coverage, t3))) {
                      if (1 == l2.ltype)
                        ;
                      else if (2 == l2.ltype) {
                        var U = null;
                        if (1 == p.fmt) {
                          var g = p.pairsets[c6];
                          for (f2 = 0; f2 < g.length; f2++)
                            g[f2].gid2 == a4 && (U = g[f2]);
                        } else if (2 == p.fmt) {
                          var S = e2.U._getGlyphClass(t3, p.classDef1), m = e2.U._getGlyphClass(a4, p.classDef2);
                          U = p.matrix[S][m];
                        }
                        if (U) {
                          var b = 0;
                          return U.val1 && U.val1[2] && (b += U.val1[2]), U.val2 && U.val2[0] && (b += U.val2[0]), b;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (r3.kern && !n2) {
        var y = r3.kern.glyph1.indexOf(t3);
        if (-1 != y) {
          var F = r3.kern.rval[y].glyph2.indexOf(a4);
          if (-1 != F)
            return r3.kern.rval[y].vals[F];
        }
      }
      return 0;
    }, e2.U._applySubs = function(r3, t3, a4, n2) {
      for (var o2 = r3.length - t3 - 1, s2 = 0; s2 < a4.tabs.length; s2++)
        if (null != a4.tabs[s2]) {
          var i3, h = a4.tabs[s2];
          if (!h.coverage || -1 != (i3 = e2._lctf.coverageIndex(h.coverage, r3[t3]))) {
            if (1 == a4.ltype)
              r3[t3], 1 == h.fmt ? r3[t3] = r3[t3] + h.delta : r3[t3] = h.newg[i3];
            else if (4 == a4.ltype)
              for (var f2 = h.vals[i3], d2 = 0; d2 < f2.length; d2++) {
                var u = f2[d2], l2 = u.chain.length;
                if (!(l2 > o2)) {
                  for (var v4 = true, c6 = 0, p = 0; p < l2; p++) {
                    for (; -1 == r3[t3 + c6 + (1 + p)]; )
                      c6++;
                    u.chain[p] != r3[t3 + c6 + (1 + p)] && (v4 = false);
                  }
                  if (v4) {
                    r3[t3] = u.nglyph;
                    for (p = 0; p < l2 + c6; p++)
                      r3[t3 + p + 1] = -1;
                    break;
                  }
                }
              }
            else if (5 == a4.ltype && 2 == h.fmt)
              for (var U = e2._lctf.getInterval(h.cDef, r3[t3]), g = h.cDef[U + 2], S = h.scset[g], m = 0; m < S.length; m++) {
                var b = S[m], y = b.input;
                if (!(y.length > o2)) {
                  for (v4 = true, p = 0; p < y.length; p++) {
                    var F = e2._lctf.getInterval(h.cDef, r3[t3 + 1 + p]);
                    if (-1 == U && h.cDef[F + 2] != y[p]) {
                      v4 = false;
                      break;
                    }
                  }
                  if (v4) {
                    var _ = b.substLookupRecords;
                    for (d2 = 0; d2 < _.length; d2 += 2)
                      _[d2], _[d2 + 1];
                  }
                }
              }
            else if (6 == a4.ltype && 3 == h.fmt) {
              if (!e2.U._glsCovered(r3, h.backCvg, t3 - h.backCvg.length))
                continue;
              if (!e2.U._glsCovered(r3, h.inptCvg, t3))
                continue;
              if (!e2.U._glsCovered(r3, h.ahedCvg, t3 + h.inptCvg.length))
                continue;
              var C = h.lookupRec;
              for (m = 0; m < C.length; m += 2) {
                U = C[m];
                var x = n2[C[m + 1]];
                e2.U._applySubs(r3, t3 + U, x, n2);
              }
            }
          }
        }
    }, e2.U._glsCovered = function(r3, t3, a4) {
      for (var n2 = 0; n2 < t3.length; n2++) {
        if (-1 == e2._lctf.coverageIndex(t3[n2], r3[a4 + n2]))
          return false;
      }
      return true;
    }, e2.U.glyphsToPath = function(r3, t3, a4) {
      for (var n2 = { cmds: [], crds: [] }, o2 = 0, s2 = 0; s2 < t3.length; s2++) {
        var i3 = t3[s2];
        if (-1 != i3) {
          for (var h = s2 < t3.length - 1 && -1 != t3[s2 + 1] ? t3[s2 + 1] : 0, f2 = e2.U.glyphToPath(r3, i3), d2 = 0; d2 < f2.crds.length; d2 += 2)
            n2.crds.push(f2.crds[d2] + o2), n2.crds.push(f2.crds[d2 + 1]);
          a4 && n2.cmds.push(a4);
          for (d2 = 0; d2 < f2.cmds.length; d2++)
            n2.cmds.push(f2.cmds[d2]);
          a4 && n2.cmds.push("X"), o2 += r3.hmtx.aWidth[i3], s2 < t3.length - 1 && (o2 += e2.U.getPairAdjustment(r3, i3, h));
        }
      }
      return n2;
    }, e2.U.P = {}, e2.U.P.moveTo = function(r3, e3, t3) {
      r3.cmds.push("M"), r3.crds.push(e3, t3);
    }, e2.U.P.lineTo = function(r3, e3, t3) {
      r3.cmds.push("L"), r3.crds.push(e3, t3);
    }, e2.U.P.curveTo = function(r3, e3, t3, a4, n2, o2, s2) {
      r3.cmds.push("C"), r3.crds.push(e3, t3, a4, n2, o2, s2);
    }, e2.U.P.qcurveTo = function(r3, e3, t3, a4, n2) {
      r3.cmds.push("Q"), r3.crds.push(e3, t3, a4, n2);
    }, e2.U.P.closePath = function(r3) {
      r3.cmds.push("Z");
    }, e2.U._drawCFF = function(r3, t3, a4, n2, o2) {
      for (var s2 = t3.stack, i3 = t3.nStems, h = t3.haveWidth, f2 = t3.width, d2 = t3.open, u = 0, l2 = t3.x, v4 = t3.y, c6 = 0, p = 0, U = 0, g = 0, S = 0, m = 0, b = 0, y = 0, F = 0, _ = 0, C = { val: 0, size: 0 }; u < r3.length; ) {
        e2.CFF.getCharString(r3, u, C);
        var x = C.val;
        if (u += C.size, "o1" == x || "o18" == x)
          s2.length % 2 != 0 && !h && (f2 = s2.shift() + n2.nominalWidthX), i3 += s2.length >> 1, s2.length = 0, h = true;
        else if ("o3" == x || "o23" == x) {
          s2.length % 2 != 0 && !h && (f2 = s2.shift() + n2.nominalWidthX), i3 += s2.length >> 1, s2.length = 0, h = true;
        } else if ("o4" == x)
          s2.length > 1 && !h && (f2 = s2.shift() + n2.nominalWidthX, h = true), d2 && e2.U.P.closePath(o2), v4 += s2.pop(), e2.U.P.moveTo(o2, l2, v4), d2 = true;
        else if ("o5" == x)
          for (; s2.length > 0; )
            l2 += s2.shift(), v4 += s2.shift(), e2.U.P.lineTo(o2, l2, v4);
        else if ("o6" == x || "o7" == x)
          for (var P = s2.length, I = "o6" == x, w = 0; w < P; w++) {
            var O = s2.shift();
            I ? l2 += O : v4 += O, I = !I, e2.U.P.lineTo(o2, l2, v4);
          }
        else if ("o8" == x || "o24" == x) {
          P = s2.length;
          for (var T = 0; T + 6 <= P; )
            c6 = l2 + s2.shift(), p = v4 + s2.shift(), U = c6 + s2.shift(), g = p + s2.shift(), l2 = U + s2.shift(), v4 = g + s2.shift(), e2.U.P.curveTo(o2, c6, p, U, g, l2, v4), T += 6;
          "o24" == x && (l2 += s2.shift(), v4 += s2.shift(), e2.U.P.lineTo(o2, l2, v4));
        } else {
          if ("o11" == x)
            break;
          if ("o1234" == x || "o1235" == x || "o1236" == x || "o1237" == x)
            "o1234" == x && (p = v4, U = (c6 = l2 + s2.shift()) + s2.shift(), _ = g = p + s2.shift(), m = g, y = v4, l2 = (b = (S = (F = U + s2.shift()) + s2.shift()) + s2.shift()) + s2.shift(), e2.U.P.curveTo(o2, c6, p, U, g, F, _), e2.U.P.curveTo(o2, S, m, b, y, l2, v4)), "o1235" == x && (c6 = l2 + s2.shift(), p = v4 + s2.shift(), U = c6 + s2.shift(), g = p + s2.shift(), F = U + s2.shift(), _ = g + s2.shift(), S = F + s2.shift(), m = _ + s2.shift(), b = S + s2.shift(), y = m + s2.shift(), l2 = b + s2.shift(), v4 = y + s2.shift(), s2.shift(), e2.U.P.curveTo(o2, c6, p, U, g, F, _), e2.U.P.curveTo(o2, S, m, b, y, l2, v4)), "o1236" == x && (c6 = l2 + s2.shift(), p = v4 + s2.shift(), U = c6 + s2.shift(), _ = g = p + s2.shift(), m = g, b = (S = (F = U + s2.shift()) + s2.shift()) + s2.shift(), y = m + s2.shift(), l2 = b + s2.shift(), e2.U.P.curveTo(o2, c6, p, U, g, F, _), e2.U.P.curveTo(o2, S, m, b, y, l2, v4)), "o1237" == x && (c6 = l2 + s2.shift(), p = v4 + s2.shift(), U = c6 + s2.shift(), g = p + s2.shift(), F = U + s2.shift(), _ = g + s2.shift(), S = F + s2.shift(), m = _ + s2.shift(), b = S + s2.shift(), y = m + s2.shift(), Math.abs(b - l2) > Math.abs(y - v4) ? l2 = b + s2.shift() : v4 = y + s2.shift(), e2.U.P.curveTo(o2, c6, p, U, g, F, _), e2.U.P.curveTo(o2, S, m, b, y, l2, v4));
          else if ("o14" == x) {
            if (s2.length > 0 && !h && (f2 = s2.shift() + a4.nominalWidthX, h = true), 4 == s2.length) {
              var k = s2.shift(), G = s2.shift(), D = s2.shift(), B = s2.shift(), L = e2.CFF.glyphBySE(a4, D), R = e2.CFF.glyphBySE(a4, B);
              e2.U._drawCFF(a4.CharStrings[L], t3, a4, n2, o2), t3.x = k, t3.y = G, e2.U._drawCFF(a4.CharStrings[R], t3, a4, n2, o2);
            }
            d2 && (e2.U.P.closePath(o2), d2 = false);
          } else if ("o19" == x || "o20" == x) {
            s2.length % 2 != 0 && !h && (f2 = s2.shift() + n2.nominalWidthX), i3 += s2.length >> 1, s2.length = 0, h = true, u += i3 + 7 >> 3;
          } else if ("o21" == x)
            s2.length > 2 && !h && (f2 = s2.shift() + n2.nominalWidthX, h = true), v4 += s2.pop(), l2 += s2.pop(), d2 && e2.U.P.closePath(o2), e2.U.P.moveTo(o2, l2, v4), d2 = true;
          else if ("o22" == x)
            s2.length > 1 && !h && (f2 = s2.shift() + n2.nominalWidthX, h = true), l2 += s2.pop(), d2 && e2.U.P.closePath(o2), e2.U.P.moveTo(o2, l2, v4), d2 = true;
          else if ("o25" == x) {
            for (; s2.length > 6; )
              l2 += s2.shift(), v4 += s2.shift(), e2.U.P.lineTo(o2, l2, v4);
            c6 = l2 + s2.shift(), p = v4 + s2.shift(), U = c6 + s2.shift(), g = p + s2.shift(), l2 = U + s2.shift(), v4 = g + s2.shift(), e2.U.P.curveTo(o2, c6, p, U, g, l2, v4);
          } else if ("o26" == x)
            for (s2.length % 2 && (l2 += s2.shift()); s2.length > 0; )
              c6 = l2, p = v4 + s2.shift(), l2 = U = c6 + s2.shift(), v4 = (g = p + s2.shift()) + s2.shift(), e2.U.P.curveTo(o2, c6, p, U, g, l2, v4);
          else if ("o27" == x)
            for (s2.length % 2 && (v4 += s2.shift()); s2.length > 0; )
              p = v4, U = (c6 = l2 + s2.shift()) + s2.shift(), g = p + s2.shift(), l2 = U + s2.shift(), v4 = g, e2.U.P.curveTo(o2, c6, p, U, g, l2, v4);
          else if ("o10" == x || "o29" == x) {
            var A = "o10" == x ? n2 : a4;
            if (0 == s2.length)
              console.debug("error: empty stack");
            else {
              var W = s2.pop(), M = A.Subrs[W + A.Bias];
              t3.x = l2, t3.y = v4, t3.nStems = i3, t3.haveWidth = h, t3.width = f2, t3.open = d2, e2.U._drawCFF(M, t3, a4, n2, o2), l2 = t3.x, v4 = t3.y, i3 = t3.nStems, h = t3.haveWidth, f2 = t3.width, d2 = t3.open;
            }
          } else if ("o30" == x || "o31" == x) {
            var V2 = s2.length, N = (T = 0, "o31" == x);
            for (T += V2 - (P = -3 & V2); T < P; )
              N ? (p = v4, U = (c6 = l2 + s2.shift()) + s2.shift(), v4 = (g = p + s2.shift()) + s2.shift(), P - T == 5 ? (l2 = U + s2.shift(), T++) : l2 = U, N = false) : (c6 = l2, p = v4 + s2.shift(), U = c6 + s2.shift(), g = p + s2.shift(), l2 = U + s2.shift(), P - T == 5 ? (v4 = g + s2.shift(), T++) : v4 = g, N = true), e2.U.P.curveTo(o2, c6, p, U, g, l2, v4), T += 4;
          } else {
            if ("o" == (x + "").charAt(0))
              throw console.debug("Unknown operation: " + x, r3), x;
            s2.push(x);
          }
        }
      }
      t3.x = l2, t3.y = v4, t3.nStems = i3, t3.haveWidth = h, t3.width = f2, t3.open = d2;
    };
    var t2 = e2, a3 = { Typr: t2 };
    return r2.Typr = t2, r2.default = a3, Object.defineProperty(r2, "__esModule", { value: true }), r2;
  }({}).Typr;
}
function woff2otfFactory() {
  return function(r2) {
    var e2 = Uint8Array, n2 = Uint16Array, t2 = Uint32Array, a3 = new e2([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i3 = new e2([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o2 = new e2([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f2 = function(r3, e3) {
      for (var a4 = new n2(31), i4 = 0; i4 < 31; ++i4)
        a4[i4] = e3 += 1 << r3[i4 - 1];
      var o3 = new t2(a4[30]);
      for (i4 = 1; i4 < 30; ++i4)
        for (var f3 = a4[i4]; f3 < a4[i4 + 1]; ++f3)
          o3[f3] = f3 - a4[i4] << 5 | i4;
      return [a4, o3];
    }, u = f2(a3, 2), v4 = u[0], s2 = u[1];
    v4[28] = 258, s2[258] = 28;
    for (var l2 = f2(i3, 0)[0], c6 = new n2(32768), g = 0; g < 32768; ++g) {
      var h = (43690 & g) >>> 1 | (21845 & g) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c6[g] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r3, e3, t3) {
      for (var a4 = r3.length, i4 = 0, o3 = new n2(e3); i4 < a4; ++i4)
        ++o3[r3[i4] - 1];
      var f3, u2 = new n2(e3);
      for (i4 = 0; i4 < e3; ++i4)
        u2[i4] = u2[i4 - 1] + o3[i4 - 1] << 1;
      if (t3) {
        f3 = new n2(1 << e3);
        var v5 = 15 - e3;
        for (i4 = 0; i4 < a4; ++i4)
          if (r3[i4])
            for (var s3 = i4 << 4 | r3[i4], l3 = e3 - r3[i4], g2 = u2[r3[i4] - 1]++ << l3, h2 = g2 | (1 << l3) - 1; g2 <= h2; ++g2)
              f3[c6[g2] >>> v5] = s3;
      } else
        for (f3 = new n2(a4), i4 = 0; i4 < a4; ++i4)
          r3[i4] && (f3[i4] = c6[u2[r3[i4] - 1]++] >>> 15 - r3[i4]);
      return f3;
    }, d2 = new e2(288);
    for (g = 0; g < 144; ++g)
      d2[g] = 8;
    for (g = 144; g < 256; ++g)
      d2[g] = 9;
    for (g = 256; g < 280; ++g)
      d2[g] = 7;
    for (g = 280; g < 288; ++g)
      d2[g] = 8;
    var m = new e2(32);
    for (g = 0; g < 32; ++g)
      m[g] = 5;
    var b = w(d2, 9, 1), p = w(m, 5, 1), y = function(r3) {
      for (var e3 = r3[0], n3 = 1; n3 < r3.length; ++n3)
        r3[n3] > e3 && (e3 = r3[n3]);
      return e3;
    }, L = function(r3, e3, n3) {
      var t3 = e3 / 8 | 0;
      return (r3[t3] | r3[t3 + 1] << 8) >> (7 & e3) & n3;
    }, U = function(r3, e3) {
      var n3 = e3 / 8 | 0;
      return (r3[n3] | r3[n3 + 1] << 8 | r3[n3 + 2] << 16) >> (7 & e3);
    }, k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T = function(r3, e3, n3) {
      var t3 = new Error(e3 || k[r3]);
      if (t3.code = r3, Error.captureStackTrace && Error.captureStackTrace(t3, T), !n3)
        throw t3;
      return t3;
    }, O = function(r3, f3, u2) {
      var s3 = r3.length;
      if (!s3 || u2 && !u2.l && s3 < 5)
        return f3 || new e2(0);
      var c7 = !f3 || u2, g2 = !u2 || u2.i;
      u2 || (u2 = {}), f3 || (f3 = new e2(3 * s3));
      var h2, d3 = function(r4) {
        var n3 = f3.length;
        if (r4 > n3) {
          var t3 = new e2(Math.max(2 * n3, r4));
          t3.set(f3), f3 = t3;
        }
      }, m2 = u2.f || 0, k2 = u2.p || 0, O2 = u2.b || 0, A2 = u2.l, x2 = u2.d, E = u2.m, D = u2.n, M = 8 * s3;
      do {
        if (!A2) {
          u2.f = m2 = L(r3, k2, 1);
          var S = L(r3, k2 + 1, 3);
          if (k2 += 3, !S) {
            var V2 = r3[(I = ((h2 = k2) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r3[I - 3] << 8, _ = I + V2;
            if (_ > s3) {
              g2 && T(0);
              break;
            }
            c7 && d3(O2 + V2), f3.set(r3.subarray(I, _), O2), u2.b = O2 += V2, u2.p = k2 = 8 * _;
            continue;
          }
          if (1 == S)
            A2 = b, x2 = p, E = 9, D = 5;
          else if (2 == S) {
            var j = L(r3, k2, 31) + 257, z = L(r3, k2 + 10, 15) + 4, C = j + L(r3, k2 + 5, 31) + 1;
            k2 += 14;
            for (var F = new e2(C), P = new e2(19), q = 0; q < z; ++q)
              P[o2[q]] = L(r3, k2 + 3 * q, 7);
            k2 += 3 * z;
            var B = y(P), G = (1 << B) - 1, H = w(P, B, 1);
            for (q = 0; q < C; ) {
              var I, J = H[L(r3, k2, G)];
              if (k2 += 15 & J, (I = J >>> 4) < 16)
                F[q++] = I;
              else {
                var K = 0, N = 0;
                for (16 == I ? (N = 3 + L(r3, k2, 3), k2 += 2, K = F[q - 1]) : 17 == I ? (N = 3 + L(r3, k2, 7), k2 += 3) : 18 == I && (N = 11 + L(r3, k2, 127), k2 += 7); N--; )
                  F[q++] = K;
              }
            }
            var Q = F.subarray(0, j), R = F.subarray(j);
            E = y(Q), D = y(R), A2 = w(Q, E, 1), x2 = w(R, D, 1);
          } else
            T(1);
          if (k2 > M) {
            g2 && T(0);
            break;
          }
        }
        c7 && d3(O2 + 131072);
        for (var W = (1 << E) - 1, X = (1 << D) - 1, Y = k2; ; Y = k2) {
          var Z = (K = A2[U(r3, k2) & W]) >>> 4;
          if ((k2 += 15 & K) > M) {
            g2 && T(0);
            break;
          }
          if (K || T(2), Z < 256)
            f3[O2++] = Z;
          else {
            if (256 == Z) {
              Y = k2, A2 = null;
              break;
            }
            var $ = Z - 254;
            if (Z > 264) {
              var rr = a3[q = Z - 257];
              $ = L(r3, k2, (1 << rr) - 1) + v4[q], k2 += rr;
            }
            var er = x2[U(r3, k2) & X], nr = er >>> 4;
            er || T(3), k2 += 15 & er;
            R = l2[nr];
            if (nr > 3) {
              rr = i3[nr];
              R += U(r3, k2) & (1 << rr) - 1, k2 += rr;
            }
            if (k2 > M) {
              g2 && T(0);
              break;
            }
            c7 && d3(O2 + 131072);
            for (var tr = O2 + $; O2 < tr; O2 += 4)
              f3[O2] = f3[O2 - R], f3[O2 + 1] = f3[O2 + 1 - R], f3[O2 + 2] = f3[O2 + 2 - R], f3[O2 + 3] = f3[O2 + 3 - R];
            O2 = tr;
          }
        }
        u2.l = A2, u2.p = Y, u2.b = O2, A2 && (m2 = 1, u2.m = E, u2.d = x2, u2.n = D);
      } while (!m2);
      return O2 == f3.length ? f3 : function(r4, a4, i4) {
        (null == a4 || a4 < 0) && (a4 = 0), (null == i4 || i4 > r4.length) && (i4 = r4.length);
        var o3 = new (r4 instanceof n2 ? n2 : r4 instanceof t2 ? t2 : e2)(i4 - a4);
        return o3.set(r4.subarray(a4, i4)), o3;
      }(f3, 0, O2);
    }, A = new e2(0);
    var x = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x.decode(A, { stream: true }), 1;
    } catch (r3) {
    }
    return r2.convert_streams = function(r3) {
      var e3 = new DataView(r3), n3 = 0;
      function t3() {
        var r4 = e3.getUint16(n3);
        return n3 += 2, r4;
      }
      function a4() {
        var r4 = e3.getUint32(n3);
        return n3 += 4, r4;
      }
      function i4(r4) {
        m2.setUint16(b2, r4), b2 += 2;
      }
      function o3(r4) {
        m2.setUint32(b2, r4), b2 += 4;
      }
      for (var f3 = { signature: a4(), flavor: a4(), length: a4(), numTables: t3(), reserved: t3(), totalSfntSize: a4(), majorVersion: t3(), minorVersion: t3(), metaOffset: a4(), metaLength: a4(), metaOrigLength: a4(), privOffset: a4(), privLength: a4() }, u2 = 0; Math.pow(2, u2) <= f3.numTables; )
        u2++;
      u2--;
      for (var v5 = 16 * Math.pow(2, u2), s3 = 16 * f3.numTables - v5, l3 = 12, c7 = [], g2 = 0; g2 < f3.numTables; g2++)
        c7.push({ tag: a4(), offset: a4(), compLength: a4(), origLength: a4(), origChecksum: a4() }), l3 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c7.length + c7.reduce(function(r4, e4) {
        return r4 + e4.origLength + 4;
      }, 0)), d3 = w2.buffer, m2 = new DataView(d3), b2 = 0;
      return o3(f3.flavor), i4(f3.numTables), i4(v5), i4(u2), i4(s3), c7.forEach(function(r4) {
        o3(r4.tag), o3(r4.origChecksum), o3(l3), o3(r4.origLength), r4.outOffset = l3, (l3 += r4.origLength) % 4 != 0 && (l3 += 4 - l3 % 4);
      }), c7.forEach(function(e4) {
        var n4, t4 = r3.slice(e4.offset, e4.offset + e4.compLength);
        if (e4.compLength != e4.origLength) {
          var a5 = new Uint8Array(e4.origLength);
          n4 = new Uint8Array(t4, 2), O(n4, a5);
        } else
          a5 = new Uint8Array(t4);
        w2.set(a5, e4.outOffset);
        var i5 = 0;
        (l3 = e4.outOffset + e4.origLength) % 4 != 0 && (i5 = 4 - l3 % 4), w2.set(new Uint8Array(i5).buffer, e4.outOffset + e4.origLength), h2 = l3 + i5;
      }), d3.slice(0, h2);
    }, Object.defineProperty(r2, "__esModule", { value: true }), r2;
  }({}).convert_streams;
}
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = /* @__PURE__ */ new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range) => {
          let [skip, step] = range.split("+");
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m[type]);
          for (let i3 = step; i3--; ) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i3 = 0; i3 < str.length; i3++) {
      const code = str.codePointAt(i3);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i3] = form;
      prevJoiningType = joiningType;
      prevIndex = i3;
      if (code > 65535)
        i3++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i3 = 0; i3 < str.length; i3++) {
      const cc = str.codePointAt(i3);
      if (cc > 65535)
        i3++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font["GSUB"];
    if (gsub) {
      const { lookupList, featureList } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]])
              continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function firstNum(...args) {
    for (let i3 = 0; i3 < args.length; i3++) {
      if (typeof args[i3] === "number") {
        return args[i3];
      }
    }
  }
  function wrapFontObj(typrFont) {
    const glyphMap = /* @__PURE__ */ Object.create(null);
    const os2 = typrFont["OS/2"];
    const hhea = typrFont.hhea;
    const unitsPerEm = typrFont.head.unitsPerEm;
    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);
    const fontObj = {
      unitsPerEm,
      ascender,
      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),
      capHeight: firstNum(os2 && os2.sCapHeight, ascender),
      xHeight: firstNum(os2 && os2.sxHeight, ascender),
      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let glyphX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIndices = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        let prevGlyphIndex = -1;
        glyphIndices.forEach((glyphIndex, i3) => {
          if (glyphIndex !== -1) {
            let glyphObj = glyphMap[glyphIndex];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphIndex);
              let path = "";
              let crdsIdx = 0;
              for (let i4 = 0, len = cmds.length; i4 < len; i4++) {
                const numArgs = cmdArgLengths[cmds[i4]];
                path += cmds[i4];
                for (let j = 1; j <= numArgs; j++) {
                  path += (j > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i4 = 0, len = crds.length; i4 < len; i4 += 2) {
                  let x = crds[i4];
                  let y = crds[i4 + 1];
                  if (x < xMin)
                    xMin = x;
                  if (y < yMin)
                    yMin = y;
                  if (x > xMax)
                    xMax = x;
                  if (y > yMax)
                    yMax = y;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphIndex] = {
                index: glyphIndex,
                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],
                xMin,
                yMin,
                xMax,
                yMax,
                path,
                pathCommandCount: cmds.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            if (prevGlyphIndex !== -1) {
              glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;
            }
            callback.call(null, glyphObj, glyphX, charIndex);
            if (glyphObj.advanceWidth) {
              glyphX += glyphObj.advanceWidth * fontScale;
            }
            if (letterSpacing) {
              glyphX += letterSpacing * fontSize;
            }
            prevGlyphIndex = glyphIndex;
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return glyphX;
      }
    };
    return fontObj;
  }
  return function parse2(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
var workerModule = defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory2, woff2otfFactory2, parserFactory2) {
    const Typr = typrFactory2();
    const woff2otf = woff2otfFactory2();
    return parserFactory2(Typr, woff2otf);
  }
});
var CONFIG = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  //Roboto Regular
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
};
var tempColor = new Color();
var hasRequested = false;
function now$1() {
  return (self.performance || Date).now();
}
var atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(args, callback) {
  hasRequested = true;
  args = assign3({}, args);
  const totalStart = now$1();
  args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  if (args.colorRanges != null) {
    let colors3 = {};
    for (let key in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key)) {
        let val = args.colorRanges[key];
        if (typeof val !== "number") {
          val = tempColor.set(val).getHex();
        }
        colors3[key] = val;
      }
    }
    args.colorRanges = colors3;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG;
  const { sdfGlyphSize } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement("canvas");
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow;
    atlas = atlases[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new Texture(
        canvas,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: false,
      glyphsByFont: /* @__PURE__ */ new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling(atlas);
  }
  const { sdfTexture, sdfCanvas } = atlas;
  let fontGlyphs = atlas.glyphsByFont.get(args.font);
  if (!fontGlyphs) {
    atlas.glyphsByFont.set(args.font, fontGlyphs = /* @__PURE__ */ new Map());
  }
  typesetInWorker(args).then((result) => {
    const { glyphIds, glyphPositions, fontSize, unitsPerEm, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    const fontSizeMult = fontSize / unitsPerEm;
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$1();
    glyphIds.forEach((glyphId, i3) => {
      let glyphInfo = fontGlyphs.get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        fontGlyphs.set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i3] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);
    const sdfStart = now$1();
    timings.sdf = {};
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
      sdfTexture.dispose();
    }
    Promise.all(neededSDFs.map(
      (glyphInfo) => generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing }) => {
        timings.sdf[glyphInfo.atlasIndex] = timing;
      })
    )).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$1() - sdfStart;
      timings.total = now$1() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        caretHeight: result.caretHeight,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        capHeight: result.capHeight,
        xHeight: result.xHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings
      }));
    });
  });
  Promise.resolve().then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas(sdfCanvas);
    }
  });
}
function generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {
  if (contextLost) {
    return Promise.resolve({ timing: -1 });
  }
  const { textureWidth, sdfExponent } = CONFIG;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU);
}
function initContextLossHandling(atlas) {
  const canvas = atlas.sdfCanvas;
  canvas.addEventListener("webglcontextlost", (event) => {
    console.log("Context Lost", event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener("webglcontextrestored", (event) => {
    console.log("Context Restored", event);
    atlas.contextLost = false;
    const promises = [];
    atlas.glyphsByFont.forEach((glyphMap) => {
      glyphMap.forEach((glyph) => {
        promises.push(generateGlyphSDF(glyph, atlas, true));
      });
    });
    Promise.all(promises).then(() => {
      safariPre15Workaround(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}
function preloadFont({ font, characters, sdfGlyphSize }, callback) {
  let text = Array.isArray(characters) ? characters.join("\n") : "" + characters;
  getTextRenderInfo({ font, sdfGlyphSize, text }, callback);
}
function assign3(toObj, fromObj) {
  for (let key in fromObj) {
    if (fromObj.hasOwnProperty(key)) {
      toObj[key] = fromObj[key];
    }
  }
  return toObj;
}
var linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl.href = path;
  return linkEl.href;
}
function safariPre15Workaround(atlas) {
  if (typeof createImageBitmap !== "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas, sdfTexture } = atlas;
    const { width, height } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext("webgl");
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width * height * 4) {
      pixels = new Uint8Array(width * height * 4);
      sdfTexture.image = { width, height, data: pixels };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
var typesetterWorkerModule = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    CONFIG,
    workerModule,
    createTypesetter,
    bidi_default
  ],
  init(config2, fontParser, createTypesetter2, bidiFactory2) {
    const { defaultFontURL } = config2;
    return createTypesetter2(fontParser, bidiFactory2(), { defaultFontURL });
  }
});
var typesetInWorker = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule
  ],
  init(typesetter) {
    return function(args) {
      return new Promise((resolve2) => {
        typesetter.typeset(args, resolve2);
      });
    };
  },
  getTransferables(result) {
    const transferables = [
      result.glyphPositions.buffer,
      result.glyphIds.buffer
    ];
    if (result.caretPositions) {
      transferables.push(result.caretPositions.buffer);
    }
    if (result.glyphColors) {
      transferables.push(result.glyphColors.buffer);
    }
    return transferables;
  }
});
var templateGeometries = {};
function getTemplateGeometry(detail) {
  let geom = templateGeometries[detail];
  if (!geom) {
    const front = new PlaneGeometry(1, 1, detail, detail);
    const back = front.clone();
    const frontAttrs = front.attributes;
    const backAttrs = back.attributes;
    const combined = new BufferGeometry();
    const vertCount = frontAttrs.uv.count;
    for (let i3 = 0; i3 < vertCount; i3++) {
      backAttrs.position.array[i3 * 3] *= -1;
      backAttrs.normal.array[i3 * 3 + 2] *= -1;
    }
    ["position", "normal", "uv"].forEach((name) => {
      combined.setAttribute(
        name,
        new Float32BufferAttribute(
          [...frontAttrs[name].array, ...backAttrs[name].array],
          frontAttrs[name].itemSize
        )
      );
    });
    combined.setIndex([...front.index.array, ...back.index.array.map((n2) => n2 + vertCount)]);
    combined.translate(0.5, 0.5, 0);
    geom = templateGeometries[detail] = combined;
  }
  return geom;
}
var glyphBoundsAttrName = "aTroikaGlyphBounds";
var glyphIndexAttrName = "aTroikaGlyphIndex";
var glyphColorAttrName = "aTroikaGlyphColor";
var GlyphsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.detail = 1;
    this.curveRadius = 0;
    this.groups = [
      { start: 0, count: Infinity, materialIndex: 0 },
      { start: 0, count: Infinity, materialIndex: 1 }
    ];
    this.boundingSphere = new Sphere();
    this.boundingBox = new Box3();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  // Since our base geometry contains triangles for both front and back sides, we can emulate
  // the "side" by restricting the draw range.
  setSide(side) {
    const verts = this.getIndex().count;
    this.setDrawRange(side === BackSide ? verts / 2 : 0, side === DoubleSide ? verts : verts / 2);
  }
  set detail(detail) {
    if (detail !== this._detail) {
      this._detail = detail;
      if (typeof detail !== "number" || detail < 1) {
        detail = 1;
      }
      let tpl = getTemplateGeometry(detail);
      ["position", "normal", "uv"].forEach((attr) => {
        this.attributes[attr] = tpl.attributes[attr].clone();
      });
      this.setIndex(tpl.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(r2) {
    if (r2 !== this._curveRadius) {
      this._curveRadius = r2;
      this._updateBounds();
    }
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);
    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);
    updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);
    this._blockBounds = blockBounds;
    this._chunkedBounds = chunkedBounds;
    this.instanceCount = glyphAtlasIndices.length;
    this._updateBounds();
  }
  _updateBounds() {
    const bounds = this._blockBounds;
    if (bounds) {
      const { curveRadius, boundingBox: bbox } = this;
      if (curveRadius) {
        const { PI, floor, min, max, sin, cos } = Math;
        const halfPi = PI / 2;
        const twoPi = PI * 2;
        const absR = Math.abs(curveRadius);
        const leftAngle = bounds[0] / absR;
        const rightAngle = bounds[2] / absR;
        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
      } else {
        bbox.min.set(bounds[0], bounds[1], 0);
        bbox.max.set(bounds[2], bounds[3], 0);
      }
      bbox.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(clipRect) {
    let count = this.getAttribute(glyphIndexAttrName).count;
    let chunks = this._chunkedBounds;
    if (chunks) {
      for (let i3 = chunks.length; i3--; ) {
        count = chunks[i3].end;
        let rect = chunks[i3].rect;
        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
          break;
        }
      }
    }
    this.instanceCount = count;
  }
};
function updateBufferAttr(geom, attrName, newArray, itemSize) {
  const attr = geom.getAttribute(attrName);
  if (newArray) {
    if (attr && attr.array.length === newArray.length) {
      attr.array.set(newArray);
      attr.needsUpdate = true;
    } else {
      geom.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
      delete geom._maxInstanceCount;
      geom.dispose();
    }
  } else if (attr) {
    geom.deleteAttribute(attrName);
  }
}
var VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = createDerivedMaterial(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader: vertexShader2, fragmentShader: fragmentShader2 }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader2)) {
        fragmentShader2 = fragmentShader2.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader2)) {
          vertexShader2 = vertexShader2.replace(
            voidMainRegExp,
            "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
          );
        }
      }
      return { vertexShader: vertexShader2, fragmentShader: fragmentShader2 };
    }
  });
  textMaterial.transparent = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
var defaultMaterial = new MeshBasicMaterial({
  color: 16777215,
  side: DoubleSide,
  transparent: true
});
var defaultStrokeColor = 8421504;
var tempMat4 = new Matrix4();
var tempVec3a = new Vector3();
var tempVec3b = new Vector3();
var tempArray = [];
var origin = new Vector3();
var defaultOrient = "+x+y";
function first(o2) {
  return Array.isArray(o2) ? o2[0] : o2;
}
var getFlatRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1),
    defaultMaterial
  );
  getFlatRaycastMesh = () => mesh;
  return mesh;
};
var getCurvedRaycastMesh = () => {
  const mesh = new Mesh(
    new PlaneGeometry(1, 1, 32, 1),
    defaultMaterial
  );
  getCurvedRaycastMesh = () => mesh;
  return mesh;
};
var syncStartEvent = { type: "syncstart" };
var syncCompleteEvent = { type: "synccomplete" };
var SYNCABLE_PROPS = [
  "font",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
];
var COPYABLE_PROPS = SYNCABLE_PROPS.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
var Text = class extends Mesh {
  constructor() {
    const geometry = new GlyphsGeometry();
    super(geometry, null);
    this.text = "";
    this.anchorX = 0;
    this.anchorY = 0;
    this.curveRadius = 0;
    this.direction = "auto";
    this.font = null;
    this.fontSize = 0.1;
    this.letterSpacing = 0;
    this.lineHeight = "normal";
    this.maxWidth = Infinity;
    this.overflowWrap = "normal";
    this.textAlign = "left";
    this.textIndent = 0;
    this.whiteSpace = "normal";
    this.material = null;
    this.color = null;
    this.colorRanges = null;
    this.outlineWidth = 0;
    this.outlineColor = 0;
    this.outlineOpacity = 1;
    this.outlineBlur = 0;
    this.outlineOffsetX = 0;
    this.outlineOffsetY = 0;
    this.strokeWidth = 0;
    this.strokeColor = defaultStrokeColor;
    this.strokeOpacity = 1;
    this.fillOpacity = 1;
    this.depthOffset = 0;
    this.clipRect = null;
    this.orientation = defaultOrient;
    this.glyphGeometryDetail = 1;
    this.sdfGlyphSize = null;
    this.gpuAccelerateSDF = true;
    this.debugSDF = false;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(callback) {
    if (this._needsSync) {
      this._needsSync = false;
      if (this._isSyncing) {
        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
      } else {
        this._isSyncing = true;
        this.dispatchEvent(syncStartEvent);
        getTextRenderInfo({
          text: this.text,
          font: this.font,
          fontSize: this.fontSize || 0.1,
          letterSpacing: this.letterSpacing || 0,
          lineHeight: this.lineHeight || "normal",
          maxWidth: this.maxWidth,
          direction: this.direction || "auto",
          textAlign: this.textAlign,
          textIndent: this.textIndent,
          whiteSpace: this.whiteSpace,
          overflowWrap: this.overflowWrap,
          anchorX: this.anchorX,
          anchorY: this.anchorY,
          colorRanges: this.colorRanges,
          includeCaretPositions: true,
          //TODO parameterize
          sdfGlyphSize: this.sdfGlyphSize,
          gpuAccelerateSDF: this.gpuAccelerateSDF
        }, (textRenderInfo) => {
          this._isSyncing = false;
          this._textRenderInfo = textRenderInfo;
          this.geometry.updateGlyphs(
            textRenderInfo.glyphBounds,
            textRenderInfo.glyphAtlasIndices,
            textRenderInfo.blockBounds,
            textRenderInfo.chunkedBounds,
            textRenderInfo.glyphColors
          );
          const queued = this._queuedSyncs;
          if (queued) {
            this._queuedSyncs = null;
            this._needsSync = true;
            this.sync(() => {
              queued.forEach((fn) => fn && fn());
            });
          }
          this.dispatchEvent(syncCompleteEvent);
          if (callback) {
            callback();
          }
        });
      }
    }
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(renderer, scene, camera, geometry, material, group) {
    this.sync();
    if (material.isTroikaTextMaterial) {
      this._prepareForRender(material);
    }
    material._hadOwnSide = material.hasOwnProperty("side");
    this.geometry.setSide(material._actualSide = material.side);
    material.side = FrontSide;
  }
  onAfterRender(renderer, scene, camera, geometry, material, group) {
    if (material._hadOwnSide) {
      material.side = material._actualSide;
    } else {
      delete material.side;
    }
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let derivedMaterial = this._derivedMaterial;
    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);
      baseMaterial.addEventListener("dispose", function onDispose() {
        baseMaterial.removeEventListener("dispose", onDispose);
        derivedMaterial.dispose();
      });
    }
    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let outlineMaterial = derivedMaterial._outlineMtl;
      if (!outlineMaterial) {
        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
          id: { value: derivedMaterial.id + 0.1 }
        });
        outlineMaterial.isTextOutlineMaterial = true;
        outlineMaterial.depthWrite = false;
        outlineMaterial.map = null;
        derivedMaterial.addEventListener("dispose", function onDispose() {
          derivedMaterial.removeEventListener("dispose", onDispose);
          outlineMaterial.dispose();
        });
      }
      return [
        outlineMaterial,
        derivedMaterial
      ];
    } else {
      return derivedMaterial;
    }
  }
  set material(baseMaterial) {
    if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
      this._derivedMaterial = baseMaterial;
      this._baseMaterial = baseMaterial.baseMaterial;
    } else {
      this._baseMaterial = baseMaterial;
    }
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(detail) {
    this.geometry.detail = detail;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(r2) {
    this.geometry.curveRadius = r2;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return first(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return first(this.material).getDistanceMaterial();
  }
  _prepareForRender(material) {
    const isOutline = material.isTextOutlineMaterial;
    const uniforms = material.uniforms;
    const textInfo = this.textRenderInfo;
    if (textInfo) {
      const { sdfTexture, blockBounds } = textInfo;
      uniforms.uTroikaSDFTexture.value = sdfTexture;
      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
      let distanceOffset = 0;
      let blurRadius = 0;
      let strokeWidth = 0;
      let fillOpacity;
      let strokeOpacity;
      let strokeColor;
      let offsetX = 0;
      let offsetY = 0;
      if (isOutline) {
        let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
        distanceOffset = this._parsePercent(outlineWidth) || 0;
        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
        fillOpacity = outlineOpacity;
        offsetX = this._parsePercent(outlineOffsetX) || 0;
        offsetY = this._parsePercent(outlineOffsetY) || 0;
      } else {
        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
        if (strokeWidth) {
          strokeColor = this.strokeColor;
          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
          strokeOpacity = this.strokeOpacity;
          if (strokeOpacity == null)
            strokeOpacity = 1;
        }
        fillOpacity = this.fillOpacity;
      }
      uniforms.uTroikaDistanceOffset.value = distanceOffset;
      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
      uniforms.uTroikaBlurRadius.value = blurRadius;
      uniforms.uTroikaStrokeWidth.value = strokeWidth;
      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
      let clipRect = this.clipRect;
      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
        uniforms.uTroikaClipRect.value.fromArray(clipRect);
      } else {
        const pad = (this.fontSize || 0.1) * 100;
        uniforms.uTroikaClipRect.value.set(
          blockBounds[0] - pad,
          blockBounds[1] - pad,
          blockBounds[2] + pad,
          blockBounds[3] + pad
        );
      }
      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
    }
    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
    material.polygonOffset = !!this.depthOffset;
    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;
    const color = isOutline ? this.outlineColor || 0 : this.color;
    if (color == null) {
      delete material.color;
    } else {
      const colorObj = material.hasOwnProperty("color") ? material.color : material.color = new Color();
      if (color !== colorObj._input || typeof color === "object") {
        colorObj.set(colorObj._input = color);
      }
    }
    let orient = this.orientation || defaultOrient;
    if (orient !== material._orientation) {
      let rotMat = uniforms.uTroikaOrient.value;
      orient = orient.replace(/[^-+xyz]/g, "");
      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (match) {
        let [, hSign, hAxis, vSign, vAxis] = match;
        tempVec3a.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
        tempVec3b.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
        rotMat.setFromMatrix4(tempMat4);
      } else {
        rotMat.identity();
      }
      material._orientation = orient;
    }
  }
  _parsePercent(value) {
    if (typeof value === "string") {
      let match = value.match(/^(-?[\d.]+)%$/);
      let pct = match ? parseFloat(match[1]) : NaN;
      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
    }
    return value;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(position2, target2 = new Vector2()) {
    target2.copy(position2);
    const r2 = this.curveRadius;
    if (r2) {
      target2.x = Math.atan2(position2.x, Math.abs(r2) - Math.abs(position2.z)) * Math.abs(r2);
    }
    return target2;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(position2, target2 = new Vector2()) {
    tempVec3a.copy(position2);
    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target2);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(raycaster, intersects) {
    const { textRenderInfo, curveRadius } = this;
    if (textRenderInfo) {
      const bounds = textRenderInfo.blockBounds;
      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
      const geom = raycastMesh.geometry;
      const { position: position2, uv } = geom.attributes;
      for (let i3 = 0; i3 < uv.count; i3++) {
        let x = bounds[0] + uv.getX(i3) * (bounds[2] - bounds[0]);
        const y = bounds[1] + uv.getY(i3) * (bounds[3] - bounds[1]);
        let z = 0;
        if (curveRadius) {
          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;
          x = Math.sin(x / curveRadius) * curveRadius;
        }
        position2.setXYZ(i3, x, y, z);
      }
      geom.boundingSphere = this.geometry.boundingSphere;
      geom.boundingBox = this.geometry.boundingBox;
      raycastMesh.matrixWorld = this.matrixWorld;
      raycastMesh.material.side = this.material.side;
      tempArray.length = 0;
      raycastMesh.raycast(raycaster, tempArray);
      for (let i3 = 0; i3 < tempArray.length; i3++) {
        tempArray[i3].object = this;
        intersects.push(tempArray[i3]);
      }
    }
  }
  copy(source) {
    const geom = this.geometry;
    super.copy(source);
    this.geometry = geom;
    COPYABLE_PROPS.forEach((prop) => {
      this[prop] = source[prop];
    });
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
SYNCABLE_PROPS.forEach((prop) => {
  const privateKey = "_private_" + prop;
  Object.defineProperty(Text.prototype, prop, {
    get() {
      return this[privateKey];
    },
    set(value) {
      if (value !== this[privateKey]) {
        this[privateKey] = value;
        this._needsSync = true;
      }
    }
  });
});

// node_modules/@react-three/drei/core/Text.js
var Text2 = React19.forwardRef(({
  sdfGlyphSize = 64,
  anchorX = "center",
  anchorY = "middle",
  font,
  fontSize = 1,
  children,
  characters,
  onSync,
  ...props
}, ref) => {
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const [troikaMesh] = React19.useState(() => new Text());
  const [nodes, text] = React19.useMemo(() => {
    const n2 = [];
    let t2 = "";
    React19.Children.forEach(children, (child) => {
      if (typeof child === "string" || typeof child === "number") {
        t2 += child;
      } else {
        n2.push(child);
      }
    });
    return [n2, t2];
  }, [children]);
  suspend(() => new Promise((res) => preloadFont({
    font,
    characters
  }, res)), ["troika-text", font, characters]);
  React19.useLayoutEffect(() => void troikaMesh.sync(() => {
    invalidate();
    if (onSync)
      onSync(troikaMesh);
  }));
  React19.useEffect(() => {
    return () => troikaMesh.dispose();
  }, [troikaMesh]);
  return React19.createElement("primitive", _extends({
    object: troikaMesh,
    ref,
    font,
    text,
    anchorX,
    anchorY,
    fontSize,
    sdfGlyphSize
  }, props), nodes);
});

// node_modules/@react-three/drei/core/Text3D.js
var React20 = __toESM(require_react());
var import_react6 = __toESM(require_react());

// node_modules/@react-three/drei/core/useFont.js
var fontLoader = null;
async function loader(font) {
  if (!fontLoader)
    fontLoader = new FontLoader();
  let data = typeof font === "string" ? await (await fetch(font)).json() : font;
  return fontLoader.parse(data);
}
function useFont(font) {
  return suspend(loader, [font]);
}
useFont.preload = (font) => preload(loader, [font]);
useFont.clear = (font) => clear([font]);

// node_modules/@react-three/drei/core/Text3D.js
var types = ["string", "number"];
var getTextFromChildren = (children) => {
  let label = "";
  const rest = [];
  React20.Children.forEach(children, (child) => {
    if (types.includes(typeof child))
      label += child + "";
    else
      rest.push(child);
  });
  return [label, ...rest];
};
var Text3D = React20.forwardRef(({
  font: _font,
  letterSpacing = 0,
  lineHeight = 1,
  size = 1,
  height = 0.2,
  bevelThickness = 0.1,
  bevelSize = 0.01,
  bevelEnabled = false,
  bevelOffset = 0,
  bevelSegments = 4,
  curveSegments = 8,
  smooth,
  children,
  ...props
}, fref) => {
  React20.useMemo(() => extend({
    RenamedTextGeometry: TextGeometry
  }), []);
  const ref = React20.useRef(null);
  const font = useFont(_font);
  const opts = (0, import_react6.useMemo)(() => {
    return {
      font,
      size,
      height,
      bevelThickness,
      bevelSize,
      bevelEnabled,
      bevelSegments,
      bevelOffset,
      curveSegments,
      letterSpacing,
      lineHeight
    };
  }, [font, size, height, bevelThickness, bevelSize, bevelEnabled, bevelSegments, bevelOffset, curveSegments, letterSpacing, lineHeight]);
  const [label, ...rest] = (0, import_react6.useMemo)(() => getTextFromChildren(children), [children]);
  const args = React20.useMemo(() => [label, opts], [label, opts]);
  React20.useLayoutEffect(() => {
    if (smooth) {
      ref.current.geometry = mergeVertices(ref.current.geometry, smooth);
      ref.current.geometry.computeVertexNormals();
    }
  }, [args, smooth]);
  React20.useImperativeHandle(fref, () => ref.current, []);
  return React20.createElement("mesh", _extends({}, props, {
    ref
  }), React20.createElement("renamedTextGeometry", {
    args
  }), rest);
});

// node_modules/@react-three/drei/core/Effects.js
var React21 = __toESM(require_react());
var isWebGL2Available = () => {
  try {
    var canvas = document.createElement("canvas");
    return !!(window.WebGL2RenderingContext && canvas.getContext("webgl2"));
  } catch (e2) {
    return false;
  }
};
var Effects = React21.forwardRef(({
  children,
  multisamping = 8,
  renderIndex = 1,
  disableRender,
  disableGamma,
  disableRenderPass,
  depthBuffer = true,
  stencilBuffer = false,
  anisotropy = 1,
  encoding,
  type,
  ...props
}, ref) => {
  React21.useMemo(() => extend({
    EffectComposer,
    RenderPass,
    ShaderPass
  }), []);
  const composer = React21.useRef();
  const {
    scene,
    camera,
    gl,
    size,
    viewport
  } = useThree();
  const [target2] = React21.useState(() => {
    const t2 = new WebGLRenderTarget(size.width, size.height, {
      type: type || HalfFloatType,
      format: RGBAFormat,
      depthBuffer,
      stencilBuffer,
      anisotropy
    });
    if (type === UnsignedByteType && encoding != null) {
      if ("colorSpace" in t2)
        t2.texture.colorSpace = encoding;
      else
        t2.texture.encoding = encoding;
    }
    t2.samples = multisamping;
    return t2;
  });
  React21.useEffect(() => {
    var _composer$current, _composer$current2;
    (_composer$current = composer.current) == null ? void 0 : _composer$current.setSize(size.width, size.height);
    (_composer$current2 = composer.current) == null ? void 0 : _composer$current2.setPixelRatio(viewport.dpr);
  }, [gl, size, viewport.dpr]);
  useFrame(() => {
    var _composer$current3;
    if (!disableRender)
      (_composer$current3 = composer.current) == null ? void 0 : _composer$current3.render();
  }, renderIndex);
  const passes = [];
  if (!disableRenderPass)
    passes.push(React21.createElement("renderPass", {
      key: "renderpass",
      attach: `passes-${passes.length}`,
      args: [scene, camera]
    }));
  if (!disableGamma)
    passes.push(React21.createElement("shaderPass", {
      attach: `passes-${passes.length}`,
      key: "gammapass",
      args: [GammaCorrectionShader]
    }));
  React21.Children.forEach(children, (el) => {
    el && passes.push(React21.cloneElement(el, {
      key: passes.length,
      attach: `passes-${passes.length}`
    }));
  });
  return React21.createElement("effectComposer", _extends({
    ref: react_merge_refs_esm_default([ref, composer]),
    args: [gl, target2]
  }, props), passes);
});

// node_modules/@react-three/drei/core/GradientTexture.js
var React22 = __toESM(require_react());
function GradientTexture({
  stops,
  colors: colors3,
  size = 1024,
  ...props
}) {
  const canvas = React22.useMemo(() => {
    const canvas2 = document.createElement("canvas");
    const context10 = canvas2.getContext("2d");
    canvas2.width = 16;
    canvas2.height = size;
    const gradient = context10.createLinearGradient(0, 0, 0, size);
    let i3 = stops.length;
    while (i3--) {
      gradient.addColorStop(stops[i3], colors3[i3]);
    }
    context10.fillStyle = gradient;
    context10.fillRect(0, 0, 16, size);
    return canvas2;
  }, [stops]);
  return React22.createElement("canvasTexture", _extends({
    args: [canvas],
    attach: "map"
  }, props));
}

// node_modules/@react-three/drei/core/Image.js
var React23 = __toESM(require_react());

// node_modules/@react-three/drei/core/shaderMaterial.js
function shaderMaterial(uniforms, vertexShader2, fragmentShader2, onInit) {
  const material = class material extends ShaderMaterial {
    constructor(parameters = {}) {
      const entries = Object.entries(uniforms);
      super({
        uniforms: entries.reduce((acc, [name, value]) => {
          const uniform = UniformsUtils.clone({
            [name]: {
              value
            }
          });
          return {
            ...acc,
            ...uniform
          };
        }, {}),
        vertexShader: vertexShader2,
        fragmentShader: fragmentShader2
      });
      this.key = "";
      entries.forEach(([name]) => Object.defineProperty(this, name, {
        get: () => this.uniforms[name].value,
        set: (v4) => this.uniforms[name].value = v4
      }));
      Object.assign(this, parameters);
      if (onInit)
        onInit(this);
    }
  };
  material.key = MathUtils.generateUUID();
  return material;
}

// node_modules/@react-three/drei/core/useTexture.js
var import_react7 = __toESM(require_react());
var IsObject = (url) => url === Object(url) && !Array.isArray(url) && typeof url !== "function";
function useTexture(input, onLoad) {
  const gl = useThree((state) => state.gl);
  const textures = useLoader(TextureLoader, IsObject(input) ? Object.values(input) : input);
  (0, import_react7.useLayoutEffect)(() => {
    onLoad == null ? void 0 : onLoad(textures);
  }, [onLoad]);
  (0, import_react7.useEffect)(() => {
    const array = Array.isArray(textures) ? textures : [textures];
    array.forEach(gl.initTexture);
  }, [gl, textures]);
  if (IsObject(input)) {
    const keys = Object.keys(input);
    const keyed = {};
    keys.forEach((key) => Object.assign(keyed, {
      [key]: textures[keys.indexOf(key)]
    }));
    return keyed;
  } else {
    return textures;
  }
}
useTexture.preload = (url) => useLoader.preload(TextureLoader, url);
useTexture.clear = (input) => useLoader.clear(TextureLoader, input);

// node_modules/@react-three/drei/core/Image.js
var ImageMaterialImpl = shaderMaterial(
  {
    color: new Color("white"),
    scale: [1, 1],
    imageBounds: [1, 1],
    map: null,
    zoom: 1,
    grayscale: 0,
    opacity: 1
  },
  /* glsl */
  `
  varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
    vUv = uv;
  }
`,
  /* glsl */
  `
  // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
  varying vec2 vUv;
  uniform vec2 scale;
  uniform vec2 imageBounds;
  uniform vec3 color;
  uniform sampler2D map;
  uniform float zoom;
  uniform float grayscale;
  uniform float opacity;
  const vec3 luma = vec3(.299, 0.587, 0.114);
  vec4 toGrayscale(vec4 color, float intensity) {
    return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);
  }
  vec2 aspect(vec2 size) {
    return size / min(size.x, size.y);
  }
  void main() {
    vec2 s = aspect(scale);
    vec2 i = aspect(imageBounds);
    float rs = s.x / s.y;
    float ri = i.x / i.y;
    vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
    vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
    vec2 uv = vUv * s / new + offset;
    vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);
    gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, opacity), grayscale);
    
    #include <tonemapping_fragment>
    #include <encodings_fragment>
  }
`
);
var ImageBase = React23.forwardRef(({
  children,
  color,
  segments = 1,
  scale: scale2 = 1,
  zoom = 1,
  grayscale = 0,
  opacity = 1,
  texture,
  toneMapped,
  transparent,
  ...props
}, ref) => {
  extend({
    ImageMaterial: ImageMaterialImpl
  });
  const planeBounds = Array.isArray(scale2) ? [scale2[0], scale2[1]] : [scale2, scale2];
  const imageBounds = [texture.image.width, texture.image.height];
  return React23.createElement("mesh", _extends({
    ref,
    scale: Array.isArray(scale2) ? [...scale2, 1] : scale2
  }, props), React23.createElement("planeGeometry", {
    args: [1, 1, segments, segments]
  }), React23.createElement("imageMaterial", {
    color,
    map: texture,
    zoom,
    grayscale,
    opacity,
    scale: planeBounds,
    imageBounds,
    toneMapped,
    transparent
  }), children);
});
var ImageWithUrl = React23.forwardRef(({
  url,
  ...props
}, ref) => {
  const texture = useTexture(url);
  return React23.createElement(ImageBase, _extends({}, props, {
    texture,
    ref
  }));
});
var ImageWithTexture = React23.forwardRef(({
  url: _url,
  ...props
}, ref) => {
  return React23.createElement(ImageBase, _extends({}, props, {
    ref
  }));
});
var Image = React23.forwardRef((props, ref) => {
  if (props.url)
    return React23.createElement(ImageWithUrl, _extends({}, props, {
      ref
    }));
  else if (props.texture)
    return React23.createElement(ImageWithTexture, _extends({}, props, {
      ref
    }));
  else
    throw new Error("<Image /> requires a url or texture");
});

// node_modules/@react-three/drei/core/Edges.js
var React24 = __toESM(require_react());
var Edges = React24.forwardRef(({
  userData,
  children,
  geometry,
  threshold = 15,
  color = "black",
  ...props
}, fref) => {
  const ref = React24.useRef(null);
  React24.useLayoutEffect(() => {
    const parent = ref.current.parent;
    if (parent) {
      const geom = geometry || parent.geometry;
      if (geom !== ref.current.userData.currentGeom || threshold !== ref.current.userData.currentThreshold) {
        ref.current.userData.currentGeom = geom;
        ref.current.userData.currentThreshold = threshold;
        ref.current.geometry = new EdgesGeometry(geom, threshold);
      }
    }
  });
  React24.useImperativeHandle(fref, () => ref.current);
  return React24.createElement("lineSegments", _extends({
    ref,
    raycast: () => null
  }, props), children ? children : React24.createElement("lineBasicMaterial", {
    color
  }));
});

// node_modules/@react-three/drei/core/Trail.js
var React25 = __toESM(require_react());

// node_modules/meshline/dist/index.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function memcpy(src, srcOffset, dst, dstOffset, length) {
  let i3;
  src = src.subarray || src.slice ? src : src.buffer;
  dst = dst.subarray || dst.slice ? dst : dst.buffer;
  src = srcOffset ? src.subarray ? src.subarray(srcOffset, length && srcOffset + length) : src.slice(srcOffset, length && srcOffset + length) : src;
  if (dst.set) {
    dst.set(src, dstOffset);
  } else {
    for (i3 = 0; i3 < src.length; i3++)
      dst[i3 + dstOffset] = src[i3];
  }
  return dst;
}
function convertPoints(points) {
  if (points instanceof Float32Array)
    return points;
  if (points instanceof BufferGeometry)
    return points.getAttribute("position").array;
  return points.map((p) => {
    const isArray3 = Array.isArray(p);
    return p instanceof Vector3 ? [p.x, p.y, p.z] : p instanceof Vector2 ? [p.x, p.y, 0] : isArray3 && p.length === 3 ? [p[0], p[1], p[2]] : isArray3 && p.length === 2 ? [p[0], p[1], 0] : p;
  }).flat();
}
var MeshLineGeometry = class extends BufferGeometry {
  constructor() {
    super();
    __publicField(this, "type", "MeshLine");
    __publicField(this, "isMeshLine", true);
    __publicField(this, "positions", []);
    __publicField(this, "previous", []);
    __publicField(this, "next", []);
    __publicField(this, "side", []);
    __publicField(this, "width", []);
    __publicField(this, "indices_array", []);
    __publicField(this, "uvs", []);
    __publicField(this, "counters", []);
    __publicField(this, "widthCallback", null);
    __publicField(this, "_attributes");
    __publicField(this, "_points", []);
    __publicField(this, "points");
    __publicField(this, "matrixWorld", new Matrix4());
    Object.defineProperties(this, {
      points: {
        enumerable: true,
        get() {
          return this._points;
        },
        set(value) {
          this.setPoints(value, this.widthCallback);
        }
      }
    });
  }
  setMatrixWorld(matrixWorld) {
    this.matrixWorld = matrixWorld;
  }
  setPoints(points, wcb) {
    points = convertPoints(points);
    this._points = points;
    this.widthCallback = wcb != null ? wcb : null;
    this.positions = [];
    this.counters = [];
    if (points.length && points[0] instanceof Vector3) {
      for (let j = 0; j < points.length; j++) {
        const p = points[j];
        const c6 = j / (points.length - 1);
        this.positions.push(p.x, p.y, p.z);
        this.positions.push(p.x, p.y, p.z);
        this.counters.push(c6);
        this.counters.push(c6);
      }
    } else {
      for (let j = 0; j < points.length; j += 3) {
        const c6 = j / (points.length - 1);
        this.positions.push(points[j], points[j + 1], points[j + 2]);
        this.positions.push(points[j], points[j + 1], points[j + 2]);
        this.counters.push(c6);
        this.counters.push(c6);
      }
    }
    this.process();
  }
  compareV3(a3, b) {
    const aa = a3 * 6;
    const ab = b * 6;
    return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];
  }
  copyV3(a3) {
    const aa = a3 * 6;
    return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];
  }
  process() {
    const l2 = this.positions.length / 6;
    this.previous = [];
    this.next = [];
    this.side = [];
    this.width = [];
    this.indices_array = [];
    this.uvs = [];
    let w;
    let v4;
    if (this.compareV3(0, l2 - 1)) {
      v4 = this.copyV3(l2 - 2);
    } else {
      v4 = this.copyV3(0);
    }
    this.previous.push(v4[0], v4[1], v4[2]);
    this.previous.push(v4[0], v4[1], v4[2]);
    for (let j = 0; j < l2; j++) {
      this.side.push(1);
      this.side.push(-1);
      if (this.widthCallback)
        w = this.widthCallback(j / (l2 - 1));
      else
        w = 1;
      this.width.push(w);
      this.width.push(w);
      this.uvs.push(j / (l2 - 1), 0);
      this.uvs.push(j / (l2 - 1), 1);
      if (j < l2 - 1) {
        v4 = this.copyV3(j);
        this.previous.push(v4[0], v4[1], v4[2]);
        this.previous.push(v4[0], v4[1], v4[2]);
        const n2 = j * 2;
        this.indices_array.push(n2, n2 + 1, n2 + 2);
        this.indices_array.push(n2 + 2, n2 + 1, n2 + 3);
      }
      if (j > 0) {
        v4 = this.copyV3(j);
        this.next.push(v4[0], v4[1], v4[2]);
        this.next.push(v4[0], v4[1], v4[2]);
      }
    }
    if (this.compareV3(l2 - 1, 0)) {
      v4 = this.copyV3(1);
    } else {
      v4 = this.copyV3(l2 - 1);
    }
    this.next.push(v4[0], v4[1], v4[2]);
    this.next.push(v4[0], v4[1], v4[2]);
    if (!this._attributes || this._attributes.position.count !== this.positions.length) {
      this._attributes = {
        position: new BufferAttribute(new Float32Array(this.positions), 3),
        previous: new BufferAttribute(new Float32Array(this.previous), 3),
        next: new BufferAttribute(new Float32Array(this.next), 3),
        side: new BufferAttribute(new Float32Array(this.side), 1),
        width: new BufferAttribute(new Float32Array(this.width), 1),
        uv: new BufferAttribute(new Float32Array(this.uvs), 2),
        index: new BufferAttribute(new Uint16Array(this.indices_array), 1),
        counters: new BufferAttribute(new Float32Array(this.counters), 1)
      };
    } else {
      this._attributes.position.copyArray(new Float32Array(this.positions));
      this._attributes.position.needsUpdate = true;
      this._attributes.previous.copyArray(new Float32Array(this.previous));
      this._attributes.previous.needsUpdate = true;
      this._attributes.next.copyArray(new Float32Array(this.next));
      this._attributes.next.needsUpdate = true;
      this._attributes.side.copyArray(new Float32Array(this.side));
      this._attributes.side.needsUpdate = true;
      this._attributes.width.copyArray(new Float32Array(this.width));
      this._attributes.width.needsUpdate = true;
      this._attributes.uv.copyArray(new Float32Array(this.uvs));
      this._attributes.uv.needsUpdate = true;
      this._attributes.index.copyArray(new Uint16Array(this.indices_array));
      this._attributes.index.needsUpdate = true;
    }
    this.setAttribute("position", this._attributes.position);
    this.setAttribute("previous", this._attributes.previous);
    this.setAttribute("next", this._attributes.next);
    this.setAttribute("side", this._attributes.side);
    this.setAttribute("width", this._attributes.width);
    this.setAttribute("uv", this._attributes.uv);
    this.setAttribute("counters", this._attributes.counters);
    this.setAttribute("position", this._attributes.position);
    this.setAttribute("previous", this._attributes.previous);
    this.setAttribute("next", this._attributes.next);
    this.setAttribute("side", this._attributes.side);
    this.setAttribute("width", this._attributes.width);
    this.setAttribute("uv", this._attributes.uv);
    this.setAttribute("counters", this._attributes.counters);
    this.setIndex(this._attributes.index);
    this.computeBoundingSphere();
    this.computeBoundingBox();
  }
  advance({ x, y, z }) {
    const positions = this._attributes.position.array;
    const previous = this._attributes.previous.array;
    const next = this._attributes.next.array;
    const l2 = positions.length;
    memcpy(positions, 0, previous, 0, l2);
    memcpy(positions, 6, positions, 0, l2 - 6);
    positions[l2 - 6] = x;
    positions[l2 - 5] = y;
    positions[l2 - 4] = z;
    positions[l2 - 3] = x;
    positions[l2 - 2] = y;
    positions[l2 - 1] = z;
    memcpy(positions, 6, next, 0, l2 - 6);
    next[l2 - 6] = x;
    next[l2 - 5] = y;
    next[l2 - 4] = z;
    next[l2 - 3] = x;
    next[l2 - 2] = y;
    next[l2 - 1] = z;
    this._attributes.position.needsUpdate = true;
    this._attributes.previous.needsUpdate = true;
    this._attributes.next.needsUpdate = true;
  }
};
var vertexShader = `
  #include <common>
  #include <logdepthbuf_pars_vertex>
  #include <fog_pars_vertex>

  attribute vec3 previous;
  attribute vec3 next;
  attribute float side;
  attribute float width;
  attribute float counters;
  
  uniform vec2 resolution;
  uniform float lineWidth;
  uniform vec3 color;
  uniform float opacity;
  uniform float sizeAttenuation;
  
  varying vec2 vUV;
  varying vec4 vColor;
  varying float vCounters;
  
  vec2 fix(vec4 i, float aspect) {
    vec2 res = i.xy / i.w;
    res.x *= aspect;
  	vCounters = counters;
    return res;
  }
  
  void main() {
    float aspect = resolution.x / resolution.y;
    vColor = vec4(color, opacity);
    vUV = uv;
  
    mat4 m = projectionMatrix * modelViewMatrix;
    vec4 finalPosition = m * vec4(position, 1.0);
    vec4 prevPos = m * vec4(previous, 1.0);
    vec4 nextPos = m * vec4(next, 1.0);
  
    vec2 currentP = fix(finalPosition, aspect);
    vec2 prevP = fix(prevPos, aspect);
    vec2 nextP = fix(nextPos, aspect);
  
    float w = lineWidth * width;
  
    vec2 dir;
    if (nextP == currentP) dir = normalize(currentP - prevP);
    else if (prevP == currentP) dir = normalize(nextP - currentP);
    else {
      vec2 dir1 = normalize(currentP - prevP);
      vec2 dir2 = normalize(nextP - currentP);
      dir = normalize(dir1 + dir2);
  
      vec2 perp = vec2(-dir1.y, dir1.x);
      vec2 miter = vec2(-dir.y, dir.x);
      //w = clamp(w / dot(miter, perp), 0., 4. * lineWidth * width);
    }
  
    //vec2 normal = (cross(vec3(dir, 0.), vec3(0., 0., 1.))).xy;
    vec4 normal = vec4(-dir.y, dir.x, 0., 1.);
    normal.xy *= .5 * w;
    //normal *= projectionMatrix;
    if (sizeAttenuation == 0.) {
      normal.xy *= finalPosition.w;
      normal.xy /= (vec4(resolution, 0., 1.) * projectionMatrix).xy;
    }
  
    finalPosition.xy += normal.xy * side;
    gl_Position = finalPosition;
    #include <logdepthbuf_vertex>
    #include <fog_vertex>
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    #include <fog_vertex>
  }
`;
var fragmentShader = `
  #include <fog_pars_fragment>
  #include <logdepthbuf_pars_fragment>
  
  uniform sampler2D map;
  uniform sampler2D alphaMap;
  uniform float useMap;
  uniform float useAlphaMap;
  uniform float useDash;
  uniform float dashArray;
  uniform float dashOffset;
  uniform float dashRatio;
  uniform float visibility;
  uniform float alphaTest;
  uniform vec2 repeat;
  
  varying vec2 vUV;
  varying vec4 vColor;
  varying float vCounters;
  
  void main() {
    #include <logdepthbuf_fragment>
    vec4 c = vColor;
    if (useMap == 1.) c *= texture2D(map, vUV * repeat);
    if (useAlphaMap == 1.) c.a *= texture2D(alphaMap, vUV * repeat).a;
    if (c.a < alphaTest) discard;
    if (useDash == 1.) {
      c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));
    }
    gl_FragColor = c;
    gl_FragColor.a *= step(vCounters, visibility);
    #include <fog_fragment>
    #include <tonemapping_fragment>
    #include <encodings_fragment>
  }
`;
var MeshLineMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super({
      uniforms: {
        ...UniformsLib.fog,
        lineWidth: { value: 1 },
        map: { value: null },
        useMap: { value: 0 },
        alphaMap: { value: null },
        useAlphaMap: { value: 0 },
        color: { value: new Color(16777215) },
        opacity: { value: 1 },
        resolution: { value: new Vector2(1, 1) },
        sizeAttenuation: { value: 1 },
        dashArray: { value: 0 },
        dashOffset: { value: 0 },
        dashRatio: { value: 0.5 },
        useDash: { value: 0 },
        visibility: { value: 1 },
        alphaTest: { value: 0 },
        repeat: { value: new Vector2(1, 1) }
      },
      vertexShader,
      fragmentShader
    });
    __publicField(this, "lineWidth");
    __publicField(this, "map");
    __publicField(this, "useMap");
    __publicField(this, "alphaMap");
    __publicField(this, "useAlphaMap");
    __publicField(this, "color");
    __publicField(this, "resolution");
    __publicField(this, "sizeAttenuation");
    __publicField(this, "dashArray");
    __publicField(this, "dashOffset");
    __publicField(this, "dashRatio");
    __publicField(this, "useDash");
    __publicField(this, "visibility");
    __publicField(this, "repeat");
    this.type = "MeshLineMaterial";
    Object.defineProperties(this, {
      lineWidth: {
        enumerable: true,
        get() {
          return this.uniforms.lineWidth.value;
        },
        set(value) {
          this.uniforms.lineWidth.value = value;
        }
      },
      map: {
        enumerable: true,
        get() {
          return this.uniforms.map.value;
        },
        set(value) {
          this.uniforms.map.value = value;
        }
      },
      useMap: {
        enumerable: true,
        get() {
          return this.uniforms.useMap.value;
        },
        set(value) {
          this.uniforms.useMap.value = value;
        }
      },
      alphaMap: {
        enumerable: true,
        get() {
          return this.uniforms.alphaMap.value;
        },
        set(value) {
          this.uniforms.alphaMap.value = value;
        }
      },
      useAlphaMap: {
        enumerable: true,
        get() {
          return this.uniforms.useAlphaMap.value;
        },
        set(value) {
          this.uniforms.useAlphaMap.value = value;
        }
      },
      color: {
        enumerable: true,
        get() {
          return this.uniforms.color.value;
        },
        set(value) {
          this.uniforms.color.value = value;
        }
      },
      opacity: {
        enumerable: true,
        get() {
          return this.uniforms.opacity.value;
        },
        set(value) {
          this.uniforms.opacity.value = value;
        }
      },
      resolution: {
        enumerable: true,
        get() {
          return this.uniforms.resolution.value;
        },
        set(value) {
          this.uniforms.resolution.value.copy(value);
        }
      },
      sizeAttenuation: {
        enumerable: true,
        get() {
          return this.uniforms.sizeAttenuation.value;
        },
        set(value) {
          this.uniforms.sizeAttenuation.value = value;
        }
      },
      dashArray: {
        enumerable: true,
        get() {
          return this.uniforms.dashArray.value;
        },
        set(value) {
          this.uniforms.dashArray.value = value;
          this.useDash = value !== 0 ? 1 : 0;
        }
      },
      dashOffset: {
        enumerable: true,
        get() {
          return this.uniforms.dashOffset.value;
        },
        set(value) {
          this.uniforms.dashOffset.value = value;
        }
      },
      dashRatio: {
        enumerable: true,
        get() {
          return this.uniforms.dashRatio.value;
        },
        set(value) {
          this.uniforms.dashRatio.value = value;
        }
      },
      useDash: {
        enumerable: true,
        get() {
          return this.uniforms.useDash.value;
        },
        set(value) {
          this.uniforms.useDash.value = value;
        }
      },
      visibility: {
        enumerable: true,
        get() {
          return this.uniforms.visibility.value;
        },
        set(value) {
          this.uniforms.visibility.value = value;
        }
      },
      alphaTest: {
        enumerable: true,
        get() {
          return this.uniforms.alphaTest.value;
        },
        set(value) {
          this.uniforms.alphaTest.value = value;
        }
      },
      repeat: {
        enumerable: true,
        get() {
          return this.uniforms.repeat.value;
        },
        set(value) {
          this.uniforms.repeat.value.copy(value);
        }
      }
    });
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.lineWidth = source.lineWidth;
    this.map = source.map;
    this.useMap = source.useMap;
    this.alphaMap = source.alphaMap;
    this.useAlphaMap = source.useAlphaMap;
    this.color.copy(source.color);
    this.opacity = source.opacity;
    this.resolution.copy(source.resolution);
    this.sizeAttenuation = source.sizeAttenuation;
    this.dashArray = source.dashArray;
    this.dashOffset = source.dashOffset;
    this.dashRatio = source.dashRatio;
    this.useDash = source.useDash;
    this.visibility = source.visibility;
    this.alphaTest = source.alphaTest;
    this.repeat.copy(source.repeat);
    return this;
  }
};

// node_modules/@react-three/drei/core/Trail.js
var defaults2 = {
  width: 0.2,
  length: 1,
  decay: 1,
  local: false,
  stride: 0,
  interval: 1
};
var shiftLeft = (collection, steps2 = 1) => {
  collection.set(collection.subarray(steps2));
  collection.fill(-Infinity, -steps2);
  return collection;
};
function useTrail(target2, settings) {
  const {
    length,
    local,
    decay,
    interval,
    stride
  } = {
    ...defaults2,
    ...settings
  };
  const points = React25.useRef();
  const [worldPosition] = React25.useState(() => new Vector3());
  React25.useLayoutEffect(() => {
    if (target2) {
      points.current = Float32Array.from({
        length: length * 10 * 3
      }, (_, i3) => target2.position.getComponent(i3 % 3));
    }
  }, [length, target2]);
  const prevPosition = React25.useRef(new Vector3());
  const frameCount = React25.useRef(0);
  useFrame(() => {
    if (!target2)
      return;
    if (!points.current)
      return;
    if (frameCount.current === 0) {
      let newPosition;
      if (local) {
        newPosition = target2.position;
      } else {
        target2.getWorldPosition(worldPosition);
        newPosition = worldPosition;
      }
      const steps2 = 1 * decay;
      for (let i3 = 0; i3 < steps2; i3++) {
        if (newPosition.distanceTo(prevPosition.current) < stride)
          continue;
        shiftLeft(points.current, 3);
        points.current.set(newPosition.toArray(), points.current.length - 3);
      }
      prevPosition.current.copy(newPosition);
    }
    frameCount.current++;
    frameCount.current = frameCount.current % interval;
  });
  return points;
}
var Trail = React25.forwardRef((props, forwardRef71) => {
  const {
    children
  } = props;
  const {
    width,
    length,
    decay,
    local,
    stride,
    interval
  } = {
    ...defaults2,
    ...props
  };
  const {
    color = "hotpink",
    attenuation,
    target: target2
  } = props;
  const size = useThree((s2) => s2.size);
  const scene = useThree((s2) => s2.scene);
  const ref = React25.useRef(null);
  const [anchor, setAnchor] = React25.useState(null);
  const points = useTrail(anchor, {
    length,
    decay,
    local,
    stride,
    interval
  });
  React25.useEffect(() => {
    const t2 = (target2 == null ? void 0 : target2.current) || ref.current.children.find((o2) => {
      return o2 instanceof Object3D;
    });
    if (t2) {
      setAnchor(t2);
    }
  }, [points, target2]);
  const geo = React25.useMemo(() => new MeshLineGeometry(), []);
  const mat = React25.useMemo(() => {
    var _matOverride;
    const m = new MeshLineMaterial({
      lineWidth: 0.1 * width,
      color,
      sizeAttenuation: 1,
      resolution: new Vector2(size.width, size.height)
    });
    let matOverride;
    if (children) {
      if (Array.isArray(children)) {
        matOverride = children.find((child) => {
          const c6 = child;
          return typeof c6.type === "string" && c6.type === "meshLineMaterial";
        });
      } else {
        const c6 = children;
        if (typeof c6.type === "string" && c6.type === "meshLineMaterial") {
          matOverride = c6;
        }
      }
    }
    if (typeof ((_matOverride = matOverride) == null ? void 0 : _matOverride.props) === "object") {
      m.setValues(matOverride.props);
    }
    return m;
  }, [width, color, size, children]);
  React25.useEffect(() => {
    mat.uniforms.resolution.value.set(size.width, size.height);
  }, [size]);
  useFrame(() => {
    if (!points.current)
      return;
    geo.setPoints(points.current, attenuation);
  });
  return React25.createElement("group", null, createPortal(React25.createElement("mesh", {
    ref: forwardRef71,
    geometry: geo,
    material: mat
  }), scene), React25.createElement("group", {
    ref
  }, children));
});

// node_modules/@react-three/drei/core/Sampler.js
var React26 = __toESM(require_react());
function useSurfaceSampler(mesh, count = 16, transform, weight, instanceMesh) {
  const [buffer, setBuffer] = React26.useState(() => {
    const arr = Array.from({
      length: count
    }, () => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]).flat();
    return new InstancedBufferAttribute(Float32Array.from(arr), 16);
  });
  React26.useLayoutEffect(() => {
    if (typeof mesh.current === "undefined")
      return;
    const sampler = new MeshSurfaceSampler(mesh.current);
    if (weight) {
      sampler.setWeightAttribute(weight);
    }
    sampler.build();
    const position2 = new Vector3();
    const normal2 = new Vector3();
    const color = new Color();
    const dummy2 = new Object3D();
    mesh.current.updateMatrixWorld(true);
    for (let i3 = 0; i3 < count; i3++) {
      sampler.sample(position2, normal2, color);
      if (typeof transform === "function") {
        transform({
          dummy: dummy2,
          sampledMesh: mesh.current,
          position: position2,
          normal: normal2,
          color
        }, i3);
      } else {
        dummy2.position.copy(position2);
      }
      dummy2.updateMatrix();
      if (instanceMesh != null && instanceMesh.current) {
        instanceMesh.current.setMatrixAt(i3, dummy2.matrix);
      }
      dummy2.matrix.toArray(buffer.array, i3 * 16);
    }
    if (instanceMesh != null && instanceMesh.current) {
      instanceMesh.current.instanceMatrix.needsUpdate = true;
    }
    buffer.needsUpdate = true;
    setBuffer(buffer.clone());
  }, [mesh, instanceMesh, weight, count, transform]);
  return buffer;
}
function Sampler({
  children,
  weight,
  transform,
  instances,
  mesh,
  count = 16,
  ...props
}) {
  const group = React26.useRef(null);
  const instancedRef = React26.useRef(null);
  const meshToSampleRef = React26.useRef(null);
  React26.useLayoutEffect(() => {
    var _instances$current, _mesh$current;
    instancedRef.current = (_instances$current = instances == null ? void 0 : instances.current) !== null && _instances$current !== void 0 ? _instances$current : group.current.children.find((c6) => c6.hasOwnProperty("instanceMatrix"));
    meshToSampleRef.current = (_mesh$current = mesh == null ? void 0 : mesh.current) !== null && _mesh$current !== void 0 ? _mesh$current : group.current.children.find((c6) => c6.type === "Mesh");
  }, [children, mesh == null ? void 0 : mesh.current, instances == null ? void 0 : instances.current]);
  useSurfaceSampler(meshToSampleRef, count, transform, weight, instancedRef);
  return React26.createElement("group", _extends({
    ref: group
  }, props), children);
}

// node_modules/@react-three/drei/core/ComputedAttribute.js
var React27 = __toESM(require_react());
var ComputedAttribute = ({
  compute: compute2,
  name,
  ...props
}) => {
  const [bufferAttribute] = React27.useState(() => new BufferAttribute(new Float32Array(0), 1));
  const primitive = React27.useRef(null);
  React27.useLayoutEffect(() => {
    if (primitive.current) {
      var _ref;
      const parent = (_ref = primitive.current.parent) !== null && _ref !== void 0 ? _ref : primitive.current.__r3f.parent;
      const attr = compute2(parent);
      primitive.current.copy(attr);
    }
  }, [compute2]);
  return React27.createElement("primitive", _extends({
    ref: primitive,
    object: bufferAttribute,
    attach: `attributes-${name}`
  }, props));
};

// node_modules/@react-three/drei/core/Clone.js
var React28 = __toESM(require_react());
var import_lodash = __toESM(require_lodash());
function createSpread(child, {
  keys = ["near", "far", "color", "distance", "decay", "penumbra", "angle", "intensity", "skeleton", "visible", "castShadow", "receiveShadow", "morphTargetDictionary", "morphTargetInfluences", "name", "geometry", "material", "position", "rotation", "scale", "up", "userData", "bindMode", "bindMatrix", "bindMatrixInverse", "skeleton"],
  deep,
  inject,
  castShadow,
  receiveShadow
}) {
  let spread = (0, import_lodash.default)(child, keys);
  if (deep) {
    if (spread.geometry && deep !== "materialsOnly")
      spread.geometry = spread.geometry.clone();
    if (spread.material && deep !== "geometriesOnly")
      spread.material = spread.material.clone();
  }
  if (inject) {
    if (typeof inject === "function")
      spread = {
        ...spread,
        children: inject(child)
      };
    else if (React28.isValidElement(inject))
      spread = {
        ...spread,
        children: inject
      };
    else
      spread = {
        ...spread,
        ...inject
      };
  }
  if (child instanceof Mesh) {
    if (castShadow)
      spread.castShadow = true;
    if (receiveShadow)
      spread.receiveShadow = true;
  }
  return spread;
}
var Clone = React28.forwardRef(({
  isChild = false,
  object,
  children,
  deep,
  castShadow,
  receiveShadow,
  inject,
  keys,
  ...props
}, forwardRef71) => {
  var _object;
  const config2 = {
    keys,
    deep,
    inject,
    castShadow,
    receiveShadow
  };
  object = React28.useMemo(() => {
    if (isChild === false && !Array.isArray(object)) {
      let isSkinned = false;
      object.traverse((object2) => {
        if (object2.isSkinnedMesh)
          isSkinned = true;
      });
      if (isSkinned)
        return SkeletonUtils.clone(object);
    }
    return object;
  }, [object, isChild]);
  if (Array.isArray(object)) {
    return React28.createElement("group", _extends({}, props, {
      ref: forwardRef71
    }), object.map((o2) => React28.createElement(Clone, _extends({
      key: o2.uuid,
      object: o2
    }, config2))), children);
  }
  const {
    children: injectChildren,
    ...spread
  } = createSpread(object, config2);
  const Element = object.type[0].toLowerCase() + object.type.slice(1);
  return React28.createElement(Element, _extends({}, spread, props, {
    ref: forwardRef71
  }), ((_object = object) == null ? void 0 : _object.children).map((child) => {
    if (child.type === "Bone")
      return React28.createElement("primitive", _extends({
        key: child.uuid,
        object: child
      }, config2));
    return React28.createElement(Clone, _extends({
      key: child.uuid,
      object: child
    }, config2, {
      isChild: true
    }));
  }), children, injectChildren);
});

// node_modules/@react-three/drei/core/MarchingCubes.js
var React29 = __toESM(require_react());
var globalContext = React29.createContext(null);
var MarchingCubes2 = React29.forwardRef(({
  resolution = 28,
  maxPolyCount = 1e4,
  enableUvs = false,
  enableColors = false,
  children,
  ...props
}, ref) => {
  const marchingCubesRef = React29.useRef(null);
  const marchingCubes = React29.useMemo(() => new MarchingCubes(resolution, null, enableUvs, enableColors, maxPolyCount), [resolution, maxPolyCount, enableUvs, enableColors]);
  const api = React29.useMemo(() => ({
    getParent: () => marchingCubesRef
  }), []);
  useFrame(() => {
    marchingCubes.update();
    marchingCubes.reset();
  }, -1);
  return React29.createElement(React29.Fragment, null, React29.createElement("primitive", _extends({
    object: marchingCubes,
    ref: react_merge_refs_esm_default([marchingCubesRef, ref])
  }, props), React29.createElement(globalContext.Provider, {
    value: api
  }, children)));
});
var MarchingCube = React29.forwardRef(({
  strength = 0.5,
  subtract = 12,
  color,
  ...props
}, ref) => {
  const {
    getParent
  } = React29.useContext(globalContext);
  const parentRef = React29.useMemo(() => getParent(), [getParent]);
  const cubeRef = React29.useRef();
  const vec = new Vector3();
  useFrame((state) => {
    if (!parentRef.current || !cubeRef.current)
      return;
    cubeRef.current.getWorldPosition(vec);
    parentRef.current.addBall(0.5 + vec.x * 0.5, 0.5 + vec.y * 0.5, 0.5 + vec.z * 0.5, strength, subtract, color);
  });
  return React29.createElement("group", _extends({
    ref: react_merge_refs_esm_default([ref, cubeRef])
  }, props));
});
var MarchingPlane = React29.forwardRef(({
  planeType: _planeType = "x",
  strength = 0.5,
  subtract = 12,
  ...props
}, ref) => {
  const {
    getParent
  } = React29.useContext(globalContext);
  const parentRef = React29.useMemo(() => getParent(), [getParent]);
  const wallRef = React29.useRef();
  const planeType = React29.useMemo(() => _planeType === "x" ? "addPlaneX" : _planeType === "y" ? "addPlaneY" : "addPlaneZ", [_planeType]);
  useFrame(() => {
    if (!parentRef.current || !wallRef.current)
      return;
    parentRef.current[planeType](strength, subtract);
  });
  return React29.createElement("group", _extends({
    ref: react_merge_refs_esm_default([ref, wallRef])
  }, props));
});

// node_modules/@react-three/drei/core/Decal.js
var React30 = __toESM(require_react());
function isArray(vec) {
  return Array.isArray(vec);
}
function vecToArray(vec = [0, 0, 0]) {
  if (isArray(vec)) {
    return vec;
  } else if (vec instanceof Vector3 || vec instanceof Euler) {
    return [vec.x, vec.y, vec.z];
  } else {
    return [vec, vec, vec];
  }
}
var Decal = React30.forwardRef(function Decal2({
  debug,
  mesh,
  children,
  position: position2,
  rotation: rotation2,
  scale: scale2,
  ...props
}, forwardRef71) {
  const ref = React30.useRef(null);
  React30.useImperativeHandle(forwardRef71, () => ref.current);
  const helper = React30.useRef(null);
  React30.useLayoutEffect(() => {
    const parent = (mesh == null ? void 0 : mesh.current) || ref.current.parent;
    const target2 = ref.current;
    if (!(parent instanceof Mesh)) {
      throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop');
    }
    const state = {
      position: new Vector3(),
      rotation: new Euler(),
      scale: new Vector3(1, 1, 1)
    };
    if (parent) {
      applyProps(state, {
        position: position2,
        scale: scale2
      });
      const matrixWorld = parent.matrixWorld.clone();
      parent.matrixWorld.identity();
      if (!rotation2 || typeof rotation2 === "number") {
        const o2 = new Object3D();
        o2.position.copy(state.position);
        o2.lookAt(parent.position);
        if (typeof rotation2 === "number")
          o2.rotateZ(rotation2);
        applyProps(state, {
          rotation: o2.rotation
        });
      } else {
        applyProps(state, {
          rotation: rotation2
        });
      }
      target2.geometry = new DecalGeometry(parent, state.position, state.rotation, state.scale);
      if (helper.current)
        applyProps(helper.current, state);
      parent.matrixWorld = matrixWorld;
      return () => {
        target2.geometry.dispose();
      };
    }
  }, [mesh, ...vecToArray(position2), ...vecToArray(scale2), ...vecToArray(rotation2)]);
  return React30.createElement("mesh", {
    ref
  }, children || React30.createElement("meshStandardMaterial", _extends({
    transparent: true,
    polygonOffset: true,
    polygonOffsetFactor: -10
  }, props)), debug && React30.createElement("mesh", {
    ref: helper
  }, React30.createElement("boxGeometry", null), React30.createElement("meshNormalMaterial", {
    wireframe: true
  }), React30.createElement("axesHelper", null)));
});

// node_modules/@react-three/drei/core/Svg.js
var React31 = __toESM(require_react());
var import_react8 = __toESM(require_react());
var Svg = (0, import_react8.forwardRef)(function R3FSvg({
  src,
  skipFill,
  skipStrokes,
  fillMaterial,
  strokeMaterial,
  fillMeshProps,
  strokeMeshProps,
  ...props
}, ref) {
  const svg = useLoader(SVGLoader, !src.startsWith("<svg") ? src : `data:image/svg+xml;utf8,${src}`);
  const strokeGeometries = (0, import_react8.useMemo)(() => skipStrokes ? [] : svg.paths.map((path) => {
    var _path$userData;
    return ((_path$userData = path.userData) == null ? void 0 : _path$userData.style.stroke) === void 0 || path.userData.style.stroke === "none" ? null : path.subPaths.map((subPath) => SVGLoader.pointsToStroke(subPath.getPoints(), path.userData.style));
  }), [svg, skipStrokes]);
  (0, import_react8.useEffect)(() => {
    return () => strokeGeometries.forEach((group) => group && group.map((g) => g.dispose()));
  }, [strokeGeometries]);
  return React31.createElement("object3D", _extends({
    ref
  }, props), React31.createElement("object3D", {
    scale: [1, -1, 1]
  }, svg.paths.map((path, p) => {
    var _path$userData2, _path$userData3;
    return React31.createElement(import_react8.Fragment, {
      key: p
    }, !skipFill && ((_path$userData2 = path.userData) == null ? void 0 : _path$userData2.style.fill) !== void 0 && path.userData.style.fill !== "none" && SVGLoader.createShapes(path).map((shape, s2) => React31.createElement("mesh", _extends({
      key: s2
    }, fillMeshProps), React31.createElement("shapeGeometry", {
      args: [shape]
    }), React31.createElement("meshBasicMaterial", _extends({
      color: path.userData.style.fill,
      opacity: path.userData.style.fillOpacity,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    }, fillMaterial)))), !skipStrokes && ((_path$userData3 = path.userData) == null ? void 0 : _path$userData3.style.stroke) !== void 0 && path.userData.style.stroke !== "none" && path.subPaths.map((_subPath, s2) => React31.createElement("mesh", _extends({
      key: s2,
      geometry: strokeGeometries[p][s2]
    }, strokeMeshProps), React31.createElement("meshBasicMaterial", _extends({
      color: path.userData.style.stroke,
      opacity: path.userData.style.strokeOpacity,
      transparent: true,
      side: DoubleSide,
      depthWrite: false
    }, strokeMaterial)))));
  })));
});

// node_modules/@react-three/drei/core/Gltf.js
var React32 = __toESM(require_react());

// node_modules/@react-three/drei/core/useGLTF.js
var dracoLoader = null;
function extensions(useDraco, useMeshopt, extendLoader) {
  return (loader2) => {
    if (extendLoader) {
      extendLoader(loader2);
    }
    if (useDraco) {
      if (!dracoLoader) {
        dracoLoader = new DRACOLoader();
      }
      dracoLoader.setDecoderPath(typeof useDraco === "string" ? useDraco : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/");
      loader2.setDRACOLoader(dracoLoader);
    }
    if (useMeshopt) {
      loader2.setMeshoptDecoder(typeof MeshoptDecoder === "function" ? MeshoptDecoder() : MeshoptDecoder);
    }
  };
}
function useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {
  const gltf = useLoader(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));
  return gltf;
}
useGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));
useGLTF.clear = (input) => useLoader.clear(GLTFLoader, input);

// node_modules/@react-three/drei/core/Gltf.js
var Gltf = React32.forwardRef(({
  src,
  ...props
}, ref) => {
  const {
    scene
  } = useGLTF(src);
  return React32.createElement(Clone, _extends({
    ref
  }, props, {
    object: scene
  }));
});

// node_modules/@react-three/drei/core/AsciiRenderer.js
var React33 = __toESM(require_react());
function AsciiRenderer({
  renderIndex = 1,
  bgColor = "black",
  fgColor = "white",
  characters = " .:-+*=%@#",
  invert = true,
  color = false,
  resolution = 0.15
}) {
  const {
    size,
    gl,
    scene,
    camera
  } = useThree();
  const effect = React33.useMemo(() => {
    const effect2 = new AsciiEffect(gl, characters, {
      invert,
      color,
      resolution
    });
    effect2.domElement.style.position = "absolute";
    effect2.domElement.style.top = "0px";
    effect2.domElement.style.left = "0px";
    effect2.domElement.style.pointerEvents = "none";
    return effect2;
  }, [characters, invert, color, resolution]);
  React33.useLayoutEffect(() => {
    effect.domElement.style.color = fgColor;
    effect.domElement.style.backgroundColor = bgColor;
  }, [fgColor, bgColor]);
  React33.useEffect(() => {
    gl.domElement.style.opacity = "0";
    gl.domElement.parentNode.appendChild(effect.domElement);
    return () => {
      gl.domElement.style.opacity = "1";
      gl.domElement.parentNode.removeChild(effect.domElement);
    };
  }, [effect]);
  React33.useEffect(() => {
    effect.setSize(size.width, size.height);
  }, [effect, size]);
  useFrame((state) => {
    effect.render(scene, camera);
  }, renderIndex);
  return React33.createElement(React33.Fragment, null);
}

// node_modules/@react-three/drei/core/OrthographicCamera.js
var React35 = __toESM(require_react());

// node_modules/@react-three/drei/core/useFBO.js
var React34 = __toESM(require_react());
function useFBO(width, height, settings) {
  const size = useThree((state) => state.size);
  const viewport = useThree((state) => state.viewport);
  const _width = typeof width === "number" ? width : size.width * viewport.dpr;
  const _height = typeof height === "number" ? height : size.height * viewport.dpr;
  const _settings = (typeof width === "number" ? settings : width) || {};
  const {
    samples = 0,
    depth,
    ...targetSettings
  } = _settings;
  const target2 = React34.useMemo(() => {
    const target3 = new WebGLRenderTarget(_width, _height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      ...targetSettings
    });
    if (depth) {
      target3.depthTexture = new DepthTexture(_width, _height, FloatType);
    }
    target3.samples = samples;
    return target3;
  }, []);
  React34.useLayoutEffect(() => {
    target2.setSize(_width, _height);
    if (samples)
      target2.samples = samples;
  }, [samples, target2, _width, _height]);
  React34.useEffect(() => {
    return () => target2.dispose();
  }, []);
  return target2;
}

// node_modules/@react-three/drei/core/OrthographicCamera.js
var isFunction = (node) => typeof node === "function";
var OrthographicCamera2 = React35.forwardRef(({
  envMap,
  resolution = 256,
  frames = Infinity,
  children,
  makeDefault,
  ...props
}, ref) => {
  const set = useThree(({
    set: set2
  }) => set2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const size = useThree(({
    size: size2
  }) => size2);
  const cameraRef = React35.useRef(null);
  const groupRef = React35.useRef(null);
  const fbo = useFBO(resolution);
  React35.useLayoutEffect(() => {
    if (!props.manual) {
      cameraRef.current.updateProjectionMatrix();
    }
  }, [size, props]);
  React35.useLayoutEffect(() => {
    cameraRef.current.updateProjectionMatrix();
  });
  React35.useLayoutEffect(() => {
    if (makeDefault) {
      const oldCam = camera;
      set(() => ({
        camera: cameraRef.current
      }));
      return () => set(() => ({
        camera: oldCam
      }));
    }
  }, [cameraRef, makeDefault, set]);
  let count = 0;
  let oldEnvMap = null;
  const functional = isFunction(children);
  useFrame((state) => {
    if (functional && (frames === Infinity || count < frames)) {
      groupRef.current.visible = false;
      state.gl.setRenderTarget(fbo);
      oldEnvMap = state.scene.background;
      if (envMap)
        state.scene.background = envMap;
      state.gl.render(state.scene, cameraRef.current);
      state.scene.background = oldEnvMap;
      state.gl.setRenderTarget(null);
      groupRef.current.visible = true;
      count++;
    }
  });
  return React35.createElement(React35.Fragment, null, React35.createElement("orthographicCamera", _extends({
    left: size.width / -2,
    right: size.width / 2,
    top: size.height / 2,
    bottom: size.height / -2,
    ref: react_merge_refs_esm_default([cameraRef, ref])
  }, props), !functional && children), React35.createElement("group", {
    ref: groupRef
  }, functional && children(fbo.texture)));
});

// node_modules/@react-three/drei/core/PerspectiveCamera.js
var React36 = __toESM(require_react());
var isFunction2 = (node) => typeof node === "function";
var PerspectiveCamera2 = React36.forwardRef(({
  envMap,
  resolution = 256,
  frames = Infinity,
  makeDefault,
  children,
  ...props
}, ref) => {
  const set = useThree(({
    set: set2
  }) => set2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const size = useThree(({
    size: size2
  }) => size2);
  const cameraRef = React36.useRef(null);
  const groupRef = React36.useRef(null);
  const fbo = useFBO(resolution);
  React36.useLayoutEffect(() => {
    if (!props.manual) {
      cameraRef.current.aspect = size.width / size.height;
    }
  }, [size, props]);
  React36.useLayoutEffect(() => {
    cameraRef.current.updateProjectionMatrix();
  });
  let count = 0;
  let oldEnvMap = null;
  const functional = isFunction2(children);
  useFrame((state) => {
    if (functional && (frames === Infinity || count < frames)) {
      groupRef.current.visible = false;
      state.gl.setRenderTarget(fbo);
      oldEnvMap = state.scene.background;
      if (envMap)
        state.scene.background = envMap;
      state.gl.render(state.scene, cameraRef.current);
      state.scene.background = oldEnvMap;
      state.gl.setRenderTarget(null);
      groupRef.current.visible = true;
      count++;
    }
  });
  React36.useLayoutEffect(() => {
    if (makeDefault) {
      const oldCam = camera;
      set(() => ({
        camera: cameraRef.current
      }));
      return () => set(() => ({
        camera: oldCam
      }));
    }
  }, [cameraRef, makeDefault, set]);
  return React36.createElement(React36.Fragment, null, React36.createElement("perspectiveCamera", _extends({
    ref: react_merge_refs_esm_default([cameraRef, ref])
  }, props), !functional && children), React36.createElement("group", {
    ref: groupRef
  }, functional && children(fbo.texture)));
});

// node_modules/@react-three/drei/core/CubeCamera.js
var React38 = __toESM(require_react());

// node_modules/@react-three/drei/core/useCubeCamera.js
var React37 = __toESM(require_react());
var import_react9 = __toESM(require_react());
function useCubeCamera({
  resolution = 256,
  near = 0.1,
  far = 1e3,
  envMap,
  fog
} = {}) {
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  const fbo = (0, import_react9.useMemo)(() => {
    const fbo2 = new WebGLCubeRenderTarget(resolution);
    fbo2.texture.type = HalfFloatType;
    return fbo2;
  }, [resolution]);
  (0, import_react9.useEffect)(() => {
    return () => {
      fbo.dispose();
    };
  }, [fbo]);
  const camera = (0, import_react9.useMemo)(() => new CubeCamera(near, far, fbo), [near, far, fbo]);
  let originalFog;
  let originalBackground;
  const update3 = React37.useCallback(() => {
    originalFog = scene.fog;
    originalBackground = scene.background;
    scene.background = envMap || originalBackground;
    scene.fog = fog || originalFog;
    camera.update(gl, scene);
    scene.fog = originalFog;
    scene.background = originalBackground;
  }, [gl, scene, camera]);
  return {
    fbo,
    camera,
    update: update3
  };
}

// node_modules/@react-three/drei/core/CubeCamera.js
function CubeCamera2({
  children,
  frames = Infinity,
  resolution,
  near,
  far,
  envMap,
  fog,
  ...props
}) {
  const ref = React38.useRef();
  const {
    fbo,
    camera,
    update: update3
  } = useCubeCamera({
    resolution,
    near,
    far,
    envMap,
    fog
  });
  let count = 0;
  useFrame(() => {
    if (ref.current && (frames === Infinity || count < frames)) {
      ref.current.visible = false;
      update3();
      ref.current.visible = true;
      count++;
    }
  });
  return React38.createElement("group", props, React38.createElement("primitive", {
    object: camera
  }), React38.createElement("group", {
    ref
  }, children(fbo.texture)));
}

// node_modules/@react-three/drei/core/DeviceOrientationControls.js
var React39 = __toESM(require_react());
var DeviceOrientationControls2 = React39.forwardRef((props, ref) => {
  const {
    camera,
    onChange,
    makeDefault,
    ...rest
  } = props;
  const defaultCamera = useThree((state) => state.camera);
  const invalidate = useThree((state) => state.invalidate);
  const get = useThree((state) => state.get);
  const set = useThree((state) => state.set);
  const explCamera = camera || defaultCamera;
  const [controls] = React39.useState(() => new DeviceOrientationControls(explCamera));
  React39.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (onChange)
        onChange(e2);
    };
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("change", callback);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener("change", callback);
  }, [onChange, controls, invalidate]);
  useFrame(() => controls == null ? void 0 : controls.update(), -1);
  React39.useEffect(() => {
    const current = controls;
    current == null ? void 0 : current.connect();
    return () => current == null ? void 0 : current.dispose();
  }, [controls]);
  React39.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return controls ? React39.createElement("primitive", _extends({
    ref,
    object: controls
  }, rest)) : null;
});

// node_modules/@react-three/drei/core/FlyControls.js
var React40 = __toESM(require_react());
var FlyControls2 = React40.forwardRef(({
  domElement,
  ...props
}, fref) => {
  const {
    onChange,
    makeDefault,
    ...rest
  } = props;
  const invalidate = useThree((state) => state.invalidate);
  const camera = useThree((state) => state.camera);
  const gl = useThree((state) => state.gl);
  const events = useThree((state) => state.events);
  const get = useThree((state) => state.get);
  const set = useThree((state) => state.set);
  const explDomElement = domElement || events.connected || gl.domElement;
  const controls = React40.useMemo(() => new FlyControls(camera), [camera]);
  React40.useEffect(() => {
    controls.connect(explDomElement);
    return () => void controls.dispose();
  }, [explDomElement, controls, invalidate]);
  React40.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (onChange)
        onChange(e2);
    };
    controls.addEventListener == null ? void 0 : controls.addEventListener("change", callback);
    return () => controls.removeEventListener == null ? void 0 : controls.removeEventListener("change", callback);
  }, [onChange, invalidate]);
  React40.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  useFrame((_, delta) => controls.update(delta));
  return React40.createElement("primitive", _extends({
    ref: fref,
    object: controls,
    args: [camera, explDomElement]
  }, rest));
});

// node_modules/@react-three/drei/core/MapControls.js
var React41 = __toESM(require_react());
var MapControls2 = React41.forwardRef((props = {
  enableDamping: true
}, ref) => {
  const {
    domElement,
    camera,
    makeDefault,
    onChange,
    onStart,
    onEnd,
    ...rest
  } = props;
  const invalidate = useThree((state) => state.invalidate);
  const defaultCamera = useThree((state) => state.camera);
  const gl = useThree((state) => state.gl);
  const events = useThree((state) => state.events);
  const set = useThree((state) => state.set);
  const get = useThree((state) => state.get);
  const explDomElement = domElement || events.connected || gl.domElement;
  const explCamera = camera || defaultCamera;
  const controls = React41.useMemo(() => new MapControls(explCamera), [explCamera]);
  React41.useEffect(() => {
    controls.connect(explDomElement);
    const callback = (e2) => {
      invalidate();
      if (onChange)
        onChange(e2);
    };
    controls.addEventListener("change", callback);
    if (onStart)
      controls.addEventListener("start", onStart);
    if (onEnd)
      controls.addEventListener("end", onEnd);
    return () => {
      controls.dispose();
      controls.removeEventListener("change", callback);
      if (onStart)
        controls.removeEventListener("start", onStart);
      if (onEnd)
        controls.removeEventListener("end", onEnd);
    };
  }, [onChange, onStart, onEnd, controls, invalidate, explDomElement]);
  React41.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  useFrame(() => controls.update(), -1);
  return React41.createElement("primitive", _extends({
    ref,
    object: controls,
    enableDamping: true
  }, rest));
});

// node_modules/@react-three/drei/core/OrbitControls.js
var React42 = __toESM(require_react());
var OrbitControls2 = React42.forwardRef(({
  makeDefault,
  camera,
  regress,
  domElement,
  enableDamping = true,
  keyEvents = false,
  onChange,
  onStart,
  onEnd,
  ...restProps
}, ref) => {
  const invalidate = useThree((state) => state.invalidate);
  const defaultCamera = useThree((state) => state.camera);
  const gl = useThree((state) => state.gl);
  const events = useThree((state) => state.events);
  const setEvents = useThree((state) => state.setEvents);
  const set = useThree((state) => state.set);
  const get = useThree((state) => state.get);
  const performance2 = useThree((state) => state.performance);
  const explCamera = camera || defaultCamera;
  const explDomElement = domElement || events.connected || gl.domElement;
  const controls = React42.useMemo(() => new OrbitControls(explCamera), [explCamera]);
  useFrame(() => {
    if (controls.enabled)
      controls.update();
  }, -1);
  React42.useEffect(() => {
    if (keyEvents) {
      controls.connect(keyEvents === true ? explDomElement : keyEvents);
    }
    controls.connect(explDomElement);
    return () => void controls.dispose();
  }, [keyEvents, explDomElement, regress, controls, invalidate]);
  React42.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (regress)
        performance2.regress();
      if (onChange)
        onChange(e2);
    };
    const onStartCb = (e2) => {
      if (onStart)
        onStart(e2);
    };
    const onEndCb = (e2) => {
      if (onEnd)
        onEnd(e2);
    };
    controls.addEventListener("change", callback);
    controls.addEventListener("start", onStartCb);
    controls.addEventListener("end", onEndCb);
    return () => {
      controls.removeEventListener("start", onStartCb);
      controls.removeEventListener("end", onEndCb);
      controls.removeEventListener("change", callback);
    };
  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);
  React42.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return React42.createElement("primitive", _extends({
    ref,
    object: controls,
    enableDamping
  }, restProps));
});

// node_modules/@react-three/drei/core/TrackballControls.js
var React43 = __toESM(require_react());
var TrackballControls2 = React43.forwardRef(({
  makeDefault,
  camera,
  domElement,
  regress,
  onChange,
  onStart,
  onEnd,
  ...restProps
}, ref) => {
  const {
    invalidate,
    camera: defaultCamera,
    gl,
    events,
    set,
    get,
    performance: performance2,
    viewport
  } = useThree();
  const explCamera = camera || defaultCamera;
  const explDomElement = domElement || events.connected || gl.domElement;
  const controls = React43.useMemo(() => new TrackballControls(explCamera), [explCamera]);
  useFrame(() => {
    if (controls.enabled)
      controls.update();
  }, -1);
  React43.useEffect(() => {
    controls.connect(explDomElement);
    return () => void controls.dispose();
  }, [explDomElement, regress, controls, invalidate]);
  React43.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (regress)
        performance2.regress();
      if (onChange)
        onChange(e2);
    };
    controls.addEventListener("change", callback);
    if (onStart)
      controls.addEventListener("start", onStart);
    if (onEnd)
      controls.addEventListener("end", onEnd);
    return () => {
      if (onStart)
        controls.removeEventListener("start", onStart);
      if (onEnd)
        controls.removeEventListener("end", onEnd);
      controls.removeEventListener("change", callback);
    };
  }, [onChange, onStart, onEnd, controls, invalidate]);
  React43.useEffect(() => {
    controls.handleResize();
  }, [viewport]);
  React43.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return React43.createElement("primitive", _extends({
    ref,
    object: controls
  }, restProps));
});

// node_modules/@react-three/drei/core/ArcballControls.js
var React44 = __toESM(require_react());
var import_react10 = __toESM(require_react());
var ArcballControls2 = (0, import_react10.forwardRef)(({
  camera,
  makeDefault,
  regress,
  domElement,
  onChange,
  onStart,
  onEnd,
  ...restProps
}, ref) => {
  const invalidate = useThree((state) => state.invalidate);
  const defaultCamera = useThree((state) => state.camera);
  const gl = useThree((state) => state.gl);
  const events = useThree((state) => state.events);
  const set = useThree((state) => state.set);
  const get = useThree((state) => state.get);
  const performance2 = useThree((state) => state.performance);
  const explCamera = camera || defaultCamera;
  const explDomElement = domElement || events.connected || gl.domElement;
  const controls = (0, import_react10.useMemo)(() => new ArcballControls(explCamera), [explCamera]);
  useFrame(() => {
    if (controls.enabled)
      controls.update();
  }, -1);
  (0, import_react10.useEffect)(() => {
    controls.connect(explDomElement);
    return () => void controls.dispose();
  }, [explDomElement, regress, controls, invalidate]);
  (0, import_react10.useEffect)(() => {
    const callback = (e2) => {
      invalidate();
      if (regress)
        performance2.regress();
      if (onChange)
        onChange(e2);
    };
    controls.addEventListener("change", callback);
    if (onStart)
      controls.addEventListener("start", onStart);
    if (onEnd)
      controls.addEventListener("end", onEnd);
    return () => {
      controls.removeEventListener("change", callback);
      if (onStart)
        controls.removeEventListener("start", onStart);
      if (onEnd)
        controls.removeEventListener("end", onEnd);
    };
  }, [onChange, onStart, onEnd]);
  (0, import_react10.useEffect)(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return React44.createElement("primitive", _extends({
    ref,
    object: controls
  }, restProps));
});

// node_modules/@react-three/drei/core/TransformControls.js
var import_lodash2 = __toESM(require_lodash2());
var import_lodash3 = __toESM(require_lodash());
var React45 = __toESM(require_react());
var TransformControls2 = React45.forwardRef(({
  children,
  domElement,
  onChange,
  onMouseDown,
  onMouseUp,
  onObjectChange,
  object,
  makeDefault,
  ...props
}, ref) => {
  const transformOnlyPropNames = ["enabled", "axis", "mode", "translationSnap", "rotationSnap", "scaleSnap", "space", "size", "showX", "showY", "showZ"];
  const {
    camera,
    ...rest
  } = props;
  const transformProps = (0, import_lodash3.default)(rest, transformOnlyPropNames);
  const objectProps = (0, import_lodash2.default)(rest, transformOnlyPropNames);
  const defaultControls = useThree((state) => state.controls);
  const gl = useThree((state) => state.gl);
  const events = useThree((state) => state.events);
  const defaultCamera = useThree((state) => state.camera);
  const invalidate = useThree((state) => state.invalidate);
  const get = useThree((state) => state.get);
  const set = useThree((state) => state.set);
  const explCamera = camera || defaultCamera;
  const explDomElement = domElement || events.connected || gl.domElement;
  const controls = React45.useMemo(() => new TransformControls(explCamera, explDomElement), [explCamera, explDomElement]);
  const group = React45.useRef();
  React45.useLayoutEffect(() => {
    if (object) {
      controls.attach(object instanceof Object3D ? object : object.current);
    } else if (group.current instanceof Object3D) {
      controls.attach(group.current);
    }
    return () => void controls.detach();
  }, [object, children, controls]);
  React45.useEffect(() => {
    if (defaultControls) {
      const callback = (event) => defaultControls.enabled = !event.value;
      controls.addEventListener("dragging-changed", callback);
      return () => controls.removeEventListener("dragging-changed", callback);
    }
  }, [controls, defaultControls]);
  const onChangeRef = React45.useRef();
  const onMouseDownRef = React45.useRef();
  const onMouseUpRef = React45.useRef();
  const onObjectChangeRef = React45.useRef();
  React45.useLayoutEffect(() => void (onChangeRef.current = onChange), [onChange]);
  React45.useLayoutEffect(() => void (onMouseDownRef.current = onMouseDown), [onMouseDown]);
  React45.useLayoutEffect(() => void (onMouseUpRef.current = onMouseUp), [onMouseUp]);
  React45.useLayoutEffect(() => void (onObjectChangeRef.current = onObjectChange), [onObjectChange]);
  React45.useEffect(() => {
    const onChange2 = (e2) => {
      invalidate();
      onChangeRef.current == null ? void 0 : onChangeRef.current(e2);
    };
    const onMouseDown2 = (e2) => onMouseDownRef.current == null ? void 0 : onMouseDownRef.current(e2);
    const onMouseUp2 = (e2) => onMouseUpRef.current == null ? void 0 : onMouseUpRef.current(e2);
    const onObjectChange2 = (e2) => onObjectChangeRef.current == null ? void 0 : onObjectChangeRef.current(e2);
    controls.addEventListener("change", onChange2);
    controls.addEventListener("mouseDown", onMouseDown2);
    controls.addEventListener("mouseUp", onMouseUp2);
    controls.addEventListener("objectChange", onObjectChange2);
    return () => {
      controls.removeEventListener("change", onChange2);
      controls.removeEventListener("mouseDown", onMouseDown2);
      controls.removeEventListener("mouseUp", onMouseUp2);
      controls.removeEventListener("objectChange", onObjectChange2);
    };
  }, [invalidate, controls]);
  React45.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return controls ? React45.createElement(React45.Fragment, null, React45.createElement("primitive", _extends({
    ref,
    object: controls
  }, transformProps)), React45.createElement("group", _extends({
    ref: group
  }, objectProps), children)) : null;
});

// node_modules/@react-three/drei/core/PointerLockControls.js
var React46 = __toESM(require_react());
var PointerLockControls2 = React46.forwardRef(({
  domElement,
  selector,
  onChange,
  onLock,
  onUnlock,
  enabled = true,
  makeDefault,
  ...props
}, ref) => {
  const {
    camera,
    ...rest
  } = props;
  const setEvents = useThree((state) => state.setEvents);
  const gl = useThree((state) => state.gl);
  const defaultCamera = useThree((state) => state.camera);
  const invalidate = useThree((state) => state.invalidate);
  const events = useThree((state) => state.events);
  const get = useThree((state) => state.get);
  const set = useThree((state) => state.set);
  const explCamera = camera || defaultCamera;
  const explDomElement = domElement || events.connected || gl.domElement;
  const [controls] = React46.useState(() => new PointerLockControls(explCamera));
  React46.useEffect(() => {
    if (enabled) {
      controls.connect(explDomElement);
      const oldComputeOffsets = get().events.compute;
      setEvents({
        compute(event, state) {
          const offsetX = state.size.width / 2;
          const offsetY = state.size.height / 2;
          state.pointer.set(offsetX / state.size.width * 2 - 1, -(offsetY / state.size.height) * 2 + 1);
          state.raycaster.setFromCamera(state.pointer, state.camera);
        }
      });
      return () => {
        controls.disconnect();
        setEvents({
          compute: oldComputeOffsets
        });
      };
    }
  }, [enabled, controls]);
  React46.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (onChange)
        onChange(e2);
    };
    controls.addEventListener("change", callback);
    if (onLock)
      controls.addEventListener("lock", onLock);
    if (onUnlock)
      controls.addEventListener("unlock", onUnlock);
    const handler = () => controls.lock();
    const elements = selector ? Array.from(document.querySelectorAll(selector)) : [document];
    elements.forEach((element) => element && element.addEventListener("click", handler));
    return () => {
      controls.removeEventListener("change", callback);
      if (onLock)
        controls.addEventListener("lock", onLock);
      if (onUnlock)
        controls.addEventListener("unlock", onUnlock);
      elements.forEach((element) => element ? element.removeEventListener("click", handler) : void 0);
    };
  }, [onChange, onLock, onUnlock, selector, controls, invalidate]);
  React46.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return React46.createElement("primitive", _extends({
    ref,
    object: controls
  }, rest));
});

// node_modules/@react-three/drei/core/FirstPersonControls.js
var React47 = __toESM(require_react());
var FirstPersonControls2 = React47.forwardRef(({
  domElement,
  makeDefault,
  ...props
}, ref) => {
  const camera = useThree((state) => state.camera);
  const gl = useThree((state) => state.gl);
  const events = useThree((state) => state.events);
  const get = useThree((state) => state.get);
  const set = useThree((state) => state.set);
  const explDomElement = domElement || events.connected || gl.domElement;
  const [controls] = React47.useState(() => new FirstPersonControls(camera, explDomElement));
  React47.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  useFrame((_, delta) => {
    controls.update(delta);
  }, -1);
  return controls ? React47.createElement("primitive", _extends({
    ref,
    object: controls
  }, props)) : null;
});

// node_modules/@react-three/drei/core/CameraControls.js
var React48 = __toESM(require_react());
var import_react11 = __toESM(require_react());

// node_modules/camera-controls/dist/camera-controls.module.js
var MOUSE_BUTTON = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var ACTION = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var DOLLY_DIRECTION = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
  return camera.isOrthographicCamera;
}
var PI_2 = Math.PI * 2;
var PI_HALF = Math.PI / 2;
var EPSILON = 1e-5;
var DEG2RAD = Math.PI / 180;
function clamp3(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function approxZero(number, error = EPSILON) {
  return Math.abs(number) < error;
}
function approxEquals(a3, b, error = EPSILON) {
  return approxZero(a3 - b, error);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function smoothDamp(current, target2, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let change = current - target2;
  const originalTo = target2;
  const maxChange = maxSpeed * smoothTime;
  change = clamp3(change, -maxChange, maxChange);
  target2 = current - change;
  const temp5 = (currentVelocityRef.value + omega * change) * deltaTime;
  currentVelocityRef.value = (currentVelocityRef.value - omega * temp5) * exp;
  let output = target2 + (change + temp5) * exp;
  if (originalTo - current > 0 === output > originalTo) {
    output = originalTo;
    currentVelocityRef.value = (output - originalTo) / deltaTime;
  }
  return output;
}
function smoothDampVec3(current, target2, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let targetX = target2.x;
  let targetY = target2.y;
  let targetZ = target2.z;
  let changeX = current.x - targetX;
  let changeY = current.y - targetY;
  let changeZ = current.z - targetZ;
  const originalToX = targetX;
  const originalToY = targetY;
  const originalToZ = targetZ;
  const maxChange = maxSpeed * smoothTime;
  const maxChangeSq = maxChange * maxChange;
  const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
  if (magnitudeSq > maxChangeSq) {
    const magnitude = Math.sqrt(magnitudeSq);
    changeX = changeX / magnitude * maxChange;
    changeY = changeY / magnitude * maxChange;
    changeZ = changeZ / magnitude * maxChange;
  }
  targetX = current.x - changeX;
  targetY = current.y - changeY;
  targetZ = current.z - changeZ;
  const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
  const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
  const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
  currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
  currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
  currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
  out.x = targetX + (changeX + tempX) * exp;
  out.y = targetY + (changeY + tempY) * exp;
  out.z = targetZ + (changeZ + tempZ) * exp;
  const origMinusCurrentX = originalToX - current.x;
  const origMinusCurrentY = originalToY - current.y;
  const origMinusCurrentZ = originalToZ - current.z;
  const outMinusOrigX = out.x - originalToX;
  const outMinusOrigY = out.y - originalToY;
  const outMinusOrigZ = out.z - originalToZ;
  if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
    out.x = originalToX;
    out.y = originalToY;
    out.z = originalToZ;
    currentVelocityRef.x = (out.x - originalToX) / deltaTime;
    currentVelocityRef.y = (out.y - originalToY) / deltaTime;
    currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
  }
  return out;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
var EventDispatcher2 = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners[type] === void 0)
      listeners[type] = [];
    if (listeners[type].indexOf(listener) === -1)
      listeners[type].push(listener);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1)
        listenerArray.splice(index, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(type) {
    if (!type) {
      this._listeners = {};
      return;
    }
    if (Array.isArray(this._listeners[type]))
      this._listeners[type].length = 0;
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i3 = 0, l2 = array.length; i3 < l2; i3++) {
        array[i3].call(this, event);
      }
    }
  }
};
var VERSION = "2.7.3";
var TOUCH_DOLLY_FACTOR = 1 / 8;
var isBrowser2 = typeof window !== "undefined";
var isMac = isBrowser2 && /Mac/.test(navigator.platform);
var isPointerEventsNotSupported = !(isBrowser2 && "PointerEvent" in window);
var THREE;
var _ORIGIN;
var _AXIS_Y;
var _AXIS_Z;
var _v2;
var _v3A;
var _v3B;
var _v3C;
var _cameraDirection;
var _xColumn;
var _yColumn;
var _zColumn;
var _deltaTarget;
var _deltaOffset;
var _sphericalA;
var _sphericalB;
var _box3A;
var _box3B;
var _sphere;
var _quaternionA;
var _quaternionB;
var _rotationMatrix;
var _raycaster;
var CameraControls = class _CameraControls extends EventDispatcher2 {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(libs) {
    THREE = libs.THREE;
    _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
    _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
    _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
    _v2 = new THREE.Vector2();
    _v3A = new THREE.Vector3();
    _v3B = new THREE.Vector3();
    _v3C = new THREE.Vector3();
    _cameraDirection = new THREE.Vector3();
    _xColumn = new THREE.Vector3();
    _yColumn = new THREE.Vector3();
    _zColumn = new THREE.Vector3();
    _deltaTarget = new THREE.Vector3();
    _deltaOffset = new THREE.Vector3();
    _sphericalA = new THREE.Spherical();
    _sphericalB = new THREE.Spherical();
    _box3A = new THREE.Box3();
    _box3B = new THREE.Box3();
    _sphere = new THREE.Sphere();
    _quaternionA = new THREE.Quaternion();
    _quaternionB = new THREE.Quaternion();
    _rotationMatrix = new THREE.Matrix4();
    _raycaster = new THREE.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ACTION;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(camera, domElement) {
    super();
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.minDistance = Number.EPSILON;
    this.maxDistance = Infinity;
    this.infinityDolly = false;
    this.minZoom = 0.01;
    this.maxZoom = Infinity;
    this.smoothTime = 0.25;
    this.draggingSmoothTime = 0.125;
    this.maxSpeed = Infinity;
    this.azimuthRotateSpeed = 1;
    this.polarRotateSpeed = 1;
    this.dollySpeed = 1;
    this.dollyDragInverted = false;
    this.truckSpeed = 2;
    this.dollyToCursor = false;
    this.dragToOffset = false;
    this.verticalDragToForward = false;
    this.boundaryFriction = 0;
    this.restThreshold = 0.01;
    this.colliderMeshes = [];
    this.cancel = () => {
    };
    this._enabled = true;
    this._state = ACTION.NONE;
    this._viewport = null;
    this._changedDolly = 0;
    this._changedZoom = 0;
    this._hasRested = true;
    this._boundaryEnclosesCamera = false;
    this._needsUpdate = true;
    this._updatedLastTime = false;
    this._elementRect = new DOMRect();
    this._isDragging = false;
    this._dragNeedsUpdate = true;
    this._activePointers = [];
    this._lockedPointer = null;
    this._interactiveArea = new DOMRect(0, 0, 1, 1);
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._isUserControllingOffset = false;
    this._isUserControllingZoom = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._thetaVelocity = { value: 0 };
    this._phiVelocity = { value: 0 };
    this._radiusVelocity = { value: 0 };
    this._targetVelocity = new THREE.Vector3();
    this._focalOffsetVelocity = new THREE.Vector3();
    this._zoomVelocity = { value: 0 };
    this._truckInternal = (deltaX, deltaY, dragToOffset) => {
      let truckX;
      let pedestalY;
      if (isPerspectiveCamera(this._camera)) {
        const offset = _v3A.copy(this._camera.position).sub(this._target);
        const fov = this._camera.getEffectiveFOV() * DEG2RAD;
        const targetDistance = offset.length() * Math.tan(fov * 0.5);
        truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
        pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
      } else if (isOrthographicCamera(this._camera)) {
        const camera2 = this._camera;
        truckX = deltaX * (camera2.right - camera2.left) / camera2.zoom / this._elementRect.width;
        pedestalY = deltaY * (camera2.top - camera2.bottom) / camera2.zoom / this._elementRect.height;
      } else {
        return;
      }
      if (this.verticalDragToForward) {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
        this.forward(-pedestalY, true);
      } else {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
      }
    };
    this._rotateInternal = (deltaX, deltaY) => {
      const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
      const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
      this.rotate(theta, phi, true);
    };
    this._dollyInternal = (delta, x, y) => {
      const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
      const lastDistance = this._sphericalEnd.radius;
      const distance = this._sphericalEnd.radius * dollyScale;
      const clampedDistance = clamp3(distance, this.minDistance, this.maxDistance);
      const overflowedDistance = clampedDistance - distance;
      if (this.infinityDolly && this.dollyToCursor) {
        this._dollyToNoClamp(distance, true);
      } else if (this.infinityDolly && !this.dollyToCursor) {
        this.dollyInFixed(overflowedDistance, true);
        this._dollyToNoClamp(clampedDistance, true);
      } else {
        this._dollyToNoClamp(clampedDistance, true);
      }
      if (this.dollyToCursor) {
        this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;
        this._dollyControlCoord.set(x, y);
      }
      this._lastDollyDirection = Math.sign(-delta);
    };
    this._zoomInternal = (delta, x, y) => {
      const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
      const lastZoom = this._zoom;
      const zoom = this._zoom * zoomScale;
      this.zoomTo(zoom, true);
      if (this.dollyToCursor) {
        this._changedZoom += zoom - lastZoom;
        this._dollyControlCoord.set(x, y);
      }
    };
    if (typeof THREE === "undefined") {
      console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
    }
    this._camera = camera;
    this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
    this._state = ACTION.NONE;
    this._target = new THREE.Vector3();
    this._targetEnd = this._target.clone();
    this._focalOffset = new THREE.Vector3();
    this._focalOffsetEnd = this._focalOffset.clone();
    this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
    this._sphericalEnd = this._spherical.clone();
    this._lastDistance = this._spherical.radius;
    this._zoom = this._camera.zoom;
    this._zoomEnd = this._zoom;
    this._lastZoom = this._zoom;
    this._nearPlaneCorners = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    this._updateNearPlaneCorners();
    this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
    this._cameraUp0 = this._camera.up.clone();
    this._target0 = this._target.clone();
    this._position0 = this._camera.position.clone();
    this._zoom0 = this._zoom;
    this._focalOffset0 = this._focalOffset.clone();
    this._dollyControlCoord = new THREE.Vector2();
    this.mouseButtons = {
      left: ACTION.ROTATE,
      middle: ACTION.DOLLY,
      right: ACTION.TRUCK,
      wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE
    };
    this.touches = {
      one: ACTION.TOUCH_ROTATE,
      two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
      three: ACTION.TOUCH_TRUCK
    };
    const dragStartPosition = new THREE.Vector2();
    const lastDragPosition = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const onPointerDown = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = event.pointerType !== "mouse" ? null : (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
        return;
      const pointer = {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      this._isDragging = true;
      startDragging(event);
    };
    const onMouseDown = (event) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      const pointer = {
        pointerId: 1,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.RIGHT : null
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
      this._domElement.ownerDocument.addEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.addEventListener("mouseup", onMouseUp);
      this._isDragging = true;
      startDragging(event);
    };
    const onPointerMove = (event) => {
      if (event.cancelable)
        event.preventDefault();
      const pointerId2 = event.pointerId;
      const pointer = this._lockedPointer || this._findPointerById(pointerId2);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._isDragging && this._lockedPointer || this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      dragging();
    };
    const onMouseMove = (event) => {
      const pointer = this._lockedPointer || this._findPointerById(1);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (this._lockedPointer || (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
        this._state = this._state | this.mouseButtons.left;
      }
      if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
        this._state = this._state | this.mouseButtons.middle;
      }
      if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
        this._state = this._state | this.mouseButtons.right;
      }
      dragging();
    };
    const onPointerUp = (event) => {
      const pointer = this._findPointerById(event.pointerId);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 0:
            this._state = ACTION.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = ACTION.NONE;
      }
      endDragging();
    };
    const onMouseUp = () => {
      const pointer = this._findPointerById(1);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      this._state = ACTION.NONE;
      endDragging();
    };
    let lastScrollTimeStamp = -1;
    const onMouseWheel = (event) => {
      if (!this._domElement)
        return;
      if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      event.preventDefault();
      if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
        const now2 = performance.now();
        if (lastScrollTimeStamp - now2 < 1e3)
          this._getClientRect(this._elementRect);
        lastScrollTimeStamp = now2;
      }
      const deltaYFactor = isMac ? -1 : -3;
      const delta = event.deltaMode === 1 ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
      const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
      const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case ACTION.ROTATE: {
          this._rotateInternal(event.deltaX, event.deltaY);
          this._isUserControllingRotate = true;
          break;
        }
        case ACTION.TRUCK: {
          this._truckInternal(event.deltaX, event.deltaY, false);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.OFFSET: {
          this._truckInternal(event.deltaX, event.deltaY, true);
          this._isUserControllingOffset = true;
          break;
        }
        case ACTION.DOLLY: {
          this._dollyInternal(-delta, x, y);
          this._isUserControllingDolly = true;
          break;
        }
        case ACTION.ZOOM: {
          this._zoomInternal(-delta, x, y);
          this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    };
    const onContextMenu = (event) => {
      if (!this._domElement || !this._enabled)
        return;
      if (this.mouseButtons.right === _CameraControls.ACTION.NONE) {
        const pointerId2 = event instanceof PointerEvent ? event.pointerId : event instanceof MouseEvent ? 0 : 0;
        const pointer = this._findPointerById(pointerId2);
        pointer && this._disposePointer(pointer);
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
        this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
        return;
      }
      event.preventDefault();
    };
    const startDragging = (event) => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v2);
      this._getClientRect(this._elementRect);
      dragStartPosition.copy(_v2);
      lastDragPosition.copy(_v2);
      const isMultiTouch = this._activePointers.length >= 2;
      if (isMultiTouch) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
        const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
        const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        lastDragPosition.set(x, y);
      }
      this._state = 0;
      if (!event) {
        if (this._lockedPointer)
          this._state = this._state | this.mouseButtons.left;
      } else if ("pointerType" in event && event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._sphericalEnd.theta = this._spherical.theta;
        this._sphericalEnd.phi = this._spherical.phi;
        this._thetaVelocity.value = 0;
        this._phiVelocity.value = 0;
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._targetEnd.copy(this._target);
        this._targetVelocity.set(0, 0, 0);
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
        this._sphericalEnd.radius = this._spherical.radius;
        this._radiusVelocity.value = 0;
      }
      if ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._zoomEnd = this._zoom;
        this._zoomVelocity.value = 0;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._focalOffsetEnd.copy(this._focalOffset);
        this._focalOffsetVelocity.set(0, 0, 0);
      }
      this.dispatchEvent({ type: "controlstart" });
    };
    const dragging = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false;
      extractClientCoordFromEvent(this._activePointers, _v2);
      const isPointerLockActive = this._domElement && document.pointerLockElement === this._domElement;
      const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
      const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2.x;
      const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2.y;
      lastDragPosition.copy(_v2);
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._rotateInternal(deltaX, deltaY);
        this._isUserControllingRotate = true;
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        const dollyDirection = this.dollyDragInverted ? -1 : 1;
        if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
          this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        const dx = _v2.x - this._activePointers[1].clientX;
        const dy = _v2.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dollyDelta = dollyStart.y - distance;
        dollyStart.set(0, distance);
        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
          this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._truckInternal(deltaX, deltaY, false);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._truckInternal(deltaX, deltaY, true);
        this._isUserControllingOffset = true;
      }
      this.dispatchEvent({ type: "control" });
    };
    const endDragging = () => {
      extractClientCoordFromEvent(this._activePointers, _v2);
      lastDragPosition.copy(_v2);
      this._dragNeedsUpdate = false;
      if (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) {
        this._isDragging = false;
      }
      if (this._activePointers.length === 0 && this._domElement) {
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
        this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
        this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
        this.dispatchEvent({ type: "controlend" });
      }
    };
    this.lockPointer = () => {
      if (!this._enabled || !this._domElement)
        return;
      this.cancel();
      this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      };
      this._activePointers.push(this._lockedPointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.requestPointerLock();
      this._domElement.ownerDocument.addEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.addEventListener("pointerlockerror", onPointerLockError);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
      startDragging();
    };
    this.unlockPointer = () => {
      if (this._lockedPointer !== null) {
        this._disposePointer(this._lockedPointer);
        this._lockedPointer = null;
      }
      document.exitPointerLock();
      this.cancel();
      if (!this._domElement)
        return;
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    const onPointerLockChange = () => {
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      if (!isPointerLockActive)
        this.unlockPointer();
    };
    const onPointerLockError = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (domElement2) => {
      this._domElement = domElement2;
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
      this._domElement.addEventListener("pointerdown", onPointerDown);
      isPointerEventsNotSupported && this._domElement.addEventListener("mousedown", onMouseDown);
      this._domElement.addEventListener("pointercancel", onPointerUp);
      this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.addEventListener("contextmenu", onContextMenu);
    };
    this._removeAllEventListeners = () => {
      if (!this._domElement)
        return;
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
      this._domElement.removeEventListener("pointerdown", onPointerDown);
      this._domElement.removeEventListener("mousedown", onMouseDown);
      this._domElement.removeEventListener("pointercancel", onPointerUp);
      this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.removeEventListener("contextmenu", onContextMenu);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove, { passive: false });
      this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    this.cancel = () => {
      if (this._state === ACTION.NONE)
        return;
      this._state = ACTION.NONE;
      this._activePointers.length = 0;
      endDragging();
    };
    if (domElement)
      this.connect(domElement);
    this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this.updateCameraUp();
    this._camera.updateProjectionMatrix();
    this._updateNearPlaneCorners();
    this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    if (!this._domElement)
      return;
    if (enabled) {
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
    } else {
      this.cancel();
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
    }
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(distance) {
    if (this._spherical.radius === distance && this._sphericalEnd.radius === distance)
      return;
    this._spherical.radius = distance;
    this._sphericalEnd.radius = distance;
    this._needsUpdate = true;
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(azimuthAngle) {
    if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
      return;
    this._spherical.theta = azimuthAngle;
    this._sphericalEnd.theta = azimuthAngle;
    this._needsUpdate = true;
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(polarAngle) {
    if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
      return;
    this._spherical.phi = polarAngle;
    this._sphericalEnd.phi = polarAngle;
    this._needsUpdate = true;
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(boundaryEnclosesCamera) {
    this._boundaryEnclosesCamera = boundaryEnclosesCamera;
    this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(interactiveArea) {
    this._interactiveArea.width = clamp3(interactiveArea.width, 0, 1);
    this._interactiveArea.height = clamp3(interactiveArea.height, 0, 1);
    this._interactiveArea.x = clamp3(interactiveArea.x, 0, 1 - this._interactiveArea.width);
    this._interactiveArea.y = clamp3(interactiveArea.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    super.addEventListener(type, listener);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(azimuthAngle, polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(azimuthAngle, enableTransition = false) {
    return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
    this._isUserControllingRotate = false;
    const theta = clamp3(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
    const phi = clamp3(polarAngle, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = theta;
    this._sphericalEnd.phi = phi;
    this._sphericalEnd.makeSafe();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.theta = this._sphericalEnd.theta;
      this._spherical.phi = this._sphericalEnd.phi;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(distance, enableTransition = false) {
    return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(distance, enableTransition = false) {
    this._isUserControllingDolly = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    return this._dollyToNoClamp(clamp3(distance, this.minDistance, this.maxDistance), enableTransition);
  }
  _dollyToNoClamp(distance, enableTransition = false) {
    const lastRadius = this._sphericalEnd.radius;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (hasCollider) {
      const maxDistanceByCollisionTest = this._collisionTest();
      const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
      const isDollyIn = lastRadius > distance;
      if (!isDollyIn && isCollided)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);
    } else {
      this._sphericalEnd.radius = distance;
    }
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.radius = this._sphericalEnd.radius;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(distance, enableTransition = false) {
    this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(zoomStep, enableTransition = false) {
    return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(zoom, enableTransition = false) {
    this._isUserControllingZoom = false;
    this._zoomEnd = clamp3(zoom, this.minZoom, this.maxZoom);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._zoom = this._zoomEnd;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
    this._changedZoom = 0;
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(x, y, enableTransition = false) {
    console.warn("`pan` has been renamed to `truck`");
    return this.truck(x, y, enableTransition);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(x, y, enableTransition = false) {
    this._camera.updateMatrix();
    _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
    _xColumn.multiplyScalar(x);
    _yColumn.multiplyScalar(-y);
    const offset = _v3A.copy(_xColumn).add(_yColumn);
    const to2 = _v3B.copy(this._targetEnd).add(offset);
    return this.moveTo(to2.x, to2.y, to2.z, enableTransition);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(distance, enableTransition = false) {
    _v3A.setFromMatrixColumn(this._camera.matrix, 0);
    _v3A.crossVectors(this._camera.up, _v3A);
    _v3A.multiplyScalar(distance);
    const to2 = _v3B.copy(this._targetEnd).add(_v3A);
    return this.moveTo(to2.x, to2.y, to2.z, enableTransition);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(height, enableTransition = false) {
    _v3A.copy(this._camera.up).multiplyScalar(height);
    return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(x, y, z, enableTransition = false) {
    this._isUserControllingTruck = false;
    const offset = _v3A.set(x, y, z).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(x, y, z, enableTransition = false) {
    const point = _v3A.set(x, y, z);
    const direction = point.sub(this._targetEnd).normalize();
    const position2 = direction.multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(position2.x, position2.y, position2.z, enableTransition);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
    const promises = [];
    const aabb = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
    if (aabb.isEmpty()) {
      console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
      Promise.resolve();
    }
    const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
    const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
    promises.push(this.rotateTo(theta, phi, enableTransition));
    const normal2 = _v3A.setFromSpherical(this._sphericalEnd).normalize();
    const rotation2 = _quaternionA.setFromUnitVectors(normal2, _AXIS_Z);
    const viewFromPolar = approxEquals(Math.abs(normal2.y), 1);
    if (viewFromPolar) {
      rotation2.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
    }
    rotation2.multiply(this._yAxisUpSpaceInverse);
    const bb2 = _box3B.makeEmpty();
    _v3B.copy(aabb.min).applyQuaternion(rotation2);
    bb2.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation2);
    bb2.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation2);
    bb2.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation2);
    bb2.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation2);
    bb2.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation2);
    bb2.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation2);
    bb2.expandByPoint(_v3B);
    _v3B.copy(aabb.max).applyQuaternion(rotation2);
    bb2.expandByPoint(_v3B);
    bb2.min.x -= paddingLeft;
    bb2.min.y -= paddingBottom;
    bb2.max.x += paddingRight;
    bb2.max.y += paddingTop;
    rotation2.setFromUnitVectors(_AXIS_Z, normal2);
    if (viewFromPolar) {
      rotation2.premultiply(_quaternionB.invert());
    }
    rotation2.premultiply(this._yAxisUpSpace);
    const bbSize = bb2.getSize(_v3A);
    const center = bb2.getCenter(_v3B).applyQuaternion(rotation2);
    if (isPerspectiveCamera(this._camera)) {
      const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.dollyTo(distance, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const width = camera.right - camera.left;
      const height = camera.top - camera.bottom;
      const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.zoomTo(zoom, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    }
    return Promise.all(promises);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(sphereOrMesh, enableTransition) {
    const promises = [];
    const isSphere = sphereOrMesh instanceof THREE.Sphere;
    const boundingSphere = isSphere ? _sphere.copy(sphereOrMesh) : _CameraControls.createBoundingSphere(sphereOrMesh, _sphere);
    promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
    if (isPerspectiveCamera(this._camera)) {
      const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
      promises.push(this.dollyTo(distanceToFit, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const width = this._camera.right - this._camera.left;
      const height = this._camera.top - this._camera.bottom;
      const diameter = 2 * boundingSphere.radius;
      const zoom = Math.min(width / diameter, height / diameter);
      promises.push(this.zoomTo(zoom, enableTransition));
    }
    promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    return Promise.all(promises);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const target2 = _v3B.set(targetX, targetY, targetZ);
    const position2 = _v3A.set(positionX, positionY, positionZ);
    this._targetEnd.copy(target2);
    this._sphericalEnd.setFromVector3(position2.sub(target2).applyQuaternion(this._yAxisUpSpace));
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t2, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const targetA = _v3A.set(targetAX, targetAY, targetAZ);
    const positionA = _v3B.set(positionAX, positionAY, positionAZ);
    _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
    const targetB = _v3C.set(targetBX, targetBY, targetBZ);
    const positionB = _v3B.set(positionBX, positionBY, positionBZ);
    _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
    this._targetEnd.copy(targetA.lerp(targetB, t2));
    const deltaTheta = _sphericalB.theta - _sphericalA.theta;
    const deltaPhi = _sphericalB.phi - _sphericalA.phi;
    const deltaRadius = _sphericalB.radius - _sphericalA.radius;
    this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t2, _sphericalA.phi + deltaPhi * t2, _sphericalA.theta + deltaTheta * t2);
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(positionX, positionY, positionZ, enableTransition = false) {
    return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(targetX, targetY, targetZ, enableTransition = false) {
    const pos = this.getPosition(_v3A);
    const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
    this._sphericalEnd.phi = clamp3(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
    return promise;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(x, y, z, enableTransition = false) {
    this._isUserControllingOffset = false;
    this._focalOffsetEnd.set(x, y, z);
    this._needsUpdate = true;
    if (!enableTransition)
      this._focalOffset.copy(this._focalOffsetEnd);
    const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(targetX, targetY, targetZ) {
    this._camera.updateMatrixWorld();
    _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
    _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const position2 = _v3A.set(targetX, targetY, targetZ);
    const distance = position2.distanceTo(this._camera.position);
    const cameraToPoint = position2.sub(this._camera.position);
    _xColumn.multiplyScalar(cameraToPoint.x);
    _yColumn.multiplyScalar(cameraToPoint.y);
    _zColumn.multiplyScalar(cameraToPoint.z);
    _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
    _v3A.z = _v3A.z + distance;
    this.dollyTo(distance, false);
    this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
    this.moveTo(targetX, targetY, targetZ, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(box3) {
    if (!box3) {
      this._boundary.min.set(-Infinity, -Infinity, -Infinity);
      this._boundary.max.set(Infinity, Infinity, Infinity);
      this._needsUpdate = true;
      return;
    }
    this._boundary.copy(box3);
    this._boundary.clampPoint(this._targetEnd, this._targetEnd);
    this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(viewportOrX, y, width, height) {
    if (viewportOrX === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new THREE.Vector4();
    if (typeof viewportOrX === "number") {
      this._viewport.set(viewportOrX, y, width, height);
    } else {
      this._viewport.copy(viewportOrX);
    }
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(width, height, depth, cover = false) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const boundingRectAspect = width / height;
    const fov = this._camera.getEffectiveFOV() * DEG2RAD;
    const aspect = this._camera.aspect;
    const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;
    return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(radius) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;
    const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
    const fov = 1 < this._camera.aspect ? vFOV : hFOV;
    return radius / Math.sin(fov * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(out, receiveEndValue = true) {
    const _out = !!out && out instanceof THREE.Spherical ? out : new THREE.Spherical();
    return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
    if (this._sphericalEnd.theta < 0)
      this._sphericalEnd.theta += PI_2;
    this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(enableTransition = false) {
    if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const position2 = this.getPosition(_v3A);
      this.updateCameraUp();
      this.setPosition(position2.x, position2.y, position2.z);
    }
    const promises = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
      this.zoomTo(this._zoom0, enableTransition)
    ];
    return Promise.all(promises);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up);
    this.getTarget(this._target0);
    this.getPosition(this._position0);
    this._zoom0 = this._zoom;
    this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
    const side = _v3B.crossVectors(cameraDirection, this._camera.up);
    this._camera.up.crossVectors(side, cameraDirection).normalize();
    this._camera.updateMatrixWorld();
    const position2 = this.getPosition(_v3A);
    this.updateCameraUp();
    this.setPosition(position2.x, position2.y, position2.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(delta) {
    const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
    const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
    const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
    const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
    const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
    const deltaZoom = this._zoomEnd - this._zoom;
    if (approxZero(deltaTheta)) {
      this._thetaVelocity.value = 0;
      this._spherical.theta = this._sphericalEnd.theta;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaPhi)) {
      this._phiVelocity.value = 0;
      this._spherical.phi = this._sphericalEnd.phi;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaRadius)) {
      this._radiusVelocity.value = 0;
      this._spherical.radius = this._sphericalEnd.radius;
    } else {
      const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
      this._targetVelocity.set(0, 0, 0);
      this._target.copy(this._targetEnd);
    } else {
      const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
      this._needsUpdate = true;
    }
    if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
      this._focalOffsetVelocity.set(0, 0, 0);
      this._focalOffset.copy(this._focalOffsetEnd);
    } else {
      const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
      this._needsUpdate = true;
    }
    if (approxZero(deltaZoom)) {
      this._zoomVelocity.value = 0;
      this._zoom = this._zoomEnd;
    } else {
      const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
    }
    if (this.dollyToCursor) {
      if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
        const dollyControlAmount = this._spherical.radius - this._lastDistance;
        const camera = this._camera;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
        if (planeX.lengthSq() === 0)
          planeX.x = 1;
        const planeY = _v3B.crossVectors(planeX, cameraDirection);
        const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);
        const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
        const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
        const cursor = _v3C.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
        const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (isMin || isMax)) {
          this._sphericalEnd.radius -= dollyControlAmount;
          this._spherical.radius -= dollyControlAmount;
          const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
          newTargetEnd.add(dollyAmount);
        }
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedDolly -= dollyControlAmount;
        if (approxZero(this._changedDolly))
          this._changedDolly = 0;
      } else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {
        const dollyControlAmount = this._zoom - this._lastZoom;
        const camera = this._camera;
        const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
        const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
        const prevZoom = this._zoom - dollyControlAmount;
        const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const newPlaneConstant = newTargetEnd.dot(cameraDirection);
        const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
        newTargetEnd.sub(pullBack);
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedZoom -= dollyControlAmount;
        if (approxZero(this._changedZoom))
          this._changedZoom = 0;
      }
    }
    if (this._camera.zoom !== this._zoom) {
      this._camera.zoom = this._zoom;
      this._camera.updateProjectionMatrix();
      this._updateNearPlaneCorners();
      this._needsUpdate = true;
    }
    this._dragNeedsUpdate = true;
    const maxDistance = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
    this._spherical.makeSafe();
    this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
    this._camera.lookAt(this._target);
    const affectOffset = !approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z);
    if (affectOffset) {
      this._camera.updateMatrixWorld();
      _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
      _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
      _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
      _xColumn.multiplyScalar(this._focalOffset.x);
      _yColumn.multiplyScalar(-this._focalOffset.y);
      _zColumn.multiplyScalar(this._focalOffset.z);
      _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
      this._camera.position.add(_v3A);
    }
    if (this._boundaryEnclosesCamera) {
      this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    }
    const updated = this._needsUpdate;
    if (updated && !this._updatedLastTime) {
      this._hasRested = false;
      this.dispatchEvent({ type: "wake" });
      this.dispatchEvent({ type: "update" });
    } else if (updated) {
      this.dispatchEvent({ type: "update" });
      if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
        this._hasRested = true;
        this.dispatchEvent({ type: "rest" });
      }
    } else if (!updated && this._updatedLastTime) {
      this.dispatchEvent({ type: "sleep" });
    }
    this._lastDistance = this._spherical.radius;
    this._lastZoom = this._zoom;
    this._updatedLastTime = updated;
    this._needsUpdate = false;
    return updated;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: infinityToMaxNumber(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: infinityToMaxNumber(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
      minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
      maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(json, enableTransition = false) {
    const obj = JSON.parse(json);
    this.enabled = obj.enabled;
    this.minDistance = obj.minDistance;
    this.maxDistance = maxNumberToInfinity(obj.maxDistance);
    this.minZoom = obj.minZoom;
    this.maxZoom = maxNumberToInfinity(obj.maxZoom);
    this.minPolarAngle = obj.minPolarAngle;
    this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
    this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
    this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
    this.smoothTime = obj.smoothTime;
    this.draggingSmoothTime = obj.draggingSmoothTime;
    this.dollySpeed = obj.dollySpeed;
    this.truckSpeed = obj.truckSpeed;
    this.dollyToCursor = obj.dollyToCursor;
    this.verticalDragToForward = obj.verticalDragToForward;
    this._target0.fromArray(obj.target0);
    this._position0.fromArray(obj.position0);
    this._zoom0 = obj.zoom0;
    this._focalOffset0.fromArray(obj.focalOffset0);
    this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
    _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
    this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
    this.dollyTo(_sphericalA.radius, enableTransition);
    this.zoomTo(obj.zoom, enableTransition);
    this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
    this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(domElement) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    domElement.setAttribute("data-camera-controls-version", VERSION);
    this._addAllEventListeners(domElement);
    this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel();
    this._removeAllEventListeners();
    if (this._domElement) {
      this._domElement.removeAttribute("data-camera-controls-version");
      this._domElement = void 0;
    }
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners();
    this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(out) {
    return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(out) {
    return this._getTargetDirection(out).negate();
  }
  _findPointerById(pointerId2) {
    return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId2);
  }
  _findPointerByMouseButton(mouseButton) {
    return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
  }
  _disposePointer(pointer) {
    this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
  }
  _encloseToBoundary(position2, offset, friction) {
    const offsetLength2 = offset.lengthSq();
    if (offsetLength2 === 0) {
      return position2;
    }
    const newTarget = _v3B.copy(offset).add(position2);
    const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
    const deltaClampedTarget = clampedTarget.sub(newTarget);
    const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
    if (deltaClampedTargetLength2 === 0) {
      return position2.add(offset);
    } else if (deltaClampedTargetLength2 === offsetLength2) {
      return position2;
    } else if (friction === 0) {
      return position2.add(offset).add(deltaClampedTarget);
    } else {
      const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
      return position2.add(_v3B.copy(offset).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
    }
  }
  _updateNearPlaneCorners() {
    if (isPerspectiveCamera(this._camera)) {
      const camera = this._camera;
      const near = camera.near;
      const fov = camera.getEffectiveFOV() * DEG2RAD;
      const heightHalf = Math.tan(fov * 0.5) * near;
      const widthHalf = heightHalf * camera.aspect;
      this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
      this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const zoomInv = 1 / camera.zoom;
      const left = camera.left * zoomInv;
      const right = camera.right * zoomInv;
      const top = camera.top * zoomInv;
      const bottom = camera.bottom * zoomInv;
      this._nearPlaneCorners[0].set(left, top, 0);
      this._nearPlaneCorners[1].set(right, top, 0);
      this._nearPlaneCorners[2].set(right, bottom, 0);
      this._nearPlaneCorners[3].set(left, bottom, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let distance = Infinity;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (!hasCollider)
      return distance;
    if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
      return distance;
    const rayDirection = this._getTargetDirection(_cameraDirection);
    _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
    for (let i3 = 0; i3 < 4; i3++) {
      const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i3]);
      nearPlaneCorner.applyMatrix4(_rotationMatrix);
      const origin2 = _v3C.addVectors(this._target, nearPlaneCorner);
      _raycaster.set(origin2, rayDirection);
      _raycaster.far = this._spherical.radius + 1;
      const intersects = _raycaster.intersectObjects(this.colliderMeshes);
      if (intersects.length !== 0 && intersects[0].distance < distance) {
        distance = intersects[0].distance;
      }
    }
    return distance;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(target2) {
    if (!this._domElement)
      return;
    const rect = this._domElement.getBoundingClientRect();
    target2.x = rect.left;
    target2.y = rect.top;
    if (this._viewport) {
      target2.x += this._viewport.x;
      target2.y += rect.height - this._viewport.w - this._viewport.y;
      target2.width = this._viewport.z;
      target2.height = this._viewport.w;
    } else {
      target2.width = rect.width;
      target2.height = rect.height;
    }
    return target2;
  }
  _createOnRestPromise(resolveImmediately) {
    if (resolveImmediately)
      return Promise.resolve();
    this._hasRested = false;
    this.dispatchEvent({ type: "transitionstart" });
    return new Promise((resolve2) => {
      const onResolve = () => {
        this.removeEventListener("rest", onResolve);
        resolve2();
      };
      this.addEventListener("rest", onResolve);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(_domElement) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(_) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(_) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(object3d, out = new THREE.Sphere()) {
    const boundingSphere = out;
    const center = boundingSphere.center;
    _box3A.makeEmpty();
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      _box3A.expandByObject(object);
    });
    _box3A.getCenter(center);
    let maxRadiusSq = 0;
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      const mesh = object;
      const geometry = mesh.geometry.clone();
      geometry.applyMatrix4(mesh.matrixWorld);
      const bufferGeometry = geometry;
      const position2 = bufferGeometry.attributes.position;
      for (let i3 = 0, l2 = position2.count; i3 < l2; i3++) {
        _v3A.fromBufferAttribute(position2, i3);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
      }
    });
    boundingSphere.radius = Math.sqrt(maxRadiusSq);
    return boundingSphere;
  }
};

// node_modules/@react-three/drei/core/CameraControls.js
var CameraControls2 = (0, import_react11.forwardRef)((props, ref) => {
  (0, import_react11.useMemo)(() => {
    CameraControls.install({
      THREE: three_module_exports
    });
    extend({
      CameraControlsImpl: CameraControls
    });
  }, []);
  const {
    camera,
    domElement,
    makeDefault,
    onStart,
    onEnd,
    onChange,
    regress,
    ...restProps
  } = props;
  const defaultCamera = useThree((state) => state.camera);
  const gl = useThree((state) => state.gl);
  const invalidate = useThree((state) => state.invalidate);
  const events = useThree((state) => state.events);
  const setEvents = useThree((state) => state.setEvents);
  const set = useThree((state) => state.set);
  const get = useThree((state) => state.get);
  const performance2 = useThree((state) => state.performance);
  const explCamera = camera || defaultCamera;
  const explDomElement = domElement || events.connected || gl.domElement;
  const controls = (0, import_react11.useMemo)(() => new CameraControls(explCamera), [explCamera]);
  useFrame((state, delta) => {
    if (controls.enabled)
      controls.update(delta);
  }, -1);
  (0, import_react11.useEffect)(() => {
    controls.connect(explDomElement);
    return () => void controls.disconnect();
  }, [explDomElement, controls]);
  React48.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (regress)
        performance2.regress();
      if (onChange)
        onChange(e2);
    };
    const onStartCb = (e2) => {
      if (onStart)
        onStart(e2);
    };
    const onEndCb = (e2) => {
      if (onEnd)
        onEnd(e2);
    };
    controls.addEventListener("update", callback);
    controls.addEventListener("controlstart", onStartCb);
    controls.addEventListener("controlend", onEndCb);
    controls.addEventListener("control", callback);
    controls.addEventListener("transitionstart", callback);
    controls.addEventListener("wake", callback);
    return () => {
      controls.removeEventListener("update", callback);
      controls.removeEventListener("controlstart", onStartCb);
      controls.removeEventListener("controlend", onEndCb);
      controls.removeEventListener("control", callback);
      controls.removeEventListener("transitionstart", callback);
      controls.removeEventListener("wake", callback);
    };
  }, [controls, onStart, onEnd, invalidate, setEvents, regress, onChange]);
  (0, import_react11.useEffect)(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return React48.createElement("primitive", _extends({
    ref,
    object: controls
  }, restProps));
});

// node_modules/@react-three/drei/core/FaceControls.js
var React51 = __toESM(require_react());
var import_react14 = __toESM(require_react());

// node_modules/@react-three/drei/core/useVideoTexture.js
var import_react12 = __toESM(require_react());
function useVideoTexture(src, props) {
  const {
    unsuspend,
    start: start2,
    crossOrigin,
    muted,
    loop: loop2,
    ...rest
  } = {
    unsuspend: "loadedmetadata",
    crossOrigin: "Anonymous",
    muted: true,
    loop: true,
    start: true,
    playsInline: true,
    ...props
  };
  const gl = useThree((state) => state.gl);
  const texture = suspend(() => new Promise((res, rej) => {
    const video = Object.assign(document.createElement("video"), {
      src: typeof src === "string" && src || void 0,
      srcObject: src instanceof MediaStream && src || void 0,
      crossOrigin,
      loop: loop2,
      muted,
      ...rest
    });
    const texture2 = new VideoTexture(video);
    if ("colorSpace" in texture2)
      texture2.colorSpace = gl.outputColorSpace;
    else
      texture2.encoding = gl.outputEncoding;
    video.addEventListener(unsuspend, () => res(texture2));
  }), [src]);
  (0, import_react12.useEffect)(() => void (start2 && texture.image.play()), [texture, start2]);
  return texture;
}

// node_modules/@react-three/drei/core/Facemesh.js
var React49 = __toESM(require_react());
var defaultLookAt = new Vector3(0, 0, -1);
var normal = function() {
  const a3 = new Vector3();
  const b = new Vector3();
  const c6 = new Vector3();
  const ab = new Vector3();
  const ac = new Vector3();
  return function(v12, v22, v32, v4) {
    a3.copy(v12);
    b.copy(v22);
    c6.copy(v32);
    ab.copy(b).sub(a3);
    ac.copy(c6).sub(a3);
    return v4.crossVectors(ac, ab).normalize();
  };
}();
function mean(v12, v22) {
  return v12.clone().add(v22).multiplyScalar(0.5);
}
var Facemesh = React49.forwardRef(({
  points = FacemeshDatas.SAMPLE_FACELANDMARKER_RESULT.faceLandmarks[0],
  face,
  facialTransformationMatrix,
  faceBlendshapes,
  offset,
  offsetScalar = 80,
  width,
  height,
  depth = 1,
  verticalTri = [159, 386, 152],
  origin: origin2,
  eyes = true,
  eyesAsOrigin = false,
  debug = false,
  children,
  ...props
}, fref) => {
  var _meshRef$current3;
  if (face) {
    points = face.keypoints;
    console.warn("Facemesh `face` prop is deprecated: use `points` instead");
  }
  const offsetRef = React49.useRef(null);
  const scaleRef = React49.useRef(null);
  const originRef = React49.useRef(null);
  const outerRef = React49.useRef(null);
  const meshRef = React49.useRef(null);
  const eyeRightRef = React49.useRef(null);
  const eyeLeftRef = React49.useRef(null);
  const [sightDir] = React49.useState(() => new Vector3());
  const [transform] = React49.useState(() => new Object3D());
  const [sightDirQuaternion] = React49.useState(() => new Quaternion());
  const [_origin] = React49.useState(() => new Vector3());
  const {
    invalidate
  } = useThree();
  React49.useEffect(() => {
    var _meshRef$current;
    (_meshRef$current = meshRef.current) == null ? void 0 : _meshRef$current.geometry.setIndex(FacemeshDatas.TRIANGULATION);
  }, []);
  const [bboxSize] = React49.useState(() => new Vector3());
  React49.useEffect(() => {
    var _meshRef$current2, _outerRef$current;
    const faceGeometry = (_meshRef$current2 = meshRef.current) == null ? void 0 : _meshRef$current2.geometry;
    if (!faceGeometry)
      return;
    faceGeometry.setFromPoints(points);
    faceGeometry.setDrawRange(0, FacemeshDatas.TRIANGULATION.length);
    if (facialTransformationMatrix) {
      transform.matrix.fromArray(facialTransformationMatrix.data);
      transform.matrix.decompose(transform.position, transform.quaternion, transform.scale);
      transform.rotation.y *= -1;
      transform.rotation.z *= -1;
      sightDirQuaternion.setFromEuler(transform.rotation);
      if (offset) {
        var _offsetRef$current;
        transform.position.y *= -1;
        transform.position.z *= -1;
        (_offsetRef$current = offsetRef.current) == null ? void 0 : _offsetRef$current.position.copy(transform.position.divideScalar(offsetScalar));
      } else {
        var _offsetRef$current2;
        (_offsetRef$current2 = offsetRef.current) == null ? void 0 : _offsetRef$current2.position.set(0, 0, 0);
      }
    } else {
      normal(points[verticalTri[0]], points[verticalTri[1]], points[verticalTri[2]], sightDir);
      sightDirQuaternion.setFromUnitVectors(defaultLookAt, sightDir);
    }
    const sightDirQuaternionInverse = sightDirQuaternion.clone().invert();
    faceGeometry.computeBoundingBox();
    if (debug)
      invalidate();
    faceGeometry.center();
    faceGeometry.applyQuaternion(sightDirQuaternionInverse);
    (_outerRef$current = outerRef.current) == null ? void 0 : _outerRef$current.setRotationFromQuaternion(sightDirQuaternion);
    if (eyes) {
      if (!faceBlendshapes) {
        console.warn("Facemesh `eyes` option only works if `faceBlendshapes` is provided: skipping.");
      } else {
        if (eyeRightRef.current && eyeLeftRef.current && originRef.current) {
          if (eyesAsOrigin) {
            const eyeRightSphere = eyeRightRef.current._computeSphere(faceGeometry);
            const eyeLeftSphere = eyeLeftRef.current._computeSphere(faceGeometry);
            const eyesCenter = mean(eyeRightSphere.center, eyeLeftSphere.center);
            origin2 = eyesCenter.negate();
            eyeRightRef.current._update(faceGeometry, faceBlendshapes, eyeRightSphere);
            eyeLeftRef.current._update(faceGeometry, faceBlendshapes, eyeLeftSphere);
          } else {
            eyeRightRef.current._update(faceGeometry, faceBlendshapes);
            eyeLeftRef.current._update(faceGeometry, faceBlendshapes);
          }
        }
      }
    }
    if (originRef.current) {
      if (origin2 !== void 0) {
        if (typeof origin2 === "number") {
          const position2 = faceGeometry.getAttribute("position");
          _origin.set(-position2.getX(origin2), -position2.getY(origin2), -position2.getZ(origin2));
        } else if (origin2.isVector3) {
          _origin.copy(origin2);
        }
      } else {
        _origin.setScalar(0);
      }
      originRef.current.position.copy(_origin);
    }
    if (scaleRef.current) {
      let scale2 = 1;
      if (width || height || depth) {
        faceGeometry.boundingBox.getSize(bboxSize);
        if (width)
          scale2 = width / bboxSize.x;
        if (height)
          scale2 = height / bboxSize.y;
        if (depth)
          scale2 = depth / bboxSize.z;
      }
      scaleRef.current.scale.setScalar(scale2 !== 1 ? scale2 : 1);
    }
    faceGeometry.computeVertexNormals();
    faceGeometry.attributes.position.needsUpdate = true;
  }, [points, facialTransformationMatrix, faceBlendshapes, transform, offset, offsetScalar, width, height, depth, verticalTri, origin2, eyes, debug, invalidate, sightDir, sightDirQuaternion, bboxSize, _origin]);
  const api = React49.useMemo(() => ({
    outerRef,
    meshRef,
    eyeRightRef,
    eyeLeftRef
  }), []);
  React49.useImperativeHandle(fref, () => api, [api]);
  const [meshBboxSize] = React49.useState(() => new Vector3());
  const bbox = (_meshRef$current3 = meshRef.current) == null ? void 0 : _meshRef$current3.geometry.boundingBox;
  const one = (bbox == null ? void 0 : bbox.getSize(meshBboxSize).z) || 1;
  return React49.createElement("group", props, React49.createElement("group", {
    ref: offsetRef
  }, React49.createElement("group", {
    ref: outerRef
  }, React49.createElement("group", {
    ref: scaleRef
  }, debug ? React49.createElement(React49.Fragment, null, React49.createElement("axesHelper", {
    args: [one]
  }), React49.createElement(Line, {
    points: [[0, 0, 0], [0, 0, -one]],
    color: 65535
  })) : null, React49.createElement("group", {
    ref: originRef
  }, eyes && faceBlendshapes && React49.createElement("group", {
    name: "eyes"
  }, React49.createElement(FacemeshEye, {
    side: "left",
    ref: eyeRightRef,
    debug
  }), React49.createElement(FacemeshEye, {
    side: "right",
    ref: eyeLeftRef,
    debug
  })), React49.createElement("mesh", {
    ref: meshRef,
    name: "face"
  }, children, debug ? React49.createElement(React49.Fragment, null, bbox && React49.createElement("box3Helper", {
    args: [bbox]
  })) : null))))));
});
var FacemeshEyeDefaults = {
  contourLandmarks: {
    right: [33, 133, 159, 145, 153],
    left: [263, 362, 386, 374, 380]
  },
  blendshapes: {
    right: [14, 16, 18, 12],
    // lookIn,lookOut, lookUp,lookDown
    left: [13, 15, 17, 11]
    // lookIn,lookOut, lookUp,lookDown
  },
  color: {
    right: "red",
    left: "#00ff00"
  },
  fov: {
    horizontal: 100,
    vertical: 90
  }
};
var FacemeshEye = React49.forwardRef(({
  side,
  debug = true
}, fref) => {
  const eyeMeshRef = React49.useRef(null);
  const irisDirRef = React49.useRef(null);
  const [sphere] = React49.useState(() => new Sphere());
  const _computeSphere = React49.useCallback((faceGeometry) => {
    const position2 = faceGeometry.getAttribute("position");
    const eyeContourLandmarks = FacemeshEyeDefaults.contourLandmarks[side];
    const eyeContourPoints = eyeContourLandmarks.map((i3) => new Vector3(position2.getX(i3), position2.getY(i3), position2.getZ(i3)));
    sphere.center.set(0, 0, 0);
    eyeContourPoints.forEach((v4) => sphere.center.add(v4));
    sphere.center.divideScalar(eyeContourPoints.length);
    sphere.radius = eyeContourPoints[0].sub(eyeContourPoints[1]).length() / 2;
    return sphere;
  }, [sphere, side]);
  const [rotation2] = React49.useState(() => new Euler());
  const _update = React49.useCallback((faceGeometry, faceBlendshapes, sphere2) => {
    if (eyeMeshRef.current) {
      var _sphere4;
      (_sphere4 = sphere2) !== null && _sphere4 !== void 0 ? _sphere4 : sphere2 = _computeSphere(faceGeometry);
      eyeMeshRef.current.position.copy(sphere2.center);
      eyeMeshRef.current.scale.setScalar(sphere2.radius);
    }
    if (faceBlendshapes && irisDirRef.current) {
      const blendshapes = FacemeshEyeDefaults.blendshapes[side];
      const lookIn = faceBlendshapes.categories[blendshapes[0]].score;
      const lookOut = faceBlendshapes.categories[blendshapes[1]].score;
      const lookUp = faceBlendshapes.categories[blendshapes[2]].score;
      const lookDown = faceBlendshapes.categories[blendshapes[3]].score;
      const hfov = FacemeshEyeDefaults.fov.horizontal * MathUtils.DEG2RAD;
      const vfov = FacemeshEyeDefaults.fov.vertical * MathUtils.DEG2RAD;
      const rx = hfov * 0.5 * (lookDown - lookUp);
      const ry = vfov * 0.5 * (lookIn - lookOut) * (side === "left" ? 1 : -1);
      rotation2.set(rx, ry, 0);
      irisDirRef.current.setRotationFromEuler(rotation2);
    }
  }, [_computeSphere, side, rotation2]);
  const api = React49.useMemo(() => ({
    eyeMeshRef,
    irisDirRef,
    _computeSphere,
    _update
  }), [_computeSphere, _update]);
  React49.useImperativeHandle(fref, () => api, [api]);
  const color = FacemeshEyeDefaults.color[side];
  return React49.createElement("group", null, React49.createElement("group", {
    ref: eyeMeshRef
  }, debug && React49.createElement("axesHelper", null), React49.createElement("group", {
    ref: irisDirRef
  }, React49.createElement(React49.Fragment, null, debug && React49.createElement(Line, {
    points: [[0, 0, 0], [0, 0, -2]],
    lineWidth: 1,
    color
  })))));
});
var FacemeshDatas = {
  // Extracted from: https://github.com/tensorflow/tfjs-models/blob/a8f500809f5afe38feea27870c77e7ba03a6ece4/face-landmarks-detection/demos/shared/triangulation.js
  // prettier-ignore
  TRIANGULATION: [127, 34, 139, 11, 0, 37, 232, 231, 120, 72, 37, 39, 128, 121, 47, 232, 121, 128, 104, 69, 67, 175, 171, 148, 157, 154, 155, 118, 50, 101, 73, 39, 40, 9, 151, 108, 48, 115, 131, 194, 204, 211, 74, 40, 185, 80, 42, 183, 40, 92, 186, 230, 229, 118, 202, 212, 214, 83, 18, 17, 76, 61, 146, 160, 29, 30, 56, 157, 173, 106, 204, 194, 135, 214, 192, 203, 165, 98, 21, 71, 68, 51, 45, 4, 144, 24, 23, 77, 146, 91, 205, 50, 187, 201, 200, 18, 91, 106, 182, 90, 91, 181, 85, 84, 17, 206, 203, 36, 148, 171, 140, 92, 40, 39, 193, 189, 244, 159, 158, 28, 247, 246, 161, 236, 3, 196, 54, 68, 104, 193, 168, 8, 117, 228, 31, 189, 193, 55, 98, 97, 99, 126, 47, 100, 166, 79, 218, 155, 154, 26, 209, 49, 131, 135, 136, 150, 47, 126, 217, 223, 52, 53, 45, 51, 134, 211, 170, 140, 67, 69, 108, 43, 106, 91, 230, 119, 120, 226, 130, 247, 63, 53, 52, 238, 20, 242, 46, 70, 156, 78, 62, 96, 46, 53, 63, 143, 34, 227, 173, 155, 133, 123, 117, 111, 44, 125, 19, 236, 134, 51, 216, 206, 205, 154, 153, 22, 39, 37, 167, 200, 201, 208, 36, 142, 100, 57, 212, 202, 20, 60, 99, 28, 158, 157, 35, 226, 113, 160, 159, 27, 204, 202, 210, 113, 225, 46, 43, 202, 204, 62, 76, 77, 137, 123, 116, 41, 38, 72, 203, 129, 142, 64, 98, 240, 49, 102, 64, 41, 73, 74, 212, 216, 207, 42, 74, 184, 169, 170, 211, 170, 149, 176, 105, 66, 69, 122, 6, 168, 123, 147, 187, 96, 77, 90, 65, 55, 107, 89, 90, 180, 101, 100, 120, 63, 105, 104, 93, 137, 227, 15, 86, 85, 129, 102, 49, 14, 87, 86, 55, 8, 9, 100, 47, 121, 145, 23, 22, 88, 89, 179, 6, 122, 196, 88, 95, 96, 138, 172, 136, 215, 58, 172, 115, 48, 219, 42, 80, 81, 195, 3, 51, 43, 146, 61, 171, 175, 199, 81, 82, 38, 53, 46, 225, 144, 163, 110, 246, 33, 7, 52, 65, 66, 229, 228, 117, 34, 127, 234, 107, 108, 69, 109, 108, 151, 48, 64, 235, 62, 78, 191, 129, 209, 126, 111, 35, 143, 163, 161, 246, 117, 123, 50, 222, 65, 52, 19, 125, 141, 221, 55, 65, 3, 195, 197, 25, 7, 33, 220, 237, 44, 70, 71, 139, 122, 193, 245, 247, 130, 33, 71, 21, 162, 153, 158, 159, 170, 169, 150, 188, 174, 196, 216, 186, 92, 144, 160, 161, 2, 97, 167, 141, 125, 241, 164, 167, 37, 72, 38, 12, 145, 159, 160, 38, 82, 13, 63, 68, 71, 226, 35, 111, 158, 153, 154, 101, 50, 205, 206, 92, 165, 209, 198, 217, 165, 167, 97, 220, 115, 218, 133, 112, 243, 239, 238, 241, 214, 135, 169, 190, 173, 133, 171, 208, 32, 125, 44, 237, 86, 87, 178, 85, 86, 179, 84, 85, 180, 83, 84, 181, 201, 83, 182, 137, 93, 132, 76, 62, 183, 61, 76, 184, 57, 61, 185, 212, 57, 186, 214, 207, 187, 34, 143, 156, 79, 239, 237, 123, 137, 177, 44, 1, 4, 201, 194, 32, 64, 102, 129, 213, 215, 138, 59, 166, 219, 242, 99, 97, 2, 94, 141, 75, 59, 235, 24, 110, 228, 25, 130, 226, 23, 24, 229, 22, 23, 230, 26, 22, 231, 112, 26, 232, 189, 190, 243, 221, 56, 190, 28, 56, 221, 27, 28, 222, 29, 27, 223, 30, 29, 224, 247, 30, 225, 238, 79, 20, 166, 59, 75, 60, 75, 240, 147, 177, 215, 20, 79, 166, 187, 147, 213, 112, 233, 244, 233, 128, 245, 128, 114, 188, 114, 217, 174, 131, 115, 220, 217, 198, 236, 198, 131, 134, 177, 132, 58, 143, 35, 124, 110, 163, 7, 228, 110, 25, 356, 389, 368, 11, 302, 267, 452, 350, 349, 302, 303, 269, 357, 343, 277, 452, 453, 357, 333, 332, 297, 175, 152, 377, 384, 398, 382, 347, 348, 330, 303, 304, 270, 9, 336, 337, 278, 279, 360, 418, 262, 431, 304, 408, 409, 310, 415, 407, 270, 409, 410, 450, 348, 347, 422, 430, 434, 313, 314, 17, 306, 307, 375, 387, 388, 260, 286, 414, 398, 335, 406, 418, 364, 367, 416, 423, 358, 327, 251, 284, 298, 281, 5, 4, 373, 374, 253, 307, 320, 321, 425, 427, 411, 421, 313, 18, 321, 405, 406, 320, 404, 405, 315, 16, 17, 426, 425, 266, 377, 400, 369, 322, 391, 269, 417, 465, 464, 386, 257, 258, 466, 260, 388, 456, 399, 419, 284, 332, 333, 417, 285, 8, 346, 340, 261, 413, 441, 285, 327, 460, 328, 355, 371, 329, 392, 439, 438, 382, 341, 256, 429, 420, 360, 364, 394, 379, 277, 343, 437, 443, 444, 283, 275, 440, 363, 431, 262, 369, 297, 338, 337, 273, 375, 321, 450, 451, 349, 446, 342, 467, 293, 334, 282, 458, 461, 462, 276, 353, 383, 308, 324, 325, 276, 300, 293, 372, 345, 447, 382, 398, 362, 352, 345, 340, 274, 1, 19, 456, 248, 281, 436, 427, 425, 381, 256, 252, 269, 391, 393, 200, 199, 428, 266, 330, 329, 287, 273, 422, 250, 462, 328, 258, 286, 384, 265, 353, 342, 387, 259, 257, 424, 431, 430, 342, 353, 276, 273, 335, 424, 292, 325, 307, 366, 447, 345, 271, 303, 302, 423, 266, 371, 294, 455, 460, 279, 278, 294, 271, 272, 304, 432, 434, 427, 272, 407, 408, 394, 430, 431, 395, 369, 400, 334, 333, 299, 351, 417, 168, 352, 280, 411, 325, 319, 320, 295, 296, 336, 319, 403, 404, 330, 348, 349, 293, 298, 333, 323, 454, 447, 15, 16, 315, 358, 429, 279, 14, 15, 316, 285, 336, 9, 329, 349, 350, 374, 380, 252, 318, 402, 403, 6, 197, 419, 318, 319, 325, 367, 364, 365, 435, 367, 397, 344, 438, 439, 272, 271, 311, 195, 5, 281, 273, 287, 291, 396, 428, 199, 311, 271, 268, 283, 444, 445, 373, 254, 339, 263, 466, 249, 282, 334, 296, 449, 347, 346, 264, 447, 454, 336, 296, 299, 338, 10, 151, 278, 439, 455, 292, 407, 415, 358, 371, 355, 340, 345, 372, 390, 249, 466, 346, 347, 280, 442, 443, 282, 19, 94, 370, 441, 442, 295, 248, 419, 197, 263, 255, 359, 440, 275, 274, 300, 383, 368, 351, 412, 465, 263, 467, 466, 301, 368, 389, 380, 374, 386, 395, 378, 379, 412, 351, 419, 436, 426, 322, 373, 390, 388, 2, 164, 393, 370, 462, 461, 164, 0, 267, 302, 11, 12, 374, 373, 387, 268, 12, 13, 293, 300, 301, 446, 261, 340, 385, 384, 381, 330, 266, 425, 426, 423, 391, 429, 355, 437, 391, 327, 326, 440, 457, 438, 341, 382, 362, 459, 457, 461, 434, 430, 394, 414, 463, 362, 396, 369, 262, 354, 461, 457, 316, 403, 402, 315, 404, 403, 314, 405, 404, 313, 406, 405, 421, 418, 406, 366, 401, 361, 306, 408, 407, 291, 409, 408, 287, 410, 409, 432, 436, 410, 434, 416, 411, 264, 368, 383, 309, 438, 457, 352, 376, 401, 274, 275, 4, 421, 428, 262, 294, 327, 358, 433, 416, 367, 289, 455, 439, 462, 370, 326, 2, 326, 370, 305, 460, 455, 254, 449, 448, 255, 261, 446, 253, 450, 449, 252, 451, 450, 256, 452, 451, 341, 453, 452, 413, 464, 463, 441, 413, 414, 258, 442, 441, 257, 443, 442, 259, 444, 443, 260, 445, 444, 467, 342, 445, 459, 458, 250, 289, 392, 290, 290, 328, 460, 376, 433, 435, 250, 290, 392, 411, 416, 433, 341, 463, 464, 453, 464, 465, 357, 465, 412, 343, 412, 399, 360, 363, 440, 437, 399, 456, 420, 456, 363, 401, 435, 288, 372, 383, 353, 339, 255, 249, 448, 261, 255, 133, 243, 190, 133, 155, 112, 33, 246, 247, 33, 130, 25, 398, 384, 286, 362, 398, 414, 362, 463, 341, 263, 359, 467, 263, 249, 255, 466, 467, 260, 75, 60, 166, 238, 239, 79, 162, 127, 139, 72, 11, 37, 121, 232, 120, 73, 72, 39, 114, 128, 47, 233, 232, 128, 103, 104, 67, 152, 175, 148, 173, 157, 155, 119, 118, 101, 74, 73, 40, 107, 9, 108, 49, 48, 131, 32, 194, 211, 184, 74, 185, 191, 80, 183, 185, 40, 186, 119, 230, 118, 210, 202, 214, 84, 83, 17, 77, 76, 146, 161, 160, 30, 190, 56, 173, 182, 106, 194, 138, 135, 192, 129, 203, 98, 54, 21, 68, 5, 51, 4, 145, 144, 23, 90, 77, 91, 207, 205, 187, 83, 201, 18, 181, 91, 182, 180, 90, 181, 16, 85, 17, 205, 206, 36, 176, 148, 140, 165, 92, 39, 245, 193, 244, 27, 159, 28, 30, 247, 161, 174, 236, 196, 103, 54, 104, 55, 193, 8, 111, 117, 31, 221, 189, 55, 240, 98, 99, 142, 126, 100, 219, 166, 218, 112, 155, 26, 198, 209, 131, 169, 135, 150, 114, 47, 217, 224, 223, 53, 220, 45, 134, 32, 211, 140, 109, 67, 108, 146, 43, 91, 231, 230, 120, 113, 226, 247, 105, 63, 52, 241, 238, 242, 124, 46, 156, 95, 78, 96, 70, 46, 63, 116, 143, 227, 116, 123, 111, 1, 44, 19, 3, 236, 51, 207, 216, 205, 26, 154, 22, 165, 39, 167, 199, 200, 208, 101, 36, 100, 43, 57, 202, 242, 20, 99, 56, 28, 157, 124, 35, 113, 29, 160, 27, 211, 204, 210, 124, 113, 46, 106, 43, 204, 96, 62, 77, 227, 137, 116, 73, 41, 72, 36, 203, 142, 235, 64, 240, 48, 49, 64, 42, 41, 74, 214, 212, 207, 183, 42, 184, 210, 169, 211, 140, 170, 176, 104, 105, 69, 193, 122, 168, 50, 123, 187, 89, 96, 90, 66, 65, 107, 179, 89, 180, 119, 101, 120, 68, 63, 104, 234, 93, 227, 16, 15, 85, 209, 129, 49, 15, 14, 86, 107, 55, 9, 120, 100, 121, 153, 145, 22, 178, 88, 179, 197, 6, 196, 89, 88, 96, 135, 138, 136, 138, 215, 172, 218, 115, 219, 41, 42, 81, 5, 195, 51, 57, 43, 61, 208, 171, 199, 41, 81, 38, 224, 53, 225, 24, 144, 110, 105, 52, 66, 118, 229, 117, 227, 34, 234, 66, 107, 69, 10, 109, 151, 219, 48, 235, 183, 62, 191, 142, 129, 126, 116, 111, 143, 7, 163, 246, 118, 117, 50, 223, 222, 52, 94, 19, 141, 222, 221, 65, 196, 3, 197, 45, 220, 44, 156, 70, 139, 188, 122, 245, 139, 71, 162, 145, 153, 159, 149, 170, 150, 122, 188, 196, 206, 216, 92, 163, 144, 161, 164, 2, 167, 242, 141, 241, 0, 164, 37, 11, 72, 12, 144, 145, 160, 12, 38, 13, 70, 63, 71, 31, 226, 111, 157, 158, 154, 36, 101, 205, 203, 206, 165, 126, 209, 217, 98, 165, 97, 237, 220, 218, 237, 239, 241, 210, 214, 169, 140, 171, 32, 241, 125, 237, 179, 86, 178, 180, 85, 179, 181, 84, 180, 182, 83, 181, 194, 201, 182, 177, 137, 132, 184, 76, 183, 185, 61, 184, 186, 57, 185, 216, 212, 186, 192, 214, 187, 139, 34, 156, 218, 79, 237, 147, 123, 177, 45, 44, 4, 208, 201, 32, 98, 64, 129, 192, 213, 138, 235, 59, 219, 141, 242, 97, 97, 2, 141, 240, 75, 235, 229, 24, 228, 31, 25, 226, 230, 23, 229, 231, 22, 230, 232, 26, 231, 233, 112, 232, 244, 189, 243, 189, 221, 190, 222, 28, 221, 223, 27, 222, 224, 29, 223, 225, 30, 224, 113, 247, 225, 99, 60, 240, 213, 147, 215, 60, 20, 166, 192, 187, 213, 243, 112, 244, 244, 233, 245, 245, 128, 188, 188, 114, 174, 134, 131, 220, 174, 217, 236, 236, 198, 134, 215, 177, 58, 156, 143, 124, 25, 110, 7, 31, 228, 25, 264, 356, 368, 0, 11, 267, 451, 452, 349, 267, 302, 269, 350, 357, 277, 350, 452, 357, 299, 333, 297, 396, 175, 377, 381, 384, 382, 280, 347, 330, 269, 303, 270, 151, 9, 337, 344, 278, 360, 424, 418, 431, 270, 304, 409, 272, 310, 407, 322, 270, 410, 449, 450, 347, 432, 422, 434, 18, 313, 17, 291, 306, 375, 259, 387, 260, 424, 335, 418, 434, 364, 416, 391, 423, 327, 301, 251, 298, 275, 281, 4, 254, 373, 253, 375, 307, 321, 280, 425, 411, 200, 421, 18, 335, 321, 406, 321, 320, 405, 314, 315, 17, 423, 426, 266, 396, 377, 369, 270, 322, 269, 413, 417, 464, 385, 386, 258, 248, 456, 419, 298, 284, 333, 168, 417, 8, 448, 346, 261, 417, 413, 285, 326, 327, 328, 277, 355, 329, 309, 392, 438, 381, 382, 256, 279, 429, 360, 365, 364, 379, 355, 277, 437, 282, 443, 283, 281, 275, 363, 395, 431, 369, 299, 297, 337, 335, 273, 321, 348, 450, 349, 359, 446, 467, 283, 293, 282, 250, 458, 462, 300, 276, 383, 292, 308, 325, 283, 276, 293, 264, 372, 447, 346, 352, 340, 354, 274, 19, 363, 456, 281, 426, 436, 425, 380, 381, 252, 267, 269, 393, 421, 200, 428, 371, 266, 329, 432, 287, 422, 290, 250, 328, 385, 258, 384, 446, 265, 342, 386, 387, 257, 422, 424, 430, 445, 342, 276, 422, 273, 424, 306, 292, 307, 352, 366, 345, 268, 271, 302, 358, 423, 371, 327, 294, 460, 331, 279, 294, 303, 271, 304, 436, 432, 427, 304, 272, 408, 395, 394, 431, 378, 395, 400, 296, 334, 299, 6, 351, 168, 376, 352, 411, 307, 325, 320, 285, 295, 336, 320, 319, 404, 329, 330, 349, 334, 293, 333, 366, 323, 447, 316, 15, 315, 331, 358, 279, 317, 14, 316, 8, 285, 9, 277, 329, 350, 253, 374, 252, 319, 318, 403, 351, 6, 419, 324, 318, 325, 397, 367, 365, 288, 435, 397, 278, 344, 439, 310, 272, 311, 248, 195, 281, 375, 273, 291, 175, 396, 199, 312, 311, 268, 276, 283, 445, 390, 373, 339, 295, 282, 296, 448, 449, 346, 356, 264, 454, 337, 336, 299, 337, 338, 151, 294, 278, 455, 308, 292, 415, 429, 358, 355, 265, 340, 372, 388, 390, 466, 352, 346, 280, 295, 442, 282, 354, 19, 370, 285, 441, 295, 195, 248, 197, 457, 440, 274, 301, 300, 368, 417, 351, 465, 251, 301, 389, 385, 380, 386, 394, 395, 379, 399, 412, 419, 410, 436, 322, 387, 373, 388, 326, 2, 393, 354, 370, 461, 393, 164, 267, 268, 302, 12, 386, 374, 387, 312, 268, 13, 298, 293, 301, 265, 446, 340, 380, 385, 381, 280, 330, 425, 322, 426, 391, 420, 429, 437, 393, 391, 326, 344, 440, 438, 458, 459, 461, 364, 434, 394, 428, 396, 262, 274, 354, 457, 317, 316, 402, 316, 315, 403, 315, 314, 404, 314, 313, 405, 313, 421, 406, 323, 366, 361, 292, 306, 407, 306, 291, 408, 291, 287, 409, 287, 432, 410, 427, 434, 411, 372, 264, 383, 459, 309, 457, 366, 352, 401, 1, 274, 4, 418, 421, 262, 331, 294, 358, 435, 433, 367, 392, 289, 439, 328, 462, 326, 94, 2, 370, 289, 305, 455, 339, 254, 448, 359, 255, 446, 254, 253, 449, 253, 252, 450, 252, 256, 451, 256, 341, 452, 414, 413, 463, 286, 441, 414, 286, 258, 441, 258, 257, 442, 257, 259, 443, 259, 260, 444, 260, 467, 445, 309, 459, 250, 305, 289, 290, 305, 290, 460, 401, 376, 435, 309, 250, 392, 376, 411, 433, 453, 341, 464, 357, 453, 465, 343, 357, 412, 437, 343, 399, 344, 360, 440, 420, 437, 456, 360, 420, 363, 361, 401, 288, 265, 372, 353, 390, 339, 249, 339, 448, 255],
  // My face as default (captured with a 640x480 webcam)
  // prettier-ignore
  SAMPLE_FACE: {
    "keypoints": [{
      "x": 356.2804412841797,
      "y": 295.1960563659668,
      "z": -23.786449432373047,
      "name": "lips"
    }, {
      "x": 354.8859405517578,
      "y": 264.69520568847656,
      "z": -36.718435287475586
    }, {
      "x": 355.2180862426758,
      "y": 275.3360366821289,
      "z": -21.183712482452393
    }, {
      "x": 347.349853515625,
      "y": 242.4400234222412,
      "z": -25.093655586242676
    }, {
      "x": 354.40135955810547,
      "y": 256.67933464050293,
      "z": -38.23572635650635
    }, {
      "x": 353.7689971923828,
      "y": 247.54886627197266,
      "z": -34.5475435256958
    }, {
      "x": 352.1288299560547,
      "y": 227.34312057495117,
      "z": -13.095386028289795
    }, {
      "x": 303.5013198852539,
      "y": 234.67002868652344,
      "z": 12.500141859054565,
      "name": "rightEye"
    }, {
      "x": 351.09378814697266,
      "y": 211.87547206878662,
      "z": -6.413471698760986
    }, {
      "x": 350.7115936279297,
      "y": 202.1251630783081,
      "z": -6.413471698760986
    }, {
      "x": 348.33667755126953,
      "y": 168.7741756439209,
      "z": 6.483500003814697,
      "name": "faceOval"
    }, {
      "x": 356.4806365966797,
      "y": 299.2995357513428,
      "z": -23.144519329071045
    }, {
      "x": 356.5511703491211,
      "y": 302.66146659851074,
      "z": -21.020312309265137
    }, {
      "x": 356.6239547729492,
      "y": 304.1536331176758,
      "z": -18.137459754943848,
      "name": "lips"
    }, {
      "x": 356.5807342529297,
      "y": 305.1840591430664,
      "z": -18.767719268798828,
      "name": "lips"
    }, {
      "x": 356.8241500854492,
      "y": 308.25711250305176,
      "z": -20.16829490661621
    }, {
      "x": 357.113037109375,
      "y": 312.26277351379395,
      "z": -22.10575819015503
    }, {
      "x": 357.34962463378906,
      "y": 317.1123218536377,
      "z": -21.837315559387207,
      "name": "lips"
    }, {
      "x": 357.6658630371094,
      "y": 325.51036834716797,
      "z": -16.27002477645874
    }, {
      "x": 355.0201416015625,
      "y": 269.36279296875,
      "z": -33.73054027557373
    }, {
      "x": 348.5237503051758,
      "y": 270.33411026000977,
      "z": -24.93025302886963
    }, {
      "x": 279.97331619262695,
      "y": 213.24176788330078,
      "z": 47.759642601013184,
      "name": "faceOval"
    }, {
      "x": 322.66529083251953,
      "y": 238.5027265548706,
      "z": 5.535193085670471
    }, {
      "x": 316.0983657836914,
      "y": 239.94489669799805,
      "z": 5.777376294136047
    }, {
      "x": 309.9431610107422,
      "y": 240.24518966674805,
      "z": 7.510589361190796
    }, {
      "x": 301.31994247436523,
      "y": 237.86138534545898,
      "z": 13.118728399276733
    }, {
      "x": 328.14266204833984,
      "y": 235.80496788024902,
      "z": 6.646900177001953
    }, {
      "x": 313.7326431274414,
      "y": 222.11161136627197,
      "z": 3.9887237548828125
    }, {
      "x": 320.45196533203125,
      "y": 221.87729358673096,
      "z": 4.601476192474365
    }, {
      "x": 307.35679626464844,
      "y": 223.63793849945068,
      "z": 5.932023525238037
    }, {
      "x": 303.0031204223633,
      "y": 226.3743782043457,
      "z": 8.479321002960205
    }, {
      "x": 296.80023193359375,
      "y": 242.94299125671387,
      "z": 15.931552648544312
    }, {
      "x": 332.2352981567383,
      "y": 340.77341079711914,
      "z": -10.165848731994629
    }, {
      "x": 301.38587951660156,
      "y": 233.46447944641113,
      "z": 14.764405488967896,
      "name": "rightEye"
    }, {
      "x": 279.0147018432617,
      "y": 244.37155723571777,
      "z": 45.77549457550049
    }, {
      "x": 289.60548400878906,
      "y": 239.1807460784912,
      "z": 23.191204071044922
    }, {
      "x": 320.32257080078125,
      "y": 267.1292781829834,
      "z": -4.954537749290466
    }, {
      "x": 347.64583587646484,
      "y": 294.4955062866211,
      "z": -23.062820434570312,
      "name": "lips"
    }, {
      "x": 349.28138732910156,
      "y": 303.1095886230469,
      "z": -20.238323211669922
    }, {
      "x": 338.9453125,
      "y": 298.19186210632324,
      "z": -19.456336498260498,
      "name": "lips"
    }, {
      "x": 333.36788177490234,
      "y": 302.6706790924072,
      "z": -14.776077270507812,
      "name": "lips"
    }, {
      "x": 342.89188385009766,
      "y": 304.3561363220215,
      "z": -17.752301692962646
    }, {
      "x": 337.7375030517578,
      "y": 306.0098361968994,
      "z": -13.410515785217285
    }, {
      "x": 325.6159210205078,
      "y": 316.22995376586914,
      "z": -6.681914925575256
    }, {
      "x": 349.0104675292969,
      "y": 264.9818515777588,
      "z": -36.274919509887695
    }, {
      "x": 347.7138900756836,
      "y": 257.5664806365967,
      "z": -37.67549514770508
    }, {
      "x": 291.79357528686523,
      "y": 218.88171672821045,
      "z": 11.578094959259033,
      "name": "rightEyebrow"
    }, {
      "x": 332.2689437866211,
      "y": 247.56946563720703,
      "z": -3.3730539679527283
    }, {
      "x": 332.0074462890625,
      "y": 267.1201229095459,
      "z": -19.969879388809204
    }, {
      "x": 331.27952575683594,
      "y": 263.6967658996582,
      "z": -17.47218608856201
    }, {
      "x": 301.04373931884766,
      "y": 269.56552505493164,
      "z": 3.61815482378006
    }, {
      "x": 347.4863815307617,
      "y": 249.0706443786621,
      "z": -32.633421421051025
    }, {
      "x": 307.26118087768555,
      "y": 208.2646894454956,
      "z": 1.1591226607561111,
      "name": "rightEyebrow"
    }, {
      "x": 297.91919708251953,
      "y": 212.22604751586914,
      "z": 5.914516448974609,
      "name": "rightEyebrow"
    }, {
      "x": 285.1651382446289,
      "y": 197.98450469970703,
      "z": 36.391637325286865,
      "name": "faceOval"
    }, {
      "x": 337.04097747802734,
      "y": 211.25229835510254,
      "z": -4.548954665660858
    }, {
      "x": 326.5912628173828,
      "y": 223.16698551177979,
      "z": 6.670243740081787
    }, {
      "x": 320.05664825439453,
      "y": 309.5834255218506,
      "z": -4.055835008621216
    }, {
      "x": 289.6866226196289,
      "y": 314.617395401001,
      "z": 53.875489234924316,
      "name": "faceOval"
    }, {
      "x": 337.4256896972656,
      "y": 270.8755302429199,
      "z": -17.67060160636902
    }, {
      "x": 343.69922637939453,
      "y": 273.0000400543213,
      "z": -18.756048679351807
    }, {
      "x": 327.4242401123047,
      "y": 309.22399520874023,
      "z": -4.703601002693176,
      "name": "lips"
    }, {
      "x": 330.37220001220703,
      "y": 308.3323001861572,
      "z": -6.442649960517883
    }, {
      "x": 293.87027740478516,
      "y": 207.7961826324463,
      "z": 9.821539521217346,
      "name": "rightEyebrow"
    }, {
      "x": 332.11437225341797,
      "y": 271.22812271118164,
      "z": -16.64351224899292
    }, {
      "x": 320.1197814941406,
      "y": 207.40366458892822,
      "z": -2.48164564371109,
      "name": "rightEyebrow"
    }, {
      "x": 318.59575271606445,
      "y": 201.07443809509277,
      "z": -3.110446035861969,
      "name": "rightEyebrow"
    }, {
      "x": 310.72303771972656,
      "y": 175.75075149536133,
      "z": 13.328815698623657,
      "name": "faceOval"
    }, {
      "x": 289.67578887939453,
      "y": 202.29835510253906,
      "z": 21.370456218719482
    }, {
      "x": 315.30879974365234,
      "y": 187.35260009765625,
      "z": 5.0304025411605835
    }, {
      "x": 287.8936767578125,
      "y": 216.54793739318848,
      "z": 17.81065821647644,
      "name": "rightEyebrow"
    }, {
      "x": 283.9391899108887,
      "y": 215.01142501831055,
      "z": 32.04984903335571
    }, {
      "x": 348.35330963134766,
      "y": 299.4155788421631,
      "z": -22.47924566268921
    }, {
      "x": 341.1790466308594,
      "y": 301.8221855163574,
      "z": -18.977805376052856
    }, {
      "x": 335.69713592529297,
      "y": 304.4266891479492,
      "z": -14.682706594467163
    }, {
      "x": 339.4615173339844,
      "y": 272.3654365539551,
      "z": -16.38674020767212
    }, {
      "x": 328.99600982666016,
      "y": 308.86685371398926,
      "z": -5.616893768310547
    }, {
      "x": 332.00313568115234,
      "y": 309.1875743865967,
      "z": -10.335084199905396
    }, {
      "x": 331.0068130493164,
      "y": 307.9274368286133,
      "z": -6.681914925575256,
      "name": "lips"
    }, {
      "x": 341.13792419433594,
      "y": 266.4876937866211,
      "z": -26.56425952911377
    }, {
      "x": 339.02950286865234,
      "y": 305.6663703918457,
      "z": -12.33674168586731,
      "name": "lips"
    }, {
      "x": 344.22935485839844,
      "y": 304.9452781677246,
      "z": -15.161235332489014,
      "name": "lips"
    }, {
      "x": 350.1844024658203,
      "y": 304.374303817749,
      "z": -17.5305438041687,
      "name": "lips"
    }, {
      "x": 348.52630615234375,
      "y": 325.9562301635742,
      "z": -16.164982318878174
    }, {
      "x": 348.6581802368164,
      "y": 317.1624183654785,
      "z": -21.510512828826904,
      "name": "lips"
    }, {
      "x": 348.9766311645508,
      "y": 312.1923065185547,
      "z": -21.708929538726807
    }, {
      "x": 349.2427444458008,
      "y": 308.0660820007324,
      "z": -19.643079042434692
    }, {
      "x": 349.67491149902344,
      "y": 305.42747497558594,
      "z": -18.16080331802368,
      "name": "lips"
    }, {
      "x": 337.95589447021484,
      "y": 306.6535949707031,
      "z": -12.803598642349243,
      "name": "lips"
    }, {
      "x": 337.06878662109375,
      "y": 307.63169288635254,
      "z": -14.274203777313232
    }, {
      "x": 335.77449798583984,
      "y": 309.8449516296387,
      "z": -15.698124170303345
    }, {
      "x": 334.6099090576172,
      "y": 312.7997016906738,
      "z": -14.764405488967896,
      "name": "lips"
    }, {
      "x": 327.2330856323242,
      "y": 293.80866050720215,
      "z": -11.864047050476074
    }, {
      "x": 280.97679138183594,
      "y": 279.79928970336914,
      "z": 68.90834331512451,
      "name": "faceOval"
    }, {
      "x": 355.13843536376953,
      "y": 271.7875671386719,
      "z": -25.350427627563477
    }, {
      "x": 334.7235870361328,
      "y": 307.4656391143799,
      "z": -9.302158951759338,
      "name": "lips"
    }, {
      "x": 333.5293960571289,
      "y": 307.89782524108887,
      "z": -10.200862884521484
    }, {
      "x": 346.29688262939453,
      "y": 276.4256286621094,
      "z": -19.748122692108154
    }, {
      "x": 335.16246795654297,
      "y": 276.22097969055176,
      "z": -12.313398122787476
    }, {
      "x": 345.09132385253906,
      "y": 274.7082996368408,
      "z": -19.304605722427368
    }, {
      "x": 325.4267883300781,
      "y": 252.95130729675293,
      "z": -1.6661019623279572
    }, {
      "x": 315.347843170166,
      "y": 259.05200958251953,
      "z": -0.25604281574487686
    }, {
      "x": 330.44933319091797,
      "y": 267.7570152282715,
      "z": -14.017432928085327
    }, {
      "x": 294.96768951416016,
      "y": 185.26001930236816,
      "z": 23.903164863586426,
      "name": "faceOval"
    }, {
      "x": 299.63531494140625,
      "y": 192.7913761138916,
      "z": 12.640198469161987
    }, {
      "x": 304.5452117919922,
      "y": 202.4142837524414,
      "z": 3.244667649269104,
      "name": "rightEyebrow"
    }, {
      "x": 331.6915512084961,
      "y": 320.0467872619629,
      "z": -10.632705688476562
    }, {
      "x": 334.5911407470703,
      "y": 201.27566814422607,
      "z": -6.133356094360352,
      "name": "rightEyebrow"
    }, {
      "x": 331.4815902709961,
      "y": 185.44180870056152,
      "z": 0.6627205014228821
    }, {
      "x": 328.05816650390625,
      "y": 170.8385467529297,
      "z": 7.358860373497009,
      "name": "faceOval"
    }, {
      "x": 304.49764251708984,
      "y": 239.76297855377197,
      "z": 10.387605428695679
    }, {
      "x": 290.6382179260254,
      "y": 248.85257720947266,
      "z": 19.03616428375244
    }, {
      "x": 331.5682601928711,
      "y": 233.20727348327637,
      "z": 7.837390303611755
    }, {
      "x": 295.5115509033203,
      "y": 228.9834451675415,
      "z": 14.41426157951355
    }, {
      "x": 336.94332122802734,
      "y": 241.8259334564209,
      "z": -5.27842104434967
    }, {
      "x": 336.2792205810547,
      "y": 262.7049922943115,
      "z": -26.12074375152588
    }, {
      "x": 284.4102478027344,
      "y": 255.3262710571289,
      "z": 25.467140674591064
    }, {
      "x": 295.1420593261719,
      "y": 253.02655220031738,
      "z": 12.430112361907959
    }, {
      "x": 303.5196113586426,
      "y": 254.20703887939453,
      "z": 6.139191389083862
    }, {
      "x": 315.73450088500977,
      "y": 251.64799690246582,
      "z": 3.3788898587226868
    }, {
      "x": 324.69661712646484,
      "y": 247.56494522094727,
      "z": 2.3328344523906708
    }, {
      "x": 331.57970428466797,
      "y": 243.02241325378418,
      "z": 1.1423448473215103
    }, {
      "x": 345.6210708618164,
      "y": 229.9976634979248,
      "z": -10.825285911560059
    }, {
      "x": 286.26644134521484,
      "y": 270.37991523742676,
      "z": 21.708929538726807
    }, {
      "x": 290.2525520324707,
      "y": 228.4921360015869,
      "z": 17.71728754043579
    }, {
      "x": 351.65367126464844,
      "y": 269.3400764465332,
      "z": -33.450424671173096
    }, {
      "x": 333.1378936767578,
      "y": 253.88388633728027,
      "z": -7.230473756790161
    }, {
      "x": 277.8318977355957,
      "y": 246.95331573486328,
      "z": 68.20805549621582,
      "name": "faceOval"
    }, {
      "x": 336.6680908203125,
      "y": 238.10003757476807,
      "z": 0.7688578963279724
    }, {
      "x": 329.95800018310547,
      "y": 269.18323516845703,
      "z": -7.207130789756775
    }, {
      "x": 299.17491912841797,
      "y": 234.13324356079102,
      "z": 15.95489501953125
    }, {
      "x": 335.61729431152344,
      "y": 258.71752738952637,
      "z": -23.016133308410645
    }, {
      "x": 284.1079330444336,
      "y": 297.0343494415283,
      "z": 63.25934886932373,
      "name": "faceOval"
    }, {
      "x": 331.44542694091797,
      "y": 230.6892442703247,
      "z": 9.92658257484436,
      "name": "rightEye"
    }, {
      "x": 341.41536712646484,
      "y": 253.01264762878418,
      "z": -29.038610458374023
    }, {
      "x": 303.5472869873047,
      "y": 327.5896739959717,
      "z": 16.725212335586548
    }, {
      "x": 304.7756576538086,
      "y": 337.4389457702637,
      "z": 27.38126277923584,
      "name": "faceOval"
    }, {
      "x": 280.80501556396484,
      "y": 275.32050132751465,
      "z": 45.0752067565918
    }, {
      "x": 295.43582916259766,
      "y": 318.4501647949219,
      "z": 26.2608003616333
    }, {
      "x": 281.4303207397461,
      "y": 228.7355661392212,
      "z": 40.94350814819336
    }, {
      "x": 331.2549591064453,
      "y": 349.4216537475586,
      "z": -7.376367449760437
    }, {
      "x": 352.4247741699219,
      "y": 271.7330074310303,
      "z": -24.953596591949463
    }, {
      "x": 327.5672912597656,
      "y": 260.41900634765625,
      "z": -5.456410646438599
    }, {
      "x": 284.5432472229004,
      "y": 241.7647933959961,
      "z": 29.668869972229004
    }, {
      "x": 310,
      "y": 235.66174507141113,
      "z": 8.502663969993591,
      "name": "rightEye"
    }, {
      "x": 315.7071113586426,
      "y": 235.7572603225708,
      "z": 6.938687562942505,
      "name": "rightEye"
    }, {
      "x": 330.41088104248047,
      "y": 311.04143142700195,
      "z": -9.325502514839172,
      "name": "lips"
    }, {
      "x": 288.5377502441406,
      "y": 285.31983375549316,
      "z": 21.837315559387207
    }, {
      "x": 344.55039978027344,
      "y": 359.4300842285156,
      "z": -6.705257892608643,
      "name": "faceOval"
    }, {
      "x": 323.41880798339844,
      "y": 351.67362213134766,
      "z": 7.802375555038452,
      "name": "faceOval"
    }, {
      "x": 314.64088439941406,
      "y": 346.11894607543945,
      "z": 16.36339783668518,
      "name": "faceOval"
    }, {
      "x": 349.4945526123047,
      "y": 184.8434829711914,
      "z": -0.21847527474164963
    }, {
      "x": 359.24694061279297,
      "y": 359.8348903656006,
      "z": -8.403456211090088,
      "name": "faceOval"
    }, {
      "x": 321.26182556152344,
      "y": 234.64492321014404,
      "z": 6.90950870513916,
      "name": "rightEye"
    }, {
      "x": 326.318359375,
      "y": 232.90250301361084,
      "z": 8.029969334602356,
      "name": "rightEye"
    }, {
      "x": 329.6211624145508,
      "y": 231.6195774078369,
      "z": 9.722331762313843,
      "name": "rightEye"
    }, {
      "x": 285.9398078918457,
      "y": 228.2351303100586,
      "z": 24.650139808654785
    }, {
      "x": 325.79288482666016,
      "y": 227.88007736206055,
      "z": 7.469738721847534,
      "name": "rightEye"
    }, {
      "x": 320.1699447631836,
      "y": 227.5934886932373,
      "z": 6.168370842933655,
      "name": "rightEye"
    }, {
      "x": 314.85408782958984,
      "y": 227.85282611846924,
      "z": 6.2675780057907104,
      "name": "rightEye"
    }, {
      "x": 309.3084907531738,
      "y": 229.1516876220703,
      "z": 7.7031683921813965,
      "name": "rightEye"
    }, {
      "x": 305.5621337890625,
      "y": 230.92366218566895,
      "z": 9.722331762313843,
      "name": "rightEye"
    }, {
      "x": 277.8681945800781,
      "y": 228.5354232788086,
      "z": 59.71122741699219,
      "name": "faceOval"
    }, {
      "x": 306.1444664001465,
      "y": 235.1954698562622,
      "z": 10.603528022766113,
      "name": "rightEye"
    }, {
      "x": 355.4478454589844,
      "y": 281.96210861206055,
      "z": -20.565123558044434
    }, {
      "x": 333.02661895751953,
      "y": 288.0105400085449,
      "z": -14.72939133644104
    }, {
      "x": 337.15728759765625,
      "y": 269.2059516906738,
      "z": -19.8414945602417
    }, {
      "x": 345.9898376464844,
      "y": 283.5453128814697,
      "z": -20.4834246635437
    }, {
      "x": 351.48963928222656,
      "y": 219.98916149139404,
      "z": -7.0378947257995605
    }, {
      "x": 312.39574432373047,
      "y": 336.50628089904785,
      "z": 8.671900033950806
    }, {
      "x": 321.32152557373047,
      "y": 343.1755256652832,
      "z": 0.9067271649837494
    }, {
      "x": 343.78379821777344,
      "y": 353.2975959777832,
      "z": -14.355905055999756
    }, {
      "x": 296.8791389465332,
      "y": 327.91497230529785,
      "z": 41.01353645324707,
      "name": "faceOval"
    }, {
      "x": 329.6939468383789,
      "y": 229.27897453308105,
      "z": 8.934508562088013,
      "name": "rightEye"
    }, {
      "x": 341.6905212402344,
      "y": 241.4073657989502,
      "z": -14.589333534240723
    }, {
      "x": 359.03079986572266,
      "y": 353.48859786987305,
      "z": -15.803166627883911
    }, {
      "x": 333.1861877441406,
      "y": 356.43213272094727,
      "z": -1.0234417766332626,
      "name": "faceOval"
    }, {
      "x": 283.97483825683594,
      "y": 291.4318656921387,
      "z": 41.94725513458252
    }, {
      "x": 343.33770751953125,
      "y": 305.830135345459,
      "z": -15.756480693817139,
      "name": "lips"
    }, {
      "x": 342.40283966064453,
      "y": 307.7453899383545,
      "z": -17.4021577835083
    }, {
      "x": 341.53621673583984,
      "y": 311.0595703125,
      "z": -19.047834873199463
    }, {
      "x": 340.9107208251953,
      "y": 315.4837703704834,
      "z": -18.5576331615448,
      "name": "lips"
    }, {
      "x": 339.1478729248047,
      "y": 323.42233657836914,
      "z": -14.367576837539673
    }, {
      "x": 333.3201599121094,
      "y": 307.4406337738037,
      "z": -9.617288708686829
    }, {
      "x": 331.2411117553711,
      "y": 306.9811820983887,
      "z": -9.669809937477112
    }, {
      "x": 329.23255920410156,
      "y": 306.0508346557617,
      "z": -9.582273960113525,
      "name": "lips"
    }, {
      "x": 322.4586486816406,
      "y": 301.33323669433594,
      "z": -7.720675468444824
    }, {
      "x": 297.1712112426758,
      "y": 286.9552803039551,
      "z": 8.240055441856384
    }, {
      "x": 341.3060760498047,
      "y": 235.4432201385498,
      "z": -7.504753470420837
    }, {
      "x": 336.9318389892578,
      "y": 224.3451976776123,
      "z": 5.829898118972778
    }, {
      "x": 332.65323638916016,
      "y": 226.70403957366943,
      "z": 8.105834126472473
    }, {
      "x": 334.67357635498047,
      "y": 306.4397621154785,
      "z": -8.981193900108337,
      "name": "lips"
    }, {
      "x": 297.4601936340332,
      "y": 306.29210472106934,
      "z": 15.476365089416504
    }, {
      "x": 342.9119110107422,
      "y": 222.37077713012695,
      "z": -2.754466235637665
    }, {
      "x": 335.4629898071289,
      "y": 332.20250129699707,
      "z": -11.823196411132812
    }, {
      "x": 353.2412338256836,
      "y": 240.56339263916016,
      "z": -27.147831916809082
    }, {
      "x": 346.3080596923828,
      "y": 236.41446590423584,
      "z": -18.452589511871338
    }, {
      "x": 352.6475143432617,
      "y": 234.1420555114746,
      "z": -19.748122692108154
    }, {
      "x": 337.3209762573242,
      "y": 253.39937210083008,
      "z": -16.024924516677856
    }, {
      "x": 358.6122131347656,
      "y": 344.90861892700195,
      "z": -18.592647314071655
    }, {
      "x": 358.1117248535156,
      "y": 334.64990615844727,
      "z": -17.49552845954895
    }, {
      "x": 346.4450454711914,
      "y": 335.0321102142334,
      "z": -16.32838249206543
    }, {
      "x": 319.17640686035156,
      "y": 320.2833938598633,
      "z": -3.276764452457428
    }, {
      "x": 325.2540588378906,
      "y": 276.2369728088379,
      "z": -6.460157036781311
    }, {
      "x": 326.7214584350586,
      "y": 327.3939514160156,
      "z": -7.417217493057251
    }, {
      "x": 310.7190132141113,
      "y": 277.2265148162842,
      "z": -3.5452082753181458
    }, {
      "x": 319.78355407714844,
      "y": 284.8238182067871,
      "z": -6.4543211460113525
    }, {
      "x": 305.773983001709,
      "y": 290.83580017089844,
      "z": 0.06907138042151928
    }, {
      "x": 344.4001770019531,
      "y": 344.85408782958984,
      "z": -16.946970224380493
    }, {
      "x": 333.1879425048828,
      "y": 258.74256134033203,
      "z": -11.90489649772644
    }, {
      "x": 313.80598068237305,
      "y": 327.08919525146484,
      "z": 2.2277912497520447
    }, {
      "x": 322.9637908935547,
      "y": 334.6819496154785,
      "z": -3.3643004298210144
    }, {
      "x": 313.4055519104004,
      "y": 311.2166690826416,
      "z": -1.1175429821014404
    }, {
      "x": 291.0865783691406,
      "y": 298.2831001281738,
      "z": 22.467575073242188
    }, {
      "x": 305.6580924987793,
      "y": 313.3707904815674,
      "z": 5.561453700065613
    }, {
      "x": 288.23760986328125,
      "y": 305.9941864013672,
      "z": 36.765122413635254
    }, {
      "x": 315.10692596435547,
      "y": 296.26991271972656,
      "z": -4.604393839836121
    }, {
      "x": 337.50518798828125,
      "y": 247.5944423675537,
      "z": -10.597691535949707
    }, {
      "x": 338.8450622558594,
      "y": 265.47778129577637,
      "z": -27.778091430664062
    }, {
      "x": 334.25254821777344,
      "y": 269.0671920776367,
      "z": -20.938611030578613
    }, {
      "x": 341.64512634277344,
      "y": 259.6387195587158,
      "z": -32.189905643463135
    }, {
      "x": 331.44081115722656,
      "y": 219.0976095199585,
      "z": 4.207563698291779
    }, {
      "x": 320.56339263916016,
      "y": 216.49658203125,
      "z": 2.930997312068939
    }, {
      "x": 311.21912002563477,
      "y": 216.57853603363037,
      "z": 2.9674705862998962
    }, {
      "x": 303.46256256103516,
      "y": 218.54614734649658,
      "z": 5.357203483581543
    }, {
      "x": 297.99999237060547,
      "y": 222.505202293396,
      "z": 9.325502514839172
    }, {
      "x": 294.93839263916016,
      "y": 236.39654159545898,
      "z": 18.534289598464966
    }, {
      "x": 278.87489318847656,
      "y": 259.7095584869385,
      "z": 45.68212032318115
    }, {
      "x": 300.3782653808594,
      "y": 245.38593292236328,
      "z": 12.278382778167725
    }, {
      "x": 307.06348419189453,
      "y": 246.36857986450195,
      "z": 8.164191246032715
    }, {
      "x": 315.5229187011719,
      "y": 245.3949737548828,
      "z": 5.503097176551819
    }, {
      "x": 323.71395111083984,
      "y": 242.75178909301758,
      "z": 4.6335723996162415
    }, {
      "x": 330.2785873413086,
      "y": 239.34658527374268,
      "z": 4.937030673027039
    }, {
      "x": 334.6982192993164,
      "y": 236.0460376739502,
      "z": 4.823233783245087
    }, {
      "x": 279.3412208557129,
      "y": 263.5196113586426,
      "z": 70.91583728790283,
      "name": "faceOval"
    }, {
      "x": 334.65972900390625,
      "y": 271.6648578643799,
      "z": -17.775644063949585
    }, {
      "x": 342.05677032470703,
      "y": 246.99846267700195,
      "z": -20.84523916244507
    }, {
      "x": 344.0357971191406,
      "y": 264.5701503753662,
      "z": -32.936880588531494
    }, {
      "x": 348.25531005859375,
      "y": 268.6645030975342,
      "z": -30.695960521697998
    }, {
      "x": 344.12227630615234,
      "y": 266.34212493896484,
      "z": -29.808926582336426
    }, {
      "x": 337.12318420410156,
      "y": 274.2556858062744,
      "z": -15.768152475357056
    }, {
      "x": 349.49047088623047,
      "y": 269.071683883667,
      "z": -32.51670837402344
    }, {
      "x": 350.1683044433594,
      "y": 271.4691352844238,
      "z": -24.93025302886963
    }, {
      "x": 333.9634704589844,
      "y": 230.56639194488525,
      "z": 8.89949381351471
    }, {
      "x": 338.2147979736328,
      "y": 231.4807891845703,
      "z": 4.6715047955513
    }, {
      "x": 340.4712677001953,
      "y": 231.74463272094727,
      "z": -0.34996166825294495
    }, {
      "x": 303.28975677490234,
      "y": 232.24980354309082,
      "z": 11.916568279266357,
      "name": "rightEye"
    }, {
      "x": 299.4649124145508,
      "y": 229.53842639923096,
      "z": 12.325069904327393
    }, {
      "x": 359.09618377685547,
      "y": 241.77349090576172,
      "z": -24.650139808654785
    }, {
      "x": 399.46216583251953,
      "y": 229.89503860473633,
      "z": 15.919880867004395,
      "name": "leftEye"
    }, {
      "x": 361.38919830322266,
      "y": 269.6129894256592,
      "z": -24.510080814361572
    }, {
      "x": 416.9973373413086,
      "y": 206.0895538330078,
      "z": 53.26857566833496,
      "name": "faceOval"
    }, {
      "x": 381.32179260253906,
      "y": 235.5476474761963,
      "z": 7.6214683055877686
    }, {
      "x": 387.8068542480469,
      "y": 236.25958442687988,
      "z": 8.345099091529846
    }, {
      "x": 393.95751953125,
      "y": 235.8660364151001,
      "z": 10.475142002105713
    }, {
      "x": 401.84600830078125,
      "y": 232.77019500732422,
      "z": 16.760226488113403
    }, {
      "x": 375.70568084716797,
      "y": 233.48456382751465,
      "z": 8.234220147132874
    }, {
      "x": 388.17752838134766,
      "y": 218.94717693328857,
      "z": 6.810300946235657
    }, {
      "x": 381.64928436279297,
      "y": 219.2656660079956,
      "z": 6.711093783378601
    }, {
      "x": 394.4760513305664,
      "y": 219.66821193695068,
      "z": 9.173773527145386
    }, {
      "x": 398.8843536376953,
      "y": 221.8837022781372,
      "z": 12.03328251838684
    }, {
      "x": 406.5454864501953,
      "y": 237.12156772613525,
      "z": 19.7131085395813
    }, {
      "x": 383.87447357177734,
      "y": 337.6932907104492,
      "z": -8.631049990653992
    }, {
      "x": 401.2682342529297,
      "y": 228.5916566848755,
      "z": 18.359217643737793,
      "name": "leftEye"
    }, {
      "x": 422.0449447631836,
      "y": 236.73934936523438,
      "z": 51.16771221160889
    }, {
      "x": 412.69153594970703,
      "y": 232.80198097229004,
      "z": 27.52131938934326
    }, {
      "x": 387.3497772216797,
      "y": 263.298397064209,
      "z": -2.8609684109687805
    }, {
      "x": 364.5124053955078,
      "y": 293.39221000671387,
      "z": -22.397546768188477,
      "name": "lips"
    }, {
      "x": 363.62987518310547,
      "y": 302.1291446685791,
      "z": -19.643079042434692
    }, {
      "x": 373.2334518432617,
      "y": 295.8647060394287,
      "z": -18.125789165496826,
      "name": "lips"
    }, {
      "x": 378.83365631103516,
      "y": 299.5177745819092,
      "z": -13.153743743896484,
      "name": "lips"
    }, {
      "x": 369.91477966308594,
      "y": 302.5704002380371,
      "z": -16.65518283843994
    }, {
      "x": 374.9167251586914,
      "y": 303.5416603088379,
      "z": -11.963253021240234
    }, {
      "x": 387.58888244628906,
      "y": 312.2716999053955,
      "z": -4.680258631706238
    }, {
      "x": 360.6635284423828,
      "y": 264.31986808776855,
      "z": -35.94811677932739
    }, {
      "x": 361.04564666748047,
      "y": 256.8225860595703,
      "z": -37.278664112091064
    }, {
      "x": 408.3855438232422,
      "y": 213.52088928222656,
      "z": 15.756480693817139,
      "name": "leftEyebrow"
    }, {
      "x": 373.2946014404297,
      "y": 245.38101196289062,
      "z": -1.9316278398036957
    }, {
      "x": 376.83860778808594,
      "y": 264.3721103668213,
      "z": -18.510947227478027
    }, {
      "x": 376.9546127319336,
      "y": 261.0010528564453,
      "z": -15.989909172058105
    }, {
      "x": 406.1498260498047,
      "y": 263.5030174255371,
      "z": 7.072908878326416
    }, {
      "x": 360.07205963134766,
      "y": 248.3631706237793,
      "z": -32.16656446456909
    }, {
      "x": 393.11119079589844,
      "y": 205.10473251342773,
      "z": 3.7786373496055603,
      "name": "leftEyebrow"
    }, {
      "x": 402.12791442871094,
      "y": 207.89000988006592,
      "z": 9.383859634399414,
      "name": "leftEyebrow"
    }, {
      "x": 410.8693313598633,
      "y": 191.6182279586792,
      "z": 41.27030849456787,
      "name": "faceOval"
    }, {
      "x": 364.9509811401367,
      "y": 210.40483474731445,
      "z": -3.758212625980377
    }, {
      "x": 375.94444274902344,
      "y": 221.1331844329834,
      "z": 8.368442058563232
    }, {
      "x": 392.1904754638672,
      "y": 305.0360298156738,
      "z": -1.752179116010666
    }, {
      "x": 419.50225830078125,
      "y": 307.25592613220215,
      "z": 58.96425247192383,
      "name": "faceOval"
    }, {
      "x": 372.0027160644531,
      "y": 268.7212657928467,
      "z": -16.631840467453003
    }, {
      "x": 366.1614227294922,
      "y": 271.6237449645996,
      "z": -18.219159841537476
    }, {
      "x": 385.00938415527344,
      "y": 305.3863334655762,
      "z": -2.567722797393799
    }, {
      "x": 381.99771881103516,
      "y": 304.9723720550537,
      "z": -4.575215280056
    }, {
      "x": 405.078125,
      "y": 203.21216583251953,
      "z": 13.713973760604858,
      "name": "leftEyebrow"
    }, {
      "x": 377.13207244873047,
      "y": 268.4710121154785,
      "z": -15.266278982162476
    }, {
      "x": 380.9713363647461,
      "y": 205.36980628967285,
      "z": -0.7250899076461792,
      "name": "leftEyebrow"
    }, {
      "x": 381.7788314819336,
      "y": 198.9268398284912,
      "z": -1.184653863310814,
      "name": "leftEyebrow"
    }, {
      "x": 385.5204772949219,
      "y": 172.1484375,
      "z": 16.04826807975769,
      "name": "faceOval"
    }, {
      "x": 407.94189453125,
      "y": 196.76236152648926,
      "z": 25.723915100097656
    }, {
      "x": 383.03890228271484,
      "y": 184.5157527923584,
      "z": 7.393874526023865
    }, {
      "x": 411.61781311035156,
      "y": 210.79241752624512,
      "z": 22.315845489501953,
      "name": "leftEyebrow"
    }, {
      "x": 414.30870056152344,
      "y": 208.4643030166626,
      "z": 37.021894454956055
    }, {
      "x": 364.28722381591797,
      "y": 298.35777282714844,
      "z": -21.86065673828125
    }, {
      "x": 371.3682556152344,
      "y": 299.78848457336426,
      "z": -17.834001779556274
    }, {
      "x": 376.88201904296875,
      "y": 301.6696071624756,
      "z": -13.153743743896484
    }, {
      "x": 370.2193832397461,
      "y": 270.49095153808594,
      "z": -15.569736957550049
    }, {
      "x": 383.5081100463867,
      "y": 305.2726364135742,
      "z": -3.673594295978546
    }, {
      "x": 380.73760986328125,
      "y": 305.96869468688965,
      "z": -8.660228252410889
    }, {
      "x": 381.2334442138672,
      "y": 304.63574409484863,
      "z": -4.820316135883331,
      "name": "lips"
    }, {
      "x": 368.1698989868164,
      "y": 264.8884963989258,
      "z": -25.653886795043945
    }, {
      "x": 373.5087203979492,
      "y": 303.4233856201172,
      "z": -10.95950722694397,
      "name": "lips"
    }, {
      "x": 368.4544372558594,
      "y": 303.29601287841797,
      "z": -14.169161319732666,
      "name": "lips"
    }, {
      "x": 362.76554107666016,
      "y": 303.5735607147217,
      "z": -16.911956071853638,
      "name": "lips"
    }, {
      "x": 366.60980224609375,
      "y": 324.8870658874512,
      "z": -15.616422891616821
    }, {
      "x": 365.7067108154297,
      "y": 315.95678329467773,
      "z": -20.903596878051758,
      "name": "lips"
    }, {
      "x": 365.0083923339844,
      "y": 311.2232208251953,
      "z": -21.066999435424805
    }, {
      "x": 364.1508102416992,
      "y": 307.0583438873291,
      "z": -18.907777070999146
    }, {
      "x": 363.37512969970703,
      "y": 304.5721435546875,
      "z": -17.42550015449524,
      "name": "lips"
    }, {
      "x": 374.580078125,
      "y": 304.3059539794922,
      "z": -11.40302300453186,
      "name": "lips"
    }, {
      "x": 375.55362701416016,
      "y": 305.0998020172119,
      "z": -12.861957550048828
    }, {
      "x": 377.2437286376953,
      "y": 307.1674346923828,
      "z": -14.215847253799438
    }, {
      "x": 378.68587493896484,
      "y": 309.9015712738037,
      "z": -13.223772048950195,
      "name": "lips"
    }, {
      "x": 383.8992691040039,
      "y": 290.29629707336426,
      "z": -9.97326910495758
    }, {
      "x": 423.3871841430664,
      "y": 271.91688537597656,
      "z": 74.37058925628662,
      "name": "faceOval"
    }, {
      "x": 377.68043518066406,
      "y": 304.62209701538086,
      "z": -7.603961229324341,
      "name": "lips"
    }, {
      "x": 379.00428771972656,
      "y": 304.9314594268799,
      "z": -8.57852816581726
    }, {
      "x": 364.00279998779297,
      "y": 275.2813911437988,
      "z": -19.25792098045349
    }, {
      "x": 374.68231201171875,
      "y": 273.82555961608887,
      "z": -11.28047227859497
    }, {
      "x": 365.0354766845703,
      "y": 273.4548568725586,
      "z": -18.791062831878662
    }, {
      "x": 380.61901092529297,
      "y": 249.8848056793213,
      "z": 0.15501167625188828
    }, {
      "x": 391.14158630371094,
      "y": 254.7934627532959,
      "z": 2.0906515419483185
    }, {
      "x": 378.1761169433594,
      "y": 264.9612236022949,
      "z": -12.605184316635132
    }, {
      "x": 400.9540557861328,
      "y": 179.99592304229736,
      "z": 27.82477855682373,
      "name": "faceOval"
    }, {
      "x": 398.0038833618164,
      "y": 188.50656509399414,
      "z": 16.094952821731567
    }, {
      "x": 394.8717498779297,
      "y": 199.0359592437744,
      "z": 6.226727366447449,
      "name": "leftEyebrow"
    }, {
      "x": 382.10926055908203,
      "y": 316.83926582336426,
      "z": -8.946179747581482
    }, {
      "x": 366.51588439941406,
      "y": 200.32583713531494,
      "z": -5.24632453918457,
      "name": "leftEyebrow"
    }, {
      "x": 367.4893569946289,
      "y": 183.87210845947266,
      "z": 1.9039081037044525
    }, {
      "x": 368.6243438720703,
      "y": 168.8127565383911,
      "z": 8.736093044281006,
      "name": "faceOval"
    }, {
      "x": 398.96175384521484,
      "y": 234.9675178527832,
      "z": 13.713973760604858
    }, {
      "x": 412.9645538330078,
      "y": 242.23042488098145,
      "z": 23.272905349731445
    }, {
      "x": 372.05257415771484,
      "y": 231.41919136047363,
      "z": 9.226294755935669
    }, {
      "x": 406.0722351074219,
      "y": 223.58965873718262,
      "z": 18.370890617370605
    }, {
      "x": 368.27442169189453,
      "y": 240.2039337158203,
      "z": -4.166713654994965
    }, {
      "x": 372.3575210571289,
      "y": 260.66442489624023,
      "z": -24.976940155029297
    }, {
      "x": 419.2244338989258,
      "y": 247.9079246520996,
      "z": 30.299127101898193
    }, {
      "x": 409.43885803222656,
      "y": 246.60913467407227,
      "z": 16.398411989212036
    }, {
      "x": 401.69139862060547,
      "y": 248.76328468322754,
      "z": 9.395531415939331
    }, {
      "x": 389.7608184814453,
      "y": 247.56915092468262,
      "z": 5.841569304466248
    }, {
      "x": 380.5461883544922,
      "y": 244.55984115600586,
      "z": 4.263003468513489
    }, {
      "x": 373.25817108154297,
      "y": 240.80214500427246,
      "z": 2.5356262922286987
    }, {
      "x": 358.77086639404297,
      "y": 229.35615062713623,
      "z": -10.387605428695679
    }, {
      "x": 419.5793914794922,
      "y": 262.8478717803955,
      "z": 26.5175724029541
    }, {
      "x": 410.8808898925781,
      "y": 222.51372814178467,
      "z": 22.199130058288574
    }, {
      "x": 358.45714569091797,
      "y": 268.91467094421387,
      "z": -33.17030906677246
    }, {
      "x": 373.4129333496094,
      "y": 251.6385841369629,
      "z": -5.771540403366089
    }, {
      "x": 422.5408172607422,
      "y": 239.23919677734375,
      "z": 74.04378890991211,
      "name": "faceOval"
    }, {
      "x": 367.8171920776367,
      "y": 236.58040523529053,
      "z": 1.820748895406723
    }, {
      "x": 378.51959228515625,
      "y": 266.2532329559326,
      "z": -5.74819803237915
    }, {
      "x": 403.3472442626953,
      "y": 229.05112266540527,
      "z": 19.689764976501465
    }, {
      "x": 372.34840393066406,
      "y": 256.6451168060303,
      "z": -21.872329711914062
    }, {
      "x": 422.54566192626953,
      "y": 289.1587829589844,
      "z": 68.67491245269775,
      "name": "faceOval"
    }, {
      "x": 371.9297409057617,
      "y": 228.90116214752197,
      "z": 11.432201862335205,
      "name": "leftEye"
    }, {
      "x": 366.21360778808594,
      "y": 251.6158962249756,
      "z": -28.19826364517212
    }, {
      "x": 409.1571807861328,
      "y": 321.3156223297119,
      "z": 20.2266526222229
    }, {
      "x": 408.52943420410156,
      "y": 331.44238471984863,
      "z": 31.09278917312622,
      "name": "faceOval"
    }, {
      "x": 424.2788314819336,
      "y": 267.1992301940918,
      "z": 50.467424392700195
    }, {
      "x": 415.60352325439453,
      "y": 311.6528606414795,
      "z": 30.579242706298828
    }, {
      "x": 418.12793731689453,
      "y": 221.59927368164062,
      "z": 46.26569747924805
    }, {
      "x": 385.68286895751953,
      "y": 346.0184955596924,
      "z": -5.70151150226593
    }, {
      "x": 357.82936096191406,
      "y": 271.3758373260498,
      "z": -24.836881160736084
    }, {
      "x": 379.588623046875,
      "y": 257.5071716308594,
      "z": -3.755294680595398
    }, {
      "x": 417.4592590332031,
      "y": 234.71948146820068,
      "z": 34.5475435256958
    }, {
      "x": 393.4684371948242,
      "y": 231.58967971801758,
      "z": 11.408859491348267,
      "name": "leftEye"
    }, {
      "x": 387.8864288330078,
      "y": 232.14245796203613,
      "z": 9.51808214187622,
      "name": "leftEye"
    }, {
      "x": 382.4981689453125,
      "y": 307.5654888153076,
      "z": -7.522260546684265,
      "name": "lips"
    }, {
      "x": 419.00169372558594,
      "y": 277.8332805633545,
      "z": 26.424202919006348
    }, {
      "x": 373.62953186035156,
      "y": 357.6375102996826,
      "z": -5.75986921787262,
      "name": "faceOval"
    }, {
      "x": 392.8708267211914,
      "y": 347.72446632385254,
      "z": 10.154176950454712,
      "name": "faceOval"
    }, {
      "x": 400.3953552246094,
      "y": 341.0005187988281,
      "z": 19.39797878265381,
      "name": "faceOval"
    }, {
      "x": 382.25440979003906,
      "y": 231.66935920715332,
      "z": 8.998700976371765,
      "name": "leftEye"
    }, {
      "x": 377.14550018310547,
      "y": 230.4228687286377,
      "z": 9.804032444953918,
      "name": "leftEye"
    }, {
      "x": 373.8358688354492,
      "y": 229.64950561523438,
      "z": 11.292144060134888,
      "name": "leftEye"
    }, {
      "x": 414.5794677734375,
      "y": 221.67891025543213,
      "z": 29.412097930908203
    }, {
      "x": 377.00672149658203,
      "y": 225.66201210021973,
      "z": 9.360517263412476,
      "name": "leftEye"
    }, {
      "x": 382.29530334472656,
      "y": 224.8431158065796,
      "z": 8.32175612449646,
      "name": "leftEye"
    }, {
      "x": 387.5133514404297,
      "y": 224.49507236480713,
      "z": 8.917000889778137,
      "name": "leftEye"
    }, {
      "x": 393.15906524658203,
      "y": 225.24795055389404,
      "z": 10.737749338150024,
      "name": "leftEye"
    }, {
      "x": 397.05554962158203,
      "y": 226.55359268188477,
      "z": 13.002015352249146,
      "name": "leftEye"
    }, {
      "x": 420.5299377441406,
      "y": 221.014666557312,
      "z": 65.40690422058105,
      "name": "faceOval"
    }, {
      "x": 397.06920623779297,
      "y": 230.6661558151245,
      "z": 13.807345628738403,
      "name": "leftEye"
    }, {
      "x": 377.94647216796875,
      "y": 285.1647090911865,
      "z": -13.305472135543823
    }, {
      "x": 372.1118927001953,
      "y": 267.1267318725586,
      "z": -18.83774757385254
    }, {
      "x": 364.9968719482422,
      "y": 282.24411964416504,
      "z": -19.818150997161865
    }, {
      "x": 401.973876953125,
      "y": 331.20131492614746,
      "z": 11.566424369812012
    }, {
      "x": 394.3083190917969,
      "y": 338.86693954467773,
      "z": 3.142542541027069
    }, {
      "x": 373.9820861816406,
      "y": 351.4504623413086,
      "z": -13.50388765335083
    }, {
      "x": 414.3888854980469,
      "y": 321.24735832214355,
      "z": 45.51872253417969,
      "name": "faceOval"
    }, {
      "x": 373.44234466552734,
      "y": 227.33163356781006,
      "z": 10.626870393753052,
      "name": "leftEye"
    }, {
      "x": 364.0731430053711,
      "y": 240.31539916992188,
      "z": -13.807345628738403
    }, {
      "x": 384.2658233642578,
      "y": 353.3793067932129,
      "z": 0.7385850697755814,
      "name": "faceOval"
    }, {
      "x": 423.20526123046875,
      "y": 283.5176181793213,
      "z": 47.152724266052246
    }, {
      "x": 369.42798614501953,
      "y": 304.0898895263672,
      "z": -14.647691249847412,
      "name": "lips"
    }, {
      "x": 370.63812255859375,
      "y": 305.90051651000977,
      "z": -16.211668252944946
    }, {
      "x": 371.91192626953125,
      "y": 309.0167713165283,
      "z": -17.84567356109619
    }, {
      "x": 373.0583953857422,
      "y": 313.3545398712158,
      "z": -17.378815412521362,
      "name": "lips"
    }, {
      "x": 375.39905548095703,
      "y": 321.09289169311523,
      "z": -13.118728399276733
    }, {
      "x": 379.2567825317383,
      "y": 304.3582534790039,
      "z": -7.924926280975342
    }, {
      "x": 381.18797302246094,
      "y": 303.7031364440918,
      "z": -7.843226194381714
    }, {
      "x": 383.0918502807617,
      "y": 302.4884605407715,
      "z": -7.6506465673446655,
      "name": "lips"
    }, {
      "x": 389.09461975097656,
      "y": 297.1475315093994,
      "z": -5.5497825145721436
    }, {
      "x": 411.6408920288086,
      "y": 280.24898529052734,
      "z": 12.02161192893982
    }, {
      "x": 363.3110809326172,
      "y": 234.27620887756348,
      "z": -6.775286793708801
    }, {
      "x": 366.0474395751953,
      "y": 223.29872131347656,
      "z": 6.827808618545532
    }, {
      "x": 370.34427642822266,
      "y": 225.1457118988037,
      "z": 9.558931589126587
    }, {
      "x": 377.5371551513672,
      "y": 303.60079765319824,
      "z": -7.358860373497009,
      "name": "lips"
    }, {
      "x": 412.9557800292969,
      "y": 299.53579902648926,
      "z": 19.39797878265381
    }, {
      "x": 360.0810241699219,
      "y": 221.72012329101562,
      "z": -2.153385728597641
    }, {
      "x": 379.82784271240234,
      "y": 329.47723388671875,
      "z": -10.48097848892212
    }, {
      "x": 359.08477783203125,
      "y": 235.7911491394043,
      "z": -18.079102039337158
    }, {
      "x": 369.6688461303711,
      "y": 251.5407943725586,
      "z": -14.962821006774902
    }, {
      "x": 369.5555114746094,
      "y": 333.5307312011719,
      "z": -15.67478060722351
    }, {
      "x": 394.0193176269531,
      "y": 315.6973171234131,
      "z": -0.9920747578144073
    }, {
      "x": 383.78997802734375,
      "y": 272.7268695831299,
      "z": -4.689012169837952
    }, {
      "x": 387.67765045166016,
      "y": 323.6722755432129,
      "z": -5.640236139297485
    }, {
      "x": 397.8769302368164,
      "y": 272.1331214904785,
      "z": -0.9395531564950943
    }, {
      "x": 389.87476348876953,
      "y": 280.5630111694336,
      "z": -4.29218202829361
    }, {
      "x": 403.83888244628906,
      "y": 285.1167869567871,
      "z": 3.0229100584983826
    }, {
      "x": 372.5467300415039,
      "y": 343.1070327758789,
      "z": -16.153310537338257
    }, {
      "x": 374.1112518310547,
      "y": 256.3721466064453,
      "z": -10.574349164962769
    }, {
      "x": 399.73785400390625,
      "y": 321.77515983581543,
      "z": 4.849494695663452
    }, {
      "x": 392.03365325927734,
      "y": 330.56447982788086,
      "z": -1.3407598435878754
    }, {
      "x": 398.59134674072266,
      "y": 305.93902587890625,
      "z": 1.517290621995926
    }, {
      "x": 417.95997619628906,
      "y": 290.9716987609863,
      "z": 26.89105987548828
    }, {
      "x": 406.04541778564453,
      "y": 307.35154151916504,
      "z": 8.666064143180847
    }, {
      "x": 420.75328826904297,
      "y": 298.40752601623535,
      "z": 41.78385257720947
    }, {
      "x": 395.4522705078125,
      "y": 291.4153575897217,
      "z": -2.1752697229385376
    }, {
      "x": 368.6452102661133,
      "y": 245.8882999420166,
      "z": -9.453888535499573
    }, {
      "x": 370.34900665283203,
      "y": 263.56690406799316,
      "z": -26.75100326538086
    }, {
      "x": 374.98477935791016,
      "y": 266.6126346588135,
      "z": -19.77146625518799
    }, {
      "x": 366.99840545654297,
      "y": 258.12140464782715,
      "z": -31.372904777526855
    }, {
      "x": 371.00616455078125,
      "y": 217.63479709625244,
      "z": 5.60522198677063
    }, {
      "x": 381.30577087402344,
      "y": 214.14087295532227,
      "z": 4.983716309070587
    }, {
      "x": 390.1496124267578,
      "y": 213.38221549987793,
      "z": 5.593550801277161
    }, {
      "x": 397.7696990966797,
      "y": 214.3659782409668,
      "z": 8.57852816581726
    }, {
      "x": 403.1652069091797,
      "y": 217.65509605407715,
      "z": 13.013685941696167
    }, {
      "x": 407.3551940917969,
      "y": 230.72525024414062,
      "z": 22.444231510162354
    }, {
      "x": 424.0876770019531,
      "y": 251.7839241027832,
      "z": 51.16771221160889
    }, {
      "x": 403.50196838378906,
      "y": 239.88757610321045,
      "z": 15.803166627883911
    }, {
      "x": 397.31719970703125,
      "y": 241.49806022644043,
      "z": 11.233787536621094
    }, {
      "x": 388.99425506591797,
      "y": 241.4366912841797,
      "z": 7.948269248008728
    }, {
      "x": 380.7804489135742,
      "y": 239.78078842163086,
      "z": 6.600214838981628
    }, {
      "x": 374.01336669921875,
      "y": 237.11946487426758,
      "z": 6.349278092384338
    }, {
      "x": 369.39125061035156,
      "y": 234.35351371765137,
      "z": 5.987462401390076
    }, {
      "x": 422.9730987548828,
      "y": 255.76455116271973,
      "z": 76.61150932312012,
      "name": "faceOval"
    }, {
      "x": 374.73915100097656,
      "y": 269.24214363098145,
      "z": -16.608498096466064
    }, {
      "x": 364.61681365966797,
      "y": 245.71088790893555,
      "z": -20.02823829650879
    }, {
      "x": 365.3834533691406,
      "y": 263.34174156188965,
      "z": -32.32996463775635
    }, {
      "x": 361.58252716064453,
      "y": 267.8273677825928,
      "z": -30.345816612243652
    }, {
      "x": 365.37208557128906,
      "y": 265.0249671936035,
      "z": -29.178667068481445
    }, {
      "x": 372.72605895996094,
      "y": 272.05135345458984,
      "z": -14.834434986114502
    }, {
      "x": 360.48614501953125,
      "y": 268.34827423095703,
      "z": -32.189905643463135
    }, {
      "x": 359.9516296386719,
      "y": 270.8049201965332,
      "z": -24.650139808654785
    }, {
      "x": 369.5049285888672,
      "y": 229.01945114135742,
      "z": 10.107489824295044
    }, {
      "x": 365.5447769165039,
      "y": 230.24096488952637,
      "z": 5.593550801277161
    }, {
      "x": 363.50669860839844,
      "y": 230.6208372116089,
      "z": 0.43622106313705444
    }, {
      "x": 399.3529510498047,
      "y": 227.65677452087402,
      "z": 15.35965085029602,
      "name": "leftEye"
    }, {
      "x": 402.5693130493164,
      "y": 224.60190296173096,
      "z": 15.931552648544312
    }],
    "box": {
      "xMin": 277.8318977355957,
      "yMin": 168.7741756439209,
      "xMax": 424.2788314819336,
      "yMax": 359.8348903656006,
      "width": 146.4469337463379,
      "height": 191.0607147216797
    }
  },
  // Tasks-vision: https://developers.google.com/mediapipe/solutions/vision/face_landmarker/web_js
  // prettier-ignore
  SAMPLE_FACELANDMARKER_RESULT: {
    "faceLandmarks": [[{
      "x": 0.5760777592658997,
      "y": 0.8639070391654968,
      "z": -0.030997956171631813
    }, {
      "x": 0.572094738483429,
      "y": 0.7886289358139038,
      "z": -0.07189624011516571
    }, {
      "x": 0.5723551511764526,
      "y": 0.8075382709503174,
      "z": -0.03578168898820877
    }, {
      "x": 0.5548420548439026,
      "y": 0.7188365459442139,
      "z": -0.057787876576185226
    }, {
      "x": 0.5706077814102173,
      "y": 0.7674974799156189,
      "z": -0.07740399986505508
    }, {
      "x": 0.5681378245353699,
      "y": 0.7387768030166626,
      "z": -0.07356284558773041
    }, {
      "x": 0.5621535181999207,
      "y": 0.6681165099143982,
      "z": -0.04189874976873398
    }, {
      "x": 0.46613582968711853,
      "y": 0.6679812073707581,
      "z": 0.011289681307971478
    }, {
      "x": 0.5579932928085327,
      "y": 0.6174106597900391,
      "z": -0.03502821549773216
    }, {
      "x": 0.5563451647758484,
      "y": 0.5905600190162659,
      "z": -0.03928658738732338
    }, {
      "x": 0.5487832427024841,
      "y": 0.4900572597980499,
      "z": -0.029898937791585922
    }, {
      "x": 0.5765544176101685,
      "y": 0.8692144751548767,
      "z": -0.02831427752971649
    }, {
      "x": 0.5771114230155945,
      "y": 0.873644232749939,
      "z": -0.02345779910683632
    }, {
      "x": 0.5771905779838562,
      "y": 0.877016007900238,
      "z": -0.016658689826726913
    }, {
      "x": 0.5778058767318726,
      "y": 0.8770116567611694,
      "z": -0.014505492523312569
    }, {
      "x": 0.5783766508102417,
      "y": 0.8835000991821289,
      "z": -0.015996402129530907
    }, {
      "x": 0.5792440176010132,
      "y": 0.8913810849189758,
      "z": -0.01924579218029976
    }, {
      "x": 0.5796768069267273,
      "y": 0.8996334671974182,
      "z": -0.018261712044477463
    }, {
      "x": 0.5817288160324097,
      "y": 0.9255813956260681,
      "z": -0.007126849144697189
    }, {
      "x": 0.5726592540740967,
      "y": 0.7992473244667053,
      "z": -0.0643521398305893
    }, {
      "x": 0.5579419136047363,
      "y": 0.7996989488601685,
      "z": -0.04566684365272522
    }, {
      "x": 0.4216199815273285,
      "y": 0.5958762764930725,
      "z": 0.06776496022939682
    }, {
      "x": 0.5052269697189331,
      "y": 0.6796539425849915,
      "z": -0.0010737782577052712
    }, {
      "x": 0.49243026971817017,
      "y": 0.6838865876197815,
      "z": -5227324436418712e-19
    }, {
      "x": 0.4796970784664154,
      "y": 0.6856290102005005,
      "z": 0.002684245817363262
    }, {
      "x": 0.4618356227874756,
      "y": 0.6764569878578186,
      "z": 0.013439622707664967
    }, {
      "x": 0.5160380601882935,
      "y": 0.6737282276153564,
      "z": -17607348127057776e-21
    }, {
      "x": 0.48070961236953735,
      "y": 0.6255870461463928,
      "z": -0.008339674212038517
    }, {
      "x": 0.49719780683517456,
      "y": 0.6256808042526245,
      "z": -0.008027955889701843
    }, {
      "x": 0.46674346923828125,
      "y": 0.6317623853683472,
      "z": -0.004460199736058712
    }, {
      "x": 0.4582492709159851,
      "y": 0.641118049621582,
      "z": 0.0011905613355338573
    }, {
      "x": 0.45408669114112854,
      "y": 0.6911458969116211,
      "z": 0.020514748990535736
    }, {
      "x": 0.535312294960022,
      "y": 0.9619986414909363,
      "z": 0.012499462813138962
    }, {
      "x": 0.4608460068702698,
      "y": 0.6628725528717041,
      "z": 0.01517564244568348
    }, {
      "x": 0.4206731915473938,
      "y": 0.6828458309173584,
      "z": 0.07848648726940155
    }, {
      "x": 0.4390624463558197,
      "y": 0.6796106696128845,
      "z": 0.03283142298460007
    }, {
      "x": 0.5029968619346619,
      "y": 0.7701570391654968,
      "z": -0.009734481573104858
    }, {
      "x": 0.5595027208328247,
      "y": 0.8607323169708252,
      "z": -0.030043255537748337
    }, {
      "x": 0.5621269941329956,
      "y": 0.8738374710083008,
      "z": -0.021709579974412918
    }, {
      "x": 0.5451499819755554,
      "y": 0.865527331829071,
      "z": -0.022014077752828598
    }, {
      "x": 0.5351184010505676,
      "y": 0.8705098032951355,
      "z": -0.011602800339460373
    }, {
      "x": 0.5495014190673828,
      "y": 0.8744956254959106,
      "z": -0.016490943729877472
    }, {
      "x": 0.5395170450210571,
      "y": 0.8759440779685974,
      "z": -0.007333362940698862
    }, {
      "x": 0.5183624029159546,
      "y": 0.8959754705429077,
      "z": 0.010520773939788342
    }, {
      "x": 0.5604349374771118,
      "y": 0.7895449995994568,
      "z": -0.07082037627696991
    }, {
      "x": 0.557381272315979,
      "y": 0.7687489986419678,
      "z": -0.07590588927268982
    }, {
      "x": 0.4432901442050934,
      "y": 0.6308897733688354,
      "z": 0.0027153254486620426
    }, {
      "x": 0.5258325338363647,
      "y": 0.7151225805282593,
      "z": -0.014676518738269806
    }, {
      "x": 0.5271827578544617,
      "y": 0.7833116054534912,
      "z": -0.037643320858478546
    }, {
      "x": 0.5257382988929749,
      "y": 0.7717816233634949,
      "z": -0.03401920944452286
    }, {
      "x": 0.46516409516334534,
      "y": 0.7705106735229492,
      "z": 0.0065747760236263275
    }, {
      "x": 0.5558893084526062,
      "y": 0.7420997619628906,
      "z": -0.0694495290517807
    }, {
      "x": 0.4720408320426941,
      "y": 0.6066038608551025,
      "z": -0.021204356104135513
    }, {
      "x": 0.45432573556900024,
      "y": 0.6158540844917297,
      "z": -0.011054684408009052
    }, {
      "x": 0.4305151402950287,
      "y": 0.5608053803443909,
      "z": 0.0396830290555954
    }, {
      "x": 0.5310865640640259,
      "y": 0.6157484650611877,
      "z": -0.03081176057457924
    }, {
      "x": 0.5114666223526001,
      "y": 0.6329749226570129,
      "z": -0.00335998204536736
    }, {
      "x": 0.506435751914978,
      "y": 0.8786543607711792,
      "z": 0.012980876490473747
    }, {
      "x": 0.4480472207069397,
      "y": 0.8640613555908203,
      "z": 0.12569651007652283
    }, {
      "x": 0.5372058153152466,
      "y": 0.7942581176757812,
      "z": -0.03168361634016037
    }, {
      "x": 0.5488379597663879,
      "y": 0.8001630306243896,
      "z": -0.03280917927622795
    }, {
      "x": 0.5213388204574585,
      "y": 0.8794381618499756,
      "z": 0.011892606504261494
    }, {
      "x": 0.5242055654525757,
      "y": 0.8789222240447998,
      "z": 0.008370225317776203
    }, {
      "x": 0.4477175176143646,
      "y": 0.6039950251579285,
      "z": -0.0050799972377717495
    }, {
      "x": 0.526964008808136,
      "y": 0.7916748523712158,
      "z": -0.02968614175915718
    }, {
      "x": 0.4971255660057068,
      "y": 0.6050706505775452,
      "z": -0.028175678104162216
    }, {
      "x": 0.4938119053840637,
      "y": 0.5882453918457031,
      "z": -0.03210941329598427
    }, {
      "x": 0.4757143557071686,
      "y": 0.5094879865646362,
      "z": -0.01300730835646391
    }, {
      "x": 0.43947282433509827,
      "y": 0.5816648006439209,
      "z": 0.01415177434682846
    }, {
      "x": 0.485664039850235,
      "y": 0.5477864146232605,
      "z": -0.023685332387685776
    }, {
      "x": 0.43635931611061096,
      "y": 0.6226438283920288,
      "z": 0.013606148771941662
    }, {
      "x": 0.42910251021385193,
      "y": 0.6102726459503174,
      "z": 0.03926564007997513
    }, {
      "x": 0.5605402588844299,
      "y": 0.8680099248886108,
      "z": -0.027318159118294716
    }, {
      "x": 0.5474816560745239,
      "y": 0.8702861070632935,
      "z": -0.019686367362737656
    }, {
      "x": 0.5373021364212036,
      "y": 0.8728838562965393,
      "z": -0.010484928265213966
    }, {
      "x": 0.540735125541687,
      "y": 0.7979167103767395,
      "z": -0.029073253273963928
    }, {
      "x": 0.5228585004806519,
      "y": 0.87913578748703,
      "z": 0.009915109723806381
    }, {
      "x": 0.530497670173645,
      "y": 0.8815253973007202,
      "z": 0.0020524784922599792
    }, {
      "x": 0.5259912610054016,
      "y": 0.8790552616119385,
      "z": 0.007895970717072487
    }, {
      "x": 0.5433906316757202,
      "y": 0.7882310748100281,
      "z": -0.05121905356645584
    }, {
      "x": 0.541388213634491,
      "y": 0.8777219653129578,
      "z": -0.00466804439201951
    }, {
      "x": 0.5515822172164917,
      "y": 0.8767023086547852,
      "z": -0.010475946590304375
    }, {
      "x": 0.5637003779411316,
      "y": 0.877059817314148,
      "z": -0.015273625031113625
    }, {
      "x": 0.5640299320220947,
      "y": 0.9263423085212708,
      "z": -0.00658724969252944
    }, {
      "x": 0.5642300248146057,
      "y": 0.8993074893951416,
      "z": -0.017653480172157288
    }, {
      "x": 0.5637336373329163,
      "y": 0.8910360932350159,
      "z": -0.01852807030081749
    }, {
      "x": 0.5637134313583374,
      "y": 0.8837276697158813,
      "z": -0.01482592523097992
    }, {
      "x": 0.564205527305603,
      "y": 0.8768964409828186,
      "z": -0.01331155002117157
    }, {
      "x": 0.5419867634773254,
      "y": 0.8778373599052429,
      "z": -0.0037720394320786
    }, {
      "x": 0.5404468774795532,
      "y": 0.880696177482605,
      "z": -0.005610354244709015
    }, {
      "x": 0.5392338633537292,
      "y": 0.8845721483230591,
      "z": -0.007352025713771582
    }, {
      "x": 0.538469672203064,
      "y": 0.8891173601150513,
      "z": -0.005154991988092661
    }, {
      "x": 0.5189250111579895,
      "y": 0.8452741503715515,
      "z": -0.009755070321261883
    }, {
      "x": 0.4258975088596344,
      "y": 0.7662280797958374,
      "z": 0.1387351155281067
    }, {
      "x": 0.5725725293159485,
      "y": 0.8041572570800781,
      "z": -0.04583907872438431
    }, {
      "x": 0.5342061519622803,
      "y": 0.8785833120346069,
      "z": 0.002659974154084921
    }, {
      "x": 0.5324031114578247,
      "y": 0.8804071545600891,
      "z": 0.0017832003068178892
    }, {
      "x": 0.5538818836212158,
      "y": 0.8078407645225525,
      "z": -0.03254539892077446
    }, {
      "x": 0.5325431823730469,
      "y": 0.8026832938194275,
      "z": -0.019140373915433884
    }, {
      "x": 0.5514076948165894,
      "y": 0.8043903112411499,
      "z": -0.03313535451889038
    }, {
      "x": 0.5131856203079224,
      "y": 0.7284771800041199,
      "z": -0.009399853646755219
    }, {
      "x": 0.49331504106521606,
      "y": 0.7443980574607849,
      "z": -0.005225230939686298
    }, {
      "x": 0.5239617824554443,
      "y": 0.7807451486587524,
      "z": -0.025881027802824974
    }, {
      "x": 0.4473606050014496,
      "y": 0.5315827131271362,
      "z": 0.011164786294102669
    }, {
      "x": 0.45718759298324585,
      "y": 0.5604941248893738,
      "z": -0.005943301599472761
    }, {
      "x": 0.4670005738735199,
      "y": 0.5909327268600464,
      "z": -0.019681761041283607
    }, {
      "x": 0.5311570167541504,
      "y": 0.9076261520385742,
      "z": 0.00389476353302598
    }, {
      "x": 0.5249923467636108,
      "y": 0.5893563628196716,
      "z": -0.037981919944286346
    }, {
      "x": 0.5166932344436646,
      "y": 0.5429551005363464,
      "z": -0.03319704160094261
    }, {
      "x": 0.5085030198097229,
      "y": 0.49676206707954407,
      "z": -0.02691275253891945
    }, {
      "x": 0.4687720239162445,
      "y": 0.6834565997123718,
      "z": 0.008113506250083447
    }, {
      "x": 0.4426414966583252,
      "y": 0.7069531679153442,
      "z": 0.028577271848917007
    }, {
      "x": 0.5230373740196228,
      "y": 0.6675713658332825,
      "z": 0.001773772411979735
    }, {
      "x": 0.4481240212917328,
      "y": 0.6527872085571289,
      "z": 0.012414850294589996
    }, {
      "x": 0.5339856743812561,
      "y": 0.7012367844581604,
      "z": -0.020220188423991203
    }, {
      "x": 0.5347223281860352,
      "y": 0.7761190533638,
      "z": -0.05141595005989075
    }, {
      "x": 0.4315067231655121,
      "y": 0.7211957573890686,
      "z": 0.04381405934691429
    }, {
      "x": 0.45203351974487305,
      "y": 0.7206180095672607,
      "z": 0.017288070172071457
    }, {
      "x": 0.46892452239990234,
      "y": 0.7265436053276062,
      "z": 0.005602988880127668
    }, {
      "x": 0.49314674735069275,
      "y": 0.7202282547950745,
      "z": -6408205372281373e-19
    }, {
      "x": 0.5104925632476807,
      "y": 0.7091827392578125,
      "z": -0.00362918758764863
    }, {
      "x": 0.5232142210006714,
      "y": 0.698553740978241,
      "z": -0.00787867046892643
    }, {
      "x": 0.5497883558273315,
      "y": 0.6743605136871338,
      "z": -0.036349106580019
    }, {
      "x": 0.43658503890037537,
      "y": 0.7627100348472595,
      "z": 0.042555369436740875
    }, {
      "x": 0.4397648870944977,
      "y": 0.6528646349906921,
      "z": 0.017956094816327095
    }, {
      "x": 0.5653332471847534,
      "y": 0.7992802858352661,
      "z": -0.06365057826042175
    }, {
      "x": 0.5285563468933105,
      "y": 0.736810564994812,
      "z": -0.018836988136172295
    }, {
      "x": 0.4180678725242615,
      "y": 0.6792560815811157,
      "z": 0.12284679710865021
    }, {
      "x": 0.5328429937362671,
      "y": 0.6865872144699097,
      "z": -0.010484723374247551
    }, {
      "x": 0.5230283141136169,
      "y": 0.7809416055679321,
      "z": -0.011922398582100868
    }, {
      "x": 0.4551771283149719,
      "y": 0.6650775074958801,
      "z": 0.01774493046104908
    }, {
      "x": 0.5337203741073608,
      "y": 0.7618928551673889,
      "z": -0.04697106033563614
    }, {
      "x": 0.43463975191116333,
      "y": 0.8133478164672852,
      "z": 0.1354849934577942
    }, {
      "x": 0.5225707292556763,
      "y": 0.6605283617973328,
      "z": 0.004980515688657761
    }, {
      "x": 0.5441933870315552,
      "y": 0.7497199773788452,
      "z": -0.06091512367129326
    }, {
      "x": 0.4774007797241211,
      "y": 0.9159183502197266,
      "z": 0.059622734785079956
    }, {
      "x": 0.48068761825561523,
      "y": 0.9364941716194153,
      "z": 0.08404944837093353
    }, {
      "x": 0.4268292486667633,
      "y": 0.7657528519630432,
      "z": 0.09051097184419632
    }, {
      "x": 0.46051913499832153,
      "y": 0.8880485892295837,
      "z": 0.0738474428653717
    }, {
      "x": 0.4243420660495758,
      "y": 0.6434382200241089,
      "z": 0.06230505183339119
    }, {
      "x": 0.5342157483100891,
      "y": 0.9835634231567383,
      "z": 0.021662971004843712
    }, {
      "x": 0.5668109655380249,
      "y": 0.8042187094688416,
      "z": -0.044937074184417725
    }, {
      "x": 0.5176341533660889,
      "y": 0.7530587315559387,
      "z": -0.012967454269528389
    }, {
      "x": 0.430206298828125,
      "y": 0.6835605502128601,
      "z": 0.04612284153699875
    }, {
      "x": 0.4794231951236725,
      "y": 0.6732114553451538,
      "z": 0.003970044665038586
    }, {
      "x": 0.49073347449302673,
      "y": 0.6722435355186462,
      "z": 8692514384165406e-19
    }, {
      "x": 0.5294116139411926,
      "y": 0.884677529335022,
      "z": 0.004413890186697245
    }, {
      "x": 0.4430122375488281,
      "y": 0.80235356092453,
      "z": 0.04987282305955887
    }, {
      "x": 0.5603825449943542,
      "y": 1.0092442035675049,
      "z": 0.026417359709739685
    }, {
      "x": 0.5186598300933838,
      "y": 0.9828659892082214,
      "z": 0.0513598807156086
    }, {
      "x": 0.5010536909103394,
      "y": 0.9640932679176331,
      "z": 0.06591596454381943
    }, {
      "x": 0.5524769425392151,
      "y": 0.539441704750061,
      "z": -0.035816047340631485
    }, {
      "x": 0.5879997611045837,
      "y": 1.0091472864151,
      "z": 0.02285068854689598
    }, {
      "x": 0.5016193985939026,
      "y": 0.6684437990188599,
      "z": 28415941051207483e-20
    }, {
      "x": 0.511952817440033,
      "y": 0.6642197370529175,
      "z": 0.0021144719794392586
    }, {
      "x": 0.5194343328475952,
      "y": 0.6623469591140747,
      "z": 0.004674181342124939
    }, {
      "x": 0.4321230351924896,
      "y": 0.6496355533599854,
      "z": 0.03124697133898735
    }, {
      "x": 0.508686363697052,
      "y": 0.6479565501213074,
      "z": -44765998609364033e-20
    }, {
      "x": 0.4963986277580261,
      "y": 0.6431032419204712,
      "z": -0.0032507688738405704
    }, {
      "x": 0.4845542013645172,
      "y": 0.6430778503417969,
      "z": -0.002903624437749386
    }, {
      "x": 0.4733612537384033,
      "y": 0.647506833076477,
      "z": 23347247042693198e-20
    }, {
      "x": 0.4668654501438141,
      "y": 0.653346598148346,
      "z": 0.004762572236359119
    }, {
      "x": 0.41815051436424255,
      "y": 0.633708119392395,
      "z": 0.09809435904026031
    }, {
      "x": 0.47159942984580994,
      "y": 0.6711485385894775,
      "z": 0.007849935442209244
    }, {
      "x": 0.5734396576881409,
      "y": 0.8256140351295471,
      "z": -0.03155219927430153
    }, {
      "x": 0.5306524038314819,
      "y": 0.8337990641593933,
      "z": -0.018351426348090172
    }, {
      "x": 0.5371729135513306,
      "y": 0.7910830974578857,
      "z": -0.037286680191755295
    }, {
      "x": 0.5549534559249878,
      "y": 0.8275275826454163,
      "z": -0.030664825811982155
    }, {
      "x": 0.5597432255744934,
      "y": 0.6418541669845581,
      "z": -0.03318847343325615
    }, {
      "x": 0.4958484172821045,
      "y": 0.9429569244384766,
      "z": 0.048340678215026855
    }, {
      "x": 0.5140507817268372,
      "y": 0.9634028077125549,
      "z": 0.03589847311377525
    }, {
      "x": 0.5587693452835083,
      "y": 0.9951097369194031,
      "z": 0.00908728688955307
    }, {
      "x": 0.46411189436912537,
      "y": 0.9051855206489563,
      "z": 0.10601935535669327
    }, {
      "x": 0.5181609392166138,
      "y": 0.6554316878318787,
      "z": 0.002546071307733655
    }, {
      "x": 0.5436590909957886,
      "y": 0.7085841298103333,
      "z": -0.03844436630606651
    }, {
      "x": 0.5872187614440918,
      "y": 0.9960382580757141,
      "z": 0.0063423276878893375
    }, {
      "x": 0.5379653573036194,
      "y": 0.9989125728607178,
      "z": 0.03636329993605614
    }, {
      "x": 0.4350326955318451,
      "y": 0.8088565468788147,
      "z": 0.09147704392671585
    }, {
      "x": 0.5523084998130798,
      "y": 0.8773422837257385,
      "z": -0.009068487212061882
    }, {
      "x": 0.5510149598121643,
      "y": 0.8816931843757629,
      "z": -0.011043853126466274
    }, {
      "x": 0.5503793954849243,
      "y": 0.88776695728302,
      "z": -0.01348799467086792
    }, {
      "x": 0.5501549243927002,
      "y": 0.8954370617866516,
      "z": -0.012142189778387547
    }, {
      "x": 0.546072781085968,
      "y": 0.9192524552345276,
      "z": -0.003157563041895628
    }, {
      "x": 0.5314661860466003,
      "y": 0.8771666884422302,
      "z": 5075141089037061e-19
    }, {
      "x": 0.5293324589729309,
      "y": 0.8762547969818115,
      "z": 39177737198770046e-20
    }, {
      "x": 0.5275698900222778,
      "y": 0.8750609755516052,
      "z": 47732755774632096e-21
    }, {
      "x": 0.5104271173477173,
      "y": 0.8607332110404968,
      "z": 0.0012934643309563398
    }, {
      "x": 0.45938700437545776,
      "y": 0.8134918212890625,
      "z": 0.023569690063595772
    }, {
      "x": 0.5418947339057922,
      "y": 0.6864100694656372,
      "z": -0.027333909645676613
    }, {
      "x": 0.531914234161377,
      "y": 0.6456130743026733,
      "z": -0.005434140563011169
    }, {
      "x": 0.523697018623352,
      "y": 0.647885262966156,
      "z": -2466466394253075e-19
    }, {
      "x": 0.5338191390037537,
      "y": 0.8783687353134155,
      "z": 0.002268768846988678
    }, {
      "x": 0.46226605772972107,
      "y": 0.8610277771949768,
      "z": 0.04718952998518944
    }, {
      "x": 0.5434442758560181,
      "y": 0.6456181406974792,
      "z": -0.02327350154519081
    }, {
      "x": 0.5399754643440247,
      "y": 0.940219521522522,
      "z": 0.005075343884527683
    }, {
      "x": 0.5661457777023315,
      "y": 0.71457839012146,
      "z": -0.06242101639509201
    }, {
      "x": 0.5523148775100708,
      "y": 0.6974870562553406,
      "z": -0.04863070324063301
    }, {
      "x": 0.5639959573745728,
      "y": 0.6923378109931946,
      "z": -0.05180761218070984
    }, {
      "x": 0.5367592573165894,
      "y": 0.7423217296600342,
      "z": -0.03623027727007866
    }, {
      "x": 0.5853689908981323,
      "y": 0.9752064943313599,
      "z": -0.002361974213272333
    }, {
      "x": 0.5835235118865967,
      "y": 0.9493685960769653,
      "z": -0.003941743168979883
    }, {
      "x": 0.5615018606185913,
      "y": 0.949194610118866,
      "z": -0.0015953965485095978
    }, {
      "x": 0.5068561434745789,
      "y": 0.9048219323158264,
      "z": 0.01862684078514576
    }, {
      "x": 0.5134067535400391,
      "y": 0.7971825003623962,
      "z": -0.008485661819577217
    }, {
      "x": 0.5223897099494934,
      "y": 0.925589919090271,
      "z": 0.01249657291918993
    }, {
      "x": 0.48500555753707886,
      "y": 0.7959478497505188,
      "z": -0.0032065745908766985
    }, {
      "x": 0.5037734508514404,
      "y": 0.8184596300125122,
      "z": -0.004932103678584099
    }, {
      "x": 0.4766361117362976,
      "y": 0.828806459903717,
      "z": 0.01027688942849636
    }, {
      "x": 0.5589827299118042,
      "y": 0.974656343460083,
      "z": 9666886180639267e-19
    }, {
      "x": 0.5294582843780518,
      "y": 0.7541216611862183,
      "z": -0.025603046640753746
    }, {
      "x": 0.4973002076148987,
      "y": 0.9208990931510925,
      "z": 0.031931452453136444
    }, {
      "x": 0.5163551568984985,
      "y": 0.9432790875434875,
      "z": 0.024321340024471283
    }, {
      "x": 0.49399662017822266,
      "y": 0.8814862370491028,
      "z": 0.018687399104237556
    }, {
      "x": 0.44948166608810425,
      "y": 0.836137592792511,
      "z": 0.05702034756541252
    }, {
      "x": 0.47898444533348083,
      "y": 0.8836610913276672,
      "z": 0.03150695189833641
    }, {
      "x": 0.4454479217529297,
      "y": 0.8499438166618347,
      "z": 0.08868525922298431
    }, {
      "x": 0.49572959542274475,
      "y": 0.8452823758125305,
      "z": 0.0036111653316766024
    }, {
      "x": 0.5362502336502075,
      "y": 0.7222585678100586,
      "z": -0.027912352234125137
    }, {
      "x": 0.5393770337104797,
      "y": 0.7850722074508667,
      "z": -0.05415399745106697
    }, {
      "x": 0.531399667263031,
      "y": 0.7898418307304382,
      "z": -0.03883346915245056
    }, {
      "x": 0.5451627373695374,
      "y": 0.7717036604881287,
      "z": -0.06480253487825394
    }, {
      "x": 0.5206395983695984,
      "y": 0.6287745833396912,
      "z": -0.010521138086915016
    }, {
      "x": 0.4974782466888428,
      "y": 0.6191938519477844,
      "z": -0.014098240062594414
    }, {
      "x": 0.4774145185947418,
      "y": 0.6193130612373352,
      "z": -0.013643337413668633
    }, {
      "x": 0.4616098403930664,
      "y": 0.6259890198707581,
      "z": -0.008448202162981033
    }, {
      "x": 0.4516478478908539,
      "y": 0.6368461847305298,
      "z": 9050309745362028e-20
    }, {
      "x": 0.4485096037387848,
      "y": 0.6719120740890503,
      "z": 0.022984720766544342
    }, {
      "x": 0.42177659273147583,
      "y": 0.7240667343139648,
      "z": 0.08511673659086227
    }, {
      "x": 0.4616215229034424,
      "y": 0.6988231539726257,
      "z": 0.014238474890589714
    }, {
      "x": 0.4755798876285553,
      "y": 0.7034608721733093,
      "z": 0.00625590980052948
    }, {
      "x": 0.4924992024898529,
      "y": 0.7005885243415833,
      "z": 9391739731654525e-19
    }, {
      "x": 0.5082254409790039,
      "y": 0.693384051322937,
      "z": -9464038303121924e-19
    }, {
      "x": 0.5203112959861755,
      "y": 0.6849707961082458,
      "z": -0.0022114769089967012
    }, {
      "x": 0.52867591381073,
      "y": 0.6779075860977173,
      "z": -0.002962538506835699
    }, {
      "x": 0.4213953912258148,
      "y": 0.7219811677932739,
      "z": 0.1350894570350647
    }, {
      "x": 0.5320829749107361,
      "y": 0.794858992099762,
      "z": -0.03181503340601921
    }, {
      "x": 0.5452795028686523,
      "y": 0.7286570072174072,
      "z": -0.04771539941430092
    }, {
      "x": 0.5496407747268677,
      "y": 0.7866933345794678,
      "z": -0.06452003121376038
    }, {
      "x": 0.557040274143219,
      "y": 0.7962084412574768,
      "z": -0.05837344378232956
    }, {
      "x": 0.549176812171936,
      "y": 0.7895247936248779,
      "z": -0.057761140167713165
    }, {
      "x": 0.5362890362739563,
      "y": 0.8005836606025696,
      "z": -0.026903774589300156
    }, {
      "x": 0.560200035572052,
      "y": 0.7983731031417847,
      "z": -0.06172555685043335
    }, {
      "x": 0.5616944432258606,
      "y": 0.8022753596305847,
      "z": -0.045200999826192856
    }, {
      "x": 0.5273328423500061,
      "y": 0.6611284017562866,
      "z": 0.0029021520167589188
    }, {
      "x": 0.534850537776947,
      "y": 0.6660012006759644,
      "z": -0.005215510260313749
    }, {
      "x": 0.5394860506057739,
      "y": 0.6701375246047974,
      "z": -0.014931917190551758
    }, {
      "x": 0.4634307324886322,
      "y": 0.658291757106781,
      "z": 0.009295716881752014
    }, {
      "x": 0.4538393020629883,
      "y": 0.6519932150840759,
      "z": 0.00930330716073513
    }, {
      "x": 0.5776031613349915,
      "y": 0.7159298658370972,
      "z": -0.057365912944078445
    }, {
      "x": 0.6504855155944824,
      "y": 0.6461779475212097,
      "z": 0.014184834435582161
    }, {
      "x": 0.5860154032707214,
      "y": 0.7962266206741333,
      "z": -0.04522843658924103
    }, {
      "x": 0.6842049360275269,
      "y": 0.5631637573242188,
      "z": 0.07207967340946198
    }, {
      "x": 0.6152560710906982,
      "y": 0.6674962639808655,
      "z": 7529259892180562e-19
    }, {
      "x": 0.6280948519706726,
      "y": 0.6684326529502869,
      "z": 0.0016892586136236787
    }, {
      "x": 0.6408625245094299,
      "y": 0.6663892269134521,
      "z": 0.005331226624548435
    }, {
      "x": 0.6557814478874207,
      "y": 0.6534678936004639,
      "z": 0.01646413467824459
    }, {
      "x": 0.6035663485527039,
      "y": 0.6639701724052429,
      "z": 0.0013799630105495453
    }, {
      "x": 0.6329053044319153,
      "y": 0.608010470867157,
      "z": -0.006195899099111557
    }, {
      "x": 0.6167260408401489,
      "y": 0.6117533445358276,
      "z": -0.006319951266050339
    }, {
      "x": 0.6471013426780701,
      "y": 0.6112449765205383,
      "z": -0.0017843559617176652
    }, {
      "x": 0.6560901999473572,
      "y": 0.6185776591300964,
      "z": 0.004047257360070944
    }, {
      "x": 0.6666946411132812,
      "y": 0.6651176810264587,
      "z": 0.023647578433156013
    }, {
      "x": 0.6311345100402832,
      "y": 0.9495396018028259,
      "z": 0.014004078693687916
    }, {
      "x": 0.6544655561447144,
      "y": 0.6397901773452759,
      "z": 0.01809609681367874
    }, {
      "x": 0.6965808868408203,
      "y": 0.6482675075531006,
      "z": 0.08304904401302338
    }, {
      "x": 0.679817259311676,
      "y": 0.650188148021698,
      "z": 0.03632688894867897
    }, {
      "x": 0.6336516737937927,
      "y": 0.7541458010673523,
      "z": -0.007742783520370722
    }, {
      "x": 0.5921701192855835,
      "y": 0.8567668199539185,
      "z": -0.029399123042821884
    }, {
      "x": 0.591663658618927,
      "y": 0.870215654373169,
      "z": -0.02103729173541069
    }, {
      "x": 0.6068367958068848,
      "y": 0.8584195375442505,
      "z": -0.020668085664510727
    }, {
      "x": 0.6176617741584778,
      "y": 0.860965371131897,
      "z": -0.009790095500648022
    }, {
      "x": 0.6040634512901306,
      "y": 0.8686612844467163,
      "z": -0.015289564616978168
    }, {
      "x": 0.6143736839294434,
      "y": 0.8671170473098755,
      "z": -0.005712216719985008
    }, {
      "x": 0.6373105049133301,
      "y": 0.8815656900405884,
      "z": 0.012672550976276398
    }, {
      "x": 0.5832505822181702,
      "y": 0.7866312861442566,
      "z": -0.07051534950733185
    }, {
      "x": 0.5836675763130188,
      "y": 0.7658692598342896,
      "z": -0.07566110789775848
    }, {
      "x": 0.6709531545639038,
      "y": 0.604898989200592,
      "z": 0.005951565690338612
    }, {
      "x": 0.6029891967773438,
      "y": 0.705652117729187,
      "z": -0.013388276100158691
    }, {
      "x": 0.6131622195243835,
      "y": 0.7728396058082581,
      "z": -0.036248479038476944
    }, {
      "x": 0.6123163104057312,
      "y": 0.7612020373344421,
      "z": -0.03264721855521202
    }, {
      "x": 0.6696187853813171,
      "y": 0.744706928730011,
      "z": 0.009673702530562878
    }, {
      "x": 0.5803102254867554,
      "y": 0.7385968565940857,
      "z": -0.0689152330160141
    }, {
      "x": 0.6404349207878113,
      "y": 0.5877999663352966,
      "z": -0.01929756999015808
    }, {
      "x": 0.6588467955589294,
      "y": 0.5929454565048218,
      "z": -0.008487257175147533
    }, {
      "x": 0.6720337867736816,
      "y": 0.530631422996521,
      "z": 0.043437421321868896
    }, {
      "x": 0.584305465221405,
      "y": 0.6099005341529846,
      "z": -0.030301367864012718
    }, {
      "x": 0.6034283638000488,
      "y": 0.6217452883720398,
      "z": -0.001970183802768588
    }, {
      "x": 0.6460927724838257,
      "y": 0.8608663082122803,
      "z": 0.015541625209152699
    }, {
      "x": 0.6957815289497375,
      "y": 0.8326103091239929,
      "z": 0.13015234470367432
    }, {
      "x": 0.6043362617492676,
      "y": 0.7861682772636414,
      "z": -0.030476901680231094
    }, {
      "x": 0.594293475151062,
      "y": 0.7942103147506714,
      "z": -0.032218821346759796
    }, {
      "x": 0.6324057579040527,
      "y": 0.8665139675140381,
      "z": 0.014255806803703308
    }, {
      "x": 0.6296147704124451,
      "y": 0.8667733669281006,
      "z": 0.010388285852968693
    }, {
      "x": 0.663644552230835,
      "y": 0.5798642635345459,
      "z": -0.0022301070857793093
    }, {
      "x": 0.6140630841255188,
      "y": 0.7809288501739502,
      "z": -0.02835679054260254
    }, {
      "x": 0.615908145904541,
      "y": 0.5921698212623596,
      "z": -0.026804860681295395
    }, {
      "x": 0.617181122303009,
      "y": 0.5748661756515503,
      "z": -0.03060605563223362
    }, {
      "x": 0.6222207546234131,
      "y": 0.49137672781944275,
      "z": -0.011151673272252083
    }, {
      "x": 0.6669357419013977,
      "y": 0.5541607141494751,
      "z": 0.017466170713305473
    }, {
      "x": 0.6182981729507446,
      "y": 0.5320425629615784,
      "z": -0.021793590858578682
    }, {
      "x": 0.6760554313659668,
      "y": 0.595052182674408,
      "z": 0.017115700989961624
    }, {
      "x": 0.6801463961601257,
      "y": 0.5800720453262329,
      "z": 0.043127160519361496
    }, {
      "x": 0.5922210812568665,
      "y": 0.8644017577171326,
      "z": -0.02662893570959568
    }, {
      "x": 0.6054555177688599,
      "y": 0.8637874722480774,
      "z": -0.018363753333687782
    }, {
      "x": 0.6161889433860779,
      "y": 0.8641164898872375,
      "z": -0.008808949030935764
    }, {
      "x": 0.6017249822616577,
      "y": 0.7901403307914734,
      "z": -0.028126630932092667
    }, {
      "x": 0.631446123123169,
      "y": 0.8664817810058594,
      "z": 0.012112865224480629
    }, {
      "x": 0.6249198913574219,
      "y": 0.8716511130332947,
      "z": 0.003882825840264559
    }, {
      "x": 0.6281915903091431,
      "y": 0.867301881313324,
      "z": 0.009891441091895103
    }, {
      "x": 0.5986843109130859,
      "y": 0.7813931703567505,
      "z": -0.050227612257003784
    }, {
      "x": 0.6126407384872437,
      "y": 0.869275689125061,
      "z": -0.0031255714129656553
    }, {
      "x": 0.6027271151542664,
      "y": 0.8711842894554138,
      "z": -0.009324162267148495
    }, {
      "x": 0.59088134765625,
      "y": 0.8742044568061829,
      "z": -0.014608660712838173
    }, {
      "x": 0.5984604358673096,
      "y": 0.9216185212135315,
      "z": -0.005981989670544863
    }, {
      "x": 0.5950398445129395,
      "y": 0.8964707255363464,
      "z": -0.01703473925590515
    }, {
      "x": 0.5941568613052368,
      "y": 0.8882410526275635,
      "z": -0.017784785479307175
    }, {
      "x": 0.5928806662559509,
      "y": 0.8803883194923401,
      "z": -0.014153128489851952
    }, {
      "x": 0.5909661054611206,
      "y": 0.8748103976249695,
      "z": -0.012609979137778282
    }, {
      "x": 0.6128016710281372,
      "y": 0.8702545762062073,
      "z": -0.0022550546564161777
    }, {
      "x": 0.6150846481323242,
      "y": 0.8726804256439209,
      "z": -0.00414019962772727
    }, {
      "x": 0.6173093914985657,
      "y": 0.8770190477371216,
      "z": -0.005970994010567665
    }, {
      "x": 0.619335412979126,
      "y": 0.8814800977706909,
      "z": -0.0036864024586975574
    }, {
      "x": 0.6292637586593628,
      "y": 0.8314558267593384,
      "z": -0.007714875973761082
    }, {
      "x": 0.702275276184082,
      "y": 0.7320667505264282,
      "z": 0.1433621346950531
    }, {
      "x": 0.6204835176467896,
      "y": 0.8689177632331848,
      "z": 0.0044869170524179935
    }, {
      "x": 0.6223508715629578,
      "y": 0.8704851269721985,
      "z": 0.00352082890458405
    }, {
      "x": 0.590448260307312,
      "y": 0.8029727935791016,
      "z": -0.03200828656554222
    }, {
      "x": 0.6097423434257507,
      "y": 0.7933741211891174,
      "z": -0.018042555078864098
    }, {
      "x": 0.59229576587677,
      "y": 0.7993767261505127,
      "z": -0.032564569264650345
    }, {
      "x": 0.6171364188194275,
      "y": 0.7153720259666443,
      "z": -0.007672437466681004
    }, {
      "x": 0.6389747858047485,
      "y": 0.726390540599823,
      "z": -0.002999067772179842
    }, {
      "x": 0.6151940226554871,
      "y": 0.769412100315094,
      "z": -0.024427521973848343
    }, {
      "x": 0.6526776552200317,
      "y": 0.505868136882782,
      "z": 0.01412637997418642
    }, {
      "x": 0.6475822329521179,
      "y": 0.5375454425811768,
      "z": -0.0033899128902703524
    }, {
      "x": 0.6433356404304504,
      "y": 0.5714520215988159,
      "z": -0.017428796738386154
    }, {
      "x": 0.626949667930603,
      "y": 0.8962116837501526,
      "z": 0.005602736957371235
    }, {
      "x": 0.5868416428565979,
      "y": 0.5829002261161804,
      "z": -0.03727729618549347
    }, {
      "x": 0.5877229571342468,
      "y": 0.5345035791397095,
      "z": -0.032396964728832245
    }, {
      "x": 0.5887066125869751,
      "y": 0.48655083775520325,
      "z": -0.025856535881757736
    }, {
      "x": 0.6507197618484497,
      "y": 0.6612282991409302,
      "z": 0.011114613153040409
    }, {
      "x": 0.6803066730499268,
      "y": 0.677992045879364,
      "z": 0.032125361263751984
    }, {
      "x": 0.5963194370269775,
      "y": 0.6598632335662842,
      "z": 0.002976928371936083
    }, {
      "x": 0.667536199092865,
      "y": 0.6274255514144897,
      "z": 0.015618261881172657
    }, {
      "x": 0.5930740833282471,
      "y": 0.6940041780471802,
      "z": -0.019217798486351967
    }, {
      "x": 0.6053346395492554,
      "y": 0.7676517963409424,
      "z": -0.050308309495449066
    }, {
      "x": 0.6934473514556885,
      "y": 0.6884298920631409,
      "z": 0.04794462397694588
    }, {
      "x": 0.6738007664680481,
      "y": 0.6934011578559875,
      "z": 0.020697161555290222
    }, {
      "x": 0.6588084697723389,
      "y": 0.7033141851425171,
      "z": 0.008462334051728249
    }, {
      "x": 0.6346072554588318,
      "y": 0.7029502391815186,
      "z": 0.001542167621664703
    }, {
      "x": 0.6157816648483276,
      "y": 0.6966525912284851,
      "z": -0.002009218093007803
    }, {
      "x": 0.6015574336051941,
      "y": 0.688928484916687,
      "z": -0.006588225718587637
    }, {
      "x": 0.5746836066246033,
      "y": 0.6711069345474243,
      "z": -0.03597589209675789
    }, {
      "x": 0.6947521567344666,
      "y": 0.7309479117393494,
      "z": 0.046707939356565475
    }, {
      "x": 0.6759101152420044,
      "y": 0.6249120831489563,
      "z": 0.021654341369867325
    }, {
      "x": 0.5794773101806641,
      "y": 0.7971615195274353,
      "z": -0.06339326500892639
    }, {
      "x": 0.6041849851608276,
      "y": 0.727514922618866,
      "z": -0.017512541264295578
    }, {
      "x": 0.6968844532966614,
      "y": 0.6440950036048889,
      "z": 0.12727996706962585
    }, {
      "x": 0.5910853147506714,
      "y": 0.679325520992279,
      "z": -0.009497715160250664
    }, {
      "x": 0.6157375574111938,
      "y": 0.7695677280426025,
      "z": -0.010624290443956852
    }, {
      "x": 0.6606494784355164,
      "y": 0.6410489678382874,
      "z": 0.0208158977329731
    }, {
      "x": 0.6040687561035156,
      "y": 0.7531470656394958,
      "z": -0.045887019485235214
    }, {
      "x": 0.7012156248092651,
      "y": 0.780247151851654,
      "z": 0.14028730988502502
    }, {
      "x": 0.595149576663971,
      "y": 0.6527782678604126,
      "z": 0.006308757700026035
    }, {
      "x": 0.5925500392913818,
      "y": 0.7436665892601013,
      "z": -0.060151755809783936
    }, {
      "x": 0.6780198812484741,
      "y": 0.8905693888664246,
      "z": 0.0626060739159584
    }, {
      "x": 0.676746666431427,
      "y": 0.9113880395889282,
      "z": 0.08726003766059875
    }, {
      "x": 0.7030686140060425,
      "y": 0.7312687635421753,
      "z": 0.09529774636030197
    }, {
      "x": 0.688987135887146,
      "y": 0.8588417172431946,
      "z": 0.07752864807844162
    }, {
      "x": 0.6883691549301147,
      "y": 0.6109960675239563,
      "z": 0.06669612973928452
    }, {
      "x": 0.6358906030654907,
      "y": 0.9702065587043762,
      "z": 0.023120900616049767
    }, {
      "x": 0.5781539678573608,
      "y": 0.8023634552955627,
      "z": -0.044763918966054916
    }, {
      "x": 0.6170316934585571,
      "y": 0.7408350706100464,
      "z": -0.011375460773706436
    }, {
      "x": 0.688542366027832,
      "y": 0.6516284346580505,
      "z": 0.050206027925014496
    }, {
      "x": 0.6385149359703064,
      "y": 0.6540714502334595,
      "z": 0.006462941411882639
    }, {
      "x": 0.6279382109642029,
      "y": 0.6563615798950195,
      "z": 0.003062846139073372
    }, {
      "x": 0.6268895268440247,
      "y": 0.8736732006072998,
      "z": 0.00627936702221632
    }, {
      "x": 0.6944946050643921,
      "y": 0.7709181308746338,
      "z": 0.053824134171009064
    }, {
      "x": 0.614617109298706,
      "y": 1.0022112131118774,
      "z": 0.02719894051551819
    }, {
      "x": 0.6493719220161438,
      "y": 0.9665167927742004,
      "z": 0.053563784807920456
    }, {
      "x": 0.6624587178230286,
      "y": 0.943530797958374,
      "z": 0.068605437874794
    }, {
      "x": 0.6162528991699219,
      "y": 0.6558693051338196,
      "z": 0.002187855076044798
    }, {
      "x": 0.6058168411254883,
      "y": 0.654328465461731,
      "z": 0.0036193584091961384
    }, {
      "x": 0.5987918972969055,
      "y": 0.6536934971809387,
      "z": 0.006134530063718557
    }, {
      "x": 0.6831037402153015,
      "y": 0.6195642948150635,
      "z": 0.03511790186166763
    }, {
      "x": 0.6062582731246948,
      "y": 0.6356398463249207,
      "z": 0.001280312892049551
    }, {
      "x": 0.6174948811531067,
      "y": 0.62776118516922,
      "z": -0.0013642468256875873
    }, {
      "x": 0.6297246217727661,
      "y": 0.6253792643547058,
      "z": -7034156005829573e-19
    }, {
      "x": 0.6407091617584229,
      "y": 0.627578616142273,
      "z": 0.0028144705574959517
    }, {
      "x": 0.6479622721672058,
      "y": 0.6322650909423828,
      "z": 0.00750273372977972
    }, {
      "x": 0.6915091276168823,
      "y": 0.5990704298019409,
      "z": 0.10270945727825165
    }, {
      "x": 0.6457163095474243,
      "y": 0.6504453420639038,
      "z": 0.010696077719330788
    }, {
      "x": 0.6164222955703735,
      "y": 0.8231936097145081,
      "z": -0.016772059723734856
    }, {
      "x": 0.6042401194572449,
      "y": 0.7830976843833923,
      "z": -0.03630910441279411
    }, {
      "x": 0.5922216773033142,
      "y": 0.8228387236595154,
      "z": -0.029992375522851944
    }, {
      "x": 0.6646111011505127,
      "y": 0.92097008228302,
      "z": 0.050967294722795486
    }, {
      "x": 0.651232898235321,
      "y": 0.9460107088088989,
      "z": 0.038000158965587616
    }, {
      "x": 0.6140977144241333,
      "y": 0.9882472157478333,
      "z": 0.009882091544568539
    }, {
      "x": 0.6870781183242798,
      "y": 0.8768675327301025,
      "z": 0.10980932414531708
    }, {
      "x": 0.5986856818199158,
      "y": 0.6456438899040222,
      "z": 0.003999010659754276
    }, {
      "x": 0.585981547832489,
      "y": 0.7034481763839722,
      "z": -0.0377722829580307
    }, {
      "x": 0.6342031359672546,
      "y": 0.9867448806762695,
      "z": 0.03786521404981613
    }, {
      "x": 0.7013950943946838,
      "y": 0.776049017906189,
      "z": 0.09598205983638763
    }, {
      "x": 0.6030206680297852,
      "y": 0.8719133138656616,
      "z": -0.007931148633360863
    }, {
      "x": 0.6050592064857483,
      "y": 0.8767156004905701,
      "z": -0.009791925549507141
    }, {
      "x": 0.6073468923568726,
      "y": 0.8831382393836975,
      "z": -0.012361008673906326
    }, {
      "x": 0.6087977290153503,
      "y": 0.890143632888794,
      "z": -0.01098148338496685
    }, {
      "x": 0.6147705316543579,
      "y": 0.9110084772109985,
      "z": -0.0018823575228452682
    }, {
      "x": 0.622577965259552,
      "y": 0.8670604825019836,
      "z": 0.002609190298244357
    }, {
      "x": 0.6241236329078674,
      "y": 0.8651344180107117,
      "z": 0.0025534380692988634
    }, {
      "x": 0.6257084608078003,
      "y": 0.8638408184051514,
      "z": 0.0023300074972212315
    }, {
      "x": 0.639931321144104,
      "y": 0.8449671268463135,
      "z": 0.0038123116828501225
    }, {
      "x": 0.6810906529426575,
      "y": 0.7856625318527222,
      "z": 0.02717764675617218
    }, {
      "x": 0.583532452583313,
      "y": 0.6811994910240173,
      "z": -0.026588857173919678
    }, {
      "x": 0.5855660438537598,
      "y": 0.6393819451332092,
      "z": -0.004512844607234001
    }, {
      "x": 0.5932201743125916,
      "y": 0.6398029327392578,
      "z": 8020466193556786e-19
    }, {
      "x": 0.6200879812240601,
      "y": 0.8683351874351501,
      "z": 0.00417016725987196
    }, {
      "x": 0.6842559576034546,
      "y": 0.8330534100532532,
      "z": 0.050836317241191864
    }, {
      "x": 0.5754412412643433,
      "y": 0.6418221592903137,
      "z": -0.022838059812784195
    }, {
      "x": 0.6232790350914001,
      "y": 0.9295297265052795,
      "z": 0.006339520215988159
    }, {
      "x": 0.5764067769050598,
      "y": 0.694546639919281,
      "z": -0.04825803264975548
    }, {
      "x": 0.59778892993927,
      "y": 0.7343927621841431,
      "z": -0.035004377365112305
    }, {
      "x": 0.6042810678482056,
      "y": 0.9441440105438232,
      "z": -0.0010970570147037506
    }, {
      "x": 0.6496372222900391,
      "y": 0.8869078159332275,
      "z": 0.021036235615611076
    }, {
      "x": 0.6274012327194214,
      "y": 0.7830310463905334,
      "z": -0.006658440921455622
    }, {
      "x": 0.637792706489563,
      "y": 0.9104999899864197,
      "z": 0.014290250837802887
    }, {
      "x": 0.6549934148788452,
      "y": 0.7748609185218811,
      "z": -6672973395325243e-19
    }, {
      "x": 0.6404005289077759,
      "y": 0.801220715045929,
      "z": -0.0026642554439604282
    }, {
      "x": 0.6671456694602966,
      "y": 0.8045546412467957,
      "z": 0.013180811889469624
    }, {
      "x": 0.6107483506202698,
      "y": 0.9680658578872681,
      "z": 0.001778992242179811
    }, {
      "x": 0.6060343980789185,
      "y": 0.744587242603302,
      "z": -0.024382334202528
    }, {
      "x": 0.6602751612663269,
      "y": 0.8998945355415344,
      "z": 0.0344940721988678
    }, {
      "x": 0.6463775038719177,
      "y": 0.9262562394142151,
      "z": 0.02617623284459114
    }, {
      "x": 0.6579852104187012,
      "y": 0.8602304458618164,
      "z": 0.021586716175079346
    }, {
      "x": 0.6926165223121643,
      "y": 0.8053340315818787,
      "z": 0.061075080186128616
    }, {
      "x": 0.6724731922149658,
      "y": 0.8594399690628052,
      "z": 0.03457934781908989
    }, {
      "x": 0.6975721716880798,
      "y": 0.8183245062828064,
      "z": 0.09300774335861206
    }, {
      "x": 0.6512877941131592,
      "y": 0.8258221745491028,
      "z": 0.006324059329926968
    }, {
      "x": 0.594887375831604,
      "y": 0.7148372530937195,
      "z": -0.026898479089140892
    }, {
      "x": 0.6017440557479858,
      "y": 0.7773507833480835,
      "z": -0.05312420800328255
    }, {
      "x": 0.6096571683883667,
      "y": 0.7806998491287231,
      "z": -0.037646256387233734
    }, {
      "x": 0.5952993035316467,
      "y": 0.7654367685317993,
      "z": -0.06398405134677887
    }, {
      "x": 0.5950021147727966,
      "y": 0.6201304793357849,
      "z": -0.009297547861933708
    }, {
      "x": 0.6165438890457153,
      "y": 0.6052900552749634,
      "z": -0.012455573305487633
    }, {
      "x": 0.6362661719322205,
      "y": 0.6015968918800354,
      "z": -0.011649220250546932
    }, {
      "x": 0.6522727608680725,
      "y": 0.6046400666236877,
      "z": -0.005903332494199276
    }, {
      "x": 0.6625409722328186,
      "y": 0.6128141283988953,
      "z": 0.0030042496509850025
    }, {
      "x": 0.6688099503517151,
      "y": 0.6457712054252625,
      "z": 0.026322703808546066
    }, {
      "x": 0.7013440728187561,
      "y": 0.6893666386604309,
      "z": 0.08984331786632538
    }, {
      "x": 0.6608623266220093,
      "y": 0.6749406456947327,
      "z": 0.0172116681933403
    }, {
      "x": 0.6482325196266174,
      "y": 0.6823726296424866,
      "z": 0.008881398476660252
    }, {
      "x": 0.6313265562057495,
      "y": 0.6842025518417358,
      "z": 0.0031308617908507586
    }, {
      "x": 0.6147016286849976,
      "y": 0.6809731721878052,
      "z": 7630771724507213e-19
    }, {
      "x": 0.6018834114074707,
      "y": 0.6755372285842896,
      "z": -8834321051836014e-19
    }, {
      "x": 0.5925027132034302,
      "y": 0.670681357383728,
      "z": -0.001968748401850462
    }, {
      "x": 0.700127363204956,
      "y": 0.6871103644371033,
      "z": 0.13980500400066376
    }, {
      "x": 0.6095665693283081,
      "y": 0.7853189706802368,
      "z": -0.03074747882783413
    }, {
      "x": 0.5880423784255981,
      "y": 0.7229287028312683,
      "z": -0.04691500961780548
    }, {
      "x": 0.5930182337760925,
      "y": 0.7811514139175415,
      "z": -0.06398335844278336
    }, {
      "x": 0.5867722034454346,
      "y": 0.7922660112380981,
      "z": -0.05794971063733101
    }, {
      "x": 0.5933279991149902,
      "y": 0.7842848896980286,
      "z": -0.05714067071676254
    }, {
      "x": 0.6063535809516907,
      "y": 0.7920218706130981,
      "z": -0.02590685710310936
    }, {
      "x": 0.5839452743530273,
      "y": 0.794978141784668,
      "z": -0.0615212507545948
    }, {
      "x": 0.5828126072883606,
      "y": 0.8000800013542175,
      "z": -0.0449722595512867
    }, {
      "x": 0.5909603834152222,
      "y": 0.6541213393211365,
      "z": 0.003991890233010054
    }, {
      "x": 0.5852181911468506,
      "y": 0.6602938771247864,
      "z": -0.004428438376635313
    }, {
      "x": 0.5825737714767456,
      "y": 0.6651063561439514,
      "z": -0.014345290139317513
    }, {
      "x": 0.6517343521118164,
      "y": 0.6362385153770447,
      "z": 0.012151890434324741
    }, {
      "x": 0.6615052819252014,
      "y": 0.6281577944755554,
      "z": 0.0123682152479887
    }, {
      "x": 0.4856873154640198,
      "y": 0.6568945646286011,
      "z": 720038078725338e-18
    }, {
      "x": 0.49988406896591187,
      "y": 0.6547410488128662,
      "z": 6949726957827806e-19
    }, {
      "x": 0.48438939452171326,
      "y": 0.6392973065376282,
      "z": 705525919329375e-18
    }, {
      "x": 0.47143134474754333,
      "y": 0.6589511632919312,
      "z": 6980331381782889e-19
    }, {
      "x": 0.48704618215560913,
      "y": 0.6752797961235046,
      "z": 6921177846379578e-19
    }, {
      "x": 0.6243702173233032,
      "y": 0.640461802482605,
      "z": -6592126737814397e-20
    }, {
      "x": 0.6390967965126038,
      "y": 0.6385173797607422,
      "z": -16105435497593135e-20
    }, {
      "x": 0.6230536699295044,
      "y": 0.6224825382232666,
      "z": -16136496560648084e-20
    }, {
      "x": 0.6095397472381592,
      "y": 0.641917884349823,
      "z": -1803556369850412e-19
    }, {
      "x": 0.6250996589660645,
      "y": 0.6586247682571411,
      "z": -1785515050869435e-19
    }]],
    "faceBlendshapes": [{
      "categories": [{
        "index": 0,
        "score": 5187174338061595e-21,
        "categoryName": "_neutral",
        "displayName": ""
      }, {
        "index": 1,
        "score": 0.24521504342556,
        "categoryName": "browDownLeft",
        "displayName": ""
      }, {
        "index": 2,
        "score": 0.1987743377685547,
        "categoryName": "browDownRight",
        "displayName": ""
      }, {
        "index": 3,
        "score": 0.013400448486208916,
        "categoryName": "browInnerUp",
        "displayName": ""
      }, {
        "index": 4,
        "score": 0.012361560948193073,
        "categoryName": "browOuterUpLeft",
        "displayName": ""
      }, {
        "index": 5,
        "score": 0.019305096939206123,
        "categoryName": "browOuterUpRight",
        "displayName": ""
      }, {
        "index": 6,
        "score": 28426356948330067e-21,
        "categoryName": "cheekPuff",
        "displayName": ""
      }, {
        "index": 7,
        "score": 34500112633395474e-23,
        "categoryName": "cheekSquintLeft",
        "displayName": ""
      }, {
        "index": 8,
        "score": 483789051486383e-21,
        "categoryName": "cheekSquintRight",
        "displayName": ""
      }, {
        "index": 9,
        "score": 0.07650448381900787,
        "categoryName": "eyeBlinkLeft",
        "displayName": ""
      }, {
        "index": 10,
        "score": 0.05070012807846069,
        "categoryName": "eyeBlinkRight",
        "displayName": ""
      }, {
        "index": 11,
        "score": 0.13978900015354156,
        "categoryName": "eyeLookDownLeft",
        "displayName": ""
      }, {
        "index": 12,
        "score": 0.14198613166809082,
        "categoryName": "eyeLookDownRight",
        "displayName": ""
      }, {
        "index": 13,
        "score": 0.2177766114473343,
        "categoryName": "eyeLookInLeft",
        "displayName": ""
      }, {
        "index": 14,
        "score": 0.014739357866346836,
        "categoryName": "eyeLookInRight",
        "displayName": ""
      }, {
        "index": 15,
        "score": 0.02361512929201126,
        "categoryName": "eyeLookOutLeft",
        "displayName": ""
      }, {
        "index": 16,
        "score": 0.19679604470729828,
        "categoryName": "eyeLookOutRight",
        "displayName": ""
      }, {
        "index": 17,
        "score": 0.04874616861343384,
        "categoryName": "eyeLookUpLeft",
        "displayName": ""
      }, {
        "index": 18,
        "score": 0.049392376095056534,
        "categoryName": "eyeLookUpRight",
        "displayName": ""
      }, {
        "index": 19,
        "score": 0.34944331645965576,
        "categoryName": "eyeSquintLeft",
        "displayName": ""
      }, {
        "index": 20,
        "score": 0.2939716875553131,
        "categoryName": "eyeSquintRight",
        "displayName": ""
      }, {
        "index": 21,
        "score": 0.005955042317509651,
        "categoryName": "eyeWideLeft",
        "displayName": ""
      }, {
        "index": 22,
        "score": 0.006776117719709873,
        "categoryName": "eyeWideRight",
        "displayName": ""
      }, {
        "index": 23,
        "score": 16942436559475027e-21,
        "categoryName": "jawForward",
        "displayName": ""
      }, {
        "index": 24,
        "score": 0.0045165494084358215,
        "categoryName": "jawLeft",
        "displayName": ""
      }, {
        "index": 25,
        "score": 0.07803940027952194,
        "categoryName": "jawOpen",
        "displayName": ""
      }, {
        "index": 26,
        "score": 2090057751047425e-20,
        "categoryName": "jawRight",
        "displayName": ""
      }, {
        "index": 27,
        "score": 0.06032035872340202,
        "categoryName": "mouthClose",
        "displayName": ""
      }, {
        "index": 28,
        "score": 0.00228882092051208,
        "categoryName": "mouthDimpleLeft",
        "displayName": ""
      }, {
        "index": 29,
        "score": 0.00781762320548296,
        "categoryName": "mouthDimpleRight",
        "displayName": ""
      }, {
        "index": 30,
        "score": 0.0017093931091949344,
        "categoryName": "mouthFrownLeft",
        "displayName": ""
      }, {
        "index": 31,
        "score": 0.0019319106359034777,
        "categoryName": "mouthFrownRight",
        "displayName": ""
      }, {
        "index": 32,
        "score": 8485237776767462e-20,
        "categoryName": "mouthFunnel",
        "displayName": ""
      }, {
        "index": 33,
        "score": 9051355300471187e-19,
        "categoryName": "mouthLeft",
        "displayName": ""
      }, {
        "index": 34,
        "score": 3630454302765429e-19,
        "categoryName": "mouthLowerDownLeft",
        "displayName": ""
      }, {
        "index": 35,
        "score": 17601238505449146e-20,
        "categoryName": "mouthLowerDownRight",
        "displayName": ""
      }, {
        "index": 36,
        "score": 0.12865161895751953,
        "categoryName": "mouthPressLeft",
        "displayName": ""
      }, {
        "index": 37,
        "score": 0.20137207210063934,
        "categoryName": "mouthPressRight",
        "displayName": ""
      }, {
        "index": 38,
        "score": 0.0022203284315764904,
        "categoryName": "mouthPucker",
        "displayName": ""
      }, {
        "index": 39,
        "score": 9096377179957926e-19,
        "categoryName": "mouthRight",
        "displayName": ""
      }, {
        "index": 40,
        "score": 0.34189721941947937,
        "categoryName": "mouthRollLower",
        "displayName": ""
      }, {
        "index": 41,
        "score": 0.11409689486026764,
        "categoryName": "mouthRollUpper",
        "displayName": ""
      }, {
        "index": 42,
        "score": 0.17172536253929138,
        "categoryName": "mouthShrugLower",
        "displayName": ""
      }, {
        "index": 43,
        "score": 0.004038424696773291,
        "categoryName": "mouthShrugUpper",
        "displayName": ""
      }, {
        "index": 44,
        "score": 23205230536404997e-20,
        "categoryName": "mouthSmileLeft",
        "displayName": ""
      }, {
        "index": 45,
        "score": 19313619122840464e-20,
        "categoryName": "mouthSmileRight",
        "displayName": ""
      }, {
        "index": 46,
        "score": 0.0018571305554360151,
        "categoryName": "mouthStretchLeft",
        "displayName": ""
      }, {
        "index": 47,
        "score": 0.0023813238367438316,
        "categoryName": "mouthStretchRight",
        "displayName": ""
      }, {
        "index": 48,
        "score": 24323100660694763e-21,
        "categoryName": "mouthUpperUpLeft",
        "displayName": ""
      }, {
        "index": 49,
        "score": 3161552012898028e-20,
        "categoryName": "mouthUpperUpRight",
        "displayName": ""
      }, {
        "index": 50,
        "score": 108198406678639e-21,
        "categoryName": "noseSneerLeft",
        "displayName": ""
      }, {
        "index": 51,
        "score": 12652527630052646e-22,
        "categoryName": "noseSneerRight",
        "displayName": ""
      }],
      "headIndex": -1,
      "headName": ""
    }],
    "facialTransformationMatrixes": [{
      "rows": 4,
      "columns": 4,
      "data": [0.9947517514228821, 0.10230544209480286, 0.0013679931871592999, 0, -0.10230997204780579, 0.9947447776794434, 0.003816320328041911, 0, -970348424743861e-18, -0.0039362297393381596, 0.9999914169311523, 0, 2.8888821601867676, -7.808934211730957, -30.52109146118164, 1]
    }]
  }
};

// node_modules/@react-three/drei/core/FaceLandmarker.js
var React50 = __toESM(require_react());
var import_react13 = __toESM(require_react());

// node_modules/@mediapipe/tasks-vision/vision_bundle.mjs
var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
var vision = {};
var fileset_resolver = {};
var supportsSimd;
Object.defineProperty(fileset_resolver, "__esModule", { value: true }), fileset_resolver.FilesetResolver = void 0;
var WASM_SIMD_CHECK = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
async function isSimdSupported() {
  if (void 0 === supportsSimd)
    try {
      await WebAssembly.instantiate(WASM_SIMD_CHECK), supportsSimd = true;
    } catch (e2) {
      supportsSimd = false;
    }
  return supportsSimd;
}
async function createFileset(e2, t2 = "") {
  const r2 = await isSimdSupported() ? "wasm_internal" : "wasm_nosimd_internal";
  return { wasmLoaderPath: `${t2}/${e2}_${r2}.js`, wasmBinaryPath: `${t2}/${e2}_${r2}.wasm` };
}
var FilesetResolver$1 = class {
  static isSimdSupported() {
    return isSimdSupported();
  }
  static forAudioTasks(e2) {
    return createFileset("audio", e2);
  }
  static forTextTasks(e2) {
    return createFileset("text", e2);
  }
  static forVisionTasks(e2) {
    return createFileset("vision", e2);
  }
};
fileset_resolver.FilesetResolver = FilesetResolver$1;
var drawing_utils = {};
Object.defineProperty(drawing_utils, "__esModule", { value: true }), drawing_utils.DrawingUtils = void 0;
var DEFAULT_OPTIONS = { color: "white", lineWidth: 4, radius: 6 };
function addDefaultOptions(e2) {
  return e2 = e2 || {}, Object.assign(Object.assign(Object.assign({}, DEFAULT_OPTIONS), { fillColor: e2.color }), e2);
}
function resolve(e2, t2) {
  return e2 instanceof Function ? e2(t2) : e2;
}
var DrawingUtils$1 = class _DrawingUtils$1 {
  constructor(e2) {
    this.ctx = e2;
  }
  static clamp(e2, t2, r2) {
    const o2 = Math.min(t2, r2), i3 = Math.max(t2, r2);
    return Math.max(o2, Math.min(i3, e2));
  }
  static lerp(e2, t2, r2, o2, i3) {
    const a3 = o2 * (1 - (e2 - t2) / (r2 - t2)) + i3 * (1 - (r2 - e2) / (r2 - t2));
    return _DrawingUtils$1.clamp(a3, o2, i3);
  }
  drawLandmarks(e2, t2) {
    if (!e2)
      return;
    const r2 = this.ctx, o2 = addDefaultOptions(t2);
    r2.save();
    const i3 = r2.canvas;
    let a3 = 0;
    for (const t3 of e2) {
      r2.fillStyle = resolve(o2.fillColor, { index: a3, from: t3 }), r2.strokeStyle = resolve(o2.color, { index: a3, from: t3 }), r2.lineWidth = resolve(o2.lineWidth, { index: a3, from: t3 });
      const e3 = new Path2D();
      e3.arc(t3.x * i3.width, t3.y * i3.height, resolve(o2.radius, { index: a3, from: t3 }), 0, 2 * Math.PI), r2.fill(e3), r2.stroke(e3), ++a3;
    }
    r2.restore();
  }
  drawConnectors(e2, t2, r2) {
    if (!e2 || !t2)
      return;
    const o2 = this.ctx, i3 = addDefaultOptions(r2);
    o2.save();
    const a3 = o2.canvas;
    let n2 = 0;
    for (const r3 of t2) {
      o2.beginPath();
      const t3 = e2[r3.start], s2 = e2[r3.end];
      t3 && s2 && (o2.strokeStyle = resolve(i3.color, { index: n2, from: t3, to: s2 }), o2.lineWidth = resolve(i3.lineWidth, { index: n2, from: t3, to: s2 }), o2.moveTo(t3.x * a3.width, t3.y * a3.height), o2.lineTo(s2.x * a3.width, s2.y * a3.height)), ++n2, o2.stroke();
    }
    o2.restore();
  }
  drawBoundingBox(e2, t2) {
    const r2 = this.ctx, o2 = addDefaultOptions(t2);
    r2.save(), r2.beginPath(), r2.lineWidth = resolve(o2.lineWidth, {}), r2.strokeStyle = resolve(o2.color, {}), r2.fillStyle = resolve(o2.fillColor, {}), r2.moveTo(e2.originX, e2.originY), r2.lineTo(e2.originX + e2.width, e2.originY), r2.lineTo(e2.originX + e2.width, e2.originY + e2.height), r2.lineTo(e2.originX, e2.originY + e2.height), r2.lineTo(e2.originX, e2.originY), r2.stroke(), r2.fill(), r2.restore();
  }
};
drawing_utils.DrawingUtils = DrawingUtils$1;
var image = {};
var image_shader_context = {};
Object.defineProperty(image_shader_context, "__esModule", { value: true }), image_shader_context.MPImageShaderContext = image_shader_context.assertNotNull = void 0;
var VERTEX_SHADER = "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }";
var FRAGMENT_SHADER = "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D inputTexture;\n   void main() {\n     gl_FragColor = texture2D(inputTexture, vTex);\n   }\n ";
function assertNotNull(e2, t2) {
  if (null === e2)
    throw new Error(`Unable to obtain required WebGL resource: ${t2}`);
  return e2;
}
image_shader_context.assertNotNull = assertNotNull;
var MPImageShaderBuffers = class {
  constructor(e2, t2, r2, o2) {
    this.gl = e2, this.vertexArrayObject = t2, this.vertexBuffer = r2, this.textureBuffer = o2;
  }
  bind() {
    this.gl.bindVertexArray(this.vertexArrayObject);
  }
  unbind() {
    this.gl.bindVertexArray(null);
  }
  close() {
    this.gl.deleteVertexArray(this.vertexArrayObject), this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.textureBuffer);
  }
};
var MPImageShaderContext = class {
  compileShader(e2, t2) {
    const r2 = this.gl, o2 = assertNotNull(r2.createShader(t2), "Failed to create WebGL shader");
    if (r2.shaderSource(o2, e2), r2.compileShader(o2), !r2.getShaderParameter(o2, r2.COMPILE_STATUS)) {
      const e3 = r2.getShaderInfoLog(o2);
      throw new Error(`Could not compile WebGL shader: ${e3}`);
    }
    return r2.attachShader(this.program, o2), o2;
  }
  setupShaders() {
    const e2 = this.gl;
    this.program = assertNotNull(e2.createProgram(), "Failed to create WebGL program"), this.vertexShader = this.compileShader(VERTEX_SHADER, e2.VERTEX_SHADER), this.fragmentShader = this.compileShader(FRAGMENT_SHADER, e2.FRAGMENT_SHADER), e2.linkProgram(this.program);
    if (!e2.getProgramParameter(this.program, e2.LINK_STATUS)) {
      const t2 = e2.getProgramInfoLog(this.program);
      throw new Error(`Error during program linking: ${t2}`);
    }
    this.aVertex = e2.getAttribLocation(this.program, "aVertex"), this.aTex = e2.getAttribLocation(this.program, "aTex");
  }
  createBuffers(e2) {
    const t2 = this.gl, r2 = assertNotNull(t2.createVertexArray(), "Failed to create vertex array");
    t2.bindVertexArray(r2);
    const o2 = assertNotNull(t2.createBuffer(), "Failed to create buffer");
    t2.bindBuffer(t2.ARRAY_BUFFER, o2), t2.enableVertexAttribArray(this.aVertex), t2.vertexAttribPointer(this.aVertex, 2, t2.FLOAT, false, 0, 0), t2.bufferData(t2.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), t2.STATIC_DRAW);
    const i3 = assertNotNull(t2.createBuffer(), "Failed to create buffer");
    t2.bindBuffer(t2.ARRAY_BUFFER, i3), t2.enableVertexAttribArray(this.aTex), t2.vertexAttribPointer(this.aTex, 2, t2.FLOAT, false, 0, 0);
    const a3 = e2 ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0];
    return t2.bufferData(t2.ARRAY_BUFFER, new Float32Array(a3), t2.STATIC_DRAW), t2.bindBuffer(t2.ARRAY_BUFFER, null), t2.bindVertexArray(null), new MPImageShaderBuffers(t2, r2, o2, i3);
  }
  getShaderBuffers(e2) {
    return e2 ? (this.shaderBuffersFlipVertically || (this.shaderBuffersFlipVertically = this.createBuffers(true)), this.shaderBuffersFlipVertically) : (this.shaderBuffersPassthrough || (this.shaderBuffersPassthrough = this.createBuffers(false)), this.shaderBuffersPassthrough);
  }
  maybeInitGL(e2) {
    if (this.gl) {
      if (e2 !== this.gl)
        throw new Error("Cannot change GL context once initialized");
    } else
      this.gl = e2;
  }
  run(e2, t2, r2) {
    this.maybeInitGL(e2), this.program || this.setupShaders();
    const o2 = this.getShaderBuffers(t2);
    e2.useProgram(this.program), o2.bind();
    const i3 = r2();
    return o2.unbind(), i3;
  }
  bindFramebuffer(e2, t2) {
    this.maybeInitGL(e2), this.framebuffer || (this.framebuffer = assertNotNull(e2.createFramebuffer(), "Failed to create framebuffe.")), e2.bindFramebuffer(e2.FRAMEBUFFER, this.framebuffer), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0);
  }
  unbindFramebuffer() {
    var e2;
    null === (e2 = this.gl) || void 0 === e2 || e2.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  }
  close() {
    if (this.program) {
      const e2 = this.gl;
      e2.deleteProgram(this.program), e2.deleteShader(this.vertexShader), e2.deleteShader(this.fragmentShader);
    }
    this.framebuffer && this.gl.deleteFramebuffer(this.framebuffer), this.shaderBuffersPassthrough && this.shaderBuffersPassthrough.close(), this.shaderBuffersFlipVertically && this.shaderBuffersFlipVertically.close();
  }
};
image_shader_context.MPImageShaderContext = MPImageShaderContext, Object.defineProperty(image, "__esModule", { value: true }), image.MPImage = void 0;
var image_shader_context_1$2 = image_shader_context;
var INSTANCE_COUNT_WARNING_THRESHOLD$1 = 250;
var MPImageType;
!function(e2) {
  e2[e2.IMAGE_DATA = 0] = "IMAGE_DATA", e2[e2.IMAGE_BITMAP = 1] = "IMAGE_BITMAP", e2[e2.WEBGL_TEXTURE = 2] = "WEBGL_TEXTURE";
}(MPImageType || (MPImageType = {}));
var MPImage$1 = class _MPImage$1 {
  constructor(e2, t2, r2, o2, i3, a3, n2) {
    this.containers = e2, this.ownsImageBitmap = t2, this.ownsWebGLTexture = r2, this.canvas = o2, this.shaderContext = i3, this.width = a3, this.height = n2, (this.ownsImageBitmap || this.ownsWebGLTexture) && (--_MPImage$1.instancesBeforeWarning, 0 === _MPImage$1.instancesBeforeWarning && console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources."));
  }
  hasImageData() {
    return !!this.getContainer(MPImageType.IMAGE_DATA);
  }
  hasImageBitmap() {
    return !!this.getContainer(MPImageType.IMAGE_BITMAP);
  }
  hasWebGLTexture() {
    return !!this.getContainer(MPImageType.WEBGL_TEXTURE);
  }
  getAsImageData() {
    return this.convertToImageData();
  }
  getAsImageBitmap() {
    return this.convertToImageBitmap();
  }
  getAsWebGLTexture() {
    return this.convertToWebGLTexture();
  }
  getContainer(e2) {
    switch (e2) {
      case MPImageType.IMAGE_DATA:
        return this.containers.find((e3) => e3 instanceof ImageData);
      case MPImageType.IMAGE_BITMAP:
        return this.containers.find((e3) => "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap);
      case MPImageType.WEBGL_TEXTURE:
        return this.containers.find((e3) => "undefined" != typeof WebGLTexture && e3 instanceof WebGLTexture);
      default:
        throw new Error(`Type is not supported: ${e2}`);
    }
  }
  clone() {
    const e2 = [];
    for (const t2 of this.containers) {
      let r2;
      if (t2 instanceof ImageData)
        r2 = new ImageData(t2.data, this.width, this.height);
      else if (t2 instanceof WebGLTexture) {
        const e3 = this.getGL(), t3 = this.getShaderContext();
        e3.activeTexture(e3.TEXTURE1), r2 = (0, image_shader_context_1$2.assertNotNull)(e3.createTexture(), "Failed to create texture"), e3.bindTexture(e3.TEXTURE_2D, r2), this.configureTextureParams(), e3.texImage2D(e3.TEXTURE_2D, 0, e3.RGBA, this.width, this.height, 0, e3.RGBA, e3.UNSIGNED_BYTE, null), e3.bindTexture(e3.TEXTURE_2D, null), t3.bindFramebuffer(e3, r2), t3.run(e3, false, () => {
          this.bindTexture(), e3.clearColor(0, 0, 0, 0), e3.clear(e3.COLOR_BUFFER_BIT), e3.drawArrays(e3.TRIANGLE_FAN, 0, 4), this.unbindTexture();
        }), t3.unbindFramebuffer(), this.unbindTexture();
      } else {
        if (!(t2 instanceof ImageBitmap))
          throw new Error(`Type is not supported: ${t2}`);
        this.convertToWebGLTexture(), this.bindTexture(), r2 = this.copyTextureToBitmap(), this.unbindTexture();
      }
      e2.push(r2);
    }
    return new _MPImage$1(e2, this.hasImageBitmap(), this.hasWebGLTexture(), this.canvas, this.shaderContext, this.width, this.height);
  }
  getOffscreenCanvas() {
    if (!(this.canvas instanceof OffscreenCanvas))
      throw new Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
    return this.canvas;
  }
  getGL() {
    if (!this.canvas)
      throw new Error("Conversion to different image formats require that a canvas is passed when iniitializing the image.");
    return this.gl || (this.gl = (0, image_shader_context_1$2.assertNotNull)(this.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), this.gl;
  }
  getShaderContext() {
    return this.shaderContext || (this.shaderContext = new image_shader_context_1$2.MPImageShaderContext()), this.shaderContext;
  }
  convertToImageBitmap() {
    let e2 = this.getContainer(MPImageType.IMAGE_BITMAP);
    return e2 || (this.convertToWebGLTexture(), e2 = this.convertWebGLTextureToImageBitmap(), this.containers.push(e2), this.ownsImageBitmap = true), e2;
  }
  convertToImageData() {
    let e2 = this.getContainer(MPImageType.IMAGE_DATA);
    if (!e2) {
      const t2 = this.getGL(), r2 = this.getShaderContext(), o2 = new Uint8Array(this.width * this.height * 4), i3 = this.convertToWebGLTexture();
      r2.bindFramebuffer(t2, i3), t2.readPixels(0, 0, this.width, this.height, t2.RGBA, t2.UNSIGNED_BYTE, o2), r2.unbindFramebuffer(), e2 = new ImageData(new Uint8ClampedArray(o2.buffer), this.width, this.height), this.containers.push(e2);
    }
    return e2;
  }
  convertToWebGLTexture() {
    let e2 = this.getContainer(MPImageType.WEBGL_TEXTURE);
    if (!e2) {
      const t2 = this.getGL();
      e2 = this.bindTexture();
      const r2 = this.getContainer(MPImageType.IMAGE_BITMAP) || this.convertToImageData();
      t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, r2), this.unbindTexture();
    }
    return e2;
  }
  configureTextureParams() {
    const e2 = this.getGL();
    e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR);
  }
  bindTexture() {
    const e2 = this.getGL();
    e2.viewport(0, 0, this.width, this.height), e2.activeTexture(e2.TEXTURE0);
    let t2 = this.getContainer(MPImageType.WEBGL_TEXTURE);
    return t2 ? e2.bindTexture(e2.TEXTURE_2D, t2) : (t2 = (0, image_shader_context_1$2.assertNotNull)(e2.createTexture(), "Failed to create texture"), this.containers.push(t2), this.ownsWebGLTexture = true, e2.bindTexture(e2.TEXTURE_2D, t2), this.configureTextureParams()), t2;
  }
  unbindTexture() {
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
  }
  copyTextureToBitmap() {
    const e2 = this.getGL();
    return this.getShaderContext().run(e2, true, () => this.runWithResizedCanvas(() => (e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.clearColor(0, 0, 0, 0), e2.clear(e2.COLOR_BUFFER_BIT), e2.drawArrays(e2.TRIANGLE_FAN, 0, 4), this.getOffscreenCanvas().transferToImageBitmap())));
  }
  convertWebGLTextureToImageBitmap() {
    this.bindTexture();
    const e2 = this.copyTextureToBitmap();
    return this.unbindTexture(), e2;
  }
  runWithResizedCanvas(e2) {
    const t2 = this.canvas;
    if (t2.width === this.width && t2.height === this.height)
      return e2();
    const r2 = t2.width, o2 = t2.height;
    t2.width = this.width, t2.height = this.height;
    const i3 = e2();
    return t2.width = r2, t2.height = o2, i3;
  }
  close() {
    if (this.ownsImageBitmap && this.getContainer(MPImageType.IMAGE_BITMAP).close(), this.ownsWebGLTexture) {
      this.getGL().deleteTexture(this.getContainer(MPImageType.WEBGL_TEXTURE));
    }
    _MPImage$1.instancesBeforeWarning = -1;
  }
};
image.MPImage = MPImage$1, MPImage$1.instancesBeforeWarning = INSTANCE_COUNT_WARNING_THRESHOLD$1;
var mask = {};
var platform_utils = {};
function isWebKit(e2 = navigator) {
  const t2 = e2.userAgent;
  return t2.includes("Safari") && !t2.includes("Chrome");
}
function isIOS() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
Object.defineProperty(platform_utils, "__esModule", { value: true }), platform_utils.isIOS = platform_utils.isWebKit = void 0, platform_utils.isWebKit = isWebKit, platform_utils.isIOS = isIOS, Object.defineProperty(mask, "__esModule", { value: true }), mask.MPMask = void 0;
var image_shader_context_1$1 = image_shader_context;
var platform_utils_1$1 = platform_utils;
var INSTANCE_COUNT_WARNING_THRESHOLD = 250;
var MPMaskType;
!function(e2) {
  e2[e2.UINT8_ARRAY = 0] = "UINT8_ARRAY", e2[e2.FLOAT32_ARRAY = 1] = "FLOAT32_ARRAY", e2[e2.WEBGL_TEXTURE = 2] = "WEBGL_TEXTURE";
}(MPMaskType || (MPMaskType = {}));
var MPMask$1 = class _MPMask$1 {
  constructor(e2, t2, r2, o2, i3, a3) {
    this.containers = e2, this.ownsWebGLTexture = t2, this.canvas = r2, this.shaderContext = o2, this.width = i3, this.height = a3, this.ownsWebGLTexture && (--_MPMask$1.instancesBeforeWarning, 0 === _MPMask$1.instancesBeforeWarning && console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources."));
  }
  hasUint8Array() {
    return !!this.getContainer(MPMaskType.UINT8_ARRAY);
  }
  hasFloat32Array() {
    return !!this.getContainer(MPMaskType.FLOAT32_ARRAY);
  }
  hasWebGLTexture() {
    return !!this.getContainer(MPMaskType.WEBGL_TEXTURE);
  }
  getAsUint8Array() {
    return this.convertToUint8Array();
  }
  getAsFloat32Array() {
    return this.convertToFloat32Array();
  }
  getAsWebGLTexture() {
    return this.convertToWebGLTexture();
  }
  getTexImage2DFormat() {
    const e2 = this.getGL();
    if (!_MPMask$1.texImage2DFormat)
      if (e2.getExtension("EXT_color_buffer_float") && e2.getExtension("OES_texture_float_linear") && e2.getExtension("EXT_float_blend"))
        _MPMask$1.texImage2DFormat = e2.R32F;
      else {
        if (!e2.getExtension("EXT_color_buffer_half_float"))
          throw new Error("GPU does not fully support 4-channel float32 or float16 formats");
        _MPMask$1.texImage2DFormat = e2.R16F;
      }
    return _MPMask$1.texImage2DFormat;
  }
  getContainer(e2) {
    switch (e2) {
      case MPMaskType.UINT8_ARRAY:
        return this.containers.find((e3) => e3 instanceof Uint8Array);
      case MPMaskType.FLOAT32_ARRAY:
        return this.containers.find((e3) => e3 instanceof Float32Array);
      case MPMaskType.WEBGL_TEXTURE:
        return this.containers.find((e3) => "undefined" != typeof WebGLTexture && e3 instanceof WebGLTexture);
      default:
        throw new Error(`Type is not supported: ${e2}`);
    }
  }
  clone() {
    const e2 = [];
    for (const t2 of this.containers) {
      let r2;
      if (t2 instanceof Uint8Array)
        r2 = new Uint8Array(t2);
      else if (t2 instanceof Float32Array)
        r2 = new Float32Array(t2);
      else {
        if (!(t2 instanceof WebGLTexture))
          throw new Error(`Type is not supported: ${t2}`);
        {
          const e3 = this.getGL(), t3 = this.getShaderContext();
          e3.activeTexture(e3.TEXTURE1), r2 = (0, image_shader_context_1$1.assertNotNull)(e3.createTexture(), "Failed to create texture"), e3.bindTexture(e3.TEXTURE_2D, r2), this.configureTextureParams();
          const o2 = this.getTexImage2DFormat();
          e3.texImage2D(e3.TEXTURE_2D, 0, o2, this.width, this.height, 0, e3.RED, e3.FLOAT, null), e3.bindTexture(e3.TEXTURE_2D, null), t3.bindFramebuffer(e3, r2), t3.run(e3, false, () => {
            this.bindTexture(), e3.clearColor(0, 0, 0, 0), e3.clear(e3.COLOR_BUFFER_BIT), e3.drawArrays(e3.TRIANGLE_FAN, 0, 4), this.unbindTexture();
          }), t3.unbindFramebuffer(), this.unbindTexture();
        }
      }
      e2.push(r2);
    }
    return new _MPMask$1(e2, this.hasWebGLTexture(), this.canvas, this.shaderContext, this.width, this.height);
  }
  getGL() {
    if (!this.canvas)
      throw new Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
    return this.gl || (this.gl = (0, image_shader_context_1$1.assertNotNull)(this.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), this.gl;
  }
  getShaderContext() {
    return this.shaderContext || (this.shaderContext = new image_shader_context_1$1.MPImageShaderContext()), this.shaderContext;
  }
  convertToFloat32Array() {
    let e2 = this.getContainer(MPMaskType.FLOAT32_ARRAY);
    if (!e2) {
      const t2 = this.getContainer(MPMaskType.UINT8_ARRAY);
      if (t2)
        e2 = new Float32Array(t2).map((e3) => e3 / 255);
      else {
        e2 = new Float32Array(this.width * this.height);
        const t3 = this.getGL(), r2 = this.getShaderContext(), o2 = this.convertToWebGLTexture();
        if (r2.bindFramebuffer(t3, o2), (0, platform_utils_1$1.isIOS)()) {
          const r3 = new Float32Array(this.width * this.height * 4);
          t3.readPixels(0, 0, this.width, this.height, t3.RGBA, t3.FLOAT, r3);
          for (let t4 = 0, o3 = 0; t4 < e2.length; ++t4, o3 += 4)
            e2[t4] = r3[o3];
        } else
          t3.readPixels(0, 0, this.width, this.height, t3.RED, t3.FLOAT, e2);
      }
      this.containers.push(e2);
    }
    return e2;
  }
  convertToUint8Array() {
    let e2 = this.getContainer(MPMaskType.UINT8_ARRAY);
    if (!e2) {
      const t2 = this.convertToFloat32Array();
      e2 = new Uint8Array(t2.map((e3) => 255 * e3)), this.containers.push(e2);
    }
    return e2;
  }
  convertToWebGLTexture() {
    let e2 = this.getContainer(MPMaskType.WEBGL_TEXTURE);
    if (!e2) {
      const t2 = this.getGL();
      e2 = this.bindTexture();
      const r2 = this.convertToFloat32Array(), o2 = this.getTexImage2DFormat();
      t2.texImage2D(t2.TEXTURE_2D, 0, o2, this.width, this.height, 0, t2.RED, t2.FLOAT, r2), this.unbindTexture();
    }
    return e2;
  }
  configureTextureParams() {
    const e2 = this.getGL();
    e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.NEAREST), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.NEAREST);
  }
  bindTexture() {
    const e2 = this.getGL();
    e2.viewport(0, 0, this.width, this.height), e2.activeTexture(e2.TEXTURE0);
    let t2 = this.getContainer(MPMaskType.WEBGL_TEXTURE);
    return t2 ? e2.bindTexture(e2.TEXTURE_2D, t2) : (t2 = (0, image_shader_context_1$1.assertNotNull)(e2.createTexture(), "Failed to create texture"), this.containers.push(t2), this.ownsWebGLTexture = true, e2.bindTexture(e2.TEXTURE_2D, t2), this.configureTextureParams()), t2;
  }
  unbindTexture() {
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
  }
  close() {
    if (this.ownsWebGLTexture) {
      this.getGL().deleteTexture(this.getContainer(MPMaskType.WEBGL_TEXTURE));
    }
    _MPMask$1.instancesBeforeWarning = -1;
  }
};
mask.MPMask = MPMask$1, MPMask$1.instancesBeforeWarning = INSTANCE_COUNT_WARNING_THRESHOLD;
var face_detector = {};
var calculator_pb = {};
var googleProtobuf = {};
(function(exports) {
  var $jscomp = $jscomp || {};
  $jscomp.scope = {}, $jscomp.findInternal = function(e2, t2, r2) {
    e2 instanceof String && (e2 = String(e2));
    for (var o2 = e2.length, i3 = 0; i3 < o2; i3++) {
      var a3 = e2[i3];
      if (t2.call(r2, a3, i3, e2))
        return { i: i3, v: a3 };
    }
    return { i: -1, v: void 0 };
  }, $jscomp.ASSUME_ES5 = false, $jscomp.ASSUME_NO_NATIVE_MAP = false, $jscomp.ASSUME_NO_NATIVE_SET = false, $jscomp.SIMPLE_FROUND_POLYFILL = false, $jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(e2, t2, r2) {
    e2 != Array.prototype && e2 != Object.prototype && (e2[t2] = r2.value);
  }, $jscomp.getGlobal = function(e2) {
    return "undefined" != typeof window && window === e2 ? e2 : void 0 !== commonjsGlobal && null != commonjsGlobal ? commonjsGlobal : e2;
  }, $jscomp.global = $jscomp.getGlobal(commonjsGlobal), $jscomp.polyfill = function(e2, t2, r2, o2) {
    if (t2) {
      for (r2 = $jscomp.global, e2 = e2.split("."), o2 = 0; o2 < e2.length - 1; o2++) {
        var i3 = e2[o2];
        i3 in r2 || (r2[i3] = {}), r2 = r2[i3];
      }
      (t2 = t2(o2 = r2[e2 = e2[e2.length - 1]])) != o2 && null != t2 && $jscomp.defineProperty(r2, e2, { configurable: true, writable: true, value: t2 });
    }
  }, $jscomp.polyfill("Array.prototype.findIndex", function(e2) {
    return e2 || function(e3, t2) {
      return $jscomp.findInternal(this, e3, t2).i;
    };
  }, "es6", "es3"), $jscomp.checkStringArgs = function(e2, t2, r2) {
    if (null == e2)
      throw new TypeError("The 'this' value for String.prototype." + r2 + " must not be null or undefined");
    if (t2 instanceof RegExp)
      throw new TypeError("First argument to String.prototype." + r2 + " must not be a regular expression");
    return e2 + "";
  }, $jscomp.polyfill("String.prototype.endsWith", function(e2) {
    return e2 || function(e3, t2) {
      var r2 = $jscomp.checkStringArgs(this, e3, "endsWith");
      e3 += "", void 0 === t2 && (t2 = r2.length), t2 = Math.max(0, Math.min(0 | t2, r2.length));
      for (var o2 = e3.length; 0 < o2 && 0 < t2; )
        if (r2[--t2] != e3[--o2])
          return false;
      return 0 >= o2;
    };
  }, "es6", "es3"), $jscomp.polyfill("Array.prototype.find", function(e2) {
    return e2 || function(e3, t2) {
      return $jscomp.findInternal(this, e3, t2).v;
    };
  }, "es6", "es3"), $jscomp.polyfill("String.prototype.startsWith", function(e2) {
    return e2 || function(e3, t2) {
      var r2 = $jscomp.checkStringArgs(this, e3, "startsWith");
      e3 += "";
      var o2 = r2.length, i3 = e3.length;
      t2 = Math.max(0, Math.min(0 | t2, r2.length));
      for (var a3 = 0; a3 < i3 && t2 < o2; )
        if (r2[t2++] != e3[a3++])
          return false;
      return a3 >= i3;
    };
  }, "es6", "es3"), $jscomp.polyfill("String.prototype.repeat", function(e2) {
    return e2 || function(e3) {
      var t2 = $jscomp.checkStringArgs(this, null, "repeat");
      if (0 > e3 || 1342177279 < e3)
        throw new RangeError("Invalid count value");
      e3 |= 0;
      for (var r2 = ""; e3; )
        1 & e3 && (r2 += t2), (e3 >>>= 1) && (t2 += t2);
      return r2;
    };
  }, "es6", "es3");
  var COMPILED = true, goog = goog || {};
  goog.global = commonjsGlobal || self, goog.exportPath_ = function(e2, t2, r2) {
    e2 = e2.split("."), r2 = r2 || goog.global, e2[0] in r2 || void 0 === r2.execScript || r2.execScript("var " + e2[0]);
    for (var o2; e2.length && (o2 = e2.shift()); )
      e2.length || void 0 === t2 ? r2 = r2[o2] && r2[o2] !== Object.prototype[o2] ? r2[o2] : r2[o2] = {} : r2[o2] = t2;
  }, goog.define = function(e2, t2) {
    return t2;
  }, goog.FEATURESET_YEAR = 2012, goog.DEBUG = true, goog.LOCALE = "en", goog.TRUSTED_SITE = true, goog.STRICT_MODE_COMPATIBLE = false, goog.DISALLOW_TEST_ONLY_CODE = !goog.DEBUG, goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = false, goog.provide = function(e2) {
    if (goog.isInModuleLoader_())
      throw Error("goog.provide cannot be used within a module.");
    goog.constructNamespace_(e2);
  }, goog.constructNamespace_ = function(e2, t2) {
    goog.exportPath_(e2, t2);
  }, goog.getScriptNonce = function(e2) {
    return e2 && e2 != goog.global ? goog.getScriptNonce_(e2.document) : (null === goog.cspNonce_ && (goog.cspNonce_ = goog.getScriptNonce_(goog.global.document)), goog.cspNonce_);
  }, goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/, goog.cspNonce_ = null, goog.getScriptNonce_ = function(e2) {
    return (e2 = e2.querySelector && e2.querySelector("script[nonce]")) && (e2 = e2.nonce || e2.getAttribute("nonce")) && goog.NONCE_PATTERN_.test(e2) ? e2 : "";
  }, goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/, goog.module = function(e2) {
    if ("string" != typeof e2 || !e2 || -1 == e2.search(goog.VALID_MODULE_RE_))
      throw Error("Invalid module identifier");
    if (!goog.isInGoogModuleLoader_())
      throw Error("Module " + e2 + " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
    if (goog.moduleLoaderState_.moduleName)
      throw Error("goog.module may only be called once per module.");
    goog.moduleLoaderState_.moduleName = e2;
  }, goog.module.get = function(e2) {
    return goog.module.getInternal_(e2);
  }, goog.module.getInternal_ = function(e2) {
    return null;
  }, goog.ModuleType = { ES6: "es6", GOOG: "goog" }, goog.moduleLoaderState_ = null, goog.isInModuleLoader_ = function() {
    return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();
  }, goog.isInGoogModuleLoader_ = function() {
    return !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.GOOG;
  }, goog.isInEs6ModuleLoader_ = function() {
    if (goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.ES6)
      return true;
    var e2 = goog.global.$jscomp;
    return !!e2 && ("function" == typeof e2.getCurrentModulePath && !!e2.getCurrentModulePath());
  }, goog.module.declareLegacyNamespace = function() {
    goog.moduleLoaderState_.declareLegacyNamespace = true;
  }, goog.declareModuleId = function(e2) {
    if (goog.moduleLoaderState_)
      goog.moduleLoaderState_.moduleName = e2;
    else {
      var t2 = goog.global.$jscomp;
      if (!t2 || "function" != typeof t2.getCurrentModulePath)
        throw Error('Module with namespace "' + e2 + '" has been loaded incorrectly.');
      t2 = t2.require(t2.getCurrentModulePath()), goog.loadedModules_[e2] = { exports: t2, type: goog.ModuleType.ES6, moduleId: e2 };
    }
  }, goog.setTestOnly = function(e2) {
    if (goog.DISALLOW_TEST_ONLY_CODE)
      throw e2 = e2 || "", Error("Importing test-only code into non-debug environment" + (e2 ? ": " + e2 : "."));
  }, goog.forwardDeclare = function(e2) {
  }, goog.getObjectByName = function(e2, t2) {
    e2 = e2.split("."), t2 = t2 || goog.global;
    for (var r2 = 0; r2 < e2.length; r2++)
      if (null == (t2 = t2[e2[r2]]))
        return null;
    return t2;
  }, goog.globalize = function(e2, t2) {
    for (var r2 in t2 = t2 || goog.global, e2)
      t2[r2] = e2[r2];
  }, goog.addDependency = function(e2, t2, r2, o2) {
  }, goog.ENABLE_DEBUG_LOADER = true, goog.logToConsole_ = function(e2) {
    goog.global.console && goog.global.console.error(e2);
  }, goog.require = function(e2) {
  }, goog.requireType = function(e2) {
    return {};
  }, goog.basePath = "", goog.nullFunction = function() {
  }, goog.abstractMethod = function() {
    throw Error("unimplemented abstract method");
  }, goog.addSingletonGetter = function(e2) {
    e2.instance_ = void 0, e2.getInstance = function() {
      return e2.instance_ ? e2.instance_ : (goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = e2), e2.instance_ = new e2());
    };
  }, goog.instantiatedSingletons_ = [], goog.LOAD_MODULE_USING_EVAL = true, goog.SEAL_MODULE_EXPORTS = goog.DEBUG, goog.loadedModules_ = {}, goog.DEPENDENCIES_ENABLED = !COMPILED, goog.TRANSPILE = "detect", goog.ASSUME_ES_MODULES_TRANSPILED = false, goog.TRANSPILE_TO_LANGUAGE = "", goog.TRANSPILER = "transpile.js", goog.hasBadLetScoping = null, goog.useSafari10Workaround = function() {
    if (null == goog.hasBadLetScoping) {
      try {
        var a = !eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";');
      } catch (e2) {
        a = false;
      }
      goog.hasBadLetScoping = a;
    }
    return goog.hasBadLetScoping;
  }, goog.workaroundSafari10EvalBug = function(e2) {
    return "(function(){" + e2 + "\n;})();\n";
  }, goog.loadModule = function(e2) {
    var t2 = goog.moduleLoaderState_;
    try {
      if (goog.moduleLoaderState_ = { moduleName: "", declareLegacyNamespace: false, type: goog.ModuleType.GOOG }, goog.isFunction(e2))
        var r2 = e2.call(void 0, {});
      else {
        if ("string" != typeof e2)
          throw Error("Invalid module definition");
        goog.useSafari10Workaround() && (e2 = goog.workaroundSafari10EvalBug(e2)), r2 = goog.loadModuleFromSource_.call(void 0, e2);
      }
      var o2 = goog.moduleLoaderState_.moduleName;
      if ("string" != typeof o2 || !o2)
        throw Error('Invalid module name "' + o2 + '"');
      goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(o2, r2) : goog.SEAL_MODULE_EXPORTS && Object.seal && "object" == typeof r2 && null != r2 && Object.seal(r2), goog.loadedModules_[o2] = { exports: r2, type: goog.ModuleType.GOOG, moduleId: goog.moduleLoaderState_.moduleName };
    } finally {
      goog.moduleLoaderState_ = t2;
    }
  }, goog.loadModuleFromSource_ = function(a) {
    return eval(a), {};
  }, goog.normalizePath_ = function(e2) {
    e2 = e2.split("/");
    for (var t2 = 0; t2 < e2.length; )
      "." == e2[t2] ? e2.splice(t2, 1) : t2 && ".." == e2[t2] && e2[t2 - 1] && ".." != e2[t2 - 1] ? e2.splice(--t2, 2) : t2++;
    return e2.join("/");
  }, goog.loadFileSync_ = function(e2) {
    if (goog.global.CLOSURE_LOAD_FILE_SYNC)
      return goog.global.CLOSURE_LOAD_FILE_SYNC(e2);
    try {
      var t2 = new goog.global.XMLHttpRequest();
      return t2.open("get", e2, false), t2.send(), 0 == t2.status || 200 == t2.status ? t2.responseText : null;
    } catch (e3) {
      return null;
    }
  }, goog.transpile_ = function(e2, t2, r2) {
    var o2 = goog.global.$jscomp;
    o2 || (goog.global.$jscomp = o2 = {});
    var i3 = o2.transpile;
    if (!i3) {
      var a3 = goog.basePath + goog.TRANSPILER, n2 = goog.loadFileSync_(a3);
      if (n2) {
        if ((function() {
          (0, eval)(n2 + "\n//# sourceURL=" + a3);
        }).call(goog.global), goog.global.$gwtExport && goog.global.$gwtExport.$jscomp && !goog.global.$gwtExport.$jscomp.transpile)
          throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: ' + JSON.stringify(goog.global.$gwtExport));
        goog.global.$jscomp.transpile = goog.global.$gwtExport.$jscomp.transpile, i3 = (o2 = goog.global.$jscomp).transpile;
      }
    }
    return i3 || (i3 = o2.transpile = function(e3, t3) {
      return goog.logToConsole_(t3 + " requires transpilation but no transpiler was found."), e3;
    }), i3(e2, t2, r2);
  }, goog.typeOf = function(e2) {
    var t2 = typeof e2;
    if ("object" == t2) {
      if (!e2)
        return "null";
      if (e2 instanceof Array)
        return "array";
      if (e2 instanceof Object)
        return t2;
      var r2 = Object.prototype.toString.call(e2);
      if ("[object Window]" == r2)
        return "object";
      if ("[object Array]" == r2 || "number" == typeof e2.length && void 0 !== e2.splice && void 0 !== e2.propertyIsEnumerable && !e2.propertyIsEnumerable("splice"))
        return "array";
      if ("[object Function]" == r2 || void 0 !== e2.call && void 0 !== e2.propertyIsEnumerable && !e2.propertyIsEnumerable("call"))
        return "function";
    } else if ("function" == t2 && void 0 === e2.call)
      return "object";
    return t2;
  }, goog.isArray = function(e2) {
    return "array" == goog.typeOf(e2);
  }, goog.isArrayLike = function(e2) {
    var t2 = goog.typeOf(e2);
    return "array" == t2 || "object" == t2 && "number" == typeof e2.length;
  }, goog.isDateLike = function(e2) {
    return goog.isObject(e2) && "function" == typeof e2.getFullYear;
  }, goog.isFunction = function(e2) {
    return "function" == goog.typeOf(e2);
  }, goog.isObject = function(e2) {
    var t2 = typeof e2;
    return "object" == t2 && null != e2 || "function" == t2;
  }, goog.getUid = function(e2) {
    return Object.prototype.hasOwnProperty.call(e2, goog.UID_PROPERTY_) && e2[goog.UID_PROPERTY_] || (e2[goog.UID_PROPERTY_] = ++goog.uidCounter_);
  }, goog.hasUid = function(e2) {
    return !!e2[goog.UID_PROPERTY_];
  }, goog.removeUid = function(e2) {
    null !== e2 && "removeAttribute" in e2 && e2.removeAttribute(goog.UID_PROPERTY_);
    try {
      delete e2[goog.UID_PROPERTY_];
    } catch (e3) {
    }
  }, goog.UID_PROPERTY_ = "closure_uid_" + (1e9 * Math.random() >>> 0), goog.uidCounter_ = 0, goog.getHashCode = goog.getUid, goog.removeHashCode = goog.removeUid, goog.cloneObject = function(e2) {
    var t2 = goog.typeOf(e2);
    if ("object" == t2 || "array" == t2) {
      if ("function" == typeof e2.clone)
        return e2.clone();
      for (var r2 in t2 = "array" == t2 ? [] : {}, e2)
        t2[r2] = goog.cloneObject(e2[r2]);
      return t2;
    }
    return e2;
  }, goog.bindNative_ = function(e2, t2, r2) {
    return e2.call.apply(e2.bind, arguments);
  }, goog.bindJs_ = function(e2, t2, r2) {
    if (!e2)
      throw Error();
    if (2 < arguments.length) {
      var o2 = Array.prototype.slice.call(arguments, 2);
      return function() {
        var r3 = Array.prototype.slice.call(arguments);
        return Array.prototype.unshift.apply(r3, o2), e2.apply(t2, r3);
      };
    }
    return function() {
      return e2.apply(t2, arguments);
    };
  }, goog.bind = function(e2, t2, r2) {
    return Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_, goog.bind.apply(null, arguments);
  }, goog.partial = function(e2, t2) {
    var r2 = Array.prototype.slice.call(arguments, 1);
    return function() {
      var t3 = r2.slice();
      return t3.push.apply(t3, arguments), e2.apply(this, t3);
    };
  }, goog.mixin = function(e2, t2) {
    for (var r2 in t2)
      e2[r2] = t2[r2];
  }, goog.now = goog.TRUSTED_SITE && Date.now || function() {
    return +/* @__PURE__ */ new Date();
  }, goog.globalEval = function(e2) {
    if (goog.global.execScript)
      goog.global.execScript(e2, "JavaScript");
    else {
      if (!goog.global.eval)
        throw Error("goog.globalEval not available");
      if (null == goog.evalWorksForGlobals_) {
        try {
          goog.global.eval("var _evalTest_ = 1;");
        } catch (e3) {
        }
        if (void 0 !== goog.global._evalTest_) {
          try {
            delete goog.global._evalTest_;
          } catch (e3) {
          }
          goog.evalWorksForGlobals_ = true;
        } else
          goog.evalWorksForGlobals_ = false;
      }
      if (goog.evalWorksForGlobals_)
        goog.global.eval(e2);
      else {
        var t2 = goog.global.document, r2 = t2.createElement("script");
        r2.type = "text/javascript", r2.defer = false, r2.appendChild(t2.createTextNode(e2)), t2.head.appendChild(r2), t2.head.removeChild(r2);
      }
    }
  }, goog.evalWorksForGlobals_ = null, goog.getCssName = function(e2, t2) {
    if ("." == String(e2).charAt(0))
      throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + e2);
    var r2 = function(e3) {
      return goog.cssNameMapping_[e3] || e3;
    }, o2 = function(e3) {
      e3 = e3.split("-");
      for (var t3 = [], o3 = 0; o3 < e3.length; o3++)
        t3.push(r2(e3[o3]));
      return t3.join("-");
    };
    return o2 = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? r2 : o2 : function(e3) {
      return e3;
    }, e2 = t2 ? e2 + "-" + o2(t2) : o2(e2), goog.global.CLOSURE_CSS_NAME_MAP_FN ? goog.global.CLOSURE_CSS_NAME_MAP_FN(e2) : e2;
  }, goog.setCssNameMapping = function(e2, t2) {
    goog.cssNameMapping_ = e2, goog.cssNameMappingStyle_ = t2;
  }, goog.getMsg = function(e2, t2, r2) {
    return r2 && r2.html && (e2 = e2.replace(/</g, "&lt;")), t2 && (e2 = e2.replace(/\{\$([^}]+)}/g, function(e3, r3) {
      return null != t2 && r3 in t2 ? t2[r3] : e3;
    })), e2;
  }, goog.getMsgWithFallback = function(e2, t2) {
    return e2;
  }, goog.exportSymbol = function(e2, t2, r2) {
    goog.exportPath_(e2, t2, r2);
  }, goog.exportProperty = function(e2, t2, r2) {
    e2[t2] = r2;
  }, goog.inherits = function(e2, t2) {
    function r2() {
    }
    r2.prototype = t2.prototype, e2.superClass_ = t2.prototype, e2.prototype = new r2(), e2.prototype.constructor = e2, e2.base = function(e3, r3, o2) {
      for (var i3 = Array(arguments.length - 2), a3 = 2; a3 < arguments.length; a3++)
        i3[a3 - 2] = arguments[a3];
      return t2.prototype[r3].apply(e3, i3);
    };
  }, goog.scope = function(e2) {
    if (goog.isInModuleLoader_())
      throw Error("goog.scope is not supported within a module.");
    e2.call(goog.global);
  }, goog.defineClass = function(e2, t2) {
    var r2 = t2.constructor, o2 = t2.statics;
    return r2 && r2 != Object.prototype.constructor || (r2 = function() {
      throw Error("cannot instantiate an interface (no constructor defined).");
    }), r2 = goog.defineClass.createSealingConstructor_(r2, e2), e2 && goog.inherits(r2, e2), delete t2.constructor, delete t2.statics, goog.defineClass.applyProperties_(r2.prototype, t2), null != o2 && (o2 instanceof Function ? o2(r2) : goog.defineClass.applyProperties_(r2, o2)), r2;
  }, goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG, goog.defineClass.createSealingConstructor_ = function(e2, t2) {
    if (!goog.defineClass.SEAL_CLASS_INSTANCES)
      return e2;
    var r2 = !goog.defineClass.isUnsealable_(t2), o2 = function() {
      var t3 = e2.apply(this, arguments) || this;
      return t3[goog.UID_PROPERTY_] = t3[goog.UID_PROPERTY_], this.constructor === o2 && r2 && Object.seal instanceof Function && Object.seal(t3), t3;
    };
    return o2;
  }, goog.defineClass.isUnsealable_ = function(e2) {
    return e2 && e2.prototype && e2.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];
  }, goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "), goog.defineClass.applyProperties_ = function(e2, t2) {
    for (var r2 in t2)
      Object.prototype.hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
    for (var o2 = 0; o2 < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; o2++)
      r2 = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[o2], Object.prototype.hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
  }, goog.tagUnsealableClass = function(e2) {
  }, goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable", goog.TRUSTED_TYPES_POLICY_NAME = "", goog.identity_ = function(e2) {
    return e2;
  }, goog.createTrustedTypesPolicy = function(e2) {
    var t2 = null, r2 = goog.global.trustedTypes || goog.global.TrustedTypes;
    if (!r2 || !r2.createPolicy)
      return t2;
    try {
      t2 = r2.createPolicy(e2, { createHTML: goog.identity_, createScript: goog.identity_, createScriptURL: goog.identity_, createURL: goog.identity_ });
    } catch (e3) {
      goog.logToConsole_(e3.message);
    }
    return t2;
  }, goog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#base") : null, goog.object = {}, goog.object.is = function(e2, t2) {
    return e2 === t2 ? 0 !== e2 || 1 / e2 == 1 / t2 : e2 != e2 && t2 != t2;
  }, goog.object.forEach = function(e2, t2, r2) {
    for (var o2 in e2)
      t2.call(r2, e2[o2], o2, e2);
  }, goog.object.filter = function(e2, t2, r2) {
    var o2, i3 = {};
    for (o2 in e2)
      t2.call(r2, e2[o2], o2, e2) && (i3[o2] = e2[o2]);
    return i3;
  }, goog.object.map = function(e2, t2, r2) {
    var o2, i3 = {};
    for (o2 in e2)
      i3[o2] = t2.call(r2, e2[o2], o2, e2);
    return i3;
  }, goog.object.some = function(e2, t2, r2) {
    for (var o2 in e2)
      if (t2.call(r2, e2[o2], o2, e2))
        return true;
    return false;
  }, goog.object.every = function(e2, t2, r2) {
    for (var o2 in e2)
      if (!t2.call(r2, e2[o2], o2, e2))
        return false;
    return true;
  }, goog.object.getCount = function(e2) {
    var t2, r2 = 0;
    for (t2 in e2)
      r2++;
    return r2;
  }, goog.object.getAnyKey = function(e2) {
    for (var t2 in e2)
      return t2;
  }, goog.object.getAnyValue = function(e2) {
    for (var t2 in e2)
      return e2[t2];
  }, goog.object.contains = function(e2, t2) {
    return goog.object.containsValue(e2, t2);
  }, goog.object.getValues = function(e2) {
    var t2, r2 = [], o2 = 0;
    for (t2 in e2)
      r2[o2++] = e2[t2];
    return r2;
  }, goog.object.getKeys = function(e2) {
    var t2, r2 = [], o2 = 0;
    for (t2 in e2)
      r2[o2++] = t2;
    return r2;
  }, goog.object.getValueByKeys = function(e2, t2) {
    var r2 = goog.isArrayLike(t2), o2 = r2 ? t2 : arguments;
    for (r2 = r2 ? 0 : 1; r2 < o2.length; r2++) {
      if (null == e2)
        return;
      e2 = e2[o2[r2]];
    }
    return e2;
  }, goog.object.containsKey = function(e2, t2) {
    return null !== e2 && t2 in e2;
  }, goog.object.containsValue = function(e2, t2) {
    for (var r2 in e2)
      if (e2[r2] == t2)
        return true;
    return false;
  }, goog.object.findKey = function(e2, t2, r2) {
    for (var o2 in e2)
      if (t2.call(r2, e2[o2], o2, e2))
        return o2;
  }, goog.object.findValue = function(e2, t2, r2) {
    return (t2 = goog.object.findKey(e2, t2, r2)) && e2[t2];
  }, goog.object.isEmpty = function(e2) {
    for (var t2 in e2)
      return false;
    return true;
  }, goog.object.clear = function(e2) {
    for (var t2 in e2)
      delete e2[t2];
  }, goog.object.remove = function(e2, t2) {
    var r2;
    return (r2 = t2 in e2) && delete e2[t2], r2;
  }, goog.object.add = function(e2, t2, r2) {
    if (null !== e2 && t2 in e2)
      throw Error('The object already contains the key "' + t2 + '"');
    goog.object.set(e2, t2, r2);
  }, goog.object.get = function(e2, t2, r2) {
    return null !== e2 && t2 in e2 ? e2[t2] : r2;
  }, goog.object.set = function(e2, t2, r2) {
    e2[t2] = r2;
  }, goog.object.setIfUndefined = function(e2, t2, r2) {
    return t2 in e2 ? e2[t2] : e2[t2] = r2;
  }, goog.object.setWithReturnValueIfNotSet = function(e2, t2, r2) {
    return t2 in e2 ? e2[t2] : (r2 = r2(), e2[t2] = r2);
  }, goog.object.equals = function(e2, t2) {
    for (var r2 in e2)
      if (!(r2 in t2) || e2[r2] !== t2[r2])
        return false;
    for (var o2 in t2)
      if (!(o2 in e2))
        return false;
    return true;
  }, goog.object.clone = function(e2) {
    var t2, r2 = {};
    for (t2 in e2)
      r2[t2] = e2[t2];
    return r2;
  }, goog.object.unsafeClone = function(e2) {
    var t2 = goog.typeOf(e2);
    if ("object" == t2 || "array" == t2) {
      if (goog.isFunction(e2.clone))
        return e2.clone();
      for (var r2 in t2 = "array" == t2 ? [] : {}, e2)
        t2[r2] = goog.object.unsafeClone(e2[r2]);
      return t2;
    }
    return e2;
  }, goog.object.transpose = function(e2) {
    var t2, r2 = {};
    for (t2 in e2)
      r2[e2[t2]] = t2;
    return r2;
  }, goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "), goog.object.extend = function(e2, t2) {
    for (var r2, o2, i3 = 1; i3 < arguments.length; i3++) {
      for (r2 in o2 = arguments[i3])
        e2[r2] = o2[r2];
      for (var a3 = 0; a3 < goog.object.PROTOTYPE_FIELDS_.length; a3++)
        r2 = goog.object.PROTOTYPE_FIELDS_[a3], Object.prototype.hasOwnProperty.call(o2, r2) && (e2[r2] = o2[r2]);
    }
  }, goog.object.create = function(e2) {
    var t2 = arguments.length;
    if (1 == t2 && Array.isArray(arguments[0]))
      return goog.object.create.apply(null, arguments[0]);
    if (t2 % 2)
      throw Error("Uneven number of arguments");
    for (var r2 = {}, o2 = 0; o2 < t2; o2 += 2)
      r2[arguments[o2]] = arguments[o2 + 1];
    return r2;
  }, goog.object.createSet = function(e2) {
    var t2 = arguments.length;
    if (1 == t2 && Array.isArray(arguments[0]))
      return goog.object.createSet.apply(null, arguments[0]);
    for (var r2 = {}, o2 = 0; o2 < t2; o2++)
      r2[arguments[o2]] = true;
    return r2;
  }, goog.object.createImmutableView = function(e2) {
    var t2 = e2;
    return Object.isFrozen && !Object.isFrozen(e2) && (t2 = Object.create(e2), Object.freeze(t2)), t2;
  }, goog.object.isImmutableView = function(e2) {
    return !!Object.isFrozen && Object.isFrozen(e2);
  }, goog.object.getAllPropertyNames = function(e2, t2, r2) {
    if (!e2)
      return [];
    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf)
      return goog.object.getKeys(e2);
    for (var o2 = {}; e2 && (e2 !== Object.prototype || t2) && (e2 !== Function.prototype || r2); ) {
      for (var i3 = Object.getOwnPropertyNames(e2), a3 = 0; a3 < i3.length; a3++)
        o2[i3[a3]] = true;
      e2 = Object.getPrototypeOf(e2);
    }
    return goog.object.getKeys(o2);
  }, goog.object.getSuperClass = function(e2) {
    return (e2 = Object.getPrototypeOf(e2.prototype)) && e2.constructor;
  };
  var jspb = { asserts: {} };
  jspb.asserts.doAssertFailure = function(e2, t2, r2, o2) {
    var i3 = "Assertion failed";
    if (r2) {
      i3 += ": " + r2;
      var a3 = o2;
    } else
      e2 && (i3 += ": " + e2, a3 = t2);
    throw Error("" + i3, a3 || []);
  }, jspb.asserts.assert = function(e2, t2, r2) {
    for (var o2 = [], i3 = 2; i3 < arguments.length; ++i3)
      o2[i3 - 2] = arguments[i3];
    return e2 || jspb.asserts.doAssertFailure("", null, t2, o2), e2;
  }, jspb.asserts.assertString = function(e2, t2, r2) {
    for (var o2 = [], i3 = 2; i3 < arguments.length; ++i3)
      o2[i3 - 2] = arguments[i3];
    return "string" != typeof e2 && jspb.asserts.doAssertFailure("Expected string but got %s: %s.", [goog.typeOf(e2), e2], t2, o2), e2;
  }, jspb.asserts.assertArray = function(e2, t2, r2) {
    for (var o2 = [], i3 = 2; i3 < arguments.length; ++i3)
      o2[i3 - 2] = arguments[i3];
    return Array.isArray(e2) || jspb.asserts.doAssertFailure("Expected array but got %s: %s.", [goog.typeOf(e2), e2], t2, o2), e2;
  }, jspb.asserts.fail = function(e2, t2) {
    for (var r2 = [], o2 = 1; o2 < arguments.length; ++o2)
      r2[o2 - 1] = arguments[o2];
    throw Error("Failure" + (e2 ? ": " + e2 : ""), r2);
  }, jspb.asserts.assertInstanceof = function(e2, t2, r2, o2) {
    for (var i3 = [], a3 = 3; a3 < arguments.length; ++a3)
      i3[a3 - 3] = arguments[a3];
    return e2 instanceof t2 || jspb.asserts.doAssertFailure("Expected instanceof %s but got %s.", [jspb.asserts.getType(t2), jspb.asserts.getType(e2)], r2, i3), e2;
  }, jspb.asserts.getType = function(e2) {
    return e2 instanceof Function ? e2.displayName || e2.name || "unknown type name" : e2 instanceof Object ? e2.constructor.displayName || e2.constructor.name || Object.prototype.toString.call(e2) : null === e2 ? "null" : typeof e2;
  }, jspb.BinaryConstants = {}, jspb.ConstBinaryMessage = function() {
  }, jspb.BinaryMessage = function() {
  }, jspb.BinaryConstants.FieldType = { INVALID: -1, DOUBLE: 1, FLOAT: 2, INT64: 3, UINT64: 4, INT32: 5, FIXED64: 6, FIXED32: 7, BOOL: 8, STRING: 9, GROUP: 10, MESSAGE: 11, BYTES: 12, UINT32: 13, ENUM: 14, SFIXED32: 15, SFIXED64: 16, SINT32: 17, SINT64: 18, FHASH64: 30, VHASH64: 31 }, jspb.BinaryConstants.WireType = { INVALID: -1, VARINT: 0, FIXED64: 1, DELIMITED: 2, START_GROUP: 3, END_GROUP: 4, FIXED32: 5 }, jspb.BinaryConstants.FieldTypeToWireType = function(e2) {
    var t2 = jspb.BinaryConstants.FieldType, r2 = jspb.BinaryConstants.WireType;
    switch (e2) {
      case t2.INT32:
      case t2.INT64:
      case t2.UINT32:
      case t2.UINT64:
      case t2.SINT32:
      case t2.SINT64:
      case t2.BOOL:
      case t2.ENUM:
      case t2.VHASH64:
        return r2.VARINT;
      case t2.DOUBLE:
      case t2.FIXED64:
      case t2.SFIXED64:
      case t2.FHASH64:
        return r2.FIXED64;
      case t2.STRING:
      case t2.MESSAGE:
      case t2.BYTES:
        return r2.DELIMITED;
      case t2.FLOAT:
      case t2.FIXED32:
      case t2.SFIXED32:
        return r2.FIXED32;
      default:
        return r2.INVALID;
    }
  }, jspb.BinaryConstants.INVALID_FIELD_NUMBER = -1, jspb.BinaryConstants.FLOAT32_EPS = 1401298464324817e-60, jspb.BinaryConstants.FLOAT32_MIN = 11754943508222875e-54, jspb.BinaryConstants.FLOAT32_MAX = 34028234663852886e22, jspb.BinaryConstants.FLOAT64_EPS = 5e-324, jspb.BinaryConstants.FLOAT64_MIN = 22250738585072014e-324, jspb.BinaryConstants.FLOAT64_MAX = 17976931348623157e292, jspb.BinaryConstants.TWO_TO_20 = 1048576, jspb.BinaryConstants.TWO_TO_23 = 8388608, jspb.BinaryConstants.TWO_TO_31 = 2147483648, jspb.BinaryConstants.TWO_TO_32 = 4294967296, jspb.BinaryConstants.TWO_TO_52 = 4503599627370496, jspb.BinaryConstants.TWO_TO_63 = 9223372036854776e3, jspb.BinaryConstants.TWO_TO_64 = 18446744073709552e3, jspb.BinaryConstants.ZERO_HASH = "\0\0\0\0\0\0\0\0", goog.debug = {}, goog.debug.Error = function(e2) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, goog.debug.Error);
    else {
      var t2 = Error().stack;
      t2 && (this.stack = t2);
    }
    e2 && (this.message = String(e2)), this.reportErrorToServer = true;
  }, goog.inherits(goog.debug.Error, Error), goog.debug.Error.prototype.name = "CustomError", goog.dom = {}, goog.dom.NodeType = { ELEMENT: 1, ATTRIBUTE: 2, TEXT: 3, CDATA_SECTION: 4, ENTITY_REFERENCE: 5, ENTITY: 6, PROCESSING_INSTRUCTION: 7, COMMENT: 8, DOCUMENT: 9, DOCUMENT_TYPE: 10, DOCUMENT_FRAGMENT: 11, NOTATION: 12 }, goog.asserts = {}, goog.asserts.ENABLE_ASSERTS = goog.DEBUG, goog.asserts.AssertionError = function(e2, t2) {
    goog.debug.Error.call(this, goog.asserts.subs_(e2, t2)), this.messagePattern = e2;
  }, goog.inherits(goog.asserts.AssertionError, goog.debug.Error), goog.asserts.AssertionError.prototype.name = "AssertionError", goog.asserts.DEFAULT_ERROR_HANDLER = function(e2) {
    throw e2;
  }, goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER, goog.asserts.subs_ = function(e2, t2) {
    for (var r2 = "", o2 = (e2 = e2.split("%s")).length - 1, i3 = 0; i3 < o2; i3++)
      r2 += e2[i3] + (i3 < t2.length ? t2[i3] : "%s");
    return r2 + e2[o2];
  }, goog.asserts.doAssertFailure_ = function(e2, t2, r2, o2) {
    var i3 = "Assertion failed";
    if (r2) {
      i3 += ": " + r2;
      var a3 = o2;
    } else
      e2 && (i3 += ": " + e2, a3 = t2);
    e2 = new goog.asserts.AssertionError("" + i3, a3 || []), goog.asserts.errorHandler_(e2);
  }, goog.asserts.setErrorHandler = function(e2) {
    goog.asserts.ENABLE_ASSERTS && (goog.asserts.errorHandler_ = e2);
  }, goog.asserts.assert = function(e2, t2, r2) {
    return goog.asserts.ENABLE_ASSERTS && !e2 && goog.asserts.doAssertFailure_("", null, t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.assertExists = function(e2, t2, r2) {
    return goog.asserts.ENABLE_ASSERTS && null == e2 && goog.asserts.doAssertFailure_("Expected to exist: %s.", [e2], t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.fail = function(e2, t2) {
    goog.asserts.ENABLE_ASSERTS && goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure" + (e2 ? ": " + e2 : ""), Array.prototype.slice.call(arguments, 1)));
  }, goog.asserts.assertNumber = function(e2, t2, r2) {
    return goog.asserts.ENABLE_ASSERTS && "number" != typeof e2 && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(e2), e2], t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.assertString = function(e2, t2, r2) {
    return goog.asserts.ENABLE_ASSERTS && "string" != typeof e2 && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(e2), e2], t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.assertFunction = function(e2, t2, r2) {
    return goog.asserts.ENABLE_ASSERTS && !goog.isFunction(e2) && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(e2), e2], t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.assertObject = function(e2, t2, r2) {
    return goog.asserts.ENABLE_ASSERTS && !goog.isObject(e2) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(e2), e2], t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.assertArray = function(e2, t2, r2) {
    return goog.asserts.ENABLE_ASSERTS && !Array.isArray(e2) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(e2), e2], t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.assertBoolean = function(e2, t2, r2) {
    return goog.asserts.ENABLE_ASSERTS && "boolean" != typeof e2 && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(e2), e2], t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.assertElement = function(e2, t2, r2) {
    return !goog.asserts.ENABLE_ASSERTS || goog.isObject(e2) && e2.nodeType == goog.dom.NodeType.ELEMENT || goog.asserts.doAssertFailure_("Expected Element but got %s: %s.", [goog.typeOf(e2), e2], t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.assertInstanceof = function(e2, t2, r2, o2) {
    return !goog.asserts.ENABLE_ASSERTS || e2 instanceof t2 || goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.", [goog.asserts.getType_(t2), goog.asserts.getType_(e2)], r2, Array.prototype.slice.call(arguments, 3)), e2;
  }, goog.asserts.assertFinite = function(e2, t2, r2) {
    return !goog.asserts.ENABLE_ASSERTS || "number" == typeof e2 && isFinite(e2) || goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.", [e2], t2, Array.prototype.slice.call(arguments, 2)), e2;
  }, goog.asserts.assertObjectPrototypeIsIntact = function() {
    for (var e2 in Object.prototype)
      goog.asserts.fail(e2 + " should not be enumerable in Object.prototype.");
  }, goog.asserts.getType_ = function(e2) {
    return e2 instanceof Function ? e2.displayName || e2.name || "unknown type name" : e2 instanceof Object ? e2.constructor.displayName || e2.constructor.name || Object.prototype.toString.call(e2) : null === e2 ? "null" : typeof e2;
  }, goog.array = {}, goog.NATIVE_ARRAY_PROTOTYPES = goog.TRUSTED_SITE, goog.array.ASSUME_NATIVE_FUNCTIONS = 2012 < goog.FEATURESET_YEAR, goog.array.peek = function(e2) {
    return e2[e2.length - 1];
  }, goog.array.last = goog.array.peek, goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ? function(e2, t2, r2) {
    return goog.asserts.assert(null != e2.length), Array.prototype.indexOf.call(e2, t2, r2);
  } : function(e2, t2, r2) {
    if (r2 = null == r2 ? 0 : 0 > r2 ? Math.max(0, e2.length + r2) : r2, "string" == typeof e2)
      return "string" != typeof t2 || 1 != t2.length ? -1 : e2.indexOf(t2, r2);
    for (; r2 < e2.length; r2++)
      if (r2 in e2 && e2[r2] === t2)
        return r2;
    return -1;
  }, goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ? function(e2, t2, r2) {
    return goog.asserts.assert(null != e2.length), Array.prototype.lastIndexOf.call(e2, t2, null == r2 ? e2.length - 1 : r2);
  } : function(e2, t2, r2) {
    if (0 > (r2 = null == r2 ? e2.length - 1 : r2) && (r2 = Math.max(0, e2.length + r2)), "string" == typeof e2)
      return "string" != typeof t2 || 1 != t2.length ? -1 : e2.lastIndexOf(t2, r2);
    for (; 0 <= r2; r2--)
      if (r2 in e2 && e2[r2] === t2)
        return r2;
    return -1;
  }, goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ? function(e2, t2, r2) {
    goog.asserts.assert(null != e2.length), Array.prototype.forEach.call(e2, t2, r2);
  } : function(e2, t2, r2) {
    for (var o2 = e2.length, i3 = "string" == typeof e2 ? e2.split("") : e2, a3 = 0; a3 < o2; a3++)
      a3 in i3 && t2.call(r2, i3[a3], a3, e2);
  }, goog.array.forEachRight = function(e2, t2, r2) {
    var o2 = e2.length, i3 = "string" == typeof e2 ? e2.split("") : e2;
    for (--o2; 0 <= o2; --o2)
      o2 in i3 && t2.call(r2, i3[o2], o2, e2);
  }, goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ? function(e2, t2, r2) {
    return goog.asserts.assert(null != e2.length), Array.prototype.filter.call(e2, t2, r2);
  } : function(e2, t2, r2) {
    for (var o2 = e2.length, i3 = [], a3 = 0, n2 = "string" == typeof e2 ? e2.split("") : e2, s2 = 0; s2 < o2; s2++)
      if (s2 in n2) {
        var p = n2[s2];
        t2.call(r2, p, s2, e2) && (i3[a3++] = p);
      }
    return i3;
  }, goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ? function(e2, t2, r2) {
    return goog.asserts.assert(null != e2.length), Array.prototype.map.call(e2, t2, r2);
  } : function(e2, t2, r2) {
    for (var o2 = e2.length, i3 = Array(o2), a3 = "string" == typeof e2 ? e2.split("") : e2, n2 = 0; n2 < o2; n2++)
      n2 in a3 && (i3[n2] = t2.call(r2, a3[n2], n2, e2));
    return i3;
  }, goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ? function(e2, t2, r2, o2) {
    return goog.asserts.assert(null != e2.length), o2 && (t2 = goog.bind(t2, o2)), Array.prototype.reduce.call(e2, t2, r2);
  } : function(e2, t2, r2, o2) {
    var i3 = r2;
    return goog.array.forEach(e2, function(r3, a3) {
      i3 = t2.call(o2, i3, r3, a3, e2);
    }), i3;
  }, goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ? function(e2, t2, r2, o2) {
    return goog.asserts.assert(null != e2.length), goog.asserts.assert(null != t2), o2 && (t2 = goog.bind(t2, o2)), Array.prototype.reduceRight.call(e2, t2, r2);
  } : function(e2, t2, r2, o2) {
    var i3 = r2;
    return goog.array.forEachRight(e2, function(r3, a3) {
      i3 = t2.call(o2, i3, r3, a3, e2);
    }), i3;
  }, goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ? function(e2, t2, r2) {
    return goog.asserts.assert(null != e2.length), Array.prototype.some.call(e2, t2, r2);
  } : function(e2, t2, r2) {
    for (var o2 = e2.length, i3 = "string" == typeof e2 ? e2.split("") : e2, a3 = 0; a3 < o2; a3++)
      if (a3 in i3 && t2.call(r2, i3[a3], a3, e2))
        return true;
    return false;
  }, goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ? function(e2, t2, r2) {
    return goog.asserts.assert(null != e2.length), Array.prototype.every.call(e2, t2, r2);
  } : function(e2, t2, r2) {
    for (var o2 = e2.length, i3 = "string" == typeof e2 ? e2.split("") : e2, a3 = 0; a3 < o2; a3++)
      if (a3 in i3 && !t2.call(r2, i3[a3], a3, e2))
        return false;
    return true;
  }, goog.array.count = function(e2, t2, r2) {
    var o2 = 0;
    return goog.array.forEach(e2, function(e3, i3, a3) {
      t2.call(r2, e3, i3, a3) && ++o2;
    }, r2), o2;
  }, goog.array.find = function(e2, t2, r2) {
    return 0 > (t2 = goog.array.findIndex(e2, t2, r2)) ? null : "string" == typeof e2 ? e2.charAt(t2) : e2[t2];
  }, goog.array.findIndex = function(e2, t2, r2) {
    for (var o2 = e2.length, i3 = "string" == typeof e2 ? e2.split("") : e2, a3 = 0; a3 < o2; a3++)
      if (a3 in i3 && t2.call(r2, i3[a3], a3, e2))
        return a3;
    return -1;
  }, goog.array.findRight = function(e2, t2, r2) {
    return 0 > (t2 = goog.array.findIndexRight(e2, t2, r2)) ? null : "string" == typeof e2 ? e2.charAt(t2) : e2[t2];
  }, goog.array.findIndexRight = function(e2, t2, r2) {
    var o2 = e2.length, i3 = "string" == typeof e2 ? e2.split("") : e2;
    for (--o2; 0 <= o2; o2--)
      if (o2 in i3 && t2.call(r2, i3[o2], o2, e2))
        return o2;
    return -1;
  }, goog.array.contains = function(e2, t2) {
    return 0 <= goog.array.indexOf(e2, t2);
  }, goog.array.isEmpty = function(e2) {
    return 0 == e2.length;
  }, goog.array.clear = function(e2) {
    if (!Array.isArray(e2))
      for (var t2 = e2.length - 1; 0 <= t2; t2--)
        delete e2[t2];
    e2.length = 0;
  }, goog.array.insert = function(e2, t2) {
    goog.array.contains(e2, t2) || e2.push(t2);
  }, goog.array.insertAt = function(e2, t2, r2) {
    goog.array.splice(e2, r2, 0, t2);
  }, goog.array.insertArrayAt = function(e2, t2, r2) {
    goog.partial(goog.array.splice, e2, r2, 0).apply(null, t2);
  }, goog.array.insertBefore = function(e2, t2, r2) {
    var o2;
    2 == arguments.length || 0 > (o2 = goog.array.indexOf(e2, r2)) ? e2.push(t2) : goog.array.insertAt(e2, t2, o2);
  }, goog.array.remove = function(e2, t2) {
    var r2;
    return (r2 = 0 <= (t2 = goog.array.indexOf(e2, t2))) && goog.array.removeAt(e2, t2), r2;
  }, goog.array.removeLast = function(e2, t2) {
    return 0 <= (t2 = goog.array.lastIndexOf(e2, t2)) && (goog.array.removeAt(e2, t2), true);
  }, goog.array.removeAt = function(e2, t2) {
    return goog.asserts.assert(null != e2.length), 1 == Array.prototype.splice.call(e2, t2, 1).length;
  }, goog.array.removeIf = function(e2, t2, r2) {
    return 0 <= (t2 = goog.array.findIndex(e2, t2, r2)) && (goog.array.removeAt(e2, t2), true);
  }, goog.array.removeAllIf = function(e2, t2, r2) {
    var o2 = 0;
    return goog.array.forEachRight(e2, function(i3, a3) {
      t2.call(r2, i3, a3, e2) && goog.array.removeAt(e2, a3) && o2++;
    }), o2;
  }, goog.array.concat = function(e2) {
    return Array.prototype.concat.apply([], arguments);
  }, goog.array.join = function(e2) {
    return Array.prototype.concat.apply([], arguments);
  }, goog.array.toArray = function(e2) {
    var t2 = e2.length;
    if (0 < t2) {
      for (var r2 = Array(t2), o2 = 0; o2 < t2; o2++)
        r2[o2] = e2[o2];
      return r2;
    }
    return [];
  }, goog.array.clone = goog.array.toArray, goog.array.extend = function(e2, t2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var o2 = arguments[r2];
      if (goog.isArrayLike(o2)) {
        var i3 = e2.length || 0, a3 = o2.length || 0;
        e2.length = i3 + a3;
        for (var n2 = 0; n2 < a3; n2++)
          e2[i3 + n2] = o2[n2];
      } else
        e2.push(o2);
    }
  }, goog.array.splice = function(e2, t2, r2, o2) {
    return goog.asserts.assert(null != e2.length), Array.prototype.splice.apply(e2, goog.array.slice(arguments, 1));
  }, goog.array.slice = function(e2, t2, r2) {
    return goog.asserts.assert(null != e2.length), 2 >= arguments.length ? Array.prototype.slice.call(e2, t2) : Array.prototype.slice.call(e2, t2, r2);
  }, goog.array.removeDuplicates = function(e2, t2, r2) {
    t2 = t2 || e2;
    var o2 = function(e3) {
      return goog.isObject(e3) ? "o" + goog.getUid(e3) : (typeof e3).charAt(0) + e3;
    };
    r2 = r2 || o2, o2 = {};
    for (var i3 = 0, a3 = 0; a3 < e2.length; ) {
      var n2 = e2[a3++], s2 = r2(n2);
      Object.prototype.hasOwnProperty.call(o2, s2) || (o2[s2] = true, t2[i3++] = n2);
    }
    t2.length = i3;
  }, goog.array.binarySearch = function(e2, t2, r2) {
    return goog.array.binarySearch_(e2, r2 || goog.array.defaultCompare, false, t2);
  }, goog.array.binarySelect = function(e2, t2, r2) {
    return goog.array.binarySearch_(e2, t2, true, void 0, r2);
  }, goog.array.binarySearch_ = function(e2, t2, r2, o2, i3) {
    for (var a3, n2 = 0, s2 = e2.length; n2 < s2; ) {
      var p = n2 + (s2 - n2 >>> 1), d2 = r2 ? t2.call(i3, e2[p], p, e2) : t2(o2, e2[p]);
      0 < d2 ? n2 = p + 1 : (s2 = p, a3 = !d2);
    }
    return a3 ? n2 : -n2 - 1;
  }, goog.array.sort = function(e2, t2) {
    e2.sort(t2 || goog.array.defaultCompare);
  }, goog.array.stableSort = function(e2, t2) {
    for (var r2 = Array(e2.length), o2 = 0; o2 < e2.length; o2++)
      r2[o2] = { index: o2, value: e2[o2] };
    var i3 = t2 || goog.array.defaultCompare;
    for (goog.array.sort(r2, function(e3, t3) {
      return i3(e3.value, t3.value) || e3.index - t3.index;
    }), o2 = 0; o2 < e2.length; o2++)
      e2[o2] = r2[o2].value;
  }, goog.array.sortByKey = function(e2, t2, r2) {
    var o2 = r2 || goog.array.defaultCompare;
    goog.array.sort(e2, function(e3, r3) {
      return o2(t2(e3), t2(r3));
    });
  }, goog.array.sortObjectsByKey = function(e2, t2, r2) {
    goog.array.sortByKey(e2, function(e3) {
      return e3[t2];
    }, r2);
  }, goog.array.isSorted = function(e2, t2, r2) {
    t2 = t2 || goog.array.defaultCompare;
    for (var o2 = 1; o2 < e2.length; o2++) {
      var i3 = t2(e2[o2 - 1], e2[o2]);
      if (0 < i3 || 0 == i3 && r2)
        return false;
    }
    return true;
  }, goog.array.equals = function(e2, t2, r2) {
    if (!goog.isArrayLike(e2) || !goog.isArrayLike(t2) || e2.length != t2.length)
      return false;
    var o2 = e2.length;
    r2 = r2 || goog.array.defaultCompareEquality;
    for (var i3 = 0; i3 < o2; i3++)
      if (!r2(e2[i3], t2[i3]))
        return false;
    return true;
  }, goog.array.compare3 = function(e2, t2, r2) {
    r2 = r2 || goog.array.defaultCompare;
    for (var o2 = Math.min(e2.length, t2.length), i3 = 0; i3 < o2; i3++) {
      var a3 = r2(e2[i3], t2[i3]);
      if (0 != a3)
        return a3;
    }
    return goog.array.defaultCompare(e2.length, t2.length);
  }, goog.array.defaultCompare = function(e2, t2) {
    return e2 > t2 ? 1 : e2 < t2 ? -1 : 0;
  }, goog.array.inverseDefaultCompare = function(e2, t2) {
    return -goog.array.defaultCompare(e2, t2);
  }, goog.array.defaultCompareEquality = function(e2, t2) {
    return e2 === t2;
  }, goog.array.binaryInsert = function(e2, t2, r2) {
    return 0 > (r2 = goog.array.binarySearch(e2, t2, r2)) && (goog.array.insertAt(e2, t2, -(r2 + 1)), true);
  }, goog.array.binaryRemove = function(e2, t2, r2) {
    return 0 <= (t2 = goog.array.binarySearch(e2, t2, r2)) && goog.array.removeAt(e2, t2);
  }, goog.array.bucket = function(e2, t2, r2) {
    for (var o2 = {}, i3 = 0; i3 < e2.length; i3++) {
      var a3 = e2[i3], n2 = t2.call(r2, a3, i3, e2);
      void 0 !== n2 && (o2[n2] || (o2[n2] = [])).push(a3);
    }
    return o2;
  }, goog.array.toObject = function(e2, t2, r2) {
    var o2 = {};
    return goog.array.forEach(e2, function(i3, a3) {
      o2[t2.call(r2, i3, a3, e2)] = i3;
    }), o2;
  }, goog.array.range = function(e2, t2, r2) {
    var o2 = [], i3 = 0, a3 = e2;
    if (void 0 !== t2 && (i3 = e2, a3 = t2), 0 > (r2 = r2 || 1) * (a3 - i3))
      return [];
    if (0 < r2)
      for (e2 = i3; e2 < a3; e2 += r2)
        o2.push(e2);
    else
      for (e2 = i3; e2 > a3; e2 += r2)
        o2.push(e2);
    return o2;
  }, goog.array.repeat = function(e2, t2) {
    for (var r2 = [], o2 = 0; o2 < t2; o2++)
      r2[o2] = e2;
    return r2;
  }, goog.array.flatten = function(e2) {
    for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) {
      var o2 = arguments[r2];
      if (Array.isArray(o2))
        for (var i3 = 0; i3 < o2.length; i3 += 8192) {
          var a3 = goog.array.slice(o2, i3, i3 + 8192);
          a3 = goog.array.flatten.apply(null, a3);
          for (var n2 = 0; n2 < a3.length; n2++)
            t2.push(a3[n2]);
        }
      else
        t2.push(o2);
    }
    return t2;
  }, goog.array.rotate = function(e2, t2) {
    return goog.asserts.assert(null != e2.length), e2.length && (0 < (t2 %= e2.length) ? Array.prototype.unshift.apply(e2, e2.splice(-t2, t2)) : 0 > t2 && Array.prototype.push.apply(e2, e2.splice(0, -t2))), e2;
  }, goog.array.moveItem = function(e2, t2, r2) {
    goog.asserts.assert(0 <= t2 && t2 < e2.length), goog.asserts.assert(0 <= r2 && r2 < e2.length), t2 = Array.prototype.splice.call(e2, t2, 1), Array.prototype.splice.call(e2, r2, 0, t2[0]);
  }, goog.array.zip = function(e2) {
    if (!arguments.length)
      return [];
    for (var t2 = [], r2 = arguments[0].length, o2 = 1; o2 < arguments.length; o2++)
      arguments[o2].length < r2 && (r2 = arguments[o2].length);
    for (o2 = 0; o2 < r2; o2++) {
      for (var i3 = [], a3 = 0; a3 < arguments.length; a3++)
        i3.push(arguments[a3][o2]);
      t2.push(i3);
    }
    return t2;
  }, goog.array.shuffle = function(e2, t2) {
    t2 = t2 || Math.random;
    for (var r2 = e2.length - 1; 0 < r2; r2--) {
      var o2 = Math.floor(t2() * (r2 + 1)), i3 = e2[r2];
      e2[r2] = e2[o2], e2[o2] = i3;
    }
  }, goog.array.copyByIndex = function(e2, t2) {
    var r2 = [];
    return goog.array.forEach(t2, function(t3) {
      r2.push(e2[t3]);
    }), r2;
  }, goog.array.concatMap = function(e2, t2, r2) {
    return goog.array.concat.apply([], goog.array.map(e2, t2, r2));
  }, goog.crypt = {}, goog.crypt.stringToByteArray = function(e2) {
    for (var t2 = [], r2 = 0, o2 = 0; o2 < e2.length; o2++) {
      var i3 = e2.charCodeAt(o2);
      255 < i3 && (t2[r2++] = 255 & i3, i3 >>= 8), t2[r2++] = i3;
    }
    return t2;
  }, goog.crypt.byteArrayToString = function(e2) {
    if (8192 >= e2.length)
      return String.fromCharCode.apply(null, e2);
    for (var t2 = "", r2 = 0; r2 < e2.length; r2 += 8192) {
      var o2 = goog.array.slice(e2, r2, r2 + 8192);
      t2 += String.fromCharCode.apply(null, o2);
    }
    return t2;
  }, goog.crypt.byteArrayToHex = function(e2, t2) {
    return goog.array.map(e2, function(e3) {
      return 1 < (e3 = e3.toString(16)).length ? e3 : "0" + e3;
    }).join(t2 || "");
  }, goog.crypt.hexToByteArray = function(e2) {
    goog.asserts.assert(0 == e2.length % 2, "Key string length must be multiple of 2");
    for (var t2 = [], r2 = 0; r2 < e2.length; r2 += 2)
      t2.push(parseInt(e2.substring(r2, r2 + 2), 16));
    return t2;
  }, goog.crypt.stringToUtf8ByteArray = function(e2) {
    for (var t2 = [], r2 = 0, o2 = 0; o2 < e2.length; o2++) {
      var i3 = e2.charCodeAt(o2);
      128 > i3 ? t2[r2++] = i3 : (2048 > i3 ? t2[r2++] = i3 >> 6 | 192 : (55296 == (64512 & i3) && o2 + 1 < e2.length && 56320 == (64512 & e2.charCodeAt(o2 + 1)) ? (i3 = 65536 + ((1023 & i3) << 10) + (1023 & e2.charCodeAt(++o2)), t2[r2++] = i3 >> 18 | 240, t2[r2++] = i3 >> 12 & 63 | 128) : t2[r2++] = i3 >> 12 | 224, t2[r2++] = i3 >> 6 & 63 | 128), t2[r2++] = 63 & i3 | 128);
    }
    return t2;
  }, goog.crypt.utf8ByteArrayToString = function(e2) {
    for (var t2 = [], r2 = 0, o2 = 0; r2 < e2.length; ) {
      var i3 = e2[r2++];
      if (128 > i3)
        t2[o2++] = String.fromCharCode(i3);
      else if (191 < i3 && 224 > i3) {
        var a3 = e2[r2++];
        t2[o2++] = String.fromCharCode((31 & i3) << 6 | 63 & a3);
      } else if (239 < i3 && 365 > i3) {
        a3 = e2[r2++];
        var n2 = e2[r2++];
        i3 = ((7 & i3) << 18 | (63 & a3) << 12 | (63 & n2) << 6 | 63 & e2[r2++]) - 65536, t2[o2++] = String.fromCharCode(55296 + (i3 >> 10)), t2[o2++] = String.fromCharCode(56320 + (1023 & i3));
      } else
        a3 = e2[r2++], n2 = e2[r2++], t2[o2++] = String.fromCharCode((15 & i3) << 12 | (63 & a3) << 6 | 63 & n2);
    }
    return t2.join("");
  }, goog.crypt.xorByteArray = function(e2, t2) {
    goog.asserts.assert(e2.length == t2.length, "XOR array lengths must match");
    for (var r2 = [], o2 = 0; o2 < e2.length; o2++)
      r2.push(e2[o2] ^ t2[o2]);
    return r2;
  }, goog.dom.asserts = {}, goog.dom.asserts.assertIsLocation = function(e2) {
    if (goog.asserts.ENABLE_ASSERTS) {
      var t2 = goog.dom.asserts.getWindow_(e2);
      t2 && (!e2 || !(e2 instanceof t2.Location) && e2 instanceof t2.Element) && goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s", goog.dom.asserts.debugStringForType_(e2));
    }
    return e2;
  }, goog.dom.asserts.assertIsElementType_ = function(e2, t2) {
    if (goog.asserts.ENABLE_ASSERTS) {
      var r2 = goog.dom.asserts.getWindow_(e2);
      r2 && void 0 !== r2[t2] && (e2 && (e2 instanceof r2[t2] || !(e2 instanceof r2.Location || e2 instanceof r2.Element)) || goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s", t2, goog.dom.asserts.debugStringForType_(e2)));
    }
    return e2;
  }, goog.dom.asserts.assertIsHTMLAnchorElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLAnchorElement");
  }, goog.dom.asserts.assertIsHTMLButtonElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLButtonElement");
  }, goog.dom.asserts.assertIsHTMLLinkElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLLinkElement");
  }, goog.dom.asserts.assertIsHTMLImageElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLImageElement");
  }, goog.dom.asserts.assertIsHTMLAudioElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLAudioElement");
  }, goog.dom.asserts.assertIsHTMLVideoElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLVideoElement");
  }, goog.dom.asserts.assertIsHTMLInputElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLInputElement");
  }, goog.dom.asserts.assertIsHTMLTextAreaElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLTextAreaElement");
  }, goog.dom.asserts.assertIsHTMLCanvasElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLCanvasElement");
  }, goog.dom.asserts.assertIsHTMLEmbedElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLEmbedElement");
  }, goog.dom.asserts.assertIsHTMLFormElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLFormElement");
  }, goog.dom.asserts.assertIsHTMLFrameElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLFrameElement");
  }, goog.dom.asserts.assertIsHTMLIFrameElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLIFrameElement");
  }, goog.dom.asserts.assertIsHTMLObjectElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLObjectElement");
  }, goog.dom.asserts.assertIsHTMLScriptElement = function(e2) {
    return goog.dom.asserts.assertIsElementType_(e2, "HTMLScriptElement");
  }, goog.dom.asserts.debugStringForType_ = function(e2) {
    if (!goog.isObject(e2))
      return void 0 === e2 ? "undefined" : null === e2 ? "null" : typeof e2;
    try {
      return e2.constructor.displayName || e2.constructor.name || Object.prototype.toString.call(e2);
    } catch (e3) {
      return "<object could not be stringified>";
    }
  }, goog.dom.asserts.getWindow_ = function(e2) {
    try {
      var t2 = e2 && e2.ownerDocument, r2 = t2 && (t2.defaultView || t2.parentWindow);
      if ((r2 = r2 || goog.global).Element && r2.Location)
        return r2;
    } catch (e3) {
    }
    return null;
  }, goog.functions = {}, goog.functions.constant = function(e2) {
    return function() {
      return e2;
    };
  }, goog.functions.FALSE = function() {
    return false;
  }, goog.functions.TRUE = function() {
    return true;
  }, goog.functions.NULL = function() {
    return null;
  }, goog.functions.identity = function(e2, t2) {
    return e2;
  }, goog.functions.error = function(e2) {
    return function() {
      throw Error(e2);
    };
  }, goog.functions.fail = function(e2) {
    return function() {
      throw e2;
    };
  }, goog.functions.lock = function(e2, t2) {
    return t2 = t2 || 0, function() {
      return e2.apply(this, Array.prototype.slice.call(arguments, 0, t2));
    };
  }, goog.functions.nth = function(e2) {
    return function() {
      return arguments[e2];
    };
  }, goog.functions.partialRight = function(e2, t2) {
    var r2 = Array.prototype.slice.call(arguments, 1);
    return function() {
      var t3 = Array.prototype.slice.call(arguments);
      return t3.push.apply(t3, r2), e2.apply(this, t3);
    };
  }, goog.functions.withReturnValue = function(e2, t2) {
    return goog.functions.sequence(e2, goog.functions.constant(t2));
  }, goog.functions.equalTo = function(e2, t2) {
    return function(r2) {
      return t2 ? e2 == r2 : e2 === r2;
    };
  }, goog.functions.compose = function(e2, t2) {
    var r2 = arguments, o2 = r2.length;
    return function() {
      var e3;
      o2 && (e3 = r2[o2 - 1].apply(this, arguments));
      for (var t3 = o2 - 2; 0 <= t3; t3--)
        e3 = r2[t3].call(this, e3);
      return e3;
    };
  }, goog.functions.sequence = function(e2) {
    var t2 = arguments, r2 = t2.length;
    return function() {
      for (var e3, o2 = 0; o2 < r2; o2++)
        e3 = t2[o2].apply(this, arguments);
      return e3;
    };
  }, goog.functions.and = function(e2) {
    var t2 = arguments, r2 = t2.length;
    return function() {
      for (var e3 = 0; e3 < r2; e3++)
        if (!t2[e3].apply(this, arguments))
          return false;
      return true;
    };
  }, goog.functions.or = function(e2) {
    var t2 = arguments, r2 = t2.length;
    return function() {
      for (var e3 = 0; e3 < r2; e3++)
        if (t2[e3].apply(this, arguments))
          return true;
      return false;
    };
  }, goog.functions.not = function(e2) {
    return function() {
      return !e2.apply(this, arguments);
    };
  }, goog.functions.create = function(e2, t2) {
    var r2 = function() {
    };
    return r2.prototype = e2.prototype, r2 = new r2(), e2.apply(r2, Array.prototype.slice.call(arguments, 1)), r2;
  }, goog.functions.CACHE_RETURN_VALUE = true, goog.functions.cacheReturnValue = function(e2) {
    var t2, r2 = false;
    return function() {
      return goog.functions.CACHE_RETURN_VALUE ? (r2 || (t2 = e2(), r2 = true), t2) : e2();
    };
  }, goog.functions.once = function(e2) {
    var t2 = e2;
    return function() {
      if (t2) {
        var e3 = t2;
        t2 = null, e3();
      }
    };
  }, goog.functions.debounce = function(e2, t2, r2) {
    var o2 = 0;
    return function(i3) {
      goog.global.clearTimeout(o2);
      var a3 = arguments;
      o2 = goog.global.setTimeout(function() {
        e2.apply(r2, a3);
      }, t2);
    };
  }, goog.functions.throttle = function(e2, t2, r2) {
    var o2 = 0, i3 = false, a3 = [], n2 = function() {
      o2 = 0, i3 && (i3 = false, s2());
    }, s2 = function() {
      o2 = goog.global.setTimeout(n2, t2), e2.apply(r2, a3);
    };
    return function(e3) {
      a3 = arguments, o2 ? i3 = true : s2();
    };
  }, goog.functions.rateLimit = function(e2, t2, r2) {
    var o2 = 0, i3 = function() {
      o2 = 0;
    };
    return function(a3) {
      o2 || (o2 = goog.global.setTimeout(i3, t2), e2.apply(r2, arguments));
    };
  }, goog.dom.HtmlElement = function() {
  }, goog.dom.TagName = function(e2) {
    this.tagName_ = e2;
  }, goog.dom.TagName.prototype.toString = function() {
    return this.tagName_;
  }, goog.dom.TagName.A = new goog.dom.TagName("A"), goog.dom.TagName.ABBR = new goog.dom.TagName("ABBR"), goog.dom.TagName.ACRONYM = new goog.dom.TagName("ACRONYM"), goog.dom.TagName.ADDRESS = new goog.dom.TagName("ADDRESS"), goog.dom.TagName.APPLET = new goog.dom.TagName("APPLET"), goog.dom.TagName.AREA = new goog.dom.TagName("AREA"), goog.dom.TagName.ARTICLE = new goog.dom.TagName("ARTICLE"), goog.dom.TagName.ASIDE = new goog.dom.TagName("ASIDE"), goog.dom.TagName.AUDIO = new goog.dom.TagName("AUDIO"), goog.dom.TagName.B = new goog.dom.TagName("B"), goog.dom.TagName.BASE = new goog.dom.TagName("BASE"), goog.dom.TagName.BASEFONT = new goog.dom.TagName("BASEFONT"), goog.dom.TagName.BDI = new goog.dom.TagName("BDI"), goog.dom.TagName.BDO = new goog.dom.TagName("BDO"), goog.dom.TagName.BIG = new goog.dom.TagName("BIG"), goog.dom.TagName.BLOCKQUOTE = new goog.dom.TagName("BLOCKQUOTE"), goog.dom.TagName.BODY = new goog.dom.TagName("BODY"), goog.dom.TagName.BR = new goog.dom.TagName("BR"), goog.dom.TagName.BUTTON = new goog.dom.TagName("BUTTON"), goog.dom.TagName.CANVAS = new goog.dom.TagName("CANVAS"), goog.dom.TagName.CAPTION = new goog.dom.TagName("CAPTION"), goog.dom.TagName.CENTER = new goog.dom.TagName("CENTER"), goog.dom.TagName.CITE = new goog.dom.TagName("CITE"), goog.dom.TagName.CODE = new goog.dom.TagName("CODE"), goog.dom.TagName.COL = new goog.dom.TagName("COL"), goog.dom.TagName.COLGROUP = new goog.dom.TagName("COLGROUP"), goog.dom.TagName.COMMAND = new goog.dom.TagName("COMMAND"), goog.dom.TagName.DATA = new goog.dom.TagName("DATA"), goog.dom.TagName.DATALIST = new goog.dom.TagName("DATALIST"), goog.dom.TagName.DD = new goog.dom.TagName("DD"), goog.dom.TagName.DEL = new goog.dom.TagName("DEL"), goog.dom.TagName.DETAILS = new goog.dom.TagName("DETAILS"), goog.dom.TagName.DFN = new goog.dom.TagName("DFN"), goog.dom.TagName.DIALOG = new goog.dom.TagName("DIALOG"), goog.dom.TagName.DIR = new goog.dom.TagName("DIR"), goog.dom.TagName.DIV = new goog.dom.TagName("DIV"), goog.dom.TagName.DL = new goog.dom.TagName("DL"), goog.dom.TagName.DT = new goog.dom.TagName("DT"), goog.dom.TagName.EM = new goog.dom.TagName("EM"), goog.dom.TagName.EMBED = new goog.dom.TagName("EMBED"), goog.dom.TagName.FIELDSET = new goog.dom.TagName("FIELDSET"), goog.dom.TagName.FIGCAPTION = new goog.dom.TagName("FIGCAPTION"), goog.dom.TagName.FIGURE = new goog.dom.TagName("FIGURE"), goog.dom.TagName.FONT = new goog.dom.TagName("FONT"), goog.dom.TagName.FOOTER = new goog.dom.TagName("FOOTER"), goog.dom.TagName.FORM = new goog.dom.TagName("FORM"), goog.dom.TagName.FRAME = new goog.dom.TagName("FRAME"), goog.dom.TagName.FRAMESET = new goog.dom.TagName("FRAMESET"), goog.dom.TagName.H1 = new goog.dom.TagName("H1"), goog.dom.TagName.H2 = new goog.dom.TagName("H2"), goog.dom.TagName.H3 = new goog.dom.TagName("H3"), goog.dom.TagName.H4 = new goog.dom.TagName("H4"), goog.dom.TagName.H5 = new goog.dom.TagName("H5"), goog.dom.TagName.H6 = new goog.dom.TagName("H6"), goog.dom.TagName.HEAD = new goog.dom.TagName("HEAD"), goog.dom.TagName.HEADER = new goog.dom.TagName("HEADER"), goog.dom.TagName.HGROUP = new goog.dom.TagName("HGROUP"), goog.dom.TagName.HR = new goog.dom.TagName("HR"), goog.dom.TagName.HTML = new goog.dom.TagName("HTML"), goog.dom.TagName.I = new goog.dom.TagName("I"), goog.dom.TagName.IFRAME = new goog.dom.TagName("IFRAME"), goog.dom.TagName.IMG = new goog.dom.TagName("IMG"), goog.dom.TagName.INPUT = new goog.dom.TagName("INPUT"), goog.dom.TagName.INS = new goog.dom.TagName("INS"), goog.dom.TagName.ISINDEX = new goog.dom.TagName("ISINDEX"), goog.dom.TagName.KBD = new goog.dom.TagName("KBD"), goog.dom.TagName.KEYGEN = new goog.dom.TagName("KEYGEN"), goog.dom.TagName.LABEL = new goog.dom.TagName("LABEL"), goog.dom.TagName.LEGEND = new goog.dom.TagName("LEGEND"), goog.dom.TagName.LI = new goog.dom.TagName("LI"), goog.dom.TagName.LINK = new goog.dom.TagName("LINK"), goog.dom.TagName.MAIN = new goog.dom.TagName("MAIN"), goog.dom.TagName.MAP = new goog.dom.TagName("MAP"), goog.dom.TagName.MARK = new goog.dom.TagName("MARK"), goog.dom.TagName.MATH = new goog.dom.TagName("MATH"), goog.dom.TagName.MENU = new goog.dom.TagName("MENU"), goog.dom.TagName.MENUITEM = new goog.dom.TagName("MENUITEM"), goog.dom.TagName.META = new goog.dom.TagName("META"), goog.dom.TagName.METER = new goog.dom.TagName("METER"), goog.dom.TagName.NAV = new goog.dom.TagName("NAV"), goog.dom.TagName.NOFRAMES = new goog.dom.TagName("NOFRAMES"), goog.dom.TagName.NOSCRIPT = new goog.dom.TagName("NOSCRIPT"), goog.dom.TagName.OBJECT = new goog.dom.TagName("OBJECT"), goog.dom.TagName.OL = new goog.dom.TagName("OL"), goog.dom.TagName.OPTGROUP = new goog.dom.TagName("OPTGROUP"), goog.dom.TagName.OPTION = new goog.dom.TagName("OPTION"), goog.dom.TagName.OUTPUT = new goog.dom.TagName("OUTPUT"), goog.dom.TagName.P = new goog.dom.TagName("P"), goog.dom.TagName.PARAM = new goog.dom.TagName("PARAM"), goog.dom.TagName.PICTURE = new goog.dom.TagName("PICTURE"), goog.dom.TagName.PRE = new goog.dom.TagName("PRE"), goog.dom.TagName.PROGRESS = new goog.dom.TagName("PROGRESS"), goog.dom.TagName.Q = new goog.dom.TagName("Q"), goog.dom.TagName.RP = new goog.dom.TagName("RP"), goog.dom.TagName.RT = new goog.dom.TagName("RT"), goog.dom.TagName.RTC = new goog.dom.TagName("RTC"), goog.dom.TagName.RUBY = new goog.dom.TagName("RUBY"), goog.dom.TagName.S = new goog.dom.TagName("S"), goog.dom.TagName.SAMP = new goog.dom.TagName("SAMP"), goog.dom.TagName.SCRIPT = new goog.dom.TagName("SCRIPT"), goog.dom.TagName.SECTION = new goog.dom.TagName("SECTION"), goog.dom.TagName.SELECT = new goog.dom.TagName("SELECT"), goog.dom.TagName.SMALL = new goog.dom.TagName("SMALL"), goog.dom.TagName.SOURCE = new goog.dom.TagName("SOURCE"), goog.dom.TagName.SPAN = new goog.dom.TagName("SPAN"), goog.dom.TagName.STRIKE = new goog.dom.TagName("STRIKE"), goog.dom.TagName.STRONG = new goog.dom.TagName("STRONG"), goog.dom.TagName.STYLE = new goog.dom.TagName("STYLE"), goog.dom.TagName.SUB = new goog.dom.TagName("SUB"), goog.dom.TagName.SUMMARY = new goog.dom.TagName("SUMMARY"), goog.dom.TagName.SUP = new goog.dom.TagName("SUP"), goog.dom.TagName.SVG = new goog.dom.TagName("SVG"), goog.dom.TagName.TABLE = new goog.dom.TagName("TABLE"), goog.dom.TagName.TBODY = new goog.dom.TagName("TBODY"), goog.dom.TagName.TD = new goog.dom.TagName("TD"), goog.dom.TagName.TEMPLATE = new goog.dom.TagName("TEMPLATE"), goog.dom.TagName.TEXTAREA = new goog.dom.TagName("TEXTAREA"), goog.dom.TagName.TFOOT = new goog.dom.TagName("TFOOT"), goog.dom.TagName.TH = new goog.dom.TagName("TH"), goog.dom.TagName.THEAD = new goog.dom.TagName("THEAD"), goog.dom.TagName.TIME = new goog.dom.TagName("TIME"), goog.dom.TagName.TITLE = new goog.dom.TagName("TITLE"), goog.dom.TagName.TR = new goog.dom.TagName("TR"), goog.dom.TagName.TRACK = new goog.dom.TagName("TRACK"), goog.dom.TagName.TT = new goog.dom.TagName("TT"), goog.dom.TagName.U = new goog.dom.TagName("U"), goog.dom.TagName.UL = new goog.dom.TagName("UL"), goog.dom.TagName.VAR = new goog.dom.TagName("VAR"), goog.dom.TagName.VIDEO = new goog.dom.TagName("VIDEO"), goog.dom.TagName.WBR = new goog.dom.TagName("WBR"), goog.dom.tags = {}, goog.dom.tags.VOID_TAGS_ = { area: true, base: true, br: true, col: true, command: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true }, goog.dom.tags.isVoidTag = function(e2) {
    return true === goog.dom.tags.VOID_TAGS_[e2];
  }, goog.html = {}, goog.html.trustedtypes = {}, goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#html") : null, goog.string = {}, goog.string.TypedString = function() {
  }, goog.string.Const = function(e2, t2) {
    this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ = e2 === goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ && t2 || "", this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ = goog.string.Const.TYPE_MARKER_;
  }, goog.string.Const.prototype.implementsGoogStringTypedString = true, goog.string.Const.prototype.getTypedStringValue = function() {
    return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
  }, goog.DEBUG && (goog.string.Const.prototype.toString = function() {
    return "Const{" + this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ + "}";
  }), goog.string.Const.unwrap = function(e2) {
    return e2 instanceof goog.string.Const && e2.constructor === goog.string.Const && e2.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ === goog.string.Const.TYPE_MARKER_ ? e2.stringConstValueWithSecurityContract__googStringSecurityPrivate_ : (goog.asserts.fail("expected object of type Const, got '" + e2 + "'"), "type_error:Const");
  }, goog.string.Const.from = function(e2) {
    return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_, e2);
  }, goog.string.Const.TYPE_MARKER_ = {}, goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.string.Const.EMPTY = goog.string.Const.from(""), goog.html.SafeScript = function() {
    this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = "", this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeScript.prototype.implementsGoogStringTypedString = true, goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeScript.fromConstant = function(e2) {
    return 0 === (e2 = goog.string.Const.unwrap(e2)).length ? goog.html.SafeScript.EMPTY : goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.SafeScript.fromConstantAndArgs = function(e2, t2) {
    for (var r2 = [], o2 = 1; o2 < arguments.length; o2++)
      r2.push(goog.html.SafeScript.stringify_(arguments[o2]));
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("(" + goog.string.Const.unwrap(e2) + ")(" + r2.join(", ") + ");");
  }, goog.html.SafeScript.fromJson = function(e2) {
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(e2));
  }, goog.html.SafeScript.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString();
  }, goog.DEBUG && (goog.html.SafeScript.prototype.toString = function() {
    return "SafeScript{" + this.privateDoNotAccessOrElseSafeScriptWrappedValue_ + "}";
  }), goog.html.SafeScript.unwrap = function(e2) {
    return goog.html.SafeScript.unwrapTrustedScript(e2).toString();
  }, goog.html.SafeScript.unwrapTrustedScript = function(e2) {
    return e2 instanceof goog.html.SafeScript && e2.constructor === goog.html.SafeScript && e2.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e2.privateDoNotAccessOrElseSafeScriptWrappedValue_ : (goog.asserts.fail("expected object of type SafeScript, got '" + e2 + "' of type " + goog.typeOf(e2)), "type_error:SafeScript");
  }, goog.html.SafeScript.stringify_ = function(e2) {
    return JSON.stringify(e2).replace(/</g, "\\x3c");
  }, goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse = function(e2) {
    return new goog.html.SafeScript().initSecurityPrivateDoNotAccessOrElse_(e2);
  }, goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(e2) {
    return this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(e2) : e2, this;
  }, goog.html.SafeScript.EMPTY = goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(""), goog.fs = {}, goog.fs.url = {}, goog.fs.url.createObjectUrl = function(e2) {
    return goog.fs.url.getUrlObject_().createObjectURL(e2);
  }, goog.fs.url.revokeObjectUrl = function(e2) {
    goog.fs.url.getUrlObject_().revokeObjectURL(e2);
  }, goog.fs.url.UrlObject_ = function() {
  }, goog.fs.url.UrlObject_.prototype.createObjectURL = function(e2) {
  }, goog.fs.url.UrlObject_.prototype.revokeObjectURL = function(e2) {
  }, goog.fs.url.getUrlObject_ = function() {
    var e2 = goog.fs.url.findUrlObject_();
    if (null != e2)
      return e2;
    throw Error("This browser doesn't seem to support blob URLs");
  }, goog.fs.url.findUrlObject_ = function() {
    return void 0 !== goog.global.URL && void 0 !== goog.global.URL.createObjectURL ? goog.global.URL : void 0 !== goog.global.webkitURL && void 0 !== goog.global.webkitURL.createObjectURL ? goog.global.webkitURL : void 0 !== goog.global.createObjectURL ? goog.global : null;
  }, goog.fs.url.browserSupportsObjectUrls = function() {
    return null != goog.fs.url.findUrlObject_();
  }, goog.fs.blob = {}, goog.fs.blob.getBlob = function(e2) {
    var t2 = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;
    if (void 0 !== t2) {
      t2 = new t2();
      for (var r2 = 0; r2 < arguments.length; r2++)
        t2.append(arguments[r2]);
      return t2.getBlob();
    }
    return goog.fs.blob.getBlobWithProperties(goog.array.toArray(arguments));
  }, goog.fs.blob.getBlobWithProperties = function(e2, t2, r2) {
    var o2 = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;
    if (void 0 !== o2) {
      o2 = new o2();
      for (var i3 = 0; i3 < e2.length; i3++)
        o2.append(e2[i3], r2);
      return o2.getBlob(t2);
    }
    if (void 0 !== goog.global.Blob)
      return o2 = {}, t2 && (o2.type = t2), r2 && (o2.endings = r2), new Blob(e2, o2);
    throw Error("This browser doesn't seem to support creating Blobs");
  }, goog.i18n = {}, goog.i18n.bidi = {}, goog.i18n.bidi.FORCE_RTL = false, goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || ("ar" == goog.LOCALE.substring(0, 2).toLowerCase() || "fa" == goog.LOCALE.substring(0, 2).toLowerCase() || "he" == goog.LOCALE.substring(0, 2).toLowerCase() || "iw" == goog.LOCALE.substring(0, 2).toLowerCase() || "ps" == goog.LOCALE.substring(0, 2).toLowerCase() || "sd" == goog.LOCALE.substring(0, 2).toLowerCase() || "ug" == goog.LOCALE.substring(0, 2).toLowerCase() || "ur" == goog.LOCALE.substring(0, 2).toLowerCase() || "yi" == goog.LOCALE.substring(0, 2).toLowerCase()) && (2 == goog.LOCALE.length || "-" == goog.LOCALE.substring(2, 3) || "_" == goog.LOCALE.substring(2, 3)) || 3 <= goog.LOCALE.length && "ckb" == goog.LOCALE.substring(0, 3).toLowerCase() && (3 == goog.LOCALE.length || "-" == goog.LOCALE.substring(3, 4) || "_" == goog.LOCALE.substring(3, 4)) || 7 <= goog.LOCALE.length && ("-" == goog.LOCALE.substring(2, 3) || "_" == goog.LOCALE.substring(2, 3)) && ("adlm" == goog.LOCALE.substring(3, 7).toLowerCase() || "arab" == goog.LOCALE.substring(3, 7).toLowerCase() || "hebr" == goog.LOCALE.substring(3, 7).toLowerCase() || "nkoo" == goog.LOCALE.substring(3, 7).toLowerCase() || "rohg" == goog.LOCALE.substring(3, 7).toLowerCase() || "thaa" == goog.LOCALE.substring(3, 7).toLowerCase()) || 8 <= goog.LOCALE.length && ("-" == goog.LOCALE.substring(3, 4) || "_" == goog.LOCALE.substring(3, 4)) && ("adlm" == goog.LOCALE.substring(4, 8).toLowerCase() || "arab" == goog.LOCALE.substring(4, 8).toLowerCase() || "hebr" == goog.LOCALE.substring(4, 8).toLowerCase() || "nkoo" == goog.LOCALE.substring(4, 8).toLowerCase() || "rohg" == goog.LOCALE.substring(4, 8).toLowerCase() || "thaa" == goog.LOCALE.substring(4, 8).toLowerCase()), goog.i18n.bidi.Format = { LRE: "‪", RLE: "‫", PDF: "‬", LRM: "‎", RLM: "‏" }, goog.i18n.bidi.Dir = { LTR: 1, RTL: -1, NEUTRAL: 0 }, goog.i18n.bidi.RIGHT = "right", goog.i18n.bidi.LEFT = "left", goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT, goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, goog.i18n.bidi.toDir = function(e2, t2) {
    return "number" == typeof e2 ? 0 < e2 ? goog.i18n.bidi.Dir.LTR : 0 > e2 ? goog.i18n.bidi.Dir.RTL : t2 ? null : goog.i18n.bidi.Dir.NEUTRAL : null == e2 ? null : e2 ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
  }, goog.i18n.bidi.ltrChars_ = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ऀ-῿‎Ⰰ-\uD801\uD804-\uD839\uD83C-\uDBFF豈-﬜︀-﹯﻽-￿", goog.i18n.bidi.rtlChars_ = "֑-ۯۺ-ࣿ‏\uD802-\uD803\uD83A-\uD83Bיִ-﷿ﹰ-ﻼ", goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g, goog.i18n.bidi.stripHtmlIfNeeded_ = function(e2, t2) {
    return t2 ? e2.replace(goog.i18n.bidi.htmlSkipReg_, "") : e2;
  }, goog.i18n.bidi.rtlCharReg_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.ltrCharReg_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.hasAnyRtl = function(e2, t2) {
    return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e2, t2));
  }, goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl, goog.i18n.bidi.hasAnyLtr = function(e2, t2) {
    return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e2, t2));
  }, goog.i18n.bidi.ltrRe_ = new RegExp("^[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.rtlRe_ = new RegExp("^[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.isRtlChar = function(e2) {
    return goog.i18n.bidi.rtlRe_.test(e2);
  }, goog.i18n.bidi.isLtrChar = function(e2) {
    return goog.i18n.bidi.ltrRe_.test(e2);
  }, goog.i18n.bidi.isNeutralChar = function(e2) {
    return !goog.i18n.bidi.isLtrChar(e2) && !goog.i18n.bidi.isRtlChar(e2);
  }, goog.i18n.bidi.ltrDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.rtlChars_ + "]*[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.rtlDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.ltrChars_ + "]*[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.startsWithRtl = function(e2, t2) {
    return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e2, t2));
  }, goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl, goog.i18n.bidi.startsWithLtr = function(e2, t2) {
    return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e2, t2));
  }, goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr, goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/, goog.i18n.bidi.isNeutralText = function(e2, t2) {
    return e2 = goog.i18n.bidi.stripHtmlIfNeeded_(e2, t2), goog.i18n.bidi.isRequiredLtrRe_.test(e2) || !goog.i18n.bidi.hasAnyLtr(e2) && !goog.i18n.bidi.hasAnyRtl(e2);
  }, goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "][^" + goog.i18n.bidi.rtlChars_ + "]*$"), goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "][^" + goog.i18n.bidi.ltrChars_ + "]*$"), goog.i18n.bidi.endsWithLtr = function(e2, t2) {
    return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e2, t2));
  }, goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr, goog.i18n.bidi.endsWithRtl = function(e2, t2) {
    return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e2, t2));
  }, goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl, goog.i18n.bidi.rtlLocalesRe_ = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i, goog.i18n.bidi.isRtlLanguage = function(e2) {
    return goog.i18n.bidi.rtlLocalesRe_.test(e2);
  }, goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g, goog.i18n.bidi.guardBracketInText = function(e2, t2) {
    return t2 = (void 0 === t2 ? goog.i18n.bidi.hasAnyRtl(e2) : t2) ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM, e2.replace(goog.i18n.bidi.bracketGuardTextRe_, t2 + "$&" + t2);
  }, goog.i18n.bidi.enforceRtlInHtml = function(e2) {
    return "<" == e2.charAt(0) ? e2.replace(/<\w+/, "$& dir=rtl") : "\n<span dir=rtl>" + e2 + "</span>";
  }, goog.i18n.bidi.enforceRtlInText = function(e2) {
    return goog.i18n.bidi.Format.RLE + e2 + goog.i18n.bidi.Format.PDF;
  }, goog.i18n.bidi.enforceLtrInHtml = function(e2) {
    return "<" == e2.charAt(0) ? e2.replace(/<\w+/, "$& dir=ltr") : "\n<span dir=ltr>" + e2 + "</span>";
  }, goog.i18n.bidi.enforceLtrInText = function(e2) {
    return goog.i18n.bidi.Format.LRE + e2 + goog.i18n.bidi.Format.PDF;
  }, goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g, goog.i18n.bidi.leftRe_ = /left/gi, goog.i18n.bidi.rightRe_ = /right/gi, goog.i18n.bidi.tempRe_ = /%%%%/g, goog.i18n.bidi.mirrorCSS = function(e2) {
    return e2.replace(goog.i18n.bidi.dimensionsRe_, ":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_, "%%%%").replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
  }, goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g, goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g, goog.i18n.bidi.normalizeHebrewQuote = function(e2) {
    return e2.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, "$1״").replace(goog.i18n.bidi.singleQuoteSubstituteRe_, "$1׳");
  }, goog.i18n.bidi.wordSeparatorRe_ = /\s+/, goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/, goog.i18n.bidi.rtlDetectionThreshold_ = 0.4, goog.i18n.bidi.estimateDirection = function(e2, t2) {
    var r2 = 0, o2 = 0, i3 = false;
    for (e2 = goog.i18n.bidi.stripHtmlIfNeeded_(e2, t2).split(goog.i18n.bidi.wordSeparatorRe_), t2 = 0; t2 < e2.length; t2++) {
      var a3 = e2[t2];
      goog.i18n.bidi.startsWithRtl(a3) ? (r2++, o2++) : goog.i18n.bidi.isRequiredLtrRe_.test(a3) ? i3 = true : goog.i18n.bidi.hasAnyLtr(a3) ? o2++ : goog.i18n.bidi.hasNumeralsRe_.test(a3) && (i3 = true);
    }
    return 0 == o2 ? i3 ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : r2 / o2 > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
  }, goog.i18n.bidi.detectRtlDirectionality = function(e2, t2) {
    return goog.i18n.bidi.estimateDirection(e2, t2) == goog.i18n.bidi.Dir.RTL;
  }, goog.i18n.bidi.setElementDirAndAlign = function(e2, t2) {
    e2 && (t2 = goog.i18n.bidi.toDir(t2)) && (e2.style.textAlign = t2 == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, e2.dir = t2 == goog.i18n.bidi.Dir.RTL ? "rtl" : "ltr");
  }, goog.i18n.bidi.setElementDirByTextDirectionality = function(e2, t2) {
    switch (goog.i18n.bidi.estimateDirection(t2)) {
      case goog.i18n.bidi.Dir.LTR:
        e2.dir = "ltr";
        break;
      case goog.i18n.bidi.Dir.RTL:
        e2.dir = "rtl";
        break;
      default:
        e2.removeAttribute("dir");
    }
  }, goog.i18n.bidi.DirectionalString = function() {
  }, goog.html.TrustedResourceUrl = function(e2, t2) {
    this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = e2 === goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ && t2 || "", this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString = true, goog.html.TrustedResourceUrl.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString();
  }, goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString = true, goog.html.TrustedResourceUrl.prototype.getDirection = function() {
    return goog.i18n.bidi.Dir.LTR;
  }, goog.html.TrustedResourceUrl.prototype.cloneWithParams = function(e2, t2) {
    var r2 = goog.html.TrustedResourceUrl.unwrap(this), o2 = (r2 = goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(r2))[3] || "";
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(r2[1] + goog.html.TrustedResourceUrl.stringifyParams_("?", r2[2] || "", e2) + goog.html.TrustedResourceUrl.stringifyParams_("#", o2, t2));
  }, goog.DEBUG && (goog.html.TrustedResourceUrl.prototype.toString = function() {
    return "TrustedResourceUrl{" + this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + "}";
  }), goog.html.TrustedResourceUrl.unwrap = function(e2) {
    return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(e2).toString();
  }, goog.html.TrustedResourceUrl.unwrapTrustedScriptURL = function(e2) {
    return e2 instanceof goog.html.TrustedResourceUrl && e2.constructor === goog.html.TrustedResourceUrl && e2.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e2.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ : (goog.asserts.fail("expected object of type TrustedResourceUrl, got '" + e2 + "' of type " + goog.typeOf(e2)), "type_error:TrustedResourceUrl");
  }, goog.html.TrustedResourceUrl.format = function(e2, t2) {
    var r2 = goog.string.Const.unwrap(e2);
    if (!goog.html.TrustedResourceUrl.BASE_URL_.test(r2))
      throw Error("Invalid TrustedResourceUrl format: " + r2);
    return e2 = r2.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_, function(e3, o2) {
      if (!Object.prototype.hasOwnProperty.call(t2, o2))
        throw Error('Found marker, "' + o2 + '", in format string, "' + r2 + '", but no valid label mapping found in args: ' + JSON.stringify(t2));
      return (e3 = t2[o2]) instanceof goog.string.Const ? goog.string.Const.unwrap(e3) : encodeURIComponent(String(e3));
    }), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.TrustedResourceUrl.FORMAT_MARKER_ = /%{(\w+)}/g, goog.html.TrustedResourceUrl.BASE_URL_ = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i, goog.html.TrustedResourceUrl.URL_PARAM_PARSER_ = /^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/, goog.html.TrustedResourceUrl.formatWithParams = function(e2, t2, r2, o2) {
    return goog.html.TrustedResourceUrl.format(e2, t2).cloneWithParams(r2, o2);
  }, goog.html.TrustedResourceUrl.fromConstant = function(e2) {
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(e2));
  }, goog.html.TrustedResourceUrl.fromConstants = function(e2) {
    for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
      t2 += goog.string.Const.unwrap(e2[r2]);
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(t2);
  }, goog.html.TrustedResourceUrl.fromSafeScript = function(e2) {
    return e2 = goog.fs.blob.getBlobWithProperties([goog.html.SafeScript.unwrap(e2)], "text/javascript"), e2 = goog.fs.url.createObjectUrl(e2), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(e2) {
    return e2 = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(e2) : e2, new goog.html.TrustedResourceUrl(goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_, e2);
  }, goog.html.TrustedResourceUrl.stringifyParams_ = function(e2, t2, r2) {
    if (null == r2)
      return t2;
    if ("string" == typeof r2)
      return r2 ? e2 + encodeURIComponent(r2) : "";
    for (var o2 in r2) {
      var i3 = r2[o2];
      i3 = Array.isArray(i3) ? i3 : [i3];
      for (var a3 = 0; a3 < i3.length; a3++) {
        var n2 = i3[a3];
        null != n2 && (t2 || (t2 = e2), t2 += (t2.length > e2.length ? "&" : "") + encodeURIComponent(o2) + "=" + encodeURIComponent(String(n2)));
      }
    }
    return t2;
  }, goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.string.internal = {}, goog.string.internal.startsWith = function(e2, t2) {
    return 0 == e2.lastIndexOf(t2, 0);
  }, goog.string.internal.endsWith = function(e2, t2) {
    var r2 = e2.length - t2.length;
    return 0 <= r2 && e2.indexOf(t2, r2) == r2;
  }, goog.string.internal.caseInsensitiveStartsWith = function(e2, t2) {
    return 0 == goog.string.internal.caseInsensitiveCompare(t2, e2.substr(0, t2.length));
  }, goog.string.internal.caseInsensitiveEndsWith = function(e2, t2) {
    return 0 == goog.string.internal.caseInsensitiveCompare(t2, e2.substr(e2.length - t2.length, t2.length));
  }, goog.string.internal.caseInsensitiveEquals = function(e2, t2) {
    return e2.toLowerCase() == t2.toLowerCase();
  }, goog.string.internal.isEmptyOrWhitespace = function(e2) {
    return /^[\s\xa0]*$/.test(e2);
  }, goog.string.internal.trim = goog.TRUSTED_SITE && String.prototype.trim ? function(e2) {
    return e2.trim();
  } : function(e2) {
    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(e2)[1];
  }, goog.string.internal.caseInsensitiveCompare = function(e2, t2) {
    return (e2 = String(e2).toLowerCase()) < (t2 = String(t2).toLowerCase()) ? -1 : e2 == t2 ? 0 : 1;
  }, goog.string.internal.newLineToBr = function(e2, t2) {
    return e2.replace(/(\r\n|\r|\n)/g, t2 ? "<br />" : "<br>");
  }, goog.string.internal.htmlEscape = function(e2, t2) {
    if (t2)
      e2 = e2.replace(goog.string.internal.AMP_RE_, "&amp;").replace(goog.string.internal.LT_RE_, "&lt;").replace(goog.string.internal.GT_RE_, "&gt;").replace(goog.string.internal.QUOT_RE_, "&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;").replace(goog.string.internal.NULL_RE_, "&#0;");
    else {
      if (!goog.string.internal.ALL_RE_.test(e2))
        return e2;
      -1 != e2.indexOf("&") && (e2 = e2.replace(goog.string.internal.AMP_RE_, "&amp;")), -1 != e2.indexOf("<") && (e2 = e2.replace(goog.string.internal.LT_RE_, "&lt;")), -1 != e2.indexOf(">") && (e2 = e2.replace(goog.string.internal.GT_RE_, "&gt;")), -1 != e2.indexOf('"') && (e2 = e2.replace(goog.string.internal.QUOT_RE_, "&quot;")), -1 != e2.indexOf("'") && (e2 = e2.replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;")), -1 != e2.indexOf("\0") && (e2 = e2.replace(goog.string.internal.NULL_RE_, "&#0;"));
    }
    return e2;
  }, goog.string.internal.AMP_RE_ = /&/g, goog.string.internal.LT_RE_ = /</g, goog.string.internal.GT_RE_ = />/g, goog.string.internal.QUOT_RE_ = /"/g, goog.string.internal.SINGLE_QUOTE_RE_ = /'/g, goog.string.internal.NULL_RE_ = /\x00/g, goog.string.internal.ALL_RE_ = /[\x00&<>"']/, goog.string.internal.whitespaceEscape = function(e2, t2) {
    return goog.string.internal.newLineToBr(e2.replace(/  /g, " &#160;"), t2);
  }, goog.string.internal.contains = function(e2, t2) {
    return -1 != e2.indexOf(t2);
  }, goog.string.internal.caseInsensitiveContains = function(e2, t2) {
    return goog.string.internal.contains(e2.toLowerCase(), t2.toLowerCase());
  }, goog.string.internal.compareVersions = function(e2, t2) {
    var r2 = 0;
    e2 = goog.string.internal.trim(String(e2)).split("."), t2 = goog.string.internal.trim(String(t2)).split(".");
    for (var o2 = Math.max(e2.length, t2.length), i3 = 0; 0 == r2 && i3 < o2; i3++) {
      var a3 = e2[i3] || "", n2 = t2[i3] || "";
      do {
        if (a3 = /(\d*)(\D*)(.*)/.exec(a3) || ["", "", "", ""], n2 = /(\d*)(\D*)(.*)/.exec(n2) || ["", "", "", ""], 0 == a3[0].length && 0 == n2[0].length)
          break;
        r2 = 0 == a3[1].length ? 0 : parseInt(a3[1], 10);
        var s2 = 0 == n2[1].length ? 0 : parseInt(n2[1], 10);
        r2 = goog.string.internal.compareElements_(r2, s2) || goog.string.internal.compareElements_(0 == a3[2].length, 0 == n2[2].length) || goog.string.internal.compareElements_(a3[2], n2[2]), a3 = a3[3], n2 = n2[3];
      } while (0 == r2);
    }
    return r2;
  }, goog.string.internal.compareElements_ = function(e2, t2) {
    return e2 < t2 ? -1 : e2 > t2 ? 1 : 0;
  }, goog.html.SafeUrl = function(e2, t2) {
    this.privateDoNotAccessOrElseSafeUrlWrappedValue_ = e2 === goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_ && t2 || "", this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeUrl.INNOCUOUS_STRING = "about:invalid#zClosurez", goog.html.SafeUrl.prototype.implementsGoogStringTypedString = true, goog.html.SafeUrl.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString();
  }, goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString = true, goog.html.SafeUrl.prototype.getDirection = function() {
    return goog.i18n.bidi.Dir.LTR;
  }, goog.DEBUG && (goog.html.SafeUrl.prototype.toString = function() {
    return "SafeUrl{" + this.privateDoNotAccessOrElseSafeUrlWrappedValue_ + "}";
  }), goog.html.SafeUrl.unwrap = function(e2) {
    return e2 instanceof goog.html.SafeUrl && e2.constructor === goog.html.SafeUrl && e2.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e2.privateDoNotAccessOrElseSafeUrlWrappedValue_ : (goog.asserts.fail("expected object of type SafeUrl, got '" + e2 + "' of type " + goog.typeOf(e2)), "type_error:SafeUrl");
  }, goog.html.SafeUrl.fromConstant = function(e2) {
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(e2));
  }, goog.html.SAFE_MIME_TYPE_PATTERN_ = /^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime|x-matroska))(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i, goog.html.SafeUrl.isSafeMimeType = function(e2) {
    return goog.html.SAFE_MIME_TYPE_PATTERN_.test(e2);
  }, goog.html.SafeUrl.fromBlob = function(e2) {
    return e2 = goog.html.SafeUrl.isSafeMimeType(e2.type) ? goog.fs.url.createObjectUrl(e2) : goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.SafeUrl.fromMediaSource = function(e2) {
    return goog.asserts.assert("MediaSource" in goog.global, "No support for MediaSource"), e2 = e2 instanceof MediaSource ? goog.fs.url.createObjectUrl(e2) : goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.DATA_URL_PATTERN_ = /^data:(.*);base64,[a-z0-9+\/]+=*$/i, goog.html.SafeUrl.fromDataUrl = function(e2) {
    var t2 = (e2 = e2.replace(/(%0A|%0D)/g, "")).match(goog.html.DATA_URL_PATTERN_);
    return t2 = t2 && goog.html.SafeUrl.isSafeMimeType(t2[1]), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(t2 ? e2 : goog.html.SafeUrl.INNOCUOUS_STRING);
  }, goog.html.SafeUrl.fromTelUrl = function(e2) {
    return goog.string.internal.caseInsensitiveStartsWith(e2, "tel:") || (e2 = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.SIP_URL_PATTERN_ = /^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i, goog.html.SafeUrl.fromSipUrl = function(e2) {
    return goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(e2)) || (e2 = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.SafeUrl.fromFacebookMessengerUrl = function(e2) {
    return goog.string.internal.caseInsensitiveStartsWith(e2, "fb-messenger://share") || (e2 = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.SafeUrl.fromWhatsAppUrl = function(e2) {
    return goog.string.internal.caseInsensitiveStartsWith(e2, "whatsapp://send") || (e2 = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.SafeUrl.fromSmsUrl = function(e2) {
    return goog.string.internal.caseInsensitiveStartsWith(e2, "sms:") && goog.html.SafeUrl.isSmsUrlBodyValid_(e2) || (e2 = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.SafeUrl.isSmsUrlBodyValid_ = function(e2) {
    var t2 = e2.indexOf("#");
    if (0 < t2 && (e2 = e2.substring(0, t2)), !(t2 = e2.match(/[?&]body=/gi)))
      return true;
    if (1 < t2.length)
      return false;
    if (!(e2 = e2.match(/[?&]body=([^&]*)/)[1]))
      return true;
    try {
      decodeURIComponent(e2);
    } catch (e3) {
      return false;
    }
    return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(e2);
  }, goog.html.SafeUrl.fromSshUrl = function(e2) {
    return goog.string.internal.caseInsensitiveStartsWith(e2, "ssh://") || (e2 = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.SafeUrl.sanitizeChromeExtensionUrl = function(e2, t2) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//, e2, t2);
  }, goog.html.SafeUrl.sanitizeFirefoxExtensionUrl = function(e2, t2) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//, e2, t2);
  }, goog.html.SafeUrl.sanitizeEdgeExtensionUrl = function(e2, t2) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//, e2, t2);
  }, goog.html.SafeUrl.sanitizeExtensionUrl_ = function(e2, t2, r2) {
    return (e2 = e2.exec(t2)) ? (e2 = e2[1], -1 == (r2 instanceof goog.string.Const ? [goog.string.Const.unwrap(r2)] : r2.map(function(e3) {
      return goog.string.Const.unwrap(e3);
    })).indexOf(e2) && (t2 = goog.html.SafeUrl.INNOCUOUS_STRING)) : t2 = goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(t2);
  }, goog.html.SafeUrl.fromTrustedResourceUrl = function(e2) {
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(e2));
  }, goog.html.SAFE_URL_PATTERN_ = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i, goog.html.SafeUrl.SAFE_URL_PATTERN = goog.html.SAFE_URL_PATTERN_, goog.html.SafeUrl.sanitize = function(e2) {
    return e2 instanceof goog.html.SafeUrl ? e2 : (e2 = "object" == typeof e2 && e2.implementsGoogStringTypedString ? e2.getTypedStringValue() : String(e2), goog.html.SAFE_URL_PATTERN_.test(e2) || (e2 = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2));
  }, goog.html.SafeUrl.sanitizeAssertUnchanged = function(e2, t2) {
    return e2 instanceof goog.html.SafeUrl ? e2 : (e2 = "object" == typeof e2 && e2.implementsGoogStringTypedString ? e2.getTypedStringValue() : String(e2), t2 && /^data:/i.test(e2) && (t2 = goog.html.SafeUrl.fromDataUrl(e2)).getTypedStringValue() == e2 ? t2 : (goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(e2), "%s does not match the safe URL pattern", e2) || (e2 = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e2)));
  }, goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = function(e2) {
    return new goog.html.SafeUrl(goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_, e2);
  }, goog.html.SafeUrl.ABOUT_BLANK = goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank"), goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.html.SafeStyle = function() {
    this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = "", this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeStyle.prototype.implementsGoogStringTypedString = true, goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeStyle.fromConstant = function(e2) {
    return 0 === (e2 = goog.string.Const.unwrap(e2)).length ? goog.html.SafeStyle.EMPTY : (goog.asserts.assert(goog.string.internal.endsWith(e2, ";"), "Last character of style string is not ';': " + e2), goog.asserts.assert(goog.string.internal.contains(e2, ":"), `Style string must contain at least one ':', to specify a "name: value" pair: ` + e2), goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(e2));
  }, goog.html.SafeStyle.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_;
  }, goog.DEBUG && (goog.html.SafeStyle.prototype.toString = function() {
    return "SafeStyle{" + this.privateDoNotAccessOrElseSafeStyleWrappedValue_ + "}";
  }), goog.html.SafeStyle.unwrap = function(e2) {
    return e2 instanceof goog.html.SafeStyle && e2.constructor === goog.html.SafeStyle && e2.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e2.privateDoNotAccessOrElseSafeStyleWrappedValue_ : (goog.asserts.fail("expected object of type SafeStyle, got '" + e2 + "' of type " + goog.typeOf(e2)), "type_error:SafeStyle");
  }, goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse = function(e2) {
    return new goog.html.SafeStyle().initSecurityPrivateDoNotAccessOrElse_(e2);
  }, goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(e2) {
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = e2, this;
  }, goog.html.SafeStyle.EMPTY = goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(""), goog.html.SafeStyle.INNOCUOUS_STRING = "zClosurez", goog.html.SafeStyle.create = function(e2) {
    var t2, r2 = "";
    for (t2 in e2) {
      if (!/^[-_a-zA-Z0-9]+$/.test(t2))
        throw Error("Name allows only [-_a-zA-Z0-9], got: " + t2);
      var o2 = e2[t2];
      null != o2 && (r2 += t2 + ":" + (o2 = Array.isArray(o2) ? goog.array.map(o2, goog.html.SafeStyle.sanitizePropertyValue_).join(" ") : goog.html.SafeStyle.sanitizePropertyValue_(o2)) + ";");
    }
    return r2 ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(r2) : goog.html.SafeStyle.EMPTY;
  }, goog.html.SafeStyle.sanitizePropertyValue_ = function(e2) {
    if (e2 instanceof goog.html.SafeUrl)
      return 'url("' + goog.html.SafeUrl.unwrap(e2).replace(/</g, "%3c").replace(/[\\"]/g, "\\$&") + '")';
    if (e2 = e2 instanceof goog.string.Const ? goog.string.Const.unwrap(e2) : goog.html.SafeStyle.sanitizePropertyValueString_(String(e2)), /[{;}]/.test(e2))
      throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.", [e2]);
    return e2;
  }, goog.html.SafeStyle.sanitizePropertyValueString_ = function(e2) {
    var t2 = e2.replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.URL_RE_, "url");
    return goog.html.SafeStyle.VALUE_RE_.test(t2) ? goog.html.SafeStyle.COMMENT_RE_.test(e2) ? (goog.asserts.fail("String value disallows comments, got: " + e2), goog.html.SafeStyle.INNOCUOUS_STRING) : goog.html.SafeStyle.hasBalancedQuotes_(e2) ? goog.html.SafeStyle.hasBalancedSquareBrackets_(e2) ? goog.html.SafeStyle.sanitizeUrl_(e2) : (goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: " + e2), goog.html.SafeStyle.INNOCUOUS_STRING) : (goog.asserts.fail("String value requires balanced quotes, got: " + e2), goog.html.SafeStyle.INNOCUOUS_STRING) : (goog.asserts.fail("String value allows only " + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + " and simple functions, got: " + e2), goog.html.SafeStyle.INNOCUOUS_STRING);
  }, goog.html.SafeStyle.hasBalancedQuotes_ = function(e2) {
    for (var t2 = true, r2 = true, o2 = 0; o2 < e2.length; o2++) {
      var i3 = e2.charAt(o2);
      "'" == i3 && r2 ? t2 = !t2 : '"' == i3 && t2 && (r2 = !r2);
    }
    return t2 && r2;
  }, goog.html.SafeStyle.hasBalancedSquareBrackets_ = function(e2) {
    for (var t2 = true, r2 = /^[-_a-zA-Z0-9]$/, o2 = 0; o2 < e2.length; o2++) {
      var i3 = e2.charAt(o2);
      if ("]" == i3) {
        if (t2)
          return false;
        t2 = true;
      } else if ("[" == i3) {
        if (!t2)
          return false;
        t2 = false;
      } else if (!t2 && !r2.test(i3))
        return false;
    }
    return t2;
  }, goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ = `[-,."'%_!# a-zA-Z0-9\\[\\]]`, goog.html.SafeStyle.VALUE_RE_ = new RegExp("^" + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + "+$"), goog.html.SafeStyle.URL_RE_ = /\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g, goog.html.SafeStyle.ALLOWED_FUNCTIONS_ = "calc cubic-bezier fit-content hsl hsla linear-gradient matrix minmax repeat rgb rgba (rotate|scale|translate)(X|Y|Z|3d)?".split(" "), goog.html.SafeStyle.FUNCTIONS_RE_ = new RegExp("\\b(" + goog.html.SafeStyle.ALLOWED_FUNCTIONS_.join("|") + ")\\([-+*/0-9a-z.%\\[\\], ]+\\)", "g"), goog.html.SafeStyle.COMMENT_RE_ = /\/\*/, goog.html.SafeStyle.sanitizeUrl_ = function(e2) {
    return e2.replace(goog.html.SafeStyle.URL_RE_, function(e3, t2, r2, o2) {
      var i3 = "";
      return r2 = r2.replace(/^(['"])(.*)\1$/, function(e4, t3, r3) {
        return i3 = t3, r3;
      }), e3 = goog.html.SafeUrl.sanitize(r2).getTypedStringValue(), t2 + i3 + e3 + i3 + o2;
    });
  }, goog.html.SafeStyle.concat = function(e2) {
    var t2 = "", r2 = function(e3) {
      Array.isArray(e3) ? goog.array.forEach(e3, r2) : t2 += goog.html.SafeStyle.unwrap(e3);
    };
    return goog.array.forEach(arguments, r2), t2 ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(t2) : goog.html.SafeStyle.EMPTY;
  }, goog.html.SafeStyleSheet = function() {
    this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = "", this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
  }, goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString = true, goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeStyleSheet.createRule = function(e2, t2) {
    if (goog.string.internal.contains(e2, "<"))
      throw Error("Selector does not allow '<', got: " + e2);
    var r2 = e2.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, "");
    if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(r2))
      throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: " + e2);
    if (!goog.html.SafeStyleSheet.hasBalancedBrackets_(r2))
      throw Error("() and [] in selector must be balanced, got: " + e2);
    return t2 instanceof goog.html.SafeStyle || (t2 = goog.html.SafeStyle.create(t2)), e2 = e2 + "{" + goog.html.SafeStyle.unwrap(t2).replace(/</g, "\\3C ") + "}", goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(e2);
  }, goog.html.SafeStyleSheet.hasBalancedBrackets_ = function(e2) {
    for (var t2 = { "(": ")", "[": "]" }, r2 = [], o2 = 0; o2 < e2.length; o2++) {
      var i3 = e2[o2];
      if (t2[i3])
        r2.push(t2[i3]);
      else if (goog.object.contains(t2, i3) && r2.pop() != i3)
        return false;
    }
    return 0 == r2.length;
  }, goog.html.SafeStyleSheet.concat = function(e2) {
    var t2 = "", r2 = function(e3) {
      Array.isArray(e3) ? goog.array.forEach(e3, r2) : t2 += goog.html.SafeStyleSheet.unwrap(e3);
    };
    return goog.array.forEach(arguments, r2), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(t2);
  }, goog.html.SafeStyleSheet.fromConstant = function(e2) {
    return 0 === (e2 = goog.string.Const.unwrap(e2)).length ? goog.html.SafeStyleSheet.EMPTY : (goog.asserts.assert(!goog.string.internal.contains(e2, "<"), "Forbidden '<' character in style sheet string: " + e2), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(e2));
  }, goog.html.SafeStyleSheet.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
  }, goog.DEBUG && (goog.html.SafeStyleSheet.prototype.toString = function() {
    return "SafeStyleSheet{" + this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ + "}";
  }), goog.html.SafeStyleSheet.unwrap = function(e2) {
    return e2 instanceof goog.html.SafeStyleSheet && e2.constructor === goog.html.SafeStyleSheet && e2.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e2.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ : (goog.asserts.fail("expected object of type SafeStyleSheet, got '" + e2 + "' of type " + goog.typeOf(e2)), "type_error:SafeStyleSheet");
  }, goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse = function(e2) {
    return new goog.html.SafeStyleSheet().initSecurityPrivateDoNotAccessOrElse_(e2);
  }, goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(e2) {
    return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = e2, this;
  }, goog.html.SafeStyleSheet.EMPTY = goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(""), goog.labs = {}, goog.labs.userAgent = {}, goog.labs.userAgent.util = {}, goog.labs.userAgent.util.getNativeUserAgentString_ = function() {
    var e2 = goog.labs.userAgent.util.getNavigator_();
    return e2 && (e2 = e2.userAgent) ? e2 : "";
  }, goog.labs.userAgent.util.getNavigator_ = function() {
    return goog.global.navigator;
  }, goog.labs.userAgent.util.userAgent_ = goog.labs.userAgent.util.getNativeUserAgentString_(), goog.labs.userAgent.util.setUserAgent = function(e2) {
    goog.labs.userAgent.util.userAgent_ = e2 || goog.labs.userAgent.util.getNativeUserAgentString_();
  }, goog.labs.userAgent.util.getUserAgent = function() {
    return goog.labs.userAgent.util.userAgent_;
  }, goog.labs.userAgent.util.matchUserAgent = function(e2) {
    var t2 = goog.labs.userAgent.util.getUserAgent();
    return goog.string.internal.contains(t2, e2);
  }, goog.labs.userAgent.util.matchUserAgentIgnoreCase = function(e2) {
    var t2 = goog.labs.userAgent.util.getUserAgent();
    return goog.string.internal.caseInsensitiveContains(t2, e2);
  }, goog.labs.userAgent.util.extractVersionTuples = function(e2) {
    for (var t2, r2 = /(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g, o2 = []; t2 = r2.exec(e2); )
      o2.push([t2[1], t2[2], t2[3] || void 0]);
    return o2;
  }, goog.labs.userAgent.browser = {}, goog.labs.userAgent.browser.matchOpera_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Opera");
  }, goog.labs.userAgent.browser.matchIE_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
  }, goog.labs.userAgent.browser.matchEdgeHtml_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edge");
  }, goog.labs.userAgent.browser.matchEdgeChromium_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edg/");
  }, goog.labs.userAgent.browser.matchOperaChromium_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("OPR");
  }, goog.labs.userAgent.browser.matchFirefox_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Firefox") || goog.labs.userAgent.util.matchUserAgent("FxiOS");
  }, goog.labs.userAgent.browser.matchSafari_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Safari") && !(goog.labs.userAgent.browser.matchChrome_() || goog.labs.userAgent.browser.matchCoast_() || goog.labs.userAgent.browser.matchOpera_() || goog.labs.userAgent.browser.matchEdgeHtml_() || goog.labs.userAgent.browser.matchEdgeChromium_() || goog.labs.userAgent.browser.matchOperaChromium_() || goog.labs.userAgent.browser.matchFirefox_() || goog.labs.userAgent.browser.isSilk() || goog.labs.userAgent.util.matchUserAgent("Android"));
  }, goog.labs.userAgent.browser.matchCoast_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Coast");
  }, goog.labs.userAgent.browser.matchIosWebview_ = function() {
    return (goog.labs.userAgent.util.matchUserAgent("iPad") || goog.labs.userAgent.util.matchUserAgent("iPhone")) && !goog.labs.userAgent.browser.matchSafari_() && !goog.labs.userAgent.browser.matchChrome_() && !goog.labs.userAgent.browser.matchCoast_() && !goog.labs.userAgent.browser.matchFirefox_() && goog.labs.userAgent.util.matchUserAgent("AppleWebKit");
  }, goog.labs.userAgent.browser.matchChrome_ = function() {
    return (goog.labs.userAgent.util.matchUserAgent("Chrome") || goog.labs.userAgent.util.matchUserAgent("CriOS")) && !goog.labs.userAgent.browser.matchEdgeHtml_();
  }, goog.labs.userAgent.browser.matchAndroidBrowser_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Android") && !(goog.labs.userAgent.browser.isChrome() || goog.labs.userAgent.browser.isFirefox() || goog.labs.userAgent.browser.isOpera() || goog.labs.userAgent.browser.isSilk());
  }, goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_, goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_, goog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdgeHtml_, goog.labs.userAgent.browser.isEdgeChromium = goog.labs.userAgent.browser.matchEdgeChromium_, goog.labs.userAgent.browser.isOperaChromium = goog.labs.userAgent.browser.matchOperaChromium_, goog.labs.userAgent.browser.isFirefox = goog.labs.userAgent.browser.matchFirefox_, goog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_, goog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_, goog.labs.userAgent.browser.isIosWebview = goog.labs.userAgent.browser.matchIosWebview_, goog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_, goog.labs.userAgent.browser.isAndroidBrowser = goog.labs.userAgent.browser.matchAndroidBrowser_, goog.labs.userAgent.browser.isSilk = function() {
    return goog.labs.userAgent.util.matchUserAgent("Silk");
  }, goog.labs.userAgent.browser.getVersion = function() {
    function e2(e3) {
      return e3 = goog.array.find(e3, o2), r2[e3] || "";
    }
    var t2 = goog.labs.userAgent.util.getUserAgent();
    if (goog.labs.userAgent.browser.isIE())
      return goog.labs.userAgent.browser.getIEVersion_(t2);
    t2 = goog.labs.userAgent.util.extractVersionTuples(t2);
    var r2 = {};
    goog.array.forEach(t2, function(e3) {
      r2[e3[0]] = e3[1];
    });
    var o2 = goog.partial(goog.object.containsKey, r2);
    return goog.labs.userAgent.browser.isOpera() ? e2(["Version", "Opera"]) : goog.labs.userAgent.browser.isEdge() ? e2(["Edge"]) : goog.labs.userAgent.browser.isEdgeChromium() ? e2(["Edg"]) : goog.labs.userAgent.browser.isChrome() ? e2(["Chrome", "CriOS", "HeadlessChrome"]) : (t2 = t2[2]) && t2[1] || "";
  }, goog.labs.userAgent.browser.isVersionOrHigher = function(e2) {
    return 0 <= goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(), e2);
  }, goog.labs.userAgent.browser.getIEVersion_ = function(e2) {
    var t2 = /rv: *([\d\.]*)/.exec(e2);
    if (t2 && t2[1])
      return t2[1];
    t2 = "";
    var r2 = /MSIE +([\d\.]+)/.exec(e2);
    if (r2 && r2[1])
      if (e2 = /Trident\/(\d.\d)/.exec(e2), "7.0" == r2[1])
        if (e2 && e2[1])
          switch (e2[1]) {
            case "4.0":
              t2 = "8.0";
              break;
            case "5.0":
              t2 = "9.0";
              break;
            case "6.0":
              t2 = "10.0";
              break;
            case "7.0":
              t2 = "11.0";
          }
        else
          t2 = "7.0";
      else
        t2 = r2[1];
    return t2;
  }, goog.html.SafeHtml = function() {
    this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = "", this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_, this.dir_ = null;
  }, goog.html.SafeHtml.ENABLE_ERROR_MESSAGES = goog.DEBUG, goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE = true, goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString = true, goog.html.SafeHtml.prototype.getDirection = function() {
    return this.dir_;
  }, goog.html.SafeHtml.prototype.implementsGoogStringTypedString = true, goog.html.SafeHtml.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString();
  }, goog.DEBUG && (goog.html.SafeHtml.prototype.toString = function() {
    return "SafeHtml{" + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ + "}";
  }), goog.html.SafeHtml.unwrap = function(e2) {
    return goog.html.SafeHtml.unwrapTrustedHTML(e2).toString();
  }, goog.html.SafeHtml.unwrapTrustedHTML = function(e2) {
    return e2 instanceof goog.html.SafeHtml && e2.constructor === goog.html.SafeHtml && e2.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e2.privateDoNotAccessOrElseSafeHtmlWrappedValue_ : (goog.asserts.fail("expected object of type SafeHtml, got '" + e2 + "' of type " + goog.typeOf(e2)), "type_error:SafeHtml");
  }, goog.html.SafeHtml.htmlEscape = function(e2) {
    if (e2 instanceof goog.html.SafeHtml)
      return e2;
    var t2 = "object" == typeof e2, r2 = null;
    return t2 && e2.implementsGoogI18nBidiDirectionalString && (r2 = e2.getDirection()), e2 = t2 && e2.implementsGoogStringTypedString ? e2.getTypedStringValue() : String(e2), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(e2), r2);
  }, goog.html.SafeHtml.htmlEscapePreservingNewlines = function(e2) {
    return e2 instanceof goog.html.SafeHtml ? e2 : (e2 = goog.html.SafeHtml.htmlEscape(e2), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(e2)), e2.getDirection()));
  }, goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces = function(e2) {
    return e2 instanceof goog.html.SafeHtml ? e2 : (e2 = goog.html.SafeHtml.htmlEscape(e2), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(e2)), e2.getDirection()));
  }, goog.html.SafeHtml.from = goog.html.SafeHtml.htmlEscape, goog.html.SafeHtml.comment = function(e2) {
    return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!--" + goog.string.internal.htmlEscape(e2) + "-->", null);
  }, goog.html.SafeHtml.VALID_NAMES_IN_TAG_ = /^[a-zA-Z0-9-]+$/, goog.html.SafeHtml.URL_ATTRIBUTES_ = { action: true, cite: true, data: true, formaction: true, href: true, manifest: true, poster: true, src: true }, goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_ = { APPLET: true, BASE: true, EMBED: true, IFRAME: true, LINK: true, MATH: true, META: true, OBJECT: true, SCRIPT: true, STYLE: true, SVG: true, TEMPLATE: true }, goog.html.SafeHtml.create = function(e2, t2, r2) {
    return goog.html.SafeHtml.verifyTagName(String(e2)), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(e2), t2, r2);
  }, goog.html.SafeHtml.verifyTagName = function(e2) {
    if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(e2))
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "Invalid tag name <" + e2 + ">." : "");
    if (e2.toUpperCase() in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "Tag name <" + e2 + "> is not allowed for SafeHtml." : "");
  }, goog.html.SafeHtml.createIframe = function(e2, t2, r2, o2) {
    e2 && goog.html.TrustedResourceUrl.unwrap(e2);
    var i3 = {};
    return i3.src = e2 || null, i3.srcdoc = t2 && goog.html.SafeHtml.unwrap(t2), e2 = goog.html.SafeHtml.combineAttributes(i3, { sandbox: "" }, r2), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", e2, o2);
  }, goog.html.SafeHtml.createSandboxIframe = function(e2, t2, r2, o2) {
    if (!goog.html.SafeHtml.canUseSandboxIframe())
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "The browser does not support sandboxed iframes." : "");
    var i3 = {};
    return i3.src = e2 ? goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(e2)) : null, i3.srcdoc = t2 || null, i3.sandbox = "", e2 = goog.html.SafeHtml.combineAttributes(i3, {}, r2), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", e2, o2);
  }, goog.html.SafeHtml.canUseSandboxIframe = function() {
    return goog.global.HTMLIFrameElement && "sandbox" in goog.global.HTMLIFrameElement.prototype;
  }, goog.html.SafeHtml.createScriptSrc = function(e2, t2) {
    return goog.html.TrustedResourceUrl.unwrap(e2), e2 = goog.html.SafeHtml.combineAttributes({ src: e2 }, {}, t2), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", e2);
  }, goog.html.SafeHtml.createScript = function(e2, t2) {
    for (var r2 in t2) {
      var o2 = r2.toLowerCase();
      if ("language" == o2 || "src" == o2 || "text" == o2 || "type" == o2)
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Cannot set "' + o2 + '" attribute' : "");
    }
    for (r2 = "", e2 = goog.array.concat(e2), o2 = 0; o2 < e2.length; o2++)
      r2 += goog.html.SafeScript.unwrap(e2[o2]);
    return e2 = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(r2, goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", t2, e2);
  }, goog.html.SafeHtml.createStyle = function(e2, t2) {
    t2 = goog.html.SafeHtml.combineAttributes({ type: "text/css" }, {}, t2);
    var r2 = "";
    e2 = goog.array.concat(e2);
    for (var o2 = 0; o2 < e2.length; o2++)
      r2 += goog.html.SafeStyleSheet.unwrap(e2[o2]);
    return e2 = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(r2, goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style", t2, e2);
  }, goog.html.SafeHtml.createMetaRefresh = function(e2, t2) {
    return e2 = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(e2)), (goog.labs.userAgent.browser.isIE() || goog.labs.userAgent.browser.isEdge()) && goog.string.internal.contains(e2, ";") && (e2 = "'" + e2.replace(/'/g, "%27") + "'"), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta", { "http-equiv": "refresh", content: (t2 || 0) + "; url=" + e2 });
  }, goog.html.SafeHtml.getAttrNameAndValue_ = function(e2, t2, r2) {
    if (r2 instanceof goog.string.Const)
      r2 = goog.string.Const.unwrap(r2);
    else if ("style" == t2.toLowerCase()) {
      if (!goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE)
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "style" not supported.' : "");
      r2 = goog.html.SafeHtml.getStyleValue_(r2);
    } else {
      if (/^on/i.test(t2))
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "' + t2 + '" requires goog.string.Const value, "' + r2 + '" given.' : "");
      if (t2.toLowerCase() in goog.html.SafeHtml.URL_ATTRIBUTES_)
        if (r2 instanceof goog.html.TrustedResourceUrl)
          r2 = goog.html.TrustedResourceUrl.unwrap(r2);
        else if (r2 instanceof goog.html.SafeUrl)
          r2 = goog.html.SafeUrl.unwrap(r2);
        else {
          if ("string" != typeof r2)
            throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "' + t2 + '" on tag "' + e2 + '" requires goog.html.SafeUrl, goog.string.Const, or string, value "' + r2 + '" given.' : "");
          r2 = goog.html.SafeUrl.sanitize(r2).getTypedStringValue();
        }
    }
    return r2.implementsGoogStringTypedString && (r2 = r2.getTypedStringValue()), goog.asserts.assert("string" == typeof r2 || "number" == typeof r2, "String or number value expected, got " + typeof r2 + " with value: " + r2), t2 + '="' + goog.string.internal.htmlEscape(String(r2)) + '"';
  }, goog.html.SafeHtml.getStyleValue_ = function(e2) {
    if (!goog.isObject(e2))
      throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'The "style" attribute requires goog.html.SafeStyle or map of style properties, ' + typeof e2 + " given: " + e2 : "");
    return e2 instanceof goog.html.SafeStyle || (e2 = goog.html.SafeStyle.create(e2)), goog.html.SafeStyle.unwrap(e2);
  }, goog.html.SafeHtml.createWithDir = function(e2, t2, r2, o2) {
    return (t2 = goog.html.SafeHtml.create(t2, r2, o2)).dir_ = e2, t2;
  }, goog.html.SafeHtml.join = function(e2, t2) {
    var r2 = (e2 = goog.html.SafeHtml.htmlEscape(e2)).getDirection(), o2 = [], i3 = function(e3) {
      Array.isArray(e3) ? goog.array.forEach(e3, i3) : (e3 = goog.html.SafeHtml.htmlEscape(e3), o2.push(goog.html.SafeHtml.unwrap(e3)), e3 = e3.getDirection(), r2 == goog.i18n.bidi.Dir.NEUTRAL ? r2 = e3 : e3 != goog.i18n.bidi.Dir.NEUTRAL && r2 != e3 && (r2 = null));
    };
    return goog.array.forEach(t2, i3), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(o2.join(goog.html.SafeHtml.unwrap(e2)), r2);
  }, goog.html.SafeHtml.concat = function(e2) {
    return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY, Array.prototype.slice.call(arguments));
  }, goog.html.SafeHtml.concatWithDir = function(e2, t2) {
    var r2 = goog.html.SafeHtml.concat(goog.array.slice(arguments, 1));
    return r2.dir_ = e2, r2;
  }, goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse = function(e2, t2) {
    return new goog.html.SafeHtml().initSecurityPrivateDoNotAccessOrElse_(e2, t2);
  }, goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(e2, t2) {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(e2) : e2, this.dir_ = t2, this;
  }, goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse = function(e2, t2, r2) {
    var o2 = null, i3 = "<" + e2 + goog.html.SafeHtml.stringifyAttributes(e2, t2);
    return null == r2 ? r2 = [] : Array.isArray(r2) || (r2 = [r2]), goog.dom.tags.isVoidTag(e2.toLowerCase()) ? (goog.asserts.assert(!r2.length, "Void tag <" + e2 + "> does not allow content."), i3 += ">") : (o2 = goog.html.SafeHtml.concat(r2), i3 += ">" + goog.html.SafeHtml.unwrap(o2) + "</" + e2 + ">", o2 = o2.getDirection()), (e2 = t2 && t2.dir) && (o2 = /^(ltr|rtl|auto)$/i.test(e2) ? goog.i18n.bidi.Dir.NEUTRAL : null), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(i3, o2);
  }, goog.html.SafeHtml.stringifyAttributes = function(e2, t2) {
    var r2 = "";
    if (t2)
      for (var o2 in t2) {
        if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(o2))
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Invalid attribute name "' + o2 + '".' : "");
        var i3 = t2[o2];
        null != i3 && (r2 += " " + goog.html.SafeHtml.getAttrNameAndValue_(e2, o2, i3));
      }
    return r2;
  }, goog.html.SafeHtml.combineAttributes = function(e2, t2, r2) {
    var o2, i3 = {};
    for (o2 in e2)
      goog.asserts.assert(o2.toLowerCase() == o2, "Must be lower case"), i3[o2] = e2[o2];
    for (o2 in t2)
      goog.asserts.assert(o2.toLowerCase() == o2, "Must be lower case"), i3[o2] = t2[o2];
    if (r2)
      for (o2 in r2) {
        var a3 = o2.toLowerCase();
        if (a3 in e2)
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Cannot override "' + a3 + '" attribute, got "' + o2 + '" with value "' + r2[o2] + '"' : "");
        a3 in t2 && delete i3[a3], i3[o2] = r2[o2];
      }
    return i3;
  }, goog.html.SafeHtml.DOCTYPE_HTML = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>", goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.EMPTY = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("", goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.BR = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>", goog.i18n.bidi.Dir.NEUTRAL), goog.html.uncheckedconversions = {}, goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract = function(e2, t2, r2) {
    return goog.asserts.assertString(goog.string.Const.unwrap(e2), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e2)), "must provide non-empty justification"), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(t2, r2 || null);
  }, goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract = function(e2, t2) {
    return goog.asserts.assertString(goog.string.Const.unwrap(e2), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e2)), "must provide non-empty justification"), goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(t2);
  }, goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract = function(e2, t2) {
    return goog.asserts.assertString(goog.string.Const.unwrap(e2), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e2)), "must provide non-empty justification"), goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(t2);
  }, goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract = function(e2, t2) {
    return goog.asserts.assertString(goog.string.Const.unwrap(e2), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e2)), "must provide non-empty justification"), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(t2);
  }, goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract = function(e2, t2) {
    return goog.asserts.assertString(goog.string.Const.unwrap(e2), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e2)), "must provide non-empty justification"), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(t2);
  }, goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract = function(e2, t2) {
    return goog.asserts.assertString(goog.string.Const.unwrap(e2), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e2)), "must provide non-empty justification"), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(t2);
  }, goog.dom.safe = {}, goog.dom.safe.InsertAdjacentHtmlPosition = { AFTERBEGIN: "afterbegin", AFTEREND: "afterend", BEFOREBEGIN: "beforebegin", BEFOREEND: "beforeend" }, goog.dom.safe.insertAdjacentHtml = function(e2, t2, r2) {
    e2.insertAdjacentHTML(t2, goog.html.SafeHtml.unwrapTrustedHTML(r2));
  }, goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_ = { MATH: true, SCRIPT: true, STYLE: true, SVG: true, TEMPLATE: true }, goog.dom.safe.isInnerHtmlCleanupRecursive_ = goog.functions.cacheReturnValue(function() {
    if (goog.DEBUG && "undefined" == typeof document)
      return false;
    var e2 = document.createElement("div"), t2 = document.createElement("div");
    return t2.appendChild(document.createElement("div")), e2.appendChild(t2), !(goog.DEBUG && !e2.firstChild) && (t2 = e2.firstChild.firstChild, e2.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY), !t2.parentElement);
  }), goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse = function(e2, t2) {
    if (goog.dom.safe.isInnerHtmlCleanupRecursive_())
      for (; e2.lastChild; )
        e2.removeChild(e2.lastChild);
    e2.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(t2);
  }, goog.dom.safe.setInnerHtml = function(e2, t2) {
    if (goog.asserts.ENABLE_ASSERTS) {
      var r2 = e2.tagName.toUpperCase();
      if (goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[r2])
        throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of " + e2.tagName + ".");
    }
    goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(e2, t2);
  }, goog.dom.safe.setOuterHtml = function(e2, t2) {
    e2.outerHTML = goog.html.SafeHtml.unwrapTrustedHTML(t2);
  }, goog.dom.safe.setFormElementAction = function(e2, t2) {
    t2 = t2 instanceof goog.html.SafeUrl ? t2 : goog.html.SafeUrl.sanitizeAssertUnchanged(t2), goog.dom.asserts.assertIsHTMLFormElement(e2).action = goog.html.SafeUrl.unwrap(t2);
  }, goog.dom.safe.setButtonFormAction = function(e2, t2) {
    t2 = t2 instanceof goog.html.SafeUrl ? t2 : goog.html.SafeUrl.sanitizeAssertUnchanged(t2), goog.dom.asserts.assertIsHTMLButtonElement(e2).formAction = goog.html.SafeUrl.unwrap(t2);
  }, goog.dom.safe.setInputFormAction = function(e2, t2) {
    t2 = t2 instanceof goog.html.SafeUrl ? t2 : goog.html.SafeUrl.sanitizeAssertUnchanged(t2), goog.dom.asserts.assertIsHTMLInputElement(e2).formAction = goog.html.SafeUrl.unwrap(t2);
  }, goog.dom.safe.setStyle = function(e2, t2) {
    e2.style.cssText = goog.html.SafeStyle.unwrap(t2);
  }, goog.dom.safe.documentWrite = function(e2, t2) {
    e2.write(goog.html.SafeHtml.unwrapTrustedHTML(t2));
  }, goog.dom.safe.setAnchorHref = function(e2, t2) {
    goog.dom.asserts.assertIsHTMLAnchorElement(e2), t2 = t2 instanceof goog.html.SafeUrl ? t2 : goog.html.SafeUrl.sanitizeAssertUnchanged(t2), e2.href = goog.html.SafeUrl.unwrap(t2);
  }, goog.dom.safe.setImageSrc = function(e2, t2) {
    if (goog.dom.asserts.assertIsHTMLImageElement(e2), !(t2 instanceof goog.html.SafeUrl)) {
      var r2 = /^data:image\//i.test(t2);
      t2 = goog.html.SafeUrl.sanitizeAssertUnchanged(t2, r2);
    }
    e2.src = goog.html.SafeUrl.unwrap(t2);
  }, goog.dom.safe.setAudioSrc = function(e2, t2) {
    if (goog.dom.asserts.assertIsHTMLAudioElement(e2), !(t2 instanceof goog.html.SafeUrl)) {
      var r2 = /^data:audio\//i.test(t2);
      t2 = goog.html.SafeUrl.sanitizeAssertUnchanged(t2, r2);
    }
    e2.src = goog.html.SafeUrl.unwrap(t2);
  }, goog.dom.safe.setVideoSrc = function(e2, t2) {
    if (goog.dom.asserts.assertIsHTMLVideoElement(e2), !(t2 instanceof goog.html.SafeUrl)) {
      var r2 = /^data:video\//i.test(t2);
      t2 = goog.html.SafeUrl.sanitizeAssertUnchanged(t2, r2);
    }
    e2.src = goog.html.SafeUrl.unwrap(t2);
  }, goog.dom.safe.setEmbedSrc = function(e2, t2) {
    goog.dom.asserts.assertIsHTMLEmbedElement(e2), e2.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(t2);
  }, goog.dom.safe.setFrameSrc = function(e2, t2) {
    goog.dom.asserts.assertIsHTMLFrameElement(e2), e2.src = goog.html.TrustedResourceUrl.unwrap(t2);
  }, goog.dom.safe.setIframeSrc = function(e2, t2) {
    goog.dom.asserts.assertIsHTMLIFrameElement(e2), e2.src = goog.html.TrustedResourceUrl.unwrap(t2);
  }, goog.dom.safe.setIframeSrcdoc = function(e2, t2) {
    goog.dom.asserts.assertIsHTMLIFrameElement(e2), e2.srcdoc = goog.html.SafeHtml.unwrapTrustedHTML(t2);
  }, goog.dom.safe.setLinkHrefAndRel = function(e2, t2, r2) {
    goog.dom.asserts.assertIsHTMLLinkElement(e2), e2.rel = r2, goog.string.internal.caseInsensitiveContains(r2, "stylesheet") ? (goog.asserts.assert(t2 instanceof goog.html.TrustedResourceUrl, 'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'), e2.href = goog.html.TrustedResourceUrl.unwrap(t2)) : e2.href = t2 instanceof goog.html.TrustedResourceUrl ? goog.html.TrustedResourceUrl.unwrap(t2) : t2 instanceof goog.html.SafeUrl ? goog.html.SafeUrl.unwrap(t2) : goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitizeAssertUnchanged(t2));
  }, goog.dom.safe.setObjectData = function(e2, t2) {
    goog.dom.asserts.assertIsHTMLObjectElement(e2), e2.data = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(t2);
  }, goog.dom.safe.setScriptSrc = function(e2, t2) {
    goog.dom.asserts.assertIsHTMLScriptElement(e2), e2.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(t2), (t2 = goog.getScriptNonce()) && e2.setAttribute("nonce", t2);
  }, goog.dom.safe.setScriptContent = function(e2, t2) {
    goog.dom.asserts.assertIsHTMLScriptElement(e2), e2.text = goog.html.SafeScript.unwrapTrustedScript(t2), (t2 = goog.getScriptNonce()) && e2.setAttribute("nonce", t2);
  }, goog.dom.safe.setLocationHref = function(e2, t2) {
    goog.dom.asserts.assertIsLocation(e2), t2 = t2 instanceof goog.html.SafeUrl ? t2 : goog.html.SafeUrl.sanitizeAssertUnchanged(t2), e2.href = goog.html.SafeUrl.unwrap(t2);
  }, goog.dom.safe.assignLocation = function(e2, t2) {
    goog.dom.asserts.assertIsLocation(e2), t2 = t2 instanceof goog.html.SafeUrl ? t2 : goog.html.SafeUrl.sanitizeAssertUnchanged(t2), e2.assign(goog.html.SafeUrl.unwrap(t2));
  }, goog.dom.safe.replaceLocation = function(e2, t2) {
    t2 = t2 instanceof goog.html.SafeUrl ? t2 : goog.html.SafeUrl.sanitizeAssertUnchanged(t2), e2.replace(goog.html.SafeUrl.unwrap(t2));
  }, goog.dom.safe.openInWindow = function(e2, t2, r2, o2, i3) {
    return e2 = e2 instanceof goog.html.SafeUrl ? e2 : goog.html.SafeUrl.sanitizeAssertUnchanged(e2), t2 = t2 || goog.global, r2 = r2 instanceof goog.string.Const ? goog.string.Const.unwrap(r2) : r2 || "", t2.open(goog.html.SafeUrl.unwrap(e2), r2, o2, i3);
  }, goog.dom.safe.parseFromStringHtml = function(e2, t2) {
    return goog.dom.safe.parseFromString(e2, t2, "text/html");
  }, goog.dom.safe.parseFromString = function(e2, t2, r2) {
    return e2.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(t2), r2);
  }, goog.dom.safe.createImageFromBlob = function(e2) {
    if (!/^image\/.*/g.test(e2.type))
      throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");
    var t2 = goog.global.URL.createObjectURL(e2);
    return (e2 = new goog.global.Image()).onload = function() {
      goog.global.URL.revokeObjectURL(t2);
    }, goog.dom.safe.setImageSrc(e2, goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."), t2)), e2;
  }, goog.string.DETECT_DOUBLE_ESCAPING = false, goog.string.FORCE_NON_DOM_HTML_UNESCAPING = false, goog.string.Unicode = { NBSP: " " }, goog.string.startsWith = goog.string.internal.startsWith, goog.string.endsWith = goog.string.internal.endsWith, goog.string.caseInsensitiveStartsWith = goog.string.internal.caseInsensitiveStartsWith, goog.string.caseInsensitiveEndsWith = goog.string.internal.caseInsensitiveEndsWith, goog.string.caseInsensitiveEquals = goog.string.internal.caseInsensitiveEquals, goog.string.subs = function(e2, t2) {
    for (var r2 = e2.split("%s"), o2 = "", i3 = Array.prototype.slice.call(arguments, 1); i3.length && 1 < r2.length; )
      o2 += r2.shift() + i3.shift();
    return o2 + r2.join("%s");
  }, goog.string.collapseWhitespace = function(e2) {
    return e2.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "");
  }, goog.string.isEmptyOrWhitespace = goog.string.internal.isEmptyOrWhitespace, goog.string.isEmptyString = function(e2) {
    return 0 == e2.length;
  }, goog.string.isEmpty = goog.string.isEmptyOrWhitespace, goog.string.isEmptyOrWhitespaceSafe = function(e2) {
    return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(e2));
  }, goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe, goog.string.isBreakingWhitespace = function(e2) {
    return !/[^\t\n\r ]/.test(e2);
  }, goog.string.isAlpha = function(e2) {
    return !/[^a-zA-Z]/.test(e2);
  }, goog.string.isNumeric = function(e2) {
    return !/[^0-9]/.test(e2);
  }, goog.string.isAlphaNumeric = function(e2) {
    return !/[^a-zA-Z0-9]/.test(e2);
  }, goog.string.isSpace = function(e2) {
    return " " == e2;
  }, goog.string.isUnicodeChar = function(e2) {
    return 1 == e2.length && " " <= e2 && "~" >= e2 || "" <= e2 && "�" >= e2;
  }, goog.string.stripNewlines = function(e2) {
    return e2.replace(/(\r\n|\r|\n)+/g, " ");
  }, goog.string.canonicalizeNewlines = function(e2) {
    return e2.replace(/(\r\n|\r|\n)/g, "\n");
  }, goog.string.normalizeWhitespace = function(e2) {
    return e2.replace(/\xa0|\s/g, " ");
  }, goog.string.normalizeSpaces = function(e2) {
    return e2.replace(/\xa0|[ \t]+/g, " ");
  }, goog.string.collapseBreakingSpaces = function(e2) {
    return e2.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "");
  }, goog.string.trim = goog.string.internal.trim, goog.string.trimLeft = function(e2) {
    return e2.replace(/^[\s\xa0]+/, "");
  }, goog.string.trimRight = function(e2) {
    return e2.replace(/[\s\xa0]+$/, "");
  }, goog.string.caseInsensitiveCompare = goog.string.internal.caseInsensitiveCompare, goog.string.numberAwareCompare_ = function(e2, t2, r2) {
    if (e2 == t2)
      return 0;
    if (!e2)
      return -1;
    if (!t2)
      return 1;
    for (var o2 = e2.toLowerCase().match(r2), i3 = t2.toLowerCase().match(r2), a3 = Math.min(o2.length, i3.length), n2 = 0; n2 < a3; n2++) {
      r2 = o2[n2];
      var s2 = i3[n2];
      if (r2 != s2)
        return e2 = parseInt(r2, 10), !isNaN(e2) && (t2 = parseInt(s2, 10), !isNaN(t2) && e2 - t2) ? e2 - t2 : r2 < s2 ? -1 : 1;
    }
    return o2.length != i3.length ? o2.length - i3.length : e2 < t2 ? -1 : 1;
  }, goog.string.intAwareCompare = function(e2, t2) {
    return goog.string.numberAwareCompare_(e2, t2, /\d+|\D+/g);
  }, goog.string.floatAwareCompare = function(e2, t2) {
    return goog.string.numberAwareCompare_(e2, t2, /\d+|\.\d+|\D+/g);
  }, goog.string.numerateCompare = goog.string.floatAwareCompare, goog.string.urlEncode = function(e2) {
    return encodeURIComponent(String(e2));
  }, goog.string.urlDecode = function(e2) {
    return decodeURIComponent(e2.replace(/\+/g, " "));
  }, goog.string.newLineToBr = goog.string.internal.newLineToBr, goog.string.htmlEscape = function(e2, t2) {
    return e2 = goog.string.internal.htmlEscape(e2, t2), goog.string.DETECT_DOUBLE_ESCAPING && (e2 = e2.replace(goog.string.E_RE_, "&#101;")), e2;
  }, goog.string.E_RE_ = /e/g, goog.string.unescapeEntities = function(e2) {
    return goog.string.contains(e2, "&") ? !goog.string.FORCE_NON_DOM_HTML_UNESCAPING && "document" in goog.global ? goog.string.unescapeEntitiesUsingDom_(e2) : goog.string.unescapePureXmlEntities_(e2) : e2;
  }, goog.string.unescapeEntitiesWithDocument = function(e2, t2) {
    return goog.string.contains(e2, "&") ? goog.string.unescapeEntitiesUsingDom_(e2, t2) : e2;
  }, goog.string.unescapeEntitiesUsingDom_ = function(e2, t2) {
    var r2 = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"' }, o2 = t2 ? t2.createElement("div") : goog.global.document.createElement("div");
    return e2.replace(goog.string.HTML_ENTITY_PATTERN_, function(e3, t3) {
      var i3 = r2[e3];
      return i3 || ("#" == t3.charAt(0) && (t3 = Number("0" + t3.substr(1)), isNaN(t3) || (i3 = String.fromCharCode(t3))), i3 || (goog.dom.safe.setInnerHtml(o2, goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Single HTML entity."), e3 + " ")), i3 = o2.firstChild.nodeValue.slice(0, -1)), r2[e3] = i3);
    });
  }, goog.string.unescapePureXmlEntities_ = function(e2) {
    return e2.replace(/&([^;]+);/g, function(e3, t2) {
      switch (t2) {
        case "amp":
          return "&";
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "quot":
          return '"';
        default:
          return "#" != t2.charAt(0) || (t2 = Number("0" + t2.substr(1)), isNaN(t2)) ? e3 : String.fromCharCode(t2);
      }
    });
  }, goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g, goog.string.whitespaceEscape = function(e2, t2) {
    return goog.string.newLineToBr(e2.replace(/  /g, " &#160;"), t2);
  }, goog.string.preserveSpaces = function(e2) {
    return e2.replace(/(^|[\n ]) /g, "$1" + goog.string.Unicode.NBSP);
  }, goog.string.stripQuotes = function(e2, t2) {
    for (var r2 = t2.length, o2 = 0; o2 < r2; o2++) {
      var i3 = 1 == r2 ? t2 : t2.charAt(o2);
      if (e2.charAt(0) == i3 && e2.charAt(e2.length - 1) == i3)
        return e2.substring(1, e2.length - 1);
    }
    return e2;
  }, goog.string.truncate = function(e2, t2, r2) {
    return r2 && (e2 = goog.string.unescapeEntities(e2)), e2.length > t2 && (e2 = e2.substring(0, t2 - 3) + "..."), r2 && (e2 = goog.string.htmlEscape(e2)), e2;
  }, goog.string.truncateMiddle = function(e2, t2, r2, o2) {
    if (r2 && (e2 = goog.string.unescapeEntities(e2)), o2 && e2.length > t2) {
      o2 > t2 && (o2 = t2);
      var i3 = e2.length - o2;
      e2 = e2.substring(0, t2 - o2) + "..." + e2.substring(i3);
    } else
      e2.length > t2 && (o2 = Math.floor(t2 / 2), i3 = e2.length - o2, e2 = e2.substring(0, o2 + t2 % 2) + "..." + e2.substring(i3));
    return r2 && (e2 = goog.string.htmlEscape(e2)), e2;
  }, goog.string.specialEscapeChars_ = { "\0": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\x0B", '"': '\\"', "\\": "\\\\", "<": "\\u003C" }, goog.string.jsEscapeCache_ = { "'": "\\'" }, goog.string.quote = function(e2) {
    e2 = String(e2);
    for (var t2 = ['"'], r2 = 0; r2 < e2.length; r2++) {
      var o2 = e2.charAt(r2), i3 = o2.charCodeAt(0);
      t2[r2 + 1] = goog.string.specialEscapeChars_[o2] || (31 < i3 && 127 > i3 ? o2 : goog.string.escapeChar(o2));
    }
    return t2.push('"'), t2.join("");
  }, goog.string.escapeString = function(e2) {
    for (var t2 = [], r2 = 0; r2 < e2.length; r2++)
      t2[r2] = goog.string.escapeChar(e2.charAt(r2));
    return t2.join("");
  }, goog.string.escapeChar = function(e2) {
    if (e2 in goog.string.jsEscapeCache_)
      return goog.string.jsEscapeCache_[e2];
    if (e2 in goog.string.specialEscapeChars_)
      return goog.string.jsEscapeCache_[e2] = goog.string.specialEscapeChars_[e2];
    var t2 = e2.charCodeAt(0);
    if (31 < t2 && 127 > t2)
      var r2 = e2;
    else
      256 > t2 ? (r2 = "\\x", (16 > t2 || 256 < t2) && (r2 += "0")) : (r2 = "\\u", 4096 > t2 && (r2 += "0")), r2 += t2.toString(16).toUpperCase();
    return goog.string.jsEscapeCache_[e2] = r2;
  }, goog.string.contains = goog.string.internal.contains, goog.string.caseInsensitiveContains = goog.string.internal.caseInsensitiveContains, goog.string.countOf = function(e2, t2) {
    return e2 && t2 ? e2.split(t2).length - 1 : 0;
  }, goog.string.removeAt = function(e2, t2, r2) {
    var o2 = e2;
    return 0 <= t2 && t2 < e2.length && 0 < r2 && (o2 = e2.substr(0, t2) + e2.substr(t2 + r2, e2.length - t2 - r2)), o2;
  }, goog.string.remove = function(e2, t2) {
    return e2.replace(t2, "");
  }, goog.string.removeAll = function(e2, t2) {
    return t2 = new RegExp(goog.string.regExpEscape(t2), "g"), e2.replace(t2, "");
  }, goog.string.replaceAll = function(e2, t2, r2) {
    return t2 = new RegExp(goog.string.regExpEscape(t2), "g"), e2.replace(t2, r2.replace(/\$/g, "$$$$"));
  }, goog.string.regExpEscape = function(e2) {
    return String(e2).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
  }, goog.string.repeat = String.prototype.repeat ? function(e2, t2) {
    return e2.repeat(t2);
  } : function(e2, t2) {
    return Array(t2 + 1).join(e2);
  }, goog.string.padNumber = function(e2, t2, r2) {
    return -1 == (r2 = (e2 = void 0 !== r2 ? e2.toFixed(r2) : String(e2)).indexOf(".")) && (r2 = e2.length), goog.string.repeat("0", Math.max(0, t2 - r2)) + e2;
  }, goog.string.makeSafe = function(e2) {
    return null == e2 ? "" : String(e2);
  }, goog.string.buildString = function(e2) {
    return Array.prototype.join.call(arguments, "");
  }, goog.string.getRandomString = function() {
    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);
  }, goog.string.compareVersions = goog.string.internal.compareVersions, goog.string.hashCode = function(e2) {
    for (var t2 = 0, r2 = 0; r2 < e2.length; ++r2)
      t2 = 31 * t2 + e2.charCodeAt(r2) >>> 0;
    return t2;
  }, goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0, goog.string.createUniqueString = function() {
    return "goog_" + goog.string.uniqueStringCounter_++;
  }, goog.string.toNumber = function(e2) {
    var t2 = Number(e2);
    return 0 == t2 && goog.string.isEmptyOrWhitespace(e2) ? NaN : t2;
  }, goog.string.isLowerCamelCase = function(e2) {
    return /^[a-z]+([A-Z][a-z]*)*$/.test(e2);
  }, goog.string.isUpperCamelCase = function(e2) {
    return /^([A-Z][a-z]*)+$/.test(e2);
  }, goog.string.toCamelCase = function(e2) {
    return String(e2).replace(/\-([a-z])/g, function(e3, t2) {
      return t2.toUpperCase();
    });
  }, goog.string.toSelectorCase = function(e2) {
    return String(e2).replace(/([A-Z])/g, "-$1").toLowerCase();
  }, goog.string.toTitleCase = function(e2, t2) {
    return t2 = "string" == typeof t2 ? goog.string.regExpEscape(t2) : "\\s", e2.replace(new RegExp("(^" + (t2 ? "|[" + t2 + "]+" : "") + ")([a-z])", "g"), function(e3, t3, r2) {
      return t3 + r2.toUpperCase();
    });
  }, goog.string.capitalize = function(e2) {
    return String(e2.charAt(0)).toUpperCase() + String(e2.substr(1)).toLowerCase();
  }, goog.string.parseInt = function(e2) {
    return isFinite(e2) && (e2 = String(e2)), "string" == typeof e2 ? /^\s*-?0x/i.test(e2) ? parseInt(e2, 16) : parseInt(e2, 10) : NaN;
  }, goog.string.splitLimit = function(e2, t2, r2) {
    e2 = e2.split(t2);
    for (var o2 = []; 0 < r2 && e2.length; )
      o2.push(e2.shift()), r2--;
    return e2.length && o2.push(e2.join(t2)), o2;
  }, goog.string.lastComponent = function(e2, t2) {
    if (!t2)
      return e2;
    "string" == typeof t2 && (t2 = [t2]);
    for (var r2 = -1, o2 = 0; o2 < t2.length; o2++)
      if ("" != t2[o2]) {
        var i3 = e2.lastIndexOf(t2[o2]);
        i3 > r2 && (r2 = i3);
      }
    return -1 == r2 ? e2 : e2.slice(r2 + 1);
  }, goog.string.editDistance = function(e2, t2) {
    var r2 = [], o2 = [];
    if (e2 == t2)
      return 0;
    if (!e2.length || !t2.length)
      return Math.max(e2.length, t2.length);
    for (var i3 = 0; i3 < t2.length + 1; i3++)
      r2[i3] = i3;
    for (i3 = 0; i3 < e2.length; i3++) {
      o2[0] = i3 + 1;
      for (var a3 = 0; a3 < t2.length; a3++)
        o2[a3 + 1] = Math.min(o2[a3] + 1, r2[a3 + 1] + 1, r2[a3] + Number(e2[i3] != t2[a3]));
      for (a3 = 0; a3 < r2.length; a3++)
        r2[a3] = o2[a3];
    }
    return o2[t2.length];
  }, goog.labs.userAgent.engine = {}, goog.labs.userAgent.engine.isPresto = function() {
    return goog.labs.userAgent.util.matchUserAgent("Presto");
  }, goog.labs.userAgent.engine.isTrident = function() {
    return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
  }, goog.labs.userAgent.engine.isEdge = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edge");
  }, goog.labs.userAgent.engine.isWebKit = function() {
    return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit") && !goog.labs.userAgent.engine.isEdge();
  }, goog.labs.userAgent.engine.isGecko = function() {
    return goog.labs.userAgent.util.matchUserAgent("Gecko") && !goog.labs.userAgent.engine.isWebKit() && !goog.labs.userAgent.engine.isTrident() && !goog.labs.userAgent.engine.isEdge();
  }, goog.labs.userAgent.engine.getVersion = function() {
    var e2 = goog.labs.userAgent.util.getUserAgent();
    if (e2) {
      e2 = goog.labs.userAgent.util.extractVersionTuples(e2);
      var t2, r2 = goog.labs.userAgent.engine.getEngineTuple_(e2);
      if (r2)
        return "Gecko" == r2[0] ? goog.labs.userAgent.engine.getVersionForKey_(e2, "Firefox") : r2[1];
      if ((e2 = e2[0]) && (t2 = e2[2]) && (t2 = /Trident\/([^\s;]+)/.exec(t2)))
        return t2[1];
    }
    return "";
  }, goog.labs.userAgent.engine.getEngineTuple_ = function(e2) {
    if (!goog.labs.userAgent.engine.isEdge())
      return e2[1];
    for (var t2 = 0; t2 < e2.length; t2++) {
      var r2 = e2[t2];
      if ("Edge" == r2[0])
        return r2;
    }
  }, goog.labs.userAgent.engine.isVersionOrHigher = function(e2) {
    return 0 <= goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(), e2);
  }, goog.labs.userAgent.engine.getVersionForKey_ = function(e2, t2) {
    return (e2 = goog.array.find(e2, function(e3) {
      return t2 == e3[0];
    })) && e2[1] || "";
  }, goog.labs.userAgent.platform = {}, goog.labs.userAgent.platform.isAndroid = function() {
    return goog.labs.userAgent.util.matchUserAgent("Android");
  }, goog.labs.userAgent.platform.isIpod = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPod");
  }, goog.labs.userAgent.platform.isIphone = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPhone") && !goog.labs.userAgent.util.matchUserAgent("iPod") && !goog.labs.userAgent.util.matchUserAgent("iPad");
  }, goog.labs.userAgent.platform.isIpad = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPad");
  }, goog.labs.userAgent.platform.isIos = function() {
    return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpad() || goog.labs.userAgent.platform.isIpod();
  }, goog.labs.userAgent.platform.isMacintosh = function() {
    return goog.labs.userAgent.util.matchUserAgent("Macintosh");
  }, goog.labs.userAgent.platform.isLinux = function() {
    return goog.labs.userAgent.util.matchUserAgent("Linux");
  }, goog.labs.userAgent.platform.isWindows = function() {
    return goog.labs.userAgent.util.matchUserAgent("Windows");
  }, goog.labs.userAgent.platform.isChromeOS = function() {
    return goog.labs.userAgent.util.matchUserAgent("CrOS");
  }, goog.labs.userAgent.platform.isChromecast = function() {
    return goog.labs.userAgent.util.matchUserAgent("CrKey");
  }, goog.labs.userAgent.platform.isKaiOS = function() {
    return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS");
  }, goog.labs.userAgent.platform.getVersion = function() {
    var e2 = goog.labs.userAgent.util.getUserAgent(), t2 = "";
    return goog.labs.userAgent.platform.isWindows() ? t2 = (e2 = (t2 = /Windows (?:NT|Phone) ([0-9.]+)/).exec(e2)) ? e2[1] : "0.0" : goog.labs.userAgent.platform.isIos() ? t2 = (e2 = (t2 = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/).exec(e2)) && e2[1].replace(/_/g, ".") : goog.labs.userAgent.platform.isMacintosh() ? t2 = (e2 = (t2 = /Mac OS X ([0-9_.]+)/).exec(e2)) ? e2[1].replace(/_/g, ".") : "10" : goog.labs.userAgent.platform.isKaiOS() ? t2 = (e2 = (t2 = /(?:KaiOS)\/(\S+)/i).exec(e2)) && e2[1] : goog.labs.userAgent.platform.isAndroid() ? t2 = (e2 = (t2 = /Android\s+([^\);]+)(\)|;)/).exec(e2)) && e2[1] : goog.labs.userAgent.platform.isChromeOS() && (t2 = (e2 = (t2 = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/).exec(e2)) && e2[1]), t2 || "";
  }, goog.labs.userAgent.platform.isVersionOrHigher = function(e2) {
    return 0 <= goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(), e2);
  }, goog.reflect = {}, goog.reflect.object = function(e2, t2) {
    return t2;
  }, goog.reflect.objectProperty = function(e2, t2) {
    return e2;
  }, goog.reflect.sinkValue = function(e2) {
    return goog.reflect.sinkValue[" "](e2), e2;
  }, goog.reflect.sinkValue[" "] = goog.nullFunction, goog.reflect.canAccessProperty = function(e2, t2) {
    try {
      return goog.reflect.sinkValue(e2[t2]), true;
    } catch (e3) {
    }
    return false;
  }, goog.reflect.cache = function(e2, t2, r2, o2) {
    return o2 = o2 ? o2(t2) : t2, Object.prototype.hasOwnProperty.call(e2, o2) ? e2[o2] : e2[o2] = r2(t2);
  }, goog.userAgent = {}, goog.userAgent.ASSUME_IE = false, goog.userAgent.ASSUME_EDGE = false, goog.userAgent.ASSUME_GECKO = false, goog.userAgent.ASSUME_WEBKIT = false, goog.userAgent.ASSUME_MOBILE_WEBKIT = false, goog.userAgent.ASSUME_OPERA = false, goog.userAgent.ASSUME_ANY_VERSION = false, goog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO || goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_OPERA, goog.userAgent.getUserAgentString = function() {
    return goog.labs.userAgent.util.getUserAgent();
  }, goog.userAgent.getNavigatorTyped = function() {
    return goog.global.navigator || null;
  }, goog.userAgent.getNavigator = function() {
    return goog.userAgent.getNavigatorTyped();
  }, goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_OPERA : goog.labs.userAgent.browser.isOpera(), goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_IE : goog.labs.userAgent.browser.isIE(), goog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_EDGE : goog.labs.userAgent.engine.isEdge(), goog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE, goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_GECKO : goog.labs.userAgent.engine.isGecko(), goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT : goog.labs.userAgent.engine.isWebKit(), goog.userAgent.isMobile_ = function() {
    return goog.userAgent.WEBKIT && goog.labs.userAgent.util.matchUserAgent("Mobile");
  }, goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_(), goog.userAgent.SAFARI = goog.userAgent.WEBKIT, goog.userAgent.determinePlatform_ = function() {
    var e2 = goog.userAgent.getNavigatorTyped();
    return e2 && e2.platform || "";
  }, goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_(), goog.userAgent.ASSUME_MAC = false, goog.userAgent.ASSUME_WINDOWS = false, goog.userAgent.ASSUME_LINUX = false, goog.userAgent.ASSUME_X11 = false, goog.userAgent.ASSUME_ANDROID = false, goog.userAgent.ASSUME_IPHONE = false, goog.userAgent.ASSUME_IPAD = false, goog.userAgent.ASSUME_IPOD = false, goog.userAgent.ASSUME_KAIOS = false, goog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC || goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX || goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID || goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD, goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_MAC : goog.labs.userAgent.platform.isMacintosh();
  goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_WINDOWS : goog.labs.userAgent.platform.isWindows(), goog.userAgent.isLegacyLinux_ = function() {
    return goog.labs.userAgent.platform.isLinux() || goog.labs.userAgent.platform.isChromeOS();
  }, goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_LINUX : goog.userAgent.isLegacyLinux_(), goog.userAgent.isX11_ = function() {
    var e2 = goog.userAgent.getNavigatorTyped();
    return !!e2 && goog.string.contains(e2.appVersion || "", "X11");
  }, goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_X11 : goog.userAgent.isX11_(), goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_ANDROID : goog.labs.userAgent.platform.isAndroid(), goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE : goog.labs.userAgent.platform.isIphone(), goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad(), goog.userAgent.IPOD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIpod(), goog.userAgent.IOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIos(), goog.userAgent.KAIOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_KAIOS : goog.labs.userAgent.platform.isKaiOS(), goog.userAgent.determineVersion_ = function() {
    var e2 = "", t2 = goog.userAgent.getVersionRegexResult_();
    return t2 && (e2 = t2 ? t2[1] : ""), goog.userAgent.IE && (null != (t2 = goog.userAgent.getDocumentMode_()) && t2 > parseFloat(e2)) ? String(t2) : e2;
  }, goog.userAgent.getVersionRegexResult_ = function() {
    var e2 = goog.userAgent.getUserAgentString();
    return goog.userAgent.GECKO ? /rv:([^\);]+)(\)|;)/.exec(e2) : goog.userAgent.EDGE ? /Edge\/([\d\.]+)/.exec(e2) : goog.userAgent.IE ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(e2) : goog.userAgent.WEBKIT ? /WebKit\/(\S+)/.exec(e2) : goog.userAgent.OPERA ? /(?:Version)[ \/]?(\S+)/.exec(e2) : void 0;
  }, goog.userAgent.getDocumentMode_ = function() {
    var e2 = goog.global.document;
    return e2 ? e2.documentMode : void 0;
  }, goog.userAgent.VERSION = goog.userAgent.determineVersion_(), goog.userAgent.compare = function(e2, t2) {
    return goog.string.compareVersions(e2, t2);
  }, goog.userAgent.isVersionOrHigherCache_ = {}, goog.userAgent.isVersionOrHigher = function(e2) {
    return goog.userAgent.ASSUME_ANY_VERSION || goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_, e2, function() {
      return 0 <= goog.string.compareVersions(goog.userAgent.VERSION, e2);
    });
  }, goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher, goog.userAgent.isDocumentModeOrHigher = function(e2) {
    return Number(goog.userAgent.DOCUMENT_MODE) >= e2;
  }, goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher, goog.userAgent.DOCUMENT_MODE = function() {
    if (goog.global.document && goog.userAgent.IE) {
      var e2 = goog.userAgent.getDocumentMode_();
      return e2 || (parseInt(goog.userAgent.VERSION, 10) || void 0);
    }
  }(), goog.userAgent.product = {}, goog.userAgent.product.ASSUME_FIREFOX = false, goog.userAgent.product.ASSUME_IPHONE = false, goog.userAgent.product.ASSUME_IPAD = false, goog.userAgent.product.ASSUME_ANDROID = false, goog.userAgent.product.ASSUME_CHROME = false, goog.userAgent.product.ASSUME_SAFARI = false, goog.userAgent.product.PRODUCT_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_OPERA || goog.userAgent.product.ASSUME_FIREFOX || goog.userAgent.product.ASSUME_IPHONE || goog.userAgent.product.ASSUME_IPAD || goog.userAgent.product.ASSUME_ANDROID || goog.userAgent.product.ASSUME_CHROME || goog.userAgent.product.ASSUME_SAFARI, goog.userAgent.product.OPERA = goog.userAgent.OPERA, goog.userAgent.product.IE = goog.userAgent.IE, goog.userAgent.product.EDGE = goog.userAgent.EDGE, goog.userAgent.product.FIREFOX = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_FIREFOX : goog.labs.userAgent.browser.isFirefox(), goog.userAgent.product.isIphoneOrIpod_ = function() {
    return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpod();
  }, goog.userAgent.product.IPHONE = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPHONE : goog.userAgent.product.isIphoneOrIpod_(), goog.userAgent.product.IPAD = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad(), goog.userAgent.product.ANDROID = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_ANDROID : goog.labs.userAgent.browser.isAndroidBrowser(), goog.userAgent.product.CHROME = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_CHROME : goog.labs.userAgent.browser.isChrome(), goog.userAgent.product.isSafariDesktop_ = function() {
    return goog.labs.userAgent.browser.isSafari() && !goog.labs.userAgent.platform.isIos();
  }, goog.userAgent.product.SAFARI = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_SAFARI : goog.userAgent.product.isSafariDesktop_(), goog.crypt.base64 = {}, goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", goog.crypt.base64.ENCODED_VALS = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "+/=", goog.crypt.base64.ENCODED_VALS_WEBSAFE = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "-_.", goog.crypt.base64.Alphabet = { DEFAULT: 0, NO_PADDING: 1, WEBSAFE: 2, WEBSAFE_DOT_PADDING: 3, WEBSAFE_NO_PADDING: 4 }, goog.crypt.base64.paddingChars_ = "=.", goog.crypt.base64.isPadding_ = function(e2) {
    return goog.string.contains(goog.crypt.base64.paddingChars_, e2);
  }, goog.crypt.base64.byteToCharMaps_ = {}, goog.crypt.base64.charToByteMap_ = null, goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO || goog.userAgent.WEBKIT && !goog.userAgent.product.SAFARI || goog.userAgent.OPERA, goog.crypt.base64.HAS_NATIVE_ENCODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || "function" == typeof goog.global.btoa, goog.crypt.base64.HAS_NATIVE_DECODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || !goog.userAgent.product.SAFARI && !goog.userAgent.IE && "function" == typeof goog.global.atob, goog.crypt.base64.encodeByteArray = function(e2, t2) {
    goog.asserts.assert(goog.isArrayLike(e2), "encodeByteArray takes an array as a parameter"), void 0 === t2 && (t2 = goog.crypt.base64.Alphabet.DEFAULT), goog.crypt.base64.init_(), t2 = goog.crypt.base64.byteToCharMaps_[t2];
    for (var r2 = [], o2 = 0; o2 < e2.length; o2 += 3) {
      var i3 = e2[o2], a3 = o2 + 1 < e2.length, n2 = a3 ? e2[o2 + 1] : 0, s2 = o2 + 2 < e2.length, p = s2 ? e2[o2 + 2] : 0, d2 = i3 >> 2;
      i3 = (3 & i3) << 4 | n2 >> 4, n2 = (15 & n2) << 2 | p >> 6, p &= 63, s2 || (p = 64, a3 || (n2 = 64)), r2.push(t2[d2], t2[i3], t2[n2] || "", t2[p] || "");
    }
    return r2.join("");
  }, goog.crypt.base64.encodeString = function(e2, t2) {
    return goog.crypt.base64.HAS_NATIVE_ENCODE_ && !t2 ? goog.global.btoa(e2) : goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(e2), t2);
  }, goog.crypt.base64.decodeString = function(e2, t2) {
    if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !t2)
      return goog.global.atob(e2);
    var r2 = "";
    return goog.crypt.base64.decodeStringInternal_(e2, function(e3) {
      r2 += String.fromCharCode(e3);
    }), r2;
  }, goog.crypt.base64.decodeStringToByteArray = function(e2, t2) {
    var r2 = [];
    return goog.crypt.base64.decodeStringInternal_(e2, function(e3) {
      r2.push(e3);
    }), r2;
  }, goog.crypt.base64.decodeStringToUint8Array = function(e2) {
    goog.asserts.assert(!goog.userAgent.IE || goog.userAgent.isVersionOrHigher("10"), "Browser does not support typed arrays");
    var t2 = e2.length, r2 = 3 * t2 / 4;
    r2 % 3 ? r2 = Math.floor(r2) : goog.crypt.base64.isPadding_(e2[t2 - 1]) && (r2 = goog.crypt.base64.isPadding_(e2[t2 - 2]) ? r2 - 2 : r2 - 1);
    var o2 = new Uint8Array(r2), i3 = 0;
    return goog.crypt.base64.decodeStringInternal_(e2, function(e3) {
      o2[i3++] = e3;
    }), o2.subarray(0, i3);
  }, goog.crypt.base64.decodeStringInternal_ = function(e2, t2) {
    function r2(t3) {
      for (; o2 < e2.length; ) {
        var r3 = e2.charAt(o2++), i4 = goog.crypt.base64.charToByteMap_[r3];
        if (null != i4)
          return i4;
        if (!goog.string.isEmptyOrWhitespace(r3))
          throw Error("Unknown base64 encoding at char: " + r3);
      }
      return t3;
    }
    goog.crypt.base64.init_();
    for (var o2 = 0; ; ) {
      var i3 = r2(-1), a3 = r2(0), n2 = r2(64), s2 = r2(64);
      if (64 === s2 && -1 === i3)
        break;
      t2(i3 << 2 | a3 >> 4), 64 != n2 && (t2(a3 << 4 & 240 | n2 >> 2), 64 != s2 && t2(n2 << 6 & 192 | s2));
    }
  }, goog.crypt.base64.init_ = function() {
    if (!goog.crypt.base64.charToByteMap_) {
      goog.crypt.base64.charToByteMap_ = {};
      for (var e2 = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""), t2 = ["+/=", "+/", "-_=", "-_.", "-_"], r2 = 0; 5 > r2; r2++) {
        var o2 = e2.concat(t2[r2].split(""));
        goog.crypt.base64.byteToCharMaps_[r2] = o2;
        for (var i3 = 0; i3 < o2.length; i3++) {
          var a3 = o2[i3], n2 = goog.crypt.base64.charToByteMap_[a3];
          void 0 === n2 ? goog.crypt.base64.charToByteMap_[a3] = i3 : goog.asserts.assert(n2 === i3);
        }
      }
    }
  }, jspb.utils = {}, jspb.utils.split64Low = 0, jspb.utils.split64High = 0, jspb.utils.splitUint64 = function(e2) {
    var t2 = e2 >>> 0;
    e2 = Math.floor((e2 - t2) / jspb.BinaryConstants.TWO_TO_32) >>> 0, jspb.utils.split64Low = t2, jspb.utils.split64High = e2;
  }, jspb.utils.splitInt64 = function(e2) {
    var t2 = 0 > e2, r2 = (e2 = Math.abs(e2)) >>> 0;
    e2 = Math.floor((e2 - r2) / jspb.BinaryConstants.TWO_TO_32), e2 >>>= 0, t2 && (e2 = ~e2 >>> 0, 4294967295 < (r2 = 1 + (~r2 >>> 0)) && (r2 = 0, 4294967295 < ++e2 && (e2 = 0))), jspb.utils.split64Low = r2, jspb.utils.split64High = e2;
  }, jspb.utils.splitZigzag64 = function(e2) {
    var t2 = 0 > e2;
    e2 = 2 * Math.abs(e2), jspb.utils.splitUint64(e2), e2 = jspb.utils.split64Low;
    var r2 = jspb.utils.split64High;
    t2 && (0 == e2 ? 0 == r2 ? r2 = e2 = 4294967295 : (r2--, e2 = 4294967295) : e2--), jspb.utils.split64Low = e2, jspb.utils.split64High = r2;
  }, jspb.utils.splitFloat32 = function(e2) {
    var t2 = 0 > e2 ? 1 : 0;
    if (0 === (e2 = t2 ? -e2 : e2))
      0 < 1 / e2 ? (jspb.utils.split64High = 0, jspb.utils.split64Low = 0) : (jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483648);
    else if (isNaN(e2))
      jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483647;
    else if (e2 > jspb.BinaryConstants.FLOAT32_MAX)
      jspb.utils.split64High = 0, jspb.utils.split64Low = (t2 << 31 | 2139095040) >>> 0;
    else if (e2 < jspb.BinaryConstants.FLOAT32_MIN)
      e2 = Math.round(e2 / Math.pow(2, -149)), jspb.utils.split64High = 0, jspb.utils.split64Low = (t2 << 31 | e2) >>> 0;
    else {
      var r2 = Math.floor(Math.log(e2) / Math.LN2);
      e2 *= Math.pow(2, -r2), 16777216 <= (e2 = Math.round(e2 * jspb.BinaryConstants.TWO_TO_23)) && ++r2, jspb.utils.split64High = 0, jspb.utils.split64Low = (t2 << 31 | r2 + 127 << 23 | 8388607 & e2) >>> 0;
    }
  }, jspb.utils.splitFloat64 = function(e2) {
    var t2 = 0 > e2 ? 1 : 0;
    if (0 === (e2 = t2 ? -e2 : e2))
      jspb.utils.split64High = 0 < 1 / e2 ? 0 : 2147483648, jspb.utils.split64Low = 0;
    else if (isNaN(e2))
      jspb.utils.split64High = 2147483647, jspb.utils.split64Low = 4294967295;
    else if (e2 > jspb.BinaryConstants.FLOAT64_MAX)
      jspb.utils.split64High = (t2 << 31 | 2146435072) >>> 0, jspb.utils.split64Low = 0;
    else if (e2 < jspb.BinaryConstants.FLOAT64_MIN) {
      var r2 = e2 / Math.pow(2, -1074);
      e2 = r2 / jspb.BinaryConstants.TWO_TO_32, jspb.utils.split64High = (t2 << 31 | e2) >>> 0, jspb.utils.split64Low = r2 >>> 0;
    } else {
      var o2 = 0;
      if (2 <= (r2 = e2))
        for (; 2 <= r2 && 1023 > o2; )
          o2++, r2 /= 2;
      else
        for (; 1 > r2 && -1022 < o2; )
          r2 *= 2, o2--;
      e2 = (r2 = e2 * Math.pow(2, -o2)) * jspb.BinaryConstants.TWO_TO_20 & 1048575, r2 = r2 * jspb.BinaryConstants.TWO_TO_52 >>> 0, jspb.utils.split64High = (t2 << 31 | o2 + 1023 << 20 | e2) >>> 0, jspb.utils.split64Low = r2;
    }
  }, jspb.utils.splitHash64 = function(e2) {
    var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), o2 = e2.charCodeAt(2), i3 = e2.charCodeAt(3), a3 = e2.charCodeAt(4), n2 = e2.charCodeAt(5), s2 = e2.charCodeAt(6);
    e2 = e2.charCodeAt(7), jspb.utils.split64Low = t2 + (r2 << 8) + (o2 << 16) + (i3 << 24) >>> 0, jspb.utils.split64High = a3 + (n2 << 8) + (s2 << 16) + (e2 << 24) >>> 0;
  }, jspb.utils.joinUint64 = function(e2, t2) {
    return t2 * jspb.BinaryConstants.TWO_TO_32 + (e2 >>> 0);
  }, jspb.utils.joinInt64 = function(e2, t2) {
    var r2 = 2147483648 & t2;
    return r2 && (t2 = ~t2 >>> 0, 0 == (e2 = 1 + ~e2 >>> 0) && (t2 = t2 + 1 >>> 0)), e2 = jspb.utils.joinUint64(e2, t2), r2 ? -e2 : e2;
  }, jspb.utils.toZigzag64 = function(e2, t2, r2) {
    var o2 = t2 >> 31;
    return r2(e2 << 1 ^ o2, (t2 << 1 | e2 >>> 31) ^ o2);
  }, jspb.utils.joinZigzag64 = function(e2, t2) {
    return jspb.utils.fromZigzag64(e2, t2, jspb.utils.joinInt64);
  }, jspb.utils.fromZigzag64 = function(e2, t2, r2) {
    var o2 = -(1 & e2);
    return r2((e2 >>> 1 | t2 << 31) ^ o2, t2 >>> 1 ^ o2);
  }, jspb.utils.joinFloat32 = function(e2, t2) {
    t2 = 2 * (e2 >> 31) + 1;
    var r2 = e2 >>> 23 & 255;
    return e2 &= 8388607, 255 == r2 ? e2 ? NaN : 1 / 0 * t2 : 0 == r2 ? t2 * Math.pow(2, -149) * e2 : t2 * Math.pow(2, r2 - 150) * (e2 + Math.pow(2, 23));
  }, jspb.utils.joinFloat64 = function(e2, t2) {
    var r2 = 2 * (t2 >> 31) + 1, o2 = t2 >>> 20 & 2047;
    return e2 = jspb.BinaryConstants.TWO_TO_32 * (1048575 & t2) + e2, 2047 == o2 ? e2 ? NaN : 1 / 0 * r2 : 0 == o2 ? r2 * Math.pow(2, -1074) * e2 : r2 * Math.pow(2, o2 - 1075) * (e2 + jspb.BinaryConstants.TWO_TO_52);
  }, jspb.utils.joinHash64 = function(e2, t2) {
    return String.fromCharCode(e2 >>> 0 & 255, e2 >>> 8 & 255, e2 >>> 16 & 255, e2 >>> 24 & 255, t2 >>> 0 & 255, t2 >>> 8 & 255, t2 >>> 16 & 255, t2 >>> 24 & 255);
  }, jspb.utils.DIGITS = "0123456789abcdef".split(""), jspb.utils.ZERO_CHAR_CODE_ = 48, jspb.utils.A_CHAR_CODE_ = 97, jspb.utils.joinUnsignedDecimalString = function(e2, t2) {
    function r2(e3, t3) {
      return e3 = e3 ? String(e3) : "", t3 ? "0000000".slice(e3.length) + e3 : e3;
    }
    if (2097151 >= t2)
      return "" + jspb.utils.joinUint64(e2, t2);
    var o2 = (e2 >>> 24 | t2 << 8) >>> 0 & 16777215;
    return e2 = (16777215 & e2) + 6777216 * o2 + 6710656 * (t2 = t2 >> 16 & 65535), o2 += 8147497 * t2, t2 *= 2, 1e7 <= e2 && (o2 += Math.floor(e2 / 1e7), e2 %= 1e7), 1e7 <= o2 && (t2 += Math.floor(o2 / 1e7), o2 %= 1e7), r2(t2, 0) + r2(o2, t2) + r2(e2, 1);
  }, jspb.utils.joinSignedDecimalString = function(e2, t2) {
    var r2 = 2147483648 & t2;
    return r2 && (t2 = ~t2 + (0 == (e2 = 1 + ~e2 >>> 0) ? 1 : 0) >>> 0), e2 = jspb.utils.joinUnsignedDecimalString(e2, t2), r2 ? "-" + e2 : e2;
  }, jspb.utils.hash64ToDecimalString = function(e2, t2) {
    jspb.utils.splitHash64(e2), e2 = jspb.utils.split64Low;
    var r2 = jspb.utils.split64High;
    return t2 ? jspb.utils.joinSignedDecimalString(e2, r2) : jspb.utils.joinUnsignedDecimalString(e2, r2);
  }, jspb.utils.hash64ArrayToDecimalStrings = function(e2, t2) {
    for (var r2 = Array(e2.length), o2 = 0; o2 < e2.length; o2++)
      r2[o2] = jspb.utils.hash64ToDecimalString(e2[o2], t2);
    return r2;
  }, jspb.utils.decimalStringToHash64 = function(e2) {
    function t2(e3, t3) {
      for (var r3 = 0; 8 > r3 && (1 !== e3 || 0 < t3); r3++)
        t3 = e3 * o2[r3] + t3, o2[r3] = 255 & t3, t3 >>>= 8;
    }
    jspb.asserts.assert(0 < e2.length);
    var r2 = false;
    "-" === e2[0] && (r2 = true, e2 = e2.slice(1));
    for (var o2 = [0, 0, 0, 0, 0, 0, 0, 0], i3 = 0; i3 < e2.length; i3++)
      t2(10, e2.charCodeAt(i3) - jspb.utils.ZERO_CHAR_CODE_);
    return r2 && (function() {
      for (var e3 = 0; 8 > e3; e3++)
        o2[e3] = 255 & ~o2[e3];
    }(), t2(1, 1)), goog.crypt.byteArrayToString(o2);
  }, jspb.utils.splitDecimalString = function(e2) {
    jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(e2));
  }, jspb.utils.toHexDigit_ = function(e2) {
    return String.fromCharCode(10 > e2 ? jspb.utils.ZERO_CHAR_CODE_ + e2 : jspb.utils.A_CHAR_CODE_ - 10 + e2);
  }, jspb.utils.fromHexCharCode_ = function(e2) {
    return e2 >= jspb.utils.A_CHAR_CODE_ ? e2 - jspb.utils.A_CHAR_CODE_ + 10 : e2 - jspb.utils.ZERO_CHAR_CODE_;
  }, jspb.utils.hash64ToHexString = function(e2) {
    var t2 = Array(18);
    t2[0] = "0", t2[1] = "x";
    for (var r2 = 0; 8 > r2; r2++) {
      var o2 = e2.charCodeAt(7 - r2);
      t2[2 * r2 + 2] = jspb.utils.toHexDigit_(o2 >> 4), t2[2 * r2 + 3] = jspb.utils.toHexDigit_(15 & o2);
    }
    return t2.join("");
  }, jspb.utils.hexStringToHash64 = function(e2) {
    e2 = e2.toLowerCase(), jspb.asserts.assert(18 == e2.length), jspb.asserts.assert("0" == e2[0]), jspb.asserts.assert("x" == e2[1]);
    for (var t2 = "", r2 = 0; 8 > r2; r2++) {
      var o2 = jspb.utils.fromHexCharCode_(e2.charCodeAt(2 * r2 + 2)), i3 = jspb.utils.fromHexCharCode_(e2.charCodeAt(2 * r2 + 3));
      t2 = String.fromCharCode(16 * o2 + i3) + t2;
    }
    return t2;
  }, jspb.utils.hash64ToNumber = function(e2, t2) {
    jspb.utils.splitHash64(e2), e2 = jspb.utils.split64Low;
    var r2 = jspb.utils.split64High;
    return t2 ? jspb.utils.joinInt64(e2, r2) : jspb.utils.joinUint64(e2, r2);
  }, jspb.utils.numberToHash64 = function(e2) {
    return jspb.utils.splitInt64(e2), jspb.utils.joinHash64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.utils.countVarints = function(e2, t2, r2) {
    for (var o2 = 0, i3 = t2; i3 < r2; i3++)
      o2 += e2[i3] >> 7;
    return r2 - t2 - o2;
  }, jspb.utils.countVarintFields = function(e2, t2, r2, o2) {
    var i3 = 0;
    if (128 > (o2 = 8 * o2 + jspb.BinaryConstants.WireType.VARINT))
      for (; t2 < r2 && e2[t2++] == o2; )
        for (i3++; ; ) {
          var a3 = e2[t2++];
          if (0 == (128 & a3))
            break;
        }
    else
      for (; t2 < r2; ) {
        for (a3 = o2; 128 < a3; ) {
          if (e2[t2] != (127 & a3 | 128))
            return i3;
          t2++, a3 >>= 7;
        }
        if (e2[t2++] != a3)
          break;
        for (i3++; 0 != (128 & (a3 = e2[t2++])); )
          ;
      }
    return i3;
  }, jspb.utils.countFixedFields_ = function(e2, t2, r2, o2, i3) {
    var a3 = 0;
    if (128 > o2)
      for (; t2 < r2 && e2[t2++] == o2; )
        a3++, t2 += i3;
    else
      for (; t2 < r2; ) {
        for (var n2 = o2; 128 < n2; ) {
          if (e2[t2++] != (127 & n2 | 128))
            return a3;
          n2 >>= 7;
        }
        if (e2[t2++] != n2)
          break;
        a3++, t2 += i3;
      }
    return a3;
  }, jspb.utils.countFixed32Fields = function(e2, t2, r2, o2) {
    return jspb.utils.countFixedFields_(e2, t2, r2, 8 * o2 + jspb.BinaryConstants.WireType.FIXED32, 4);
  }, jspb.utils.countFixed64Fields = function(e2, t2, r2, o2) {
    return jspb.utils.countFixedFields_(e2, t2, r2, 8 * o2 + jspb.BinaryConstants.WireType.FIXED64, 8);
  }, jspb.utils.countDelimitedFields = function(e2, t2, r2, o2) {
    var i3 = 0;
    for (o2 = 8 * o2 + jspb.BinaryConstants.WireType.DELIMITED; t2 < r2; ) {
      for (var a3 = o2; 128 < a3; ) {
        if (e2[t2++] != (127 & a3 | 128))
          return i3;
        a3 >>= 7;
      }
      if (e2[t2++] != a3)
        break;
      i3++;
      for (var n2 = 0, s2 = 1; n2 += (127 & (a3 = e2[t2++])) * s2, s2 *= 128, 0 != (128 & a3); )
        ;
      t2 += n2;
    }
    return i3;
  }, jspb.utils.debugBytesToTextFormat = function(e2) {
    var t2 = '"';
    if (e2) {
      e2 = jspb.utils.byteSourceToUint8Array(e2);
      for (var r2 = 0; r2 < e2.length; r2++)
        t2 += "\\x", 16 > e2[r2] && (t2 += "0"), t2 += e2[r2].toString(16);
    }
    return t2 + '"';
  }, jspb.utils.debugScalarToTextFormat = function(e2) {
    return "string" == typeof e2 ? goog.string.quote(e2) : e2.toString();
  }, jspb.utils.stringToByteArray = function(e2) {
    for (var t2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; r2++) {
      var o2 = e2.charCodeAt(r2);
      if (255 < o2)
        throw Error("Conversion error: string contains codepoint outside of byte range");
      t2[r2] = o2;
    }
    return t2;
  }, jspb.utils.byteSourceToUint8Array = function(e2) {
    return e2.constructor === Uint8Array ? e2 : e2.constructor === ArrayBuffer || e2.constructor === Array ? new Uint8Array(e2) : e2.constructor === String ? goog.crypt.base64.decodeStringToUint8Array(e2) : e2 instanceof Uint8Array ? new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength) : (jspb.asserts.fail("Type not convertible to Uint8Array."), new Uint8Array(0));
  }, jspb.BinaryDecoder = function(e2, t2, r2) {
    this.bytes_ = null, this.cursor_ = this.end_ = this.start_ = 0, this.error_ = false, e2 && this.setBlock(e2, t2, r2);
  }, jspb.BinaryDecoder.instanceCache_ = [], jspb.BinaryDecoder.alloc = function(e2, t2, r2) {
    if (jspb.BinaryDecoder.instanceCache_.length) {
      var o2 = jspb.BinaryDecoder.instanceCache_.pop();
      return e2 && o2.setBlock(e2, t2, r2), o2;
    }
    return new jspb.BinaryDecoder(e2, t2, r2);
  }, jspb.BinaryDecoder.prototype.free = function() {
    this.clear(), 100 > jspb.BinaryDecoder.instanceCache_.length && jspb.BinaryDecoder.instanceCache_.push(this);
  }, jspb.BinaryDecoder.prototype.clone = function() {
    return jspb.BinaryDecoder.alloc(this.bytes_, this.start_, this.end_ - this.start_);
  }, jspb.BinaryDecoder.prototype.clear = function() {
    this.bytes_ = null, this.cursor_ = this.end_ = this.start_ = 0, this.error_ = false;
  }, jspb.BinaryDecoder.prototype.getBuffer = function() {
    return this.bytes_;
  }, jspb.BinaryDecoder.prototype.setBlock = function(e2, t2, r2) {
    this.bytes_ = jspb.utils.byteSourceToUint8Array(e2), this.start_ = void 0 !== t2 ? t2 : 0, this.end_ = void 0 !== r2 ? this.start_ + r2 : this.bytes_.length, this.cursor_ = this.start_;
  }, jspb.BinaryDecoder.prototype.getEnd = function() {
    return this.end_;
  }, jspb.BinaryDecoder.prototype.setEnd = function(e2) {
    this.end_ = e2;
  }, jspb.BinaryDecoder.prototype.reset = function() {
    this.cursor_ = this.start_;
  }, jspb.BinaryDecoder.prototype.getCursor = function() {
    return this.cursor_;
  }, jspb.BinaryDecoder.prototype.setCursor = function(e2) {
    this.cursor_ = e2;
  }, jspb.BinaryDecoder.prototype.advance = function(e2) {
    this.cursor_ += e2, jspb.asserts.assert(this.cursor_ <= this.end_);
  }, jspb.BinaryDecoder.prototype.atEnd = function() {
    return this.cursor_ == this.end_;
  }, jspb.BinaryDecoder.prototype.pastEnd = function() {
    return this.cursor_ > this.end_;
  }, jspb.BinaryDecoder.prototype.getError = function() {
    return this.error_ || 0 > this.cursor_ || this.cursor_ > this.end_;
  }, jspb.BinaryDecoder.prototype.readSplitVarint64 = function(e2) {
    for (var t2 = 128, r2 = 0, o2 = 0, i3 = 0; 4 > i3 && 128 <= t2; i3++)
      r2 |= (127 & (t2 = this.bytes_[this.cursor_++])) << 7 * i3;
    if (128 <= t2 && (r2 |= (127 & (t2 = this.bytes_[this.cursor_++])) << 28, o2 |= (127 & t2) >> 4), 128 <= t2)
      for (i3 = 0; 5 > i3 && 128 <= t2; i3++)
        o2 |= (127 & (t2 = this.bytes_[this.cursor_++])) << 7 * i3 + 3;
    if (128 > t2)
      return e2(r2 >>> 0, o2 >>> 0);
    jspb.asserts.fail("Failed to read varint, encoding is invalid."), this.error_ = true;
  }, jspb.BinaryDecoder.prototype.readSplitZigzagVarint64 = function(e2) {
    return this.readSplitVarint64(function(t2, r2) {
      return jspb.utils.fromZigzag64(t2, r2, e2);
    });
  }, jspb.BinaryDecoder.prototype.readSplitFixed64 = function(e2) {
    var t2 = this.bytes_, r2 = this.cursor_;
    this.cursor_ += 8;
    for (var o2 = 0, i3 = 0, a3 = r2 + 7; a3 >= r2; a3--)
      o2 = o2 << 8 | t2[a3], i3 = i3 << 8 | t2[a3 + 4];
    return e2(o2, i3);
  }, jspb.BinaryDecoder.prototype.skipVarint = function() {
    for (; 128 & this.bytes_[this.cursor_]; )
      this.cursor_++;
    this.cursor_++;
  }, jspb.BinaryDecoder.prototype.unskipVarint = function(e2) {
    for (; 128 < e2; )
      this.cursor_--, e2 >>>= 7;
    this.cursor_--;
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint32 = function() {
    var e2 = this.bytes_, t2 = e2[this.cursor_ + 0], r2 = 127 & t2;
    return 128 > t2 ? (this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), r2) : (r2 |= (127 & (t2 = e2[this.cursor_ + 1])) << 7, 128 > t2 ? (this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), r2) : (r2 |= (127 & (t2 = e2[this.cursor_ + 2])) << 14, 128 > t2 ? (this.cursor_ += 3, jspb.asserts.assert(this.cursor_ <= this.end_), r2) : (r2 |= (127 & (t2 = e2[this.cursor_ + 3])) << 21, 128 > t2 ? (this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), r2) : (r2 |= (15 & (t2 = e2[this.cursor_ + 4])) << 28, 128 > t2 ? (this.cursor_ += 5, jspb.asserts.assert(this.cursor_ <= this.end_), r2 >>> 0) : (this.cursor_ += 5, 128 <= e2[this.cursor_++] && 128 <= e2[this.cursor_++] && 128 <= e2[this.cursor_++] && 128 <= e2[this.cursor_++] && 128 <= e2[this.cursor_++] && jspb.asserts.assert(false), jspb.asserts.assert(this.cursor_ <= this.end_), r2)))));
  }, jspb.BinaryDecoder.prototype.readSignedVarint32 = function() {
    return ~~this.readUnsignedVarint32();
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint32String = function() {
    return this.readUnsignedVarint32().toString();
  }, jspb.BinaryDecoder.prototype.readSignedVarint32String = function() {
    return this.readSignedVarint32().toString();
  }, jspb.BinaryDecoder.prototype.readZigzagVarint32 = function() {
    var e2 = this.readUnsignedVarint32();
    return e2 >>> 1 ^ -(1 & e2);
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint64 = function() {
    return this.readSplitVarint64(jspb.utils.joinUint64);
  }, jspb.BinaryDecoder.prototype.readUnsignedVarint64String = function() {
    return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString);
  }, jspb.BinaryDecoder.prototype.readSignedVarint64 = function() {
    return this.readSplitVarint64(jspb.utils.joinInt64);
  }, jspb.BinaryDecoder.prototype.readSignedVarint64String = function() {
    return this.readSplitVarint64(jspb.utils.joinSignedDecimalString);
  }, jspb.BinaryDecoder.prototype.readZigzagVarint64 = function() {
    return this.readSplitVarint64(jspb.utils.joinZigzag64);
  }, jspb.BinaryDecoder.prototype.readZigzagVarintHash64 = function() {
    return this.readSplitZigzagVarint64(jspb.utils.joinHash64);
  }, jspb.BinaryDecoder.prototype.readZigzagVarint64String = function() {
    return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString);
  }, jspb.BinaryDecoder.prototype.readUint8 = function() {
    var e2 = this.bytes_[this.cursor_ + 0];
    return this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), e2;
  }, jspb.BinaryDecoder.prototype.readUint16 = function() {
    var e2 = this.bytes_[this.cursor_ + 0], t2 = this.bytes_[this.cursor_ + 1];
    return this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), e2 << 0 | t2 << 8;
  }, jspb.BinaryDecoder.prototype.readUint32 = function() {
    var e2 = this.bytes_[this.cursor_ + 0], t2 = this.bytes_[this.cursor_ + 1], r2 = this.bytes_[this.cursor_ + 2], o2 = this.bytes_[this.cursor_ + 3];
    return this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), (e2 << 0 | t2 << 8 | r2 << 16 | o2 << 24) >>> 0;
  }, jspb.BinaryDecoder.prototype.readUint64 = function() {
    var e2 = this.readUint32(), t2 = this.readUint32();
    return jspb.utils.joinUint64(e2, t2);
  }, jspb.BinaryDecoder.prototype.readUint64String = function() {
    var e2 = this.readUint32(), t2 = this.readUint32();
    return jspb.utils.joinUnsignedDecimalString(e2, t2);
  }, jspb.BinaryDecoder.prototype.readInt8 = function() {
    var e2 = this.bytes_[this.cursor_ + 0];
    return this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), e2 << 24 >> 24;
  }, jspb.BinaryDecoder.prototype.readInt16 = function() {
    var e2 = this.bytes_[this.cursor_ + 0], t2 = this.bytes_[this.cursor_ + 1];
    return this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), (e2 << 0 | t2 << 8) << 16 >> 16;
  }, jspb.BinaryDecoder.prototype.readInt32 = function() {
    var e2 = this.bytes_[this.cursor_ + 0], t2 = this.bytes_[this.cursor_ + 1], r2 = this.bytes_[this.cursor_ + 2], o2 = this.bytes_[this.cursor_ + 3];
    return this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), e2 << 0 | t2 << 8 | r2 << 16 | o2 << 24;
  }, jspb.BinaryDecoder.prototype.readInt64 = function() {
    var e2 = this.readUint32(), t2 = this.readUint32();
    return jspb.utils.joinInt64(e2, t2);
  }, jspb.BinaryDecoder.prototype.readInt64String = function() {
    var e2 = this.readUint32(), t2 = this.readUint32();
    return jspb.utils.joinSignedDecimalString(e2, t2);
  }, jspb.BinaryDecoder.prototype.readFloat = function() {
    var e2 = this.readUint32();
    return jspb.utils.joinFloat32(e2, 0);
  }, jspb.BinaryDecoder.prototype.readDouble = function() {
    var e2 = this.readUint32(), t2 = this.readUint32();
    return jspb.utils.joinFloat64(e2, t2);
  }, jspb.BinaryDecoder.prototype.readBool = function() {
    return !!this.bytes_[this.cursor_++];
  }, jspb.BinaryDecoder.prototype.readEnum = function() {
    return this.readSignedVarint32();
  }, jspb.BinaryDecoder.prototype.readString = function(e2) {
    var t2 = this.bytes_, r2 = this.cursor_;
    e2 = r2 + e2;
    for (var o2 = [], i3 = ""; r2 < e2; ) {
      var a3 = t2[r2++];
      if (128 > a3)
        o2.push(a3);
      else {
        if (192 > a3)
          continue;
        if (224 > a3) {
          var n2 = t2[r2++];
          o2.push((31 & a3) << 6 | 63 & n2);
        } else if (240 > a3) {
          n2 = t2[r2++];
          var s2 = t2[r2++];
          o2.push((15 & a3) << 12 | (63 & n2) << 6 | 63 & s2);
        } else if (248 > a3) {
          a3 = (7 & a3) << 18 | (63 & (n2 = t2[r2++])) << 12 | (63 & (s2 = t2[r2++])) << 6 | 63 & t2[r2++], a3 -= 65536, o2.push(55296 + (a3 >> 10 & 1023), 56320 + (1023 & a3));
        }
      }
      8192 <= o2.length && (i3 += String.fromCharCode.apply(null, o2), o2.length = 0);
    }
    return i3 += goog.crypt.byteArrayToString(o2), this.cursor_ = r2, i3;
  }, jspb.BinaryDecoder.prototype.readStringWithLength = function() {
    var e2 = this.readUnsignedVarint32();
    return this.readString(e2);
  }, jspb.BinaryDecoder.prototype.readBytes = function(e2) {
    if (0 > e2 || this.cursor_ + e2 > this.bytes_.length)
      return this.error_ = true, jspb.asserts.fail("Invalid byte length!"), new Uint8Array(0);
    var t2 = this.bytes_.subarray(this.cursor_, this.cursor_ + e2);
    return this.cursor_ += e2, jspb.asserts.assert(this.cursor_ <= this.end_), t2;
  }, jspb.BinaryDecoder.prototype.readVarintHash64 = function() {
    return this.readSplitVarint64(jspb.utils.joinHash64);
  }, jspb.BinaryDecoder.prototype.readFixedHash64 = function() {
    var e2 = this.bytes_, t2 = this.cursor_, r2 = e2[t2 + 0], o2 = e2[t2 + 1], i3 = e2[t2 + 2], a3 = e2[t2 + 3], n2 = e2[t2 + 4], s2 = e2[t2 + 5], p = e2[t2 + 6];
    return e2 = e2[t2 + 7], this.cursor_ += 8, String.fromCharCode(r2, o2, i3, a3, n2, s2, p, e2);
  }, jspb.BinaryReader = function(e2, t2, r2) {
    this.decoder_ = jspb.BinaryDecoder.alloc(e2, t2, r2), this.fieldCursor_ = this.decoder_.getCursor(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID, this.error_ = false, this.readCallbacks_ = null;
  }, jspb.BinaryReader.instanceCache_ = [], jspb.BinaryReader.alloc = function(e2, t2, r2) {
    if (jspb.BinaryReader.instanceCache_.length) {
      var o2 = jspb.BinaryReader.instanceCache_.pop();
      return e2 && o2.decoder_.setBlock(e2, t2, r2), o2;
    }
    return new jspb.BinaryReader(e2, t2, r2);
  }, jspb.BinaryReader.prototype.alloc = jspb.BinaryReader.alloc, jspb.BinaryReader.prototype.free = function() {
    this.decoder_.clear(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID, this.error_ = false, this.readCallbacks_ = null, 100 > jspb.BinaryReader.instanceCache_.length && jspb.BinaryReader.instanceCache_.push(this);
  }, jspb.BinaryReader.prototype.getFieldCursor = function() {
    return this.fieldCursor_;
  }, jspb.BinaryReader.prototype.getCursor = function() {
    return this.decoder_.getCursor();
  }, jspb.BinaryReader.prototype.getBuffer = function() {
    return this.decoder_.getBuffer();
  }, jspb.BinaryReader.prototype.getFieldNumber = function() {
    return this.nextField_;
  }, goog.exportProperty(jspb.BinaryReader.prototype, "getFieldNumber", jspb.BinaryReader.prototype.getFieldNumber), jspb.BinaryReader.prototype.getWireType = function() {
    return this.nextWireType_;
  }, jspb.BinaryReader.prototype.isDelimited = function() {
    return this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED;
  }, goog.exportProperty(jspb.BinaryReader.prototype, "isDelimited", jspb.BinaryReader.prototype.isDelimited), jspb.BinaryReader.prototype.isEndGroup = function() {
    return this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP;
  }, goog.exportProperty(jspb.BinaryReader.prototype, "isEndGroup", jspb.BinaryReader.prototype.isEndGroup), jspb.BinaryReader.prototype.getError = function() {
    return this.error_ || this.decoder_.getError();
  }, jspb.BinaryReader.prototype.setBlock = function(e2, t2, r2) {
    this.decoder_.setBlock(e2, t2, r2), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
  }, jspb.BinaryReader.prototype.reset = function() {
    this.decoder_.reset(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
  }, jspb.BinaryReader.prototype.advance = function(e2) {
    this.decoder_.advance(e2);
  }, jspb.BinaryReader.prototype.nextField = function() {
    if (this.decoder_.atEnd())
      return false;
    if (this.getError())
      return jspb.asserts.fail("Decoder hit an error"), false;
    this.fieldCursor_ = this.decoder_.getCursor();
    var e2 = this.decoder_.readUnsignedVarint32(), t2 = e2 >>> 3;
    return (e2 &= 7) != jspb.BinaryConstants.WireType.VARINT && e2 != jspb.BinaryConstants.WireType.FIXED32 && e2 != jspb.BinaryConstants.WireType.FIXED64 && e2 != jspb.BinaryConstants.WireType.DELIMITED && e2 != jspb.BinaryConstants.WireType.START_GROUP && e2 != jspb.BinaryConstants.WireType.END_GROUP ? (jspb.asserts.fail("Invalid wire type: %s (at position %s)", e2, this.fieldCursor_), this.error_ = true, false) : (this.nextField_ = t2, this.nextWireType_ = e2, true);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "nextField", jspb.BinaryReader.prototype.nextField), jspb.BinaryReader.prototype.unskipHeader = function() {
    this.decoder_.unskipVarint(this.nextField_ << 3 | this.nextWireType_);
  }, jspb.BinaryReader.prototype.skipMatchingFields = function() {
    var e2 = this.nextField_;
    for (this.unskipHeader(); this.nextField() && this.getFieldNumber() == e2; )
      this.skipField();
    this.decoder_.atEnd() || this.unskipHeader();
  }, jspb.BinaryReader.prototype.skipVarintField = function() {
    this.nextWireType_ != jspb.BinaryConstants.WireType.VARINT ? (jspb.asserts.fail("Invalid wire type for skipVarintField"), this.skipField()) : this.decoder_.skipVarint();
  }, jspb.BinaryReader.prototype.skipDelimitedField = function() {
    if (this.nextWireType_ != jspb.BinaryConstants.WireType.DELIMITED)
      jspb.asserts.fail("Invalid wire type for skipDelimitedField"), this.skipField();
    else {
      var e2 = this.decoder_.readUnsignedVarint32();
      this.decoder_.advance(e2);
    }
  }, jspb.BinaryReader.prototype.skipFixed32Field = function() {
    this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED32 ? (jspb.asserts.fail("Invalid wire type for skipFixed32Field"), this.skipField()) : this.decoder_.advance(4);
  }, jspb.BinaryReader.prototype.skipFixed64Field = function() {
    this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED64 ? (jspb.asserts.fail("Invalid wire type for skipFixed64Field"), this.skipField()) : this.decoder_.advance(8);
  }, jspb.BinaryReader.prototype.skipGroup = function() {
    for (var e2 = this.nextField_; ; ) {
      if (!this.nextField()) {
        jspb.asserts.fail("Unmatched start-group tag: stream EOF"), this.error_ = true;
        break;
      }
      if (this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP) {
        this.nextField_ != e2 && (jspb.asserts.fail("Unmatched end-group tag"), this.error_ = true);
        break;
      }
      this.skipField();
    }
  }, jspb.BinaryReader.prototype.skipField = function() {
    switch (this.nextWireType_) {
      case jspb.BinaryConstants.WireType.VARINT:
        this.skipVarintField();
        break;
      case jspb.BinaryConstants.WireType.FIXED64:
        this.skipFixed64Field();
        break;
      case jspb.BinaryConstants.WireType.DELIMITED:
        this.skipDelimitedField();
        break;
      case jspb.BinaryConstants.WireType.FIXED32:
        this.skipFixed32Field();
        break;
      case jspb.BinaryConstants.WireType.START_GROUP:
        this.skipGroup();
        break;
      default:
        jspb.asserts.fail("Invalid wire encoding for field.");
    }
  }, jspb.BinaryReader.prototype.registerReadCallback = function(e2, t2) {
    null === this.readCallbacks_ && (this.readCallbacks_ = {}), jspb.asserts.assert(!this.readCallbacks_[e2]), this.readCallbacks_[e2] = t2;
  }, jspb.BinaryReader.prototype.runReadCallback = function(e2) {
    return jspb.asserts.assert(null !== this.readCallbacks_), e2 = this.readCallbacks_[e2], jspb.asserts.assert(e2), e2(this);
  }, jspb.BinaryReader.prototype.readAny = function(e2) {
    this.nextWireType_ = jspb.BinaryConstants.FieldTypeToWireType(e2);
    var t2 = jspb.BinaryConstants.FieldType;
    switch (e2) {
      case t2.DOUBLE:
        return this.readDouble();
      case t2.FLOAT:
        return this.readFloat();
      case t2.INT64:
        return this.readInt64();
      case t2.UINT64:
        return this.readUint64();
      case t2.INT32:
        return this.readInt32();
      case t2.FIXED64:
        return this.readFixed64();
      case t2.FIXED32:
        return this.readFixed32();
      case t2.BOOL:
        return this.readBool();
      case t2.STRING:
        return this.readString();
      case t2.GROUP:
        jspb.asserts.fail("Group field type not supported in readAny()");
      case t2.MESSAGE:
        jspb.asserts.fail("Message field type not supported in readAny()");
      case t2.BYTES:
        return this.readBytes();
      case t2.UINT32:
        return this.readUint32();
      case t2.ENUM:
        return this.readEnum();
      case t2.SFIXED32:
        return this.readSfixed32();
      case t2.SFIXED64:
        return this.readSfixed64();
      case t2.SINT32:
        return this.readSint32();
      case t2.SINT64:
        return this.readSint64();
      case t2.FHASH64:
        return this.readFixedHash64();
      case t2.VHASH64:
        return this.readVarintHash64();
      default:
        jspb.asserts.fail("Invalid field type in readAny()");
    }
    return 0;
  }, jspb.BinaryReader.prototype.readMessage = function(e2, t2) {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var r2 = this.decoder_.getEnd(), o2 = this.decoder_.readUnsignedVarint32();
    o2 = this.decoder_.getCursor() + o2, this.decoder_.setEnd(o2), t2(e2, this), this.decoder_.setCursor(o2), this.decoder_.setEnd(r2);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readMessage", jspb.BinaryReader.prototype.readMessage), jspb.BinaryReader.prototype.readGroup = function(e2, t2, r2) {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.START_GROUP), jspb.asserts.assert(this.nextField_ == e2), r2(t2, this), this.error_ || this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP || (jspb.asserts.fail("Group submessage did not end with an END_GROUP tag"), this.error_ = true);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readGroup", jspb.BinaryReader.prototype.readGroup), jspb.BinaryReader.prototype.getFieldDecoder = function() {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var e2 = this.decoder_.readUnsignedVarint32(), t2 = this.decoder_.getCursor(), r2 = t2 + e2;
    return e2 = jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(), t2, e2), this.decoder_.setCursor(r2), e2;
  }, jspb.BinaryReader.prototype.readInt32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readInt32", jspb.BinaryReader.prototype.readInt32), jspb.BinaryReader.prototype.readInt32String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint32String();
  }, jspb.BinaryReader.prototype.readInt64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readInt64", jspb.BinaryReader.prototype.readInt64), jspb.BinaryReader.prototype.readInt64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64String();
  }, jspb.BinaryReader.prototype.readUint32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readUint32", jspb.BinaryReader.prototype.readUint32), jspb.BinaryReader.prototype.readUint32String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint32String();
  }, jspb.BinaryReader.prototype.readUint64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readUint64", jspb.BinaryReader.prototype.readUint64), jspb.BinaryReader.prototype.readUint64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint64String();
  }, jspb.BinaryReader.prototype.readSint32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSint32", jspb.BinaryReader.prototype.readSint32), jspb.BinaryReader.prototype.readSint64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSint64", jspb.BinaryReader.prototype.readSint64), jspb.BinaryReader.prototype.readSint64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint64String();
  }, jspb.BinaryReader.prototype.readFixed32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readUint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readFixed32", jspb.BinaryReader.prototype.readFixed32), jspb.BinaryReader.prototype.readFixed64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readUint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readFixed64", jspb.BinaryReader.prototype.readFixed64), jspb.BinaryReader.prototype.readFixed64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readUint64String();
  }, jspb.BinaryReader.prototype.readSfixed32 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readInt32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSfixed32", jspb.BinaryReader.prototype.readSfixed32), jspb.BinaryReader.prototype.readSfixed32String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readInt32().toString();
  }, jspb.BinaryReader.prototype.readSfixed64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readInt64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readSfixed64", jspb.BinaryReader.prototype.readSfixed64), jspb.BinaryReader.prototype.readSfixed64String = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readInt64String();
  }, jspb.BinaryReader.prototype.readFloat = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readFloat();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readFloat", jspb.BinaryReader.prototype.readFloat), jspb.BinaryReader.prototype.readDouble = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readDouble();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readDouble", jspb.BinaryReader.prototype.readDouble), jspb.BinaryReader.prototype.readBool = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), !!this.decoder_.readUnsignedVarint32();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readBool", jspb.BinaryReader.prototype.readBool), jspb.BinaryReader.prototype.readEnum = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64();
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readEnum", jspb.BinaryReader.prototype.readEnum), jspb.BinaryReader.prototype.readString = function() {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var e2 = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readString(e2);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readString", jspb.BinaryReader.prototype.readString), jspb.BinaryReader.prototype.readBytes = function() {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var e2 = this.decoder_.readUnsignedVarint32();
    return this.decoder_.readBytes(e2);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readBytes", jspb.BinaryReader.prototype.readBytes), jspb.BinaryReader.prototype.readVarintHash64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readVarintHash64();
  }, jspb.BinaryReader.prototype.readSintHash64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarintHash64();
  }, jspb.BinaryReader.prototype.readSplitVarint64 = function(e2) {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSplitVarint64(e2);
  }, jspb.BinaryReader.prototype.readSplitZigzagVarint64 = function(e2) {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSplitVarint64(function(t2, r2) {
      return jspb.utils.fromZigzag64(t2, r2, e2);
    });
  }, jspb.BinaryReader.prototype.readFixedHash64 = function() {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readFixedHash64();
  }, jspb.BinaryReader.prototype.readSplitFixed64 = function(e2) {
    return jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readSplitFixed64(e2);
  }, jspb.BinaryReader.prototype.readPackedField_ = function(e2) {
    jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
    var t2 = this.decoder_.readUnsignedVarint32();
    t2 = this.decoder_.getCursor() + t2;
    for (var r2 = []; this.decoder_.getCursor() < t2; )
      r2.push(e2.call(this.decoder_));
    return r2;
  }, jspb.BinaryReader.prototype.readPackedInt32 = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedInt32", jspb.BinaryReader.prototype.readPackedInt32), jspb.BinaryReader.prototype.readPackedInt32String = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint32String);
  }, jspb.BinaryReader.prototype.readPackedInt64 = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedInt64", jspb.BinaryReader.prototype.readPackedInt64), jspb.BinaryReader.prototype.readPackedInt64String = function() {
    return this.readPackedField_(this.decoder_.readSignedVarint64String);
  }, jspb.BinaryReader.prototype.readPackedUint32 = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedUint32", jspb.BinaryReader.prototype.readPackedUint32), jspb.BinaryReader.prototype.readPackedUint32String = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint32String);
  }, jspb.BinaryReader.prototype.readPackedUint64 = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedUint64", jspb.BinaryReader.prototype.readPackedUint64), jspb.BinaryReader.prototype.readPackedUint64String = function() {
    return this.readPackedField_(this.decoder_.readUnsignedVarint64String);
  }, jspb.BinaryReader.prototype.readPackedSint32 = function() {
    return this.readPackedField_(this.decoder_.readZigzagVarint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSint32", jspb.BinaryReader.prototype.readPackedSint32), jspb.BinaryReader.prototype.readPackedSint64 = function() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSint64", jspb.BinaryReader.prototype.readPackedSint64), jspb.BinaryReader.prototype.readPackedSint64String = function() {
    return this.readPackedField_(this.decoder_.readZigzagVarint64String);
  }, jspb.BinaryReader.prototype.readPackedFixed32 = function() {
    return this.readPackedField_(this.decoder_.readUint32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFixed32", jspb.BinaryReader.prototype.readPackedFixed32), jspb.BinaryReader.prototype.readPackedFixed64 = function() {
    return this.readPackedField_(this.decoder_.readUint64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFixed64", jspb.BinaryReader.prototype.readPackedFixed64), jspb.BinaryReader.prototype.readPackedFixed64String = function() {
    return this.readPackedField_(this.decoder_.readUint64String);
  }, jspb.BinaryReader.prototype.readPackedSfixed32 = function() {
    return this.readPackedField_(this.decoder_.readInt32);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSfixed32", jspb.BinaryReader.prototype.readPackedSfixed32), jspb.BinaryReader.prototype.readPackedSfixed64 = function() {
    return this.readPackedField_(this.decoder_.readInt64);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSfixed64", jspb.BinaryReader.prototype.readPackedSfixed64), jspb.BinaryReader.prototype.readPackedSfixed64String = function() {
    return this.readPackedField_(this.decoder_.readInt64String);
  }, jspb.BinaryReader.prototype.readPackedFloat = function() {
    return this.readPackedField_(this.decoder_.readFloat);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFloat", jspb.BinaryReader.prototype.readPackedFloat), jspb.BinaryReader.prototype.readPackedDouble = function() {
    return this.readPackedField_(this.decoder_.readDouble);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedDouble", jspb.BinaryReader.prototype.readPackedDouble), jspb.BinaryReader.prototype.readPackedBool = function() {
    return this.readPackedField_(this.decoder_.readBool);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedBool", jspb.BinaryReader.prototype.readPackedBool), jspb.BinaryReader.prototype.readPackedEnum = function() {
    return this.readPackedField_(this.decoder_.readEnum);
  }, goog.exportProperty(jspb.BinaryReader.prototype, "readPackedEnum", jspb.BinaryReader.prototype.readPackedEnum), jspb.BinaryReader.prototype.readPackedVarintHash64 = function() {
    return this.readPackedField_(this.decoder_.readVarintHash64);
  }, jspb.BinaryReader.prototype.readPackedFixedHash64 = function() {
    return this.readPackedField_(this.decoder_.readFixedHash64);
  }, jspb.BinaryEncoder = function() {
    this.buffer_ = [];
  }, jspb.BinaryEncoder.prototype.length = function() {
    return this.buffer_.length;
  }, jspb.BinaryEncoder.prototype.end = function() {
    var e2 = this.buffer_;
    return this.buffer_ = [], e2;
  }, jspb.BinaryEncoder.prototype.writeSplitVarint64 = function(e2, t2) {
    for (jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(t2 == Math.floor(t2)), jspb.asserts.assert(0 <= e2 && e2 < jspb.BinaryConstants.TWO_TO_32), jspb.asserts.assert(0 <= t2 && t2 < jspb.BinaryConstants.TWO_TO_32); 0 < t2 || 127 < e2; )
      this.buffer_.push(127 & e2 | 128), e2 = (e2 >>> 7 | t2 << 25) >>> 0, t2 >>>= 7;
    this.buffer_.push(e2);
  }, jspb.BinaryEncoder.prototype.writeSplitFixed64 = function(e2, t2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(t2 == Math.floor(t2)), jspb.asserts.assert(0 <= e2 && e2 < jspb.BinaryConstants.TWO_TO_32), jspb.asserts.assert(0 <= t2 && t2 < jspb.BinaryConstants.TWO_TO_32), this.writeUint32(e2), this.writeUint32(t2);
  }, jspb.BinaryEncoder.prototype.writeUnsignedVarint32 = function(e2) {
    for (jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(0 <= e2 && e2 < jspb.BinaryConstants.TWO_TO_32); 127 < e2; )
      this.buffer_.push(127 & e2 | 128), e2 >>>= 7;
    this.buffer_.push(e2);
  }, jspb.BinaryEncoder.prototype.writeSignedVarint32 = function(e2) {
    if (jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(e2 >= -jspb.BinaryConstants.TWO_TO_31 && e2 < jspb.BinaryConstants.TWO_TO_31), 0 <= e2)
      this.writeUnsignedVarint32(e2);
    else {
      for (var t2 = 0; 9 > t2; t2++)
        this.buffer_.push(127 & e2 | 128), e2 >>= 7;
      this.buffer_.push(1);
    }
  }, jspb.BinaryEncoder.prototype.writeUnsignedVarint64 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(0 <= e2 && e2 < jspb.BinaryConstants.TWO_TO_64), jspb.utils.splitInt64(e2), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeSignedVarint64 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(e2 >= -jspb.BinaryConstants.TWO_TO_63 && e2 < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitInt64(e2), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeZigzagVarint32 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(e2 >= -jspb.BinaryConstants.TWO_TO_31 && e2 < jspb.BinaryConstants.TWO_TO_31), this.writeUnsignedVarint32((e2 << 1 ^ e2 >> 31) >>> 0);
  }, jspb.BinaryEncoder.prototype.writeZigzagVarint64 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(e2 >= -jspb.BinaryConstants.TWO_TO_63 && e2 < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitZigzag64(e2), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeZigzagVarint64String = function(e2) {
    this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(e2));
  }, jspb.BinaryEncoder.prototype.writeZigzagVarintHash64 = function(e2) {
    var t2 = this;
    jspb.utils.splitHash64(e2), jspb.utils.toZigzag64(jspb.utils.split64Low, jspb.utils.split64High, function(e3, r2) {
      t2.writeSplitVarint64(e3 >>> 0, r2 >>> 0);
    });
  }, jspb.BinaryEncoder.prototype.writeUint8 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(0 <= e2 && 256 > e2), this.buffer_.push(e2 >>> 0 & 255);
  }, jspb.BinaryEncoder.prototype.writeUint16 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(0 <= e2 && 65536 > e2), this.buffer_.push(e2 >>> 0 & 255), this.buffer_.push(e2 >>> 8 & 255);
  }, jspb.BinaryEncoder.prototype.writeUint32 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(0 <= e2 && e2 < jspb.BinaryConstants.TWO_TO_32), this.buffer_.push(e2 >>> 0 & 255), this.buffer_.push(e2 >>> 8 & 255), this.buffer_.push(e2 >>> 16 & 255), this.buffer_.push(e2 >>> 24 & 255);
  }, jspb.BinaryEncoder.prototype.writeUint64 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(0 <= e2 && e2 < jspb.BinaryConstants.TWO_TO_64), jspb.utils.splitUint64(e2), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeInt8 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(-128 <= e2 && 128 > e2), this.buffer_.push(e2 >>> 0 & 255);
  }, jspb.BinaryEncoder.prototype.writeInt16 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(-32768 <= e2 && 32768 > e2), this.buffer_.push(e2 >>> 0 & 255), this.buffer_.push(e2 >>> 8 & 255);
  }, jspb.BinaryEncoder.prototype.writeInt32 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(e2 >= -jspb.BinaryConstants.TWO_TO_31 && e2 < jspb.BinaryConstants.TWO_TO_31), this.buffer_.push(e2 >>> 0 & 255), this.buffer_.push(e2 >>> 8 & 255), this.buffer_.push(e2 >>> 16 & 255), this.buffer_.push(e2 >>> 24 & 255);
  }, jspb.BinaryEncoder.prototype.writeInt64 = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(e2 >= -jspb.BinaryConstants.TWO_TO_63 && e2 < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitInt64(e2), this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeInt64String = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(+e2 >= -jspb.BinaryConstants.TWO_TO_63 && +e2 < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(e2)), this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeFloat = function(e2) {
    jspb.asserts.assert(1 / 0 === e2 || -1 / 0 === e2 || isNaN(e2) || e2 >= -jspb.BinaryConstants.FLOAT32_MAX && e2 <= jspb.BinaryConstants.FLOAT32_MAX), jspb.utils.splitFloat32(e2), this.writeUint32(jspb.utils.split64Low);
  }, jspb.BinaryEncoder.prototype.writeDouble = function(e2) {
    jspb.asserts.assert(1 / 0 === e2 || -1 / 0 === e2 || isNaN(e2) || e2 >= -jspb.BinaryConstants.FLOAT64_MAX && e2 <= jspb.BinaryConstants.FLOAT64_MAX), jspb.utils.splitFloat64(e2), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeBool = function(e2) {
    jspb.asserts.assert("boolean" == typeof e2 || "number" == typeof e2), this.buffer_.push(e2 ? 1 : 0);
  }, jspb.BinaryEncoder.prototype.writeEnum = function(e2) {
    jspb.asserts.assert(e2 == Math.floor(e2)), jspb.asserts.assert(e2 >= -jspb.BinaryConstants.TWO_TO_31 && e2 < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32(e2);
  }, jspb.BinaryEncoder.prototype.writeBytes = function(e2) {
    this.buffer_.push.apply(this.buffer_, e2);
  }, jspb.BinaryEncoder.prototype.writeVarintHash64 = function(e2) {
    jspb.utils.splitHash64(e2), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeFixedHash64 = function(e2) {
    jspb.utils.splitHash64(e2), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
  }, jspb.BinaryEncoder.prototype.writeString = function(e2) {
    var t2 = this.buffer_.length;
    jspb.asserts.assertString(e2);
    for (var r2 = 0; r2 < e2.length; r2++) {
      var o2 = e2.charCodeAt(r2);
      if (128 > o2)
        this.buffer_.push(o2);
      else if (2048 > o2)
        this.buffer_.push(o2 >> 6 | 192), this.buffer_.push(63 & o2 | 128);
      else if (65536 > o2)
        if (55296 <= o2 && 56319 >= o2 && r2 + 1 < e2.length) {
          var i3 = e2.charCodeAt(r2 + 1);
          56320 <= i3 && 57343 >= i3 && (o2 = 1024 * (o2 - 55296) + i3 - 56320 + 65536, this.buffer_.push(o2 >> 18 | 240), this.buffer_.push(o2 >> 12 & 63 | 128), this.buffer_.push(o2 >> 6 & 63 | 128), this.buffer_.push(63 & o2 | 128), r2++);
        } else
          this.buffer_.push(o2 >> 12 | 224), this.buffer_.push(o2 >> 6 & 63 | 128), this.buffer_.push(63 & o2 | 128);
    }
    return this.buffer_.length - t2;
  }, jspb.arith = {}, jspb.arith.UInt64 = function(e2, t2) {
    this.lo = e2, this.hi = t2;
  }, jspb.arith.UInt64.prototype.cmp = function(e2) {
    return this.hi < e2.hi || this.hi == e2.hi && this.lo < e2.lo ? -1 : this.hi == e2.hi && this.lo == e2.lo ? 0 : 1;
  }, jspb.arith.UInt64.prototype.rightShift = function() {
    return new jspb.arith.UInt64((this.lo >>> 1 | (1 & this.hi) << 31) >>> 0, this.hi >>> 1 >>> 0);
  }, jspb.arith.UInt64.prototype.leftShift = function() {
    return new jspb.arith.UInt64(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
  }, jspb.arith.UInt64.prototype.msb = function() {
    return !!(2147483648 & this.hi);
  }, jspb.arith.UInt64.prototype.lsb = function() {
    return !!(1 & this.lo);
  }, jspb.arith.UInt64.prototype.zero = function() {
    return 0 == this.lo && 0 == this.hi;
  }, jspb.arith.UInt64.prototype.add = function(e2) {
    return new jspb.arith.UInt64((this.lo + e2.lo & 4294967295) >>> 0 >>> 0, ((this.hi + e2.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + e2.lo ? 1 : 0) >>> 0);
  }, jspb.arith.UInt64.prototype.sub = function(e2) {
    return new jspb.arith.UInt64((this.lo - e2.lo & 4294967295) >>> 0 >>> 0, ((this.hi - e2.hi & 4294967295) >>> 0) - (0 > this.lo - e2.lo ? 1 : 0) >>> 0);
  }, jspb.arith.UInt64.mul32x32 = function(e2, t2) {
    var r2 = 65535 & e2, o2 = 65535 & t2, i3 = t2 >>> 16;
    for (t2 = r2 * o2 + 65536 * (r2 * i3 & 65535) + 65536 * ((e2 >>>= 16) * o2 & 65535), r2 = e2 * i3 + (r2 * i3 >>> 16) + (e2 * o2 >>> 16); 4294967296 <= t2; )
      t2 -= 4294967296, r2 += 1;
    return new jspb.arith.UInt64(t2 >>> 0, r2 >>> 0);
  }, jspb.arith.UInt64.prototype.mul = function(e2) {
    var t2 = jspb.arith.UInt64.mul32x32(this.lo, e2);
    return (e2 = jspb.arith.UInt64.mul32x32(this.hi, e2)).hi = e2.lo, e2.lo = 0, t2.add(e2);
  }, jspb.arith.UInt64.prototype.div = function(e2) {
    if (0 == e2)
      return [];
    var t2 = new jspb.arith.UInt64(0, 0), r2 = new jspb.arith.UInt64(this.lo, this.hi);
    e2 = new jspb.arith.UInt64(e2, 0);
    for (var o2 = new jspb.arith.UInt64(1, 0); !e2.msb(); )
      e2 = e2.leftShift(), o2 = o2.leftShift();
    for (; !o2.zero(); )
      0 >= e2.cmp(r2) && (t2 = t2.add(o2), r2 = r2.sub(e2)), e2 = e2.rightShift(), o2 = o2.rightShift();
    return [t2, r2];
  }, jspb.arith.UInt64.prototype.toString = function() {
    for (var e2 = "", t2 = this; !t2.zero(); ) {
      var r2 = (t2 = t2.div(10))[0];
      e2 = t2[1].lo + e2, t2 = r2;
    }
    return "" == e2 && (e2 = "0"), e2;
  }, jspb.arith.UInt64.fromString = function(e2) {
    for (var t2 = new jspb.arith.UInt64(0, 0), r2 = new jspb.arith.UInt64(0, 0), o2 = 0; o2 < e2.length; o2++) {
      if ("0" > e2[o2] || "9" < e2[o2])
        return null;
      var i3 = parseInt(e2[o2], 10);
      r2.lo = i3, t2 = t2.mul(10).add(r2);
    }
    return t2;
  }, jspb.arith.UInt64.prototype.clone = function() {
    return new jspb.arith.UInt64(this.lo, this.hi);
  }, jspb.arith.Int64 = function(e2, t2) {
    this.lo = e2, this.hi = t2;
  }, jspb.arith.Int64.prototype.add = function(e2) {
    return new jspb.arith.Int64((this.lo + e2.lo & 4294967295) >>> 0 >>> 0, ((this.hi + e2.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + e2.lo ? 1 : 0) >>> 0);
  }, jspb.arith.Int64.prototype.sub = function(e2) {
    return new jspb.arith.Int64((this.lo - e2.lo & 4294967295) >>> 0 >>> 0, ((this.hi - e2.hi & 4294967295) >>> 0) - (0 > this.lo - e2.lo ? 1 : 0) >>> 0);
  }, jspb.arith.Int64.prototype.clone = function() {
    return new jspb.arith.Int64(this.lo, this.hi);
  }, jspb.arith.Int64.prototype.toString = function() {
    var e2 = 0 != (2147483648 & this.hi), t2 = new jspb.arith.UInt64(this.lo, this.hi);
    return e2 && (t2 = new jspb.arith.UInt64(0, 0).sub(t2)), (e2 ? "-" : "") + t2.toString();
  }, jspb.arith.Int64.fromString = function(e2) {
    var t2 = 0 < e2.length && "-" == e2[0];
    return t2 && (e2 = e2.substring(1)), null === (e2 = jspb.arith.UInt64.fromString(e2)) ? null : (t2 && (e2 = new jspb.arith.UInt64(0, 0).sub(e2)), new jspb.arith.Int64(e2.lo, e2.hi));
  }, jspb.BinaryWriter = function() {
    this.blocks_ = [], this.totalLength_ = 0, this.encoder_ = new jspb.BinaryEncoder(), this.bookmarks_ = [];
  }, jspb.BinaryWriter.prototype.appendUint8Array_ = function(e2) {
    var t2 = this.encoder_.end();
    this.blocks_.push(t2), this.blocks_.push(e2), this.totalLength_ += t2.length + e2.length;
  }, jspb.BinaryWriter.prototype.beginDelimited_ = function(e2) {
    return this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), e2 = this.encoder_.end(), this.blocks_.push(e2), this.totalLength_ += e2.length, e2.push(this.totalLength_), e2;
  }, jspb.BinaryWriter.prototype.endDelimited_ = function(e2) {
    var t2 = e2.pop();
    for (t2 = this.totalLength_ + this.encoder_.length() - t2, jspb.asserts.assert(0 <= t2); 127 < t2; )
      e2.push(127 & t2 | 128), t2 >>>= 7, this.totalLength_++;
    e2.push(t2), this.totalLength_++;
  }, jspb.BinaryWriter.prototype.writeSerializedMessage = function(e2, t2, r2) {
    this.appendUint8Array_(e2.subarray(t2, r2));
  }, jspb.BinaryWriter.prototype.maybeWriteSerializedMessage = function(e2, t2, r2) {
    null != e2 && null != t2 && null != r2 && this.writeSerializedMessage(e2, t2, r2);
  }, jspb.BinaryWriter.prototype.reset = function() {
    this.blocks_ = [], this.encoder_.end(), this.totalLength_ = 0, this.bookmarks_ = [];
  }, jspb.BinaryWriter.prototype.getResultBuffer = function() {
    jspb.asserts.assert(0 == this.bookmarks_.length);
    for (var e2 = new Uint8Array(this.totalLength_ + this.encoder_.length()), t2 = this.blocks_, r2 = t2.length, o2 = 0, i3 = 0; i3 < r2; i3++) {
      var a3 = t2[i3];
      e2.set(a3, o2), o2 += a3.length;
    }
    return t2 = this.encoder_.end(), e2.set(t2, o2), o2 += t2.length, jspb.asserts.assert(o2 == e2.length), this.blocks_ = [e2], e2;
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "getResultBuffer", jspb.BinaryWriter.prototype.getResultBuffer), jspb.BinaryWriter.prototype.getResultBase64String = function(e2) {
    return goog.crypt.base64.encodeByteArray(this.getResultBuffer(), e2);
  }, jspb.BinaryWriter.prototype.beginSubMessage = function(e2) {
    this.bookmarks_.push(this.beginDelimited_(e2));
  }, jspb.BinaryWriter.prototype.endSubMessage = function() {
    jspb.asserts.assert(0 <= this.bookmarks_.length), this.endDelimited_(this.bookmarks_.pop());
  }, jspb.BinaryWriter.prototype.writeFieldHeader_ = function(e2, t2) {
    jspb.asserts.assert(1 <= e2 && e2 == Math.floor(e2)), this.encoder_.writeUnsignedVarint32(8 * e2 + t2);
  }, jspb.BinaryWriter.prototype.writeAny = function(e2, t2, r2) {
    var o2 = jspb.BinaryConstants.FieldType;
    switch (e2) {
      case o2.DOUBLE:
        this.writeDouble(t2, r2);
        break;
      case o2.FLOAT:
        this.writeFloat(t2, r2);
        break;
      case o2.INT64:
        this.writeInt64(t2, r2);
        break;
      case o2.UINT64:
        this.writeUint64(t2, r2);
        break;
      case o2.INT32:
        this.writeInt32(t2, r2);
        break;
      case o2.FIXED64:
        this.writeFixed64(t2, r2);
        break;
      case o2.FIXED32:
        this.writeFixed32(t2, r2);
        break;
      case o2.BOOL:
        this.writeBool(t2, r2);
        break;
      case o2.STRING:
        this.writeString(t2, r2);
        break;
      case o2.GROUP:
        jspb.asserts.fail("Group field type not supported in writeAny()");
        break;
      case o2.MESSAGE:
        jspb.asserts.fail("Message field type not supported in writeAny()");
        break;
      case o2.BYTES:
        this.writeBytes(t2, r2);
        break;
      case o2.UINT32:
        this.writeUint32(t2, r2);
        break;
      case o2.ENUM:
        this.writeEnum(t2, r2);
        break;
      case o2.SFIXED32:
        this.writeSfixed32(t2, r2);
        break;
      case o2.SFIXED64:
        this.writeSfixed64(t2, r2);
        break;
      case o2.SINT32:
        this.writeSint32(t2, r2);
        break;
      case o2.SINT64:
        this.writeSint64(t2, r2);
        break;
      case o2.FHASH64:
        this.writeFixedHash64(t2, r2);
        break;
      case o2.VHASH64:
        this.writeVarintHash64(t2, r2);
        break;
      default:
        jspb.asserts.fail("Invalid field type in writeAny()");
    }
  }, jspb.BinaryWriter.prototype.writeUnsignedVarint32_ = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint32(t2));
  }, jspb.BinaryWriter.prototype.writeSignedVarint32_ = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(t2));
  }, jspb.BinaryWriter.prototype.writeUnsignedVarint64_ = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint64(t2));
  }, jspb.BinaryWriter.prototype.writeSignedVarint64_ = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint64(t2));
  }, jspb.BinaryWriter.prototype.writeZigzagVarint32_ = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint32(t2));
  }, jspb.BinaryWriter.prototype.writeZigzagVarint64_ = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64(t2));
  }, jspb.BinaryWriter.prototype.writeZigzagVarint64String_ = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64String(t2));
  }, jspb.BinaryWriter.prototype.writeZigzagVarintHash64_ = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarintHash64(t2));
  }, jspb.BinaryWriter.prototype.writeInt32 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(t2 >= -jspb.BinaryConstants.TWO_TO_31 && t2 < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(e2, t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeInt32", jspb.BinaryWriter.prototype.writeInt32), jspb.BinaryWriter.prototype.writeInt32String = function(e2, t2) {
    null != t2 && (t2 = parseInt(t2, 10), jspb.asserts.assert(t2 >= -jspb.BinaryConstants.TWO_TO_31 && t2 < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(e2, t2));
  }, jspb.BinaryWriter.prototype.writeInt64 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(t2 >= -jspb.BinaryConstants.TWO_TO_63 && t2 < jspb.BinaryConstants.TWO_TO_63), this.writeSignedVarint64_(e2, t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeInt64", jspb.BinaryWriter.prototype.writeInt64), jspb.BinaryWriter.prototype.writeInt64String = function(e2, t2) {
    null != t2 && (t2 = jspb.arith.Int64.fromString(t2), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(t2.lo, t2.hi));
  }, jspb.BinaryWriter.prototype.writeUint32 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(0 <= t2 && t2 < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(e2, t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeUint32", jspb.BinaryWriter.prototype.writeUint32), jspb.BinaryWriter.prototype.writeUint32String = function(e2, t2) {
    null != t2 && (t2 = parseInt(t2, 10), jspb.asserts.assert(0 <= t2 && t2 < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(e2, t2));
  }, jspb.BinaryWriter.prototype.writeUint64 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(0 <= t2 && t2 < jspb.BinaryConstants.TWO_TO_64), this.writeUnsignedVarint64_(e2, t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeUint64", jspb.BinaryWriter.prototype.writeUint64), jspb.BinaryWriter.prototype.writeUint64String = function(e2, t2) {
    null != t2 && (t2 = jspb.arith.UInt64.fromString(t2), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(t2.lo, t2.hi));
  }, jspb.BinaryWriter.prototype.writeSint32 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(t2 >= -jspb.BinaryConstants.TWO_TO_31 && t2 < jspb.BinaryConstants.TWO_TO_31), this.writeZigzagVarint32_(e2, t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSint32", jspb.BinaryWriter.prototype.writeSint32), jspb.BinaryWriter.prototype.writeSint64 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(t2 >= -jspb.BinaryConstants.TWO_TO_63 && t2 < jspb.BinaryConstants.TWO_TO_63), this.writeZigzagVarint64_(e2, t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSint64", jspb.BinaryWriter.prototype.writeSint64), jspb.BinaryWriter.prototype.writeSintHash64 = function(e2, t2) {
    null != t2 && this.writeZigzagVarintHash64_(e2, t2);
  }, jspb.BinaryWriter.prototype.writeSint64String = function(e2, t2) {
    null != t2 && this.writeZigzagVarint64String_(e2, t2);
  }, jspb.BinaryWriter.prototype.writeFixed32 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(0 <= t2 && t2 < jspb.BinaryConstants.TWO_TO_32), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeUint32(t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeFixed32", jspb.BinaryWriter.prototype.writeFixed32), jspb.BinaryWriter.prototype.writeFixed64 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(0 <= t2 && t2 < jspb.BinaryConstants.TWO_TO_64), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeUint64(t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeFixed64", jspb.BinaryWriter.prototype.writeFixed64), jspb.BinaryWriter.prototype.writeFixed64String = function(e2, t2) {
    null != t2 && (t2 = jspb.arith.UInt64.fromString(t2), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(t2.lo, t2.hi));
  }, jspb.BinaryWriter.prototype.writeSfixed32 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(t2 >= -jspb.BinaryConstants.TWO_TO_31 && t2 < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeInt32(t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSfixed32", jspb.BinaryWriter.prototype.writeSfixed32), jspb.BinaryWriter.prototype.writeSfixed64 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(t2 >= -jspb.BinaryConstants.TWO_TO_63 && t2 < jspb.BinaryConstants.TWO_TO_63), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeInt64(t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeSfixed64", jspb.BinaryWriter.prototype.writeSfixed64), jspb.BinaryWriter.prototype.writeSfixed64String = function(e2, t2) {
    null != t2 && (t2 = jspb.arith.Int64.fromString(t2), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(t2.lo, t2.hi));
  }, jspb.BinaryWriter.prototype.writeFloat = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeFloat(t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeFloat", jspb.BinaryWriter.prototype.writeFloat), jspb.BinaryWriter.prototype.writeDouble = function(e2, t2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeDouble(t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeDouble", jspb.BinaryWriter.prototype.writeDouble), jspb.BinaryWriter.prototype.writeBool = function(e2, t2) {
    null != t2 && (jspb.asserts.assert("boolean" == typeof t2 || "number" == typeof t2), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeBool(t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeBool", jspb.BinaryWriter.prototype.writeBool), jspb.BinaryWriter.prototype.writeEnum = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(t2 >= -jspb.BinaryConstants.TWO_TO_31 && t2 < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeEnum", jspb.BinaryWriter.prototype.writeEnum), jspb.BinaryWriter.prototype.writeString = function(e2, t2) {
    null != t2 && (e2 = this.beginDelimited_(e2), this.encoder_.writeString(t2), this.endDelimited_(e2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeString", jspb.BinaryWriter.prototype.writeString), jspb.BinaryWriter.prototype.writeBytes = function(e2, t2) {
    null != t2 && (t2 = jspb.utils.byteSourceToUint8Array(t2), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(t2.length), this.appendUint8Array_(t2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeBytes", jspb.BinaryWriter.prototype.writeBytes), jspb.BinaryWriter.prototype.writeMessage = function(e2, t2, r2) {
    null != t2 && (e2 = this.beginDelimited_(e2), r2(t2, this), this.endDelimited_(e2));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeMessage", jspb.BinaryWriter.prototype.writeMessage), jspb.BinaryWriter.prototype.writeMessageSet = function(e2, t2, r2) {
    null != t2 && (this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.START_GROUP), this.writeFieldHeader_(2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(e2), e2 = this.beginDelimited_(3), r2(t2, this), this.endDelimited_(e2), this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.END_GROUP));
  }, jspb.BinaryWriter.prototype.writeGroup = function(e2, t2, r2) {
    null != t2 && (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.START_GROUP), r2(t2, this), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.END_GROUP));
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeGroup", jspb.BinaryWriter.prototype.writeGroup), jspb.BinaryWriter.prototype.writeFixedHash64 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(8 == t2.length), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeFixedHash64(t2));
  }, jspb.BinaryWriter.prototype.writeVarintHash64 = function(e2, t2) {
    null != t2 && (jspb.asserts.assert(8 == t2.length), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeVarintHash64(t2));
  }, jspb.BinaryWriter.prototype.writeSplitFixed64 = function(e2, t2, r2) {
    this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(t2, r2);
  }, jspb.BinaryWriter.prototype.writeSplitVarint64 = function(e2, t2, r2) {
    this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(t2, r2);
  }, jspb.BinaryWriter.prototype.writeSplitZigzagVarint64 = function(e2, t2, r2) {
    this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.VARINT);
    var o2 = this.encoder_;
    jspb.utils.toZigzag64(t2, r2, function(e3, t3) {
      o2.writeSplitVarint64(e3 >>> 0, t3 >>> 0);
    });
  }, jspb.BinaryWriter.prototype.writeRepeatedInt32 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeSignedVarint32_(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedInt32", jspb.BinaryWriter.prototype.writeRepeatedInt32), jspb.BinaryWriter.prototype.writeRepeatedInt32String = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeInt32String(e2, t2[r2]);
  }, jspb.BinaryWriter.prototype.writeRepeatedInt64 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeSignedVarint64_(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedInt64", jspb.BinaryWriter.prototype.writeRepeatedInt64), jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64 = function(e2, t2, r2, o2) {
    if (null != t2)
      for (var i3 = 0; i3 < t2.length; i3++)
        this.writeSplitFixed64(e2, r2(t2[i3]), o2(t2[i3]));
  }, jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64 = function(e2, t2, r2, o2) {
    if (null != t2)
      for (var i3 = 0; i3 < t2.length; i3++)
        this.writeSplitVarint64(e2, r2(t2[i3]), o2(t2[i3]));
  }, jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64 = function(e2, t2, r2, o2) {
    if (null != t2)
      for (var i3 = 0; i3 < t2.length; i3++)
        this.writeSplitZigzagVarint64(e2, r2(t2[i3]), o2(t2[i3]));
  }, jspb.BinaryWriter.prototype.writeRepeatedInt64String = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeInt64String(e2, t2[r2]);
  }, jspb.BinaryWriter.prototype.writeRepeatedUint32 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeUnsignedVarint32_(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedUint32", jspb.BinaryWriter.prototype.writeRepeatedUint32), jspb.BinaryWriter.prototype.writeRepeatedUint32String = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeUint32String(e2, t2[r2]);
  }, jspb.BinaryWriter.prototype.writeRepeatedUint64 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeUnsignedVarint64_(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedUint64", jspb.BinaryWriter.prototype.writeRepeatedUint64), jspb.BinaryWriter.prototype.writeRepeatedUint64String = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeUint64String(e2, t2[r2]);
  }, jspb.BinaryWriter.prototype.writeRepeatedSint32 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeZigzagVarint32_(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSint32", jspb.BinaryWriter.prototype.writeRepeatedSint32), jspb.BinaryWriter.prototype.writeRepeatedSint64 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeZigzagVarint64_(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSint64", jspb.BinaryWriter.prototype.writeRepeatedSint64), jspb.BinaryWriter.prototype.writeRepeatedSint64String = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeZigzagVarint64String_(e2, t2[r2]);
  }, jspb.BinaryWriter.prototype.writeRepeatedSintHash64 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeZigzagVarintHash64_(e2, t2[r2]);
  }, jspb.BinaryWriter.prototype.writeRepeatedFixed32 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeFixed32(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed32", jspb.BinaryWriter.prototype.writeRepeatedFixed32), jspb.BinaryWriter.prototype.writeRepeatedFixed64 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeFixed64(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed64", jspb.BinaryWriter.prototype.writeRepeatedFixed64), jspb.BinaryWriter.prototype.writeRepeatedFixed64String = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeFixed64String(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed64String", jspb.BinaryWriter.prototype.writeRepeatedFixed64String), jspb.BinaryWriter.prototype.writeRepeatedSfixed32 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeSfixed32(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSfixed32", jspb.BinaryWriter.prototype.writeRepeatedSfixed32), jspb.BinaryWriter.prototype.writeRepeatedSfixed64 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeSfixed64(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSfixed64", jspb.BinaryWriter.prototype.writeRepeatedSfixed64), jspb.BinaryWriter.prototype.writeRepeatedSfixed64String = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeSfixed64String(e2, t2[r2]);
  }, jspb.BinaryWriter.prototype.writeRepeatedFloat = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeFloat(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFloat", jspb.BinaryWriter.prototype.writeRepeatedFloat), jspb.BinaryWriter.prototype.writeRepeatedDouble = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeDouble(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedDouble", jspb.BinaryWriter.prototype.writeRepeatedDouble), jspb.BinaryWriter.prototype.writeRepeatedBool = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeBool(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedBool", jspb.BinaryWriter.prototype.writeRepeatedBool), jspb.BinaryWriter.prototype.writeRepeatedEnum = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeEnum(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedEnum", jspb.BinaryWriter.prototype.writeRepeatedEnum), jspb.BinaryWriter.prototype.writeRepeatedString = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeString(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedString", jspb.BinaryWriter.prototype.writeRepeatedString), jspb.BinaryWriter.prototype.writeRepeatedBytes = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeBytes(e2, t2[r2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedBytes", jspb.BinaryWriter.prototype.writeRepeatedBytes), jspb.BinaryWriter.prototype.writeRepeatedMessage = function(e2, t2, r2) {
    if (null != t2)
      for (var o2 = 0; o2 < t2.length; o2++) {
        var i3 = this.beginDelimited_(e2);
        r2(t2[o2], this), this.endDelimited_(i3);
      }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedMessage", jspb.BinaryWriter.prototype.writeRepeatedMessage), jspb.BinaryWriter.prototype.writeRepeatedGroup = function(e2, t2, r2) {
    if (null != t2)
      for (var o2 = 0; o2 < t2.length; o2++)
        this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.START_GROUP), r2(t2[o2], this), this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.END_GROUP);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedGroup", jspb.BinaryWriter.prototype.writeRepeatedGroup), jspb.BinaryWriter.prototype.writeRepeatedFixedHash64 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeFixedHash64(e2, t2[r2]);
  }, jspb.BinaryWriter.prototype.writeRepeatedVarintHash64 = function(e2, t2) {
    if (null != t2)
      for (var r2 = 0; r2 < t2.length; r2++)
        this.writeVarintHash64(e2, t2[r2]);
  }, jspb.BinaryWriter.prototype.writePackedInt32 = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeSignedVarint32(t2[r2]);
      this.endDelimited_(e2);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedInt32", jspb.BinaryWriter.prototype.writePackedInt32), jspb.BinaryWriter.prototype.writePackedInt32String = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeSignedVarint32(parseInt(t2[r2], 10));
      this.endDelimited_(e2);
    }
  }, jspb.BinaryWriter.prototype.writePackedInt64 = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeSignedVarint64(t2[r2]);
      this.endDelimited_(e2);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedInt64", jspb.BinaryWriter.prototype.writePackedInt64), jspb.BinaryWriter.prototype.writePackedSplitFixed64 = function(e2, t2, r2, o2) {
    if (null != t2) {
      e2 = this.beginDelimited_(e2);
      for (var i3 = 0; i3 < t2.length; i3++)
        this.encoder_.writeSplitFixed64(r2(t2[i3]), o2(t2[i3]));
      this.endDelimited_(e2);
    }
  }, jspb.BinaryWriter.prototype.writePackedSplitVarint64 = function(e2, t2, r2, o2) {
    if (null != t2) {
      e2 = this.beginDelimited_(e2);
      for (var i3 = 0; i3 < t2.length; i3++)
        this.encoder_.writeSplitVarint64(r2(t2[i3]), o2(t2[i3]));
      this.endDelimited_(e2);
    }
  }, jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64 = function(e2, t2, r2, o2) {
    if (null != t2) {
      e2 = this.beginDelimited_(e2);
      for (var i3 = this.encoder_, a3 = 0; a3 < t2.length; a3++)
        jspb.utils.toZigzag64(r2(t2[a3]), o2(t2[a3]), function(e3, t3) {
          i3.writeSplitVarint64(e3 >>> 0, t3 >>> 0);
        });
      this.endDelimited_(e2);
    }
  }, jspb.BinaryWriter.prototype.writePackedInt64String = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++) {
        var o2 = jspb.arith.Int64.fromString(t2[r2]);
        this.encoder_.writeSplitVarint64(o2.lo, o2.hi);
      }
      this.endDelimited_(e2);
    }
  }, jspb.BinaryWriter.prototype.writePackedUint32 = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeUnsignedVarint32(t2[r2]);
      this.endDelimited_(e2);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedUint32", jspb.BinaryWriter.prototype.writePackedUint32), jspb.BinaryWriter.prototype.writePackedUint32String = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeUnsignedVarint32(parseInt(t2[r2], 10));
      this.endDelimited_(e2);
    }
  }, jspb.BinaryWriter.prototype.writePackedUint64 = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeUnsignedVarint64(t2[r2]);
      this.endDelimited_(e2);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedUint64", jspb.BinaryWriter.prototype.writePackedUint64), jspb.BinaryWriter.prototype.writePackedUint64String = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++) {
        var o2 = jspb.arith.UInt64.fromString(t2[r2]);
        this.encoder_.writeSplitVarint64(o2.lo, o2.hi);
      }
      this.endDelimited_(e2);
    }
  }, jspb.BinaryWriter.prototype.writePackedSint32 = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeZigzagVarint32(t2[r2]);
      this.endDelimited_(e2);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSint32", jspb.BinaryWriter.prototype.writePackedSint32), jspb.BinaryWriter.prototype.writePackedSint64 = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeZigzagVarint64(t2[r2]);
      this.endDelimited_(e2);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSint64", jspb.BinaryWriter.prototype.writePackedSint64), jspb.BinaryWriter.prototype.writePackedSint64String = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(t2[r2]));
      this.endDelimited_(e2);
    }
  }, jspb.BinaryWriter.prototype.writePackedSintHash64 = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeZigzagVarintHash64(t2[r2]);
      this.endDelimited_(e2);
    }
  }, jspb.BinaryWriter.prototype.writePackedFixed32 = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * t2.length), e2 = 0; e2 < t2.length; e2++)
        this.encoder_.writeUint32(t2[e2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFixed32", jspb.BinaryWriter.prototype.writePackedFixed32), jspb.BinaryWriter.prototype.writePackedFixed64 = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t2.length), e2 = 0; e2 < t2.length; e2++)
        this.encoder_.writeUint64(t2[e2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFixed64", jspb.BinaryWriter.prototype.writePackedFixed64), jspb.BinaryWriter.prototype.writePackedFixed64String = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t2.length), e2 = 0; e2 < t2.length; e2++) {
        var r2 = jspb.arith.UInt64.fromString(t2[e2]);
        this.encoder_.writeSplitFixed64(r2.lo, r2.hi);
      }
  }, jspb.BinaryWriter.prototype.writePackedSfixed32 = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * t2.length), e2 = 0; e2 < t2.length; e2++)
        this.encoder_.writeInt32(t2[e2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSfixed32", jspb.BinaryWriter.prototype.writePackedSfixed32), jspb.BinaryWriter.prototype.writePackedSfixed64 = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t2.length), e2 = 0; e2 < t2.length; e2++)
        this.encoder_.writeInt64(t2[e2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSfixed64", jspb.BinaryWriter.prototype.writePackedSfixed64), jspb.BinaryWriter.prototype.writePackedSfixed64String = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t2.length), e2 = 0; e2 < t2.length; e2++)
        this.encoder_.writeInt64String(t2[e2]);
  }, jspb.BinaryWriter.prototype.writePackedFloat = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * t2.length), e2 = 0; e2 < t2.length; e2++)
        this.encoder_.writeFloat(t2[e2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFloat", jspb.BinaryWriter.prototype.writePackedFloat), jspb.BinaryWriter.prototype.writePackedDouble = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t2.length), e2 = 0; e2 < t2.length; e2++)
        this.encoder_.writeDouble(t2[e2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedDouble", jspb.BinaryWriter.prototype.writePackedDouble), jspb.BinaryWriter.prototype.writePackedBool = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(t2.length), e2 = 0; e2 < t2.length; e2++)
        this.encoder_.writeBool(t2[e2]);
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedBool", jspb.BinaryWriter.prototype.writePackedBool), jspb.BinaryWriter.prototype.writePackedEnum = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeEnum(t2[r2]);
      this.endDelimited_(e2);
    }
  }, goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedEnum", jspb.BinaryWriter.prototype.writePackedEnum), jspb.BinaryWriter.prototype.writePackedFixedHash64 = function(e2, t2) {
    if (null != t2 && t2.length)
      for (this.writeFieldHeader_(e2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t2.length), e2 = 0; e2 < t2.length; e2++)
        this.encoder_.writeFixedHash64(t2[e2]);
  }, jspb.BinaryWriter.prototype.writePackedVarintHash64 = function(e2, t2) {
    if (null != t2 && t2.length) {
      e2 = this.beginDelimited_(e2);
      for (var r2 = 0; r2 < t2.length; r2++)
        this.encoder_.writeVarintHash64(t2[r2]);
      this.endDelimited_(e2);
    }
  }, jspb.Map = function(e2, t2) {
    this.arr_ = e2, this.valueCtor_ = t2, this.map_ = {}, this.arrClean = true, 0 < this.arr_.length && this.loadFromArray_();
  }, goog.exportSymbol("jspb.Map", jspb.Map), jspb.Map.prototype.loadFromArray_ = function() {
    for (var e2 = 0; e2 < this.arr_.length; e2++) {
      var t2 = this.arr_[e2], r2 = t2[0];
      this.map_[r2.toString()] = new jspb.Map.Entry_(r2, t2[1]);
    }
    this.arrClean = true;
  }, jspb.Map.prototype.toArray = function() {
    if (this.arrClean) {
      if (this.valueCtor_) {
        var e2, t2 = this.map_;
        for (e2 in t2)
          if (Object.prototype.hasOwnProperty.call(t2, e2)) {
            var r2 = t2[e2].valueWrapper;
            r2 && r2.toArray();
          }
      }
    } else {
      for (this.arr_.length = 0, (t2 = this.stringKeys_()).sort(), e2 = 0; e2 < t2.length; e2++) {
        var o2 = this.map_[t2[e2]];
        (r2 = o2.valueWrapper) && r2.toArray(), this.arr_.push([o2.key, o2.value]);
      }
      this.arrClean = true;
    }
    return this.arr_;
  }, goog.exportProperty(jspb.Map.prototype, "toArray", jspb.Map.prototype.toArray), jspb.Map.prototype.toObject = function(e2, t2) {
    for (var r2 = this.toArray(), o2 = [], i3 = 0; i3 < r2.length; i3++) {
      var a3 = this.map_[r2[i3][0].toString()];
      this.wrapEntry_(a3);
      var n2 = a3.valueWrapper;
      n2 ? (jspb.asserts.assert(t2), o2.push([a3.key, t2(e2, n2)])) : o2.push([a3.key, a3.value]);
    }
    return o2;
  }, goog.exportProperty(jspb.Map.prototype, "toObject", jspb.Map.prototype.toObject), jspb.Map.fromObject = function(e2, t2, r2) {
    t2 = new jspb.Map([], t2);
    for (var o2 = 0; o2 < e2.length; o2++) {
      var i3 = e2[o2][0], a3 = r2(e2[o2][1]);
      t2.set(i3, a3);
    }
    return t2;
  }, goog.exportProperty(jspb.Map, "fromObject", jspb.Map.fromObject), jspb.Map.ArrayIteratorIterable_ = function(e2) {
    this.idx_ = 0, this.arr_ = e2;
  }, jspb.Map.ArrayIteratorIterable_.prototype.next = function() {
    return this.idx_ < this.arr_.length ? { done: false, value: this.arr_[this.idx_++] } : { done: true, value: void 0 };
  }, "undefined" != typeof Symbol && (jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator] = function() {
    return this;
  }), jspb.Map.prototype.getLength = function() {
    return this.stringKeys_().length;
  }, goog.exportProperty(jspb.Map.prototype, "getLength", jspb.Map.prototype.getLength), jspb.Map.prototype.clear = function() {
    this.map_ = {}, this.arrClean = false;
  }, goog.exportProperty(jspb.Map.prototype, "clear", jspb.Map.prototype.clear), jspb.Map.prototype.del = function(e2) {
    e2 = e2.toString();
    var t2 = this.map_.hasOwnProperty(e2);
    return delete this.map_[e2], this.arrClean = false, t2;
  }, goog.exportProperty(jspb.Map.prototype, "del", jspb.Map.prototype.del), jspb.Map.prototype.getEntryList = function() {
    var e2 = [], t2 = this.stringKeys_();
    t2.sort();
    for (var r2 = 0; r2 < t2.length; r2++) {
      var o2 = this.map_[t2[r2]];
      e2.push([o2.key, o2.value]);
    }
    return e2;
  }, goog.exportProperty(jspb.Map.prototype, "getEntryList", jspb.Map.prototype.getEntryList), jspb.Map.prototype.entries = function() {
    var e2 = [], t2 = this.stringKeys_();
    t2.sort();
    for (var r2 = 0; r2 < t2.length; r2++) {
      var o2 = this.map_[t2[r2]];
      e2.push([o2.key, this.wrapEntry_(o2)]);
    }
    return new jspb.Map.ArrayIteratorIterable_(e2);
  }, goog.exportProperty(jspb.Map.prototype, "entries", jspb.Map.prototype.entries), jspb.Map.prototype.keys = function() {
    var e2 = [], t2 = this.stringKeys_();
    t2.sort();
    for (var r2 = 0; r2 < t2.length; r2++)
      e2.push(this.map_[t2[r2]].key);
    return new jspb.Map.ArrayIteratorIterable_(e2);
  }, goog.exportProperty(jspb.Map.prototype, "keys", jspb.Map.prototype.keys), jspb.Map.prototype.values = function() {
    var e2 = [], t2 = this.stringKeys_();
    t2.sort();
    for (var r2 = 0; r2 < t2.length; r2++)
      e2.push(this.wrapEntry_(this.map_[t2[r2]]));
    return new jspb.Map.ArrayIteratorIterable_(e2);
  }, goog.exportProperty(jspb.Map.prototype, "values", jspb.Map.prototype.values), jspb.Map.prototype.forEach = function(e2, t2) {
    var r2 = this.stringKeys_();
    r2.sort();
    for (var o2 = 0; o2 < r2.length; o2++) {
      var i3 = this.map_[r2[o2]];
      e2.call(t2, this.wrapEntry_(i3), i3.key, this);
    }
  }, goog.exportProperty(jspb.Map.prototype, "forEach", jspb.Map.prototype.forEach), jspb.Map.prototype.set = function(e2, t2) {
    var r2 = new jspb.Map.Entry_(e2);
    return this.valueCtor_ ? (r2.valueWrapper = t2, r2.value = t2.toArray()) : r2.value = t2, this.map_[e2.toString()] = r2, this.arrClean = false, this;
  }, goog.exportProperty(jspb.Map.prototype, "set", jspb.Map.prototype.set), jspb.Map.prototype.wrapEntry_ = function(e2) {
    return this.valueCtor_ ? (e2.valueWrapper || (e2.valueWrapper = new this.valueCtor_(e2.value)), e2.valueWrapper) : e2.value;
  }, jspb.Map.prototype.get = function(e2) {
    if (e2 = this.map_[e2.toString()])
      return this.wrapEntry_(e2);
  }, goog.exportProperty(jspb.Map.prototype, "get", jspb.Map.prototype.get), jspb.Map.prototype.has = function(e2) {
    return e2.toString() in this.map_;
  }, goog.exportProperty(jspb.Map.prototype, "has", jspb.Map.prototype.has), jspb.Map.prototype.serializeBinary = function(e2, t2, r2, o2, i3) {
    var a3 = this.stringKeys_();
    a3.sort();
    for (var n2 = 0; n2 < a3.length; n2++) {
      var s2 = this.map_[a3[n2]];
      t2.beginSubMessage(e2), r2.call(t2, 1, s2.key), this.valueCtor_ ? o2.call(t2, 2, this.wrapEntry_(s2), i3) : o2.call(t2, 2, s2.value), t2.endSubMessage();
    }
  }, goog.exportProperty(jspb.Map.prototype, "serializeBinary", jspb.Map.prototype.serializeBinary), jspb.Map.deserializeBinary = function(e2, t2, r2, o2, i3, a3, n2) {
    for (; t2.nextField() && !t2.isEndGroup(); ) {
      var s2 = t2.getFieldNumber();
      1 == s2 ? a3 = r2.call(t2) : 2 == s2 && (e2.valueCtor_ ? (jspb.asserts.assert(i3), n2 || (n2 = new e2.valueCtor_()), o2.call(t2, n2, i3)) : n2 = o2.call(t2));
    }
    jspb.asserts.assert(null != a3), jspb.asserts.assert(null != n2), e2.set(a3, n2);
  }, goog.exportProperty(jspb.Map, "deserializeBinary", jspb.Map.deserializeBinary), jspb.Map.prototype.stringKeys_ = function() {
    var e2, t2 = this.map_, r2 = [];
    for (e2 in t2)
      Object.prototype.hasOwnProperty.call(t2, e2) && r2.push(e2);
    return r2;
  }, jspb.Map.Entry_ = function(e2, t2) {
    this.key = e2, this.value = t2, this.valueWrapper = void 0;
  }, jspb.ExtensionFieldInfo = function(e2, t2, r2, o2, i3) {
    this.fieldIndex = e2, this.fieldName = t2, this.ctor = r2, this.toObjectFn = o2, this.isRepeated = i3;
  }, goog.exportSymbol("jspb.ExtensionFieldInfo", jspb.ExtensionFieldInfo), jspb.ExtensionFieldBinaryInfo = function(e2, t2, r2, o2, i3, a3) {
    this.fieldInfo = e2, this.binaryReaderFn = t2, this.binaryWriterFn = r2, this.binaryMessageSerializeFn = o2, this.binaryMessageDeserializeFn = i3, this.isPacked = a3;
  }, goog.exportSymbol("jspb.ExtensionFieldBinaryInfo", jspb.ExtensionFieldBinaryInfo), jspb.ExtensionFieldInfo.prototype.isMessageType = function() {
    return !!this.ctor;
  }, goog.exportProperty(jspb.ExtensionFieldInfo.prototype, "isMessageType", jspb.ExtensionFieldInfo.prototype.isMessageType), jspb.Message = function() {
  }, goog.exportSymbol("jspb.Message", jspb.Message), jspb.Message.GENERATE_TO_OBJECT = true, goog.exportProperty(jspb.Message, "GENERATE_TO_OBJECT", jspb.Message.GENERATE_TO_OBJECT), jspb.Message.GENERATE_FROM_OBJECT = !goog.DISALLOW_TEST_ONLY_CODE, goog.exportProperty(jspb.Message, "GENERATE_FROM_OBJECT", jspb.Message.GENERATE_FROM_OBJECT), jspb.Message.GENERATE_TO_STRING = true, jspb.Message.ASSUME_LOCAL_ARRAYS = false, jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS = true, jspb.Message.SUPPORTS_UINT8ARRAY_ = "function" == typeof Uint8Array, jspb.Message.prototype.getJsPbMessageId = function() {
    return this.messageId_;
  }, goog.exportProperty(jspb.Message.prototype, "getJsPbMessageId", jspb.Message.prototype.getJsPbMessageId), jspb.Message.getIndex_ = function(e2, t2) {
    return t2 + e2.arrayIndexOffset_;
  }, jspb.Message.hiddenES6Property_ = function() {
  }, jspb.Message.getFieldNumber_ = function(e2, t2) {
    return t2 - e2.arrayIndexOffset_;
  }, jspb.Message.initialize = function(e2, t2, r2, o2, i3, a3) {
    if (e2.wrappers_ = null, t2 || (t2 = r2 ? [r2] : []), e2.messageId_ = r2 ? String(r2) : void 0, e2.arrayIndexOffset_ = 0 === r2 ? -1 : 0, e2.array = t2, jspb.Message.initPivotAndExtensionObject_(e2, o2), e2.convertedPrimitiveFields_ = {}, jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS || (e2.repeatedFields = i3), i3)
      for (t2 = 0; t2 < i3.length; t2++)
        (r2 = i3[t2]) < e2.pivot_ ? (r2 = jspb.Message.getIndex_(e2, r2), e2.array[r2] = e2.array[r2] || jspb.Message.EMPTY_LIST_SENTINEL_) : (jspb.Message.maybeInitEmptyExtensionObject_(e2), e2.extensionObject_[r2] = e2.extensionObject_[r2] || jspb.Message.EMPTY_LIST_SENTINEL_);
    if (a3 && a3.length)
      for (t2 = 0; t2 < a3.length; t2++)
        jspb.Message.computeOneofCase(e2, a3[t2]);
  }, goog.exportProperty(jspb.Message, "initialize", jspb.Message.initialize), jspb.Message.EMPTY_LIST_SENTINEL_ = goog.DEBUG && Object.freeze ? Object.freeze([]) : [], jspb.Message.isArray_ = function(e2) {
    return jspb.Message.ASSUME_LOCAL_ARRAYS ? e2 instanceof Array : Array.isArray(e2);
  }, jspb.Message.isExtensionObject_ = function(e2) {
    return !(null === e2 || "object" != typeof e2 || jspb.Message.isArray_(e2) || jspb.Message.SUPPORTS_UINT8ARRAY_ && e2 instanceof Uint8Array);
  }, jspb.Message.initPivotAndExtensionObject_ = function(e2, t2) {
    var r2 = e2.array.length, o2 = -1;
    if (r2 && (o2 = r2 - 1, r2 = e2.array[o2], jspb.Message.isExtensionObject_(r2)))
      return e2.pivot_ = jspb.Message.getFieldNumber_(e2, o2), void (e2.extensionObject_ = r2);
    -1 < t2 ? (e2.pivot_ = Math.max(t2, jspb.Message.getFieldNumber_(e2, o2 + 1)), e2.extensionObject_ = null) : e2.pivot_ = Number.MAX_VALUE;
  }, jspb.Message.maybeInitEmptyExtensionObject_ = function(e2) {
    var t2 = jspb.Message.getIndex_(e2, e2.pivot_);
    e2.array[t2] || (e2.extensionObject_ = e2.array[t2] = {});
  }, jspb.Message.toObjectList = function(e2, t2, r2) {
    for (var o2 = [], i3 = 0; i3 < e2.length; i3++)
      o2[i3] = t2.call(e2[i3], r2, e2[i3]);
    return o2;
  }, goog.exportProperty(jspb.Message, "toObjectList", jspb.Message.toObjectList), jspb.Message.toObjectExtension = function(e2, t2, r2, o2, i3) {
    for (var a3 in r2) {
      var n2 = r2[a3], s2 = o2.call(e2, n2);
      if (null != s2) {
        for (var p in n2.fieldName)
          if (n2.fieldName.hasOwnProperty(p))
            break;
        t2[p] = n2.toObjectFn ? n2.isRepeated ? jspb.Message.toObjectList(s2, n2.toObjectFn, i3) : n2.toObjectFn(i3, s2) : s2;
      }
    }
  }, goog.exportProperty(jspb.Message, "toObjectExtension", jspb.Message.toObjectExtension), jspb.Message.serializeBinaryExtensions = function(e2, t2, r2, o2) {
    for (var i3 in r2) {
      var a3 = r2[i3], n2 = a3.fieldInfo;
      if (!a3.binaryWriterFn)
        throw Error("Message extension present that was generated without binary serialization support");
      var s2 = o2.call(e2, n2);
      if (null != s2)
        if (n2.isMessageType()) {
          if (!a3.binaryMessageSerializeFn)
            throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
          a3.binaryWriterFn.call(t2, n2.fieldIndex, s2, a3.binaryMessageSerializeFn);
        } else
          a3.binaryWriterFn.call(t2, n2.fieldIndex, s2);
    }
  }, goog.exportProperty(jspb.Message, "serializeBinaryExtensions", jspb.Message.serializeBinaryExtensions), jspb.Message.readBinaryExtension = function(e2, t2, r2, o2, i3) {
    var a3 = r2[t2.getFieldNumber()];
    if (a3) {
      if (r2 = a3.fieldInfo, !a3.binaryReaderFn)
        throw Error("Deserializing extension whose generated code does not support binary format");
      if (r2.isMessageType()) {
        var n2 = new r2.ctor();
        a3.binaryReaderFn.call(t2, n2, a3.binaryMessageDeserializeFn);
      } else
        n2 = a3.binaryReaderFn.call(t2);
      r2.isRepeated && !a3.isPacked ? (t2 = o2.call(e2, r2)) ? t2.push(n2) : i3.call(e2, r2, [n2]) : i3.call(e2, r2, n2);
    } else
      t2.skipField();
  }, goog.exportProperty(jspb.Message, "readBinaryExtension", jspb.Message.readBinaryExtension), jspb.Message.getField = function(e2, t2) {
    if (t2 < e2.pivot_) {
      t2 = jspb.Message.getIndex_(e2, t2);
      var r2 = e2.array[t2];
      return r2 === jspb.Message.EMPTY_LIST_SENTINEL_ ? e2.array[t2] = [] : r2;
    }
    if (e2.extensionObject_)
      return (r2 = e2.extensionObject_[t2]) === jspb.Message.EMPTY_LIST_SENTINEL_ ? e2.extensionObject_[t2] = [] : r2;
  }, goog.exportProperty(jspb.Message, "getField", jspb.Message.getField), jspb.Message.getRepeatedField = function(e2, t2) {
    return jspb.Message.getField(e2, t2);
  }, goog.exportProperty(jspb.Message, "getRepeatedField", jspb.Message.getRepeatedField), jspb.Message.getOptionalFloatingPointField = function(e2, t2) {
    return null == (e2 = jspb.Message.getField(e2, t2)) ? e2 : +e2;
  }, goog.exportProperty(jspb.Message, "getOptionalFloatingPointField", jspb.Message.getOptionalFloatingPointField), jspb.Message.getBooleanField = function(e2, t2) {
    return null == (e2 = jspb.Message.getField(e2, t2)) ? e2 : !!e2;
  }, goog.exportProperty(jspb.Message, "getBooleanField", jspb.Message.getBooleanField), jspb.Message.getRepeatedFloatingPointField = function(e2, t2) {
    var r2 = jspb.Message.getRepeatedField(e2, t2);
    if (e2.convertedPrimitiveFields_ || (e2.convertedPrimitiveFields_ = {}), !e2.convertedPrimitiveFields_[t2]) {
      for (var o2 = 0; o2 < r2.length; o2++)
        r2[o2] = +r2[o2];
      e2.convertedPrimitiveFields_[t2] = true;
    }
    return r2;
  }, goog.exportProperty(jspb.Message, "getRepeatedFloatingPointField", jspb.Message.getRepeatedFloatingPointField), jspb.Message.getRepeatedBooleanField = function(e2, t2) {
    var r2 = jspb.Message.getRepeatedField(e2, t2);
    if (e2.convertedPrimitiveFields_ || (e2.convertedPrimitiveFields_ = {}), !e2.convertedPrimitiveFields_[t2]) {
      for (var o2 = 0; o2 < r2.length; o2++)
        r2[o2] = !!r2[o2];
      e2.convertedPrimitiveFields_[t2] = true;
    }
    return r2;
  }, goog.exportProperty(jspb.Message, "getRepeatedBooleanField", jspb.Message.getRepeatedBooleanField), jspb.Message.bytesAsB64 = function(e2) {
    return null == e2 || "string" == typeof e2 ? e2 : jspb.Message.SUPPORTS_UINT8ARRAY_ && e2 instanceof Uint8Array ? goog.crypt.base64.encodeByteArray(e2) : (jspb.asserts.fail("Cannot coerce to b64 string: " + goog.typeOf(e2)), null);
  }, goog.exportProperty(jspb.Message, "bytesAsB64", jspb.Message.bytesAsB64), jspb.Message.bytesAsU8 = function(e2) {
    return null == e2 || e2 instanceof Uint8Array ? e2 : "string" == typeof e2 ? goog.crypt.base64.decodeStringToUint8Array(e2) : (jspb.asserts.fail("Cannot coerce to Uint8Array: " + goog.typeOf(e2)), null);
  }, goog.exportProperty(jspb.Message, "bytesAsU8", jspb.Message.bytesAsU8), jspb.Message.bytesListAsB64 = function(e2) {
    return jspb.Message.assertConsistentTypes_(e2), e2.length && "string" != typeof e2[0] ? goog.array.map(e2, jspb.Message.bytesAsB64) : e2;
  }, goog.exportProperty(jspb.Message, "bytesListAsB64", jspb.Message.bytesListAsB64), jspb.Message.bytesListAsU8 = function(e2) {
    return jspb.Message.assertConsistentTypes_(e2), !e2.length || e2[0] instanceof Uint8Array ? e2 : goog.array.map(e2, jspb.Message.bytesAsU8);
  }, goog.exportProperty(jspb.Message, "bytesListAsU8", jspb.Message.bytesListAsU8), jspb.Message.assertConsistentTypes_ = function(e2) {
    if (goog.DEBUG && e2 && 1 < e2.length) {
      var t2 = goog.typeOf(e2[0]);
      goog.array.forEach(e2, function(e3) {
        goog.typeOf(e3) != t2 && jspb.asserts.fail("Inconsistent type in JSPB repeated field array. Got " + goog.typeOf(e3) + " expected " + t2);
      });
    }
  }, jspb.Message.getFieldWithDefault = function(e2, t2, r2) {
    return null == (e2 = jspb.Message.getField(e2, t2)) ? r2 : e2;
  }, goog.exportProperty(jspb.Message, "getFieldWithDefault", jspb.Message.getFieldWithDefault), jspb.Message.getBooleanFieldWithDefault = function(e2, t2, r2) {
    return null == (e2 = jspb.Message.getBooleanField(e2, t2)) ? r2 : e2;
  }, goog.exportProperty(jspb.Message, "getBooleanFieldWithDefault", jspb.Message.getBooleanFieldWithDefault), jspb.Message.getFloatingPointFieldWithDefault = function(e2, t2, r2) {
    return null == (e2 = jspb.Message.getOptionalFloatingPointField(e2, t2)) ? r2 : e2;
  }, goog.exportProperty(jspb.Message, "getFloatingPointFieldWithDefault", jspb.Message.getFloatingPointFieldWithDefault), jspb.Message.getFieldProto3 = jspb.Message.getFieldWithDefault, goog.exportProperty(jspb.Message, "getFieldProto3", jspb.Message.getFieldProto3), jspb.Message.getMapField = function(e2, t2, r2, o2) {
    if (e2.wrappers_ || (e2.wrappers_ = {}), t2 in e2.wrappers_)
      return e2.wrappers_[t2];
    var i3 = jspb.Message.getField(e2, t2);
    if (!i3) {
      if (r2)
        return;
      i3 = [], jspb.Message.setField(e2, t2, i3);
    }
    return e2.wrappers_[t2] = new jspb.Map(i3, o2);
  }, goog.exportProperty(jspb.Message, "getMapField", jspb.Message.getMapField), jspb.Message.setField = function(e2, t2, r2) {
    return jspb.asserts.assertInstanceof(e2, jspb.Message), t2 < e2.pivot_ ? e2.array[jspb.Message.getIndex_(e2, t2)] = r2 : (jspb.Message.maybeInitEmptyExtensionObject_(e2), e2.extensionObject_[t2] = r2), e2;
  }, goog.exportProperty(jspb.Message, "setField", jspb.Message.setField), jspb.Message.setProto3IntField = function(e2, t2, r2) {
    return jspb.Message.setFieldIgnoringDefault_(e2, t2, r2, 0);
  }, goog.exportProperty(jspb.Message, "setProto3IntField", jspb.Message.setProto3IntField), jspb.Message.setProto3FloatField = function(e2, t2, r2) {
    return jspb.Message.setFieldIgnoringDefault_(e2, t2, r2, 0);
  }, goog.exportProperty(jspb.Message, "setProto3FloatField", jspb.Message.setProto3FloatField), jspb.Message.setProto3BooleanField = function(e2, t2, r2) {
    return jspb.Message.setFieldIgnoringDefault_(e2, t2, r2, false);
  }, goog.exportProperty(jspb.Message, "setProto3BooleanField", jspb.Message.setProto3BooleanField), jspb.Message.setProto3StringField = function(e2, t2, r2) {
    return jspb.Message.setFieldIgnoringDefault_(e2, t2, r2, "");
  }, goog.exportProperty(jspb.Message, "setProto3StringField", jspb.Message.setProto3StringField), jspb.Message.setProto3BytesField = function(e2, t2, r2) {
    return jspb.Message.setFieldIgnoringDefault_(e2, t2, r2, "");
  }, goog.exportProperty(jspb.Message, "setProto3BytesField", jspb.Message.setProto3BytesField), jspb.Message.setProto3EnumField = function(e2, t2, r2) {
    return jspb.Message.setFieldIgnoringDefault_(e2, t2, r2, 0);
  }, goog.exportProperty(jspb.Message, "setProto3EnumField", jspb.Message.setProto3EnumField), jspb.Message.setProto3StringIntField = function(e2, t2, r2) {
    return jspb.Message.setFieldIgnoringDefault_(e2, t2, r2, "0");
  }, goog.exportProperty(jspb.Message, "setProto3StringIntField", jspb.Message.setProto3StringIntField), jspb.Message.setFieldIgnoringDefault_ = function(e2, t2, r2, o2) {
    return jspb.asserts.assertInstanceof(e2, jspb.Message), r2 !== o2 ? jspb.Message.setField(e2, t2, r2) : t2 < e2.pivot_ ? e2.array[jspb.Message.getIndex_(e2, t2)] = null : (jspb.Message.maybeInitEmptyExtensionObject_(e2), delete e2.extensionObject_[t2]), e2;
  }, jspb.Message.addToRepeatedField = function(e2, t2, r2, o2) {
    return jspb.asserts.assertInstanceof(e2, jspb.Message), t2 = jspb.Message.getRepeatedField(e2, t2), null != o2 ? t2.splice(o2, 0, r2) : t2.push(r2), e2;
  }, goog.exportProperty(jspb.Message, "addToRepeatedField", jspb.Message.addToRepeatedField), jspb.Message.setOneofField = function(e2, t2, r2, o2) {
    return jspb.asserts.assertInstanceof(e2, jspb.Message), (r2 = jspb.Message.computeOneofCase(e2, r2)) && r2 !== t2 && void 0 !== o2 && (e2.wrappers_ && r2 in e2.wrappers_ && (e2.wrappers_[r2] = void 0), jspb.Message.setField(e2, r2, void 0)), jspb.Message.setField(e2, t2, o2);
  }, goog.exportProperty(jspb.Message, "setOneofField", jspb.Message.setOneofField), jspb.Message.computeOneofCase = function(e2, t2) {
    for (var r2, o2, i3 = 0; i3 < t2.length; i3++) {
      var a3 = t2[i3], n2 = jspb.Message.getField(e2, a3);
      null != n2 && (r2 = a3, o2 = n2, jspb.Message.setField(e2, a3, void 0));
    }
    return r2 ? (jspb.Message.setField(e2, r2, o2), r2) : 0;
  }, goog.exportProperty(jspb.Message, "computeOneofCase", jspb.Message.computeOneofCase), jspb.Message.getWrapperField = function(e2, t2, r2, o2) {
    if (e2.wrappers_ || (e2.wrappers_ = {}), !e2.wrappers_[r2]) {
      var i3 = jspb.Message.getField(e2, r2);
      (o2 || i3) && (e2.wrappers_[r2] = new t2(i3));
    }
    return e2.wrappers_[r2];
  }, goog.exportProperty(jspb.Message, "getWrapperField", jspb.Message.getWrapperField), jspb.Message.getRepeatedWrapperField = function(e2, t2, r2) {
    return jspb.Message.wrapRepeatedField_(e2, t2, r2), (t2 = e2.wrappers_[r2]) == jspb.Message.EMPTY_LIST_SENTINEL_ && (t2 = e2.wrappers_[r2] = []), t2;
  }, goog.exportProperty(jspb.Message, "getRepeatedWrapperField", jspb.Message.getRepeatedWrapperField), jspb.Message.wrapRepeatedField_ = function(e2, t2, r2) {
    if (e2.wrappers_ || (e2.wrappers_ = {}), !e2.wrappers_[r2]) {
      for (var o2 = jspb.Message.getRepeatedField(e2, r2), i3 = [], a3 = 0; a3 < o2.length; a3++)
        i3[a3] = new t2(o2[a3]);
      e2.wrappers_[r2] = i3;
    }
  }, jspb.Message.setWrapperField = function(e2, t2, r2) {
    jspb.asserts.assertInstanceof(e2, jspb.Message), e2.wrappers_ || (e2.wrappers_ = {});
    var o2 = r2 ? r2.toArray() : r2;
    return e2.wrappers_[t2] = r2, jspb.Message.setField(e2, t2, o2);
  }, goog.exportProperty(jspb.Message, "setWrapperField", jspb.Message.setWrapperField), jspb.Message.setOneofWrapperField = function(e2, t2, r2, o2) {
    jspb.asserts.assertInstanceof(e2, jspb.Message), e2.wrappers_ || (e2.wrappers_ = {});
    var i3 = o2 ? o2.toArray() : o2;
    return e2.wrappers_[t2] = o2, jspb.Message.setOneofField(e2, t2, r2, i3);
  }, goog.exportProperty(jspb.Message, "setOneofWrapperField", jspb.Message.setOneofWrapperField), jspb.Message.setRepeatedWrapperField = function(e2, t2, r2) {
    jspb.asserts.assertInstanceof(e2, jspb.Message), e2.wrappers_ || (e2.wrappers_ = {}), r2 = r2 || [];
    for (var o2 = [], i3 = 0; i3 < r2.length; i3++)
      o2[i3] = r2[i3].toArray();
    return e2.wrappers_[t2] = r2, jspb.Message.setField(e2, t2, o2);
  }, goog.exportProperty(jspb.Message, "setRepeatedWrapperField", jspb.Message.setRepeatedWrapperField), jspb.Message.addToRepeatedWrapperField = function(e2, t2, r2, o2, i3) {
    jspb.Message.wrapRepeatedField_(e2, o2, t2);
    var a3 = e2.wrappers_[t2];
    return a3 || (a3 = e2.wrappers_[t2] = []), r2 = r2 || new o2(), e2 = jspb.Message.getRepeatedField(e2, t2), null != i3 ? (a3.splice(i3, 0, r2), e2.splice(i3, 0, r2.toArray())) : (a3.push(r2), e2.push(r2.toArray())), r2;
  }, goog.exportProperty(jspb.Message, "addToRepeatedWrapperField", jspb.Message.addToRepeatedWrapperField), jspb.Message.toMap = function(e2, t2, r2, o2) {
    for (var i3 = {}, a3 = 0; a3 < e2.length; a3++)
      i3[t2.call(e2[a3])] = r2 ? r2.call(e2[a3], o2, e2[a3]) : e2[a3];
    return i3;
  }, goog.exportProperty(jspb.Message, "toMap", jspb.Message.toMap), jspb.Message.prototype.syncMapFields_ = function() {
    if (this.wrappers_)
      for (var e2 in this.wrappers_) {
        var t2 = this.wrappers_[e2];
        if (Array.isArray(t2))
          for (var r2 = 0; r2 < t2.length; r2++)
            t2[r2] && t2[r2].toArray();
        else
          t2 && t2.toArray();
      }
  }, jspb.Message.prototype.toArray = function() {
    return this.syncMapFields_(), this.array;
  }, goog.exportProperty(jspb.Message.prototype, "toArray", jspb.Message.prototype.toArray), jspb.Message.GENERATE_TO_STRING && (jspb.Message.prototype.toString = function() {
    return this.syncMapFields_(), this.array.toString();
  }), jspb.Message.prototype.getExtension = function(e2) {
    if (this.extensionObject_) {
      this.wrappers_ || (this.wrappers_ = {});
      var t2 = e2.fieldIndex;
      if (e2.isRepeated) {
        if (e2.isMessageType())
          return this.wrappers_[t2] || (this.wrappers_[t2] = goog.array.map(this.extensionObject_[t2] || [], function(t3) {
            return new e2.ctor(t3);
          })), this.wrappers_[t2];
      } else if (e2.isMessageType())
        return !this.wrappers_[t2] && this.extensionObject_[t2] && (this.wrappers_[t2] = new e2.ctor(this.extensionObject_[t2])), this.wrappers_[t2];
      return this.extensionObject_[t2];
    }
  }, goog.exportProperty(jspb.Message.prototype, "getExtension", jspb.Message.prototype.getExtension), jspb.Message.prototype.setExtension = function(e2, t2) {
    this.wrappers_ || (this.wrappers_ = {}), jspb.Message.maybeInitEmptyExtensionObject_(this);
    var r2 = e2.fieldIndex;
    return e2.isRepeated ? (t2 = t2 || [], e2.isMessageType() ? (this.wrappers_[r2] = t2, this.extensionObject_[r2] = goog.array.map(t2, function(e3) {
      return e3.toArray();
    })) : this.extensionObject_[r2] = t2) : e2.isMessageType() ? (this.wrappers_[r2] = t2, this.extensionObject_[r2] = t2 ? t2.toArray() : t2) : this.extensionObject_[r2] = t2, this;
  }, goog.exportProperty(jspb.Message.prototype, "setExtension", jspb.Message.prototype.setExtension), jspb.Message.difference = function(e2, t2) {
    if (!(e2 instanceof t2.constructor))
      throw Error("Messages have different types.");
    var r2 = e2.toArray();
    t2 = t2.toArray();
    var o2 = [], i3 = 0, a3 = r2.length > t2.length ? r2.length : t2.length;
    for (e2.getJsPbMessageId() && (o2[0] = e2.getJsPbMessageId(), i3 = 1); i3 < a3; i3++)
      jspb.Message.compareFields(r2[i3], t2[i3]) || (o2[i3] = t2[i3]);
    return new e2.constructor(o2);
  }, goog.exportProperty(jspb.Message, "difference", jspb.Message.difference), jspb.Message.equals = function(e2, t2) {
    return e2 == t2 || !(!e2 || !t2) && e2 instanceof t2.constructor && jspb.Message.compareFields(e2.toArray(), t2.toArray());
  }, goog.exportProperty(jspb.Message, "equals", jspb.Message.equals), jspb.Message.compareExtensions = function(e2, t2) {
    e2 = e2 || {}, t2 = t2 || {};
    var r2, o2 = {};
    for (r2 in e2)
      o2[r2] = 0;
    for (r2 in t2)
      o2[r2] = 0;
    for (r2 in o2)
      if (!jspb.Message.compareFields(e2[r2], t2[r2]))
        return false;
    return true;
  }, goog.exportProperty(jspb.Message, "compareExtensions", jspb.Message.compareExtensions), jspb.Message.compareFields = function(e2, t2) {
    if (e2 == t2)
      return true;
    if (!goog.isObject(e2) || !goog.isObject(t2))
      return !!("number" == typeof e2 && isNaN(e2) || "number" == typeof t2 && isNaN(t2)) && String(e2) == String(t2);
    if (e2.constructor != t2.constructor)
      return false;
    if (jspb.Message.SUPPORTS_UINT8ARRAY_ && e2.constructor === Uint8Array) {
      if (e2.length != t2.length)
        return false;
      for (var r2 = 0; r2 < e2.length; r2++)
        if (e2[r2] != t2[r2])
          return false;
      return true;
    }
    if (e2.constructor === Array) {
      var o2 = void 0, i3 = void 0, a3 = Math.max(e2.length, t2.length);
      for (r2 = 0; r2 < a3; r2++) {
        var n2 = e2[r2], s2 = t2[r2];
        if (n2 && n2.constructor == Object && (jspb.asserts.assert(void 0 === o2), jspb.asserts.assert(r2 === e2.length - 1), o2 = n2, n2 = void 0), s2 && s2.constructor == Object && (jspb.asserts.assert(void 0 === i3), jspb.asserts.assert(r2 === t2.length - 1), i3 = s2, s2 = void 0), !jspb.Message.compareFields(n2, s2))
          return false;
      }
      return !o2 && !i3 || (o2 = o2 || {}, i3 = i3 || {}, jspb.Message.compareExtensions(o2, i3));
    }
    if (e2.constructor === Object)
      return jspb.Message.compareExtensions(e2, t2);
    throw Error("Invalid type in JSPB array");
  }, goog.exportProperty(jspb.Message, "compareFields", jspb.Message.compareFields), jspb.Message.prototype.cloneMessage = function() {
    return jspb.Message.cloneMessage(this);
  }, goog.exportProperty(jspb.Message.prototype, "cloneMessage", jspb.Message.prototype.cloneMessage), jspb.Message.prototype.clone = function() {
    return jspb.Message.cloneMessage(this);
  }, goog.exportProperty(jspb.Message.prototype, "clone", jspb.Message.prototype.clone), jspb.Message.clone = function(e2) {
    return jspb.Message.cloneMessage(e2);
  }, goog.exportProperty(jspb.Message, "clone", jspb.Message.clone), jspb.Message.cloneMessage = function(e2) {
    return new e2.constructor(jspb.Message.clone_(e2.toArray()));
  }, jspb.Message.copyInto = function(e2, t2) {
    jspb.asserts.assertInstanceof(e2, jspb.Message), jspb.asserts.assertInstanceof(t2, jspb.Message), jspb.asserts.assert(e2.constructor == t2.constructor, "Copy source and target message should have the same type."), e2 = jspb.Message.clone(e2);
    for (var r2 = t2.toArray(), o2 = e2.toArray(), i3 = r2.length = 0; i3 < o2.length; i3++)
      r2[i3] = o2[i3];
    t2.wrappers_ = e2.wrappers_, t2.extensionObject_ = e2.extensionObject_;
  }, goog.exportProperty(jspb.Message, "copyInto", jspb.Message.copyInto), jspb.Message.clone_ = function(e2) {
    if (Array.isArray(e2)) {
      for (var t2 = Array(e2.length), r2 = 0; r2 < e2.length; r2++) {
        var o2 = e2[r2];
        null != o2 && (t2[r2] = "object" == typeof o2 ? jspb.Message.clone_(jspb.asserts.assert(o2)) : o2);
      }
      return t2;
    }
    if (jspb.Message.SUPPORTS_UINT8ARRAY_ && e2 instanceof Uint8Array)
      return new Uint8Array(e2);
    for (r2 in t2 = {}, e2)
      null != (o2 = e2[r2]) && (t2[r2] = "object" == typeof o2 ? jspb.Message.clone_(jspb.asserts.assert(o2)) : o2);
    return t2;
  }, jspb.Message.registerMessageType = function(e2, t2) {
    t2.messageId = e2;
  }, goog.exportProperty(jspb.Message, "registerMessageType", jspb.Message.registerMessageType), jspb.Message.messageSetExtensions = {}, jspb.Message.messageSetExtensionsBinary = {}, jspb.Export = {}, exports.Map = jspb.Map, exports.Message = jspb.Message, exports.BinaryReader = jspb.BinaryReader, exports.BinaryWriter = jspb.BinaryWriter, exports.ExtensionFieldInfo = jspb.ExtensionFieldInfo, exports.ExtensionFieldBinaryInfo = jspb.ExtensionFieldBinaryInfo, exports.exportSymbol = goog.exportSymbol, exports.inherits = goog.inherits, exports.object = { extend: goog.object.extend }, exports.typeOf = goog.typeOf;
})(googleProtobuf);
var calculator_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.CalculatorOptions", null, o2), proto.mediapipe.CalculatorOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, 2, null, null);
  }, r2.inherits(proto.mediapipe.CalculatorOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.CalculatorOptions.displayName = "proto.mediapipe.CalculatorOptions"), proto.mediapipe.CalculatorOptions.extensions = {}, proto.mediapipe.CalculatorOptions.extensionsBinary = {}, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.CalculatorOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.CalculatorOptions.toObject(e3, this);
  }, proto.mediapipe.CalculatorOptions.toObject = function(e3, r3) {
    var o3, i3 = { mergeFields: null == (o3 = t2.Message.getBooleanField(r3, 1)) ? void 0 : o3 };
    return t2.Message.toObjectExtension(r3, i3, proto.mediapipe.CalculatorOptions.extensions, proto.mediapipe.CalculatorOptions.prototype.getExtension, e3), e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.CalculatorOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.CalculatorOptions();
    return proto.mediapipe.CalculatorOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.CalculatorOptions.deserializeBinaryFromReader = function(e3, r3) {
    for (; r3.nextField() && !r3.isEndGroup(); ) {
      if (1 === r3.getFieldNumber()) {
        var o3 = r3.readBool();
        e3.setMergeFields(o3);
      } else
        t2.Message.readBinaryExtension(e3, r3, proto.mediapipe.CalculatorOptions.extensionsBinary, proto.mediapipe.CalculatorOptions.prototype.getExtension, proto.mediapipe.CalculatorOptions.prototype.setExtension);
    }
    return e3;
  }, proto.mediapipe.CalculatorOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.CalculatorOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.CalculatorOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeBool(1, o3), t2.Message.serializeBinaryExtensions(e3, r3, proto.mediapipe.CalculatorOptions.extensionsBinary, proto.mediapipe.CalculatorOptions.prototype.getExtension);
  }, proto.mediapipe.CalculatorOptions.prototype.getMergeFields = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 1, false);
  }, proto.mediapipe.CalculatorOptions.prototype.setMergeFields = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.CalculatorOptions.prototype.clearMergeFields = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.CalculatorOptions.prototype.hasMergeFields = function() {
    return null != t2.Message.getField(this, 1);
  }, r2.object.extend(e2, proto.mediapipe);
}(calculator_options_pb);
var any_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.google.protobuf.Any", null, o2), proto.google.protobuf.Any = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.google.protobuf.Any, t2.Message), r2.DEBUG && !COMPILED && (proto.google.protobuf.Any.displayName = "proto.google.protobuf.Any"), t2.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.Any.prototype.toObject = function(e3) {
    return proto.google.protobuf.Any.toObject(e3, this);
  }, proto.google.protobuf.Any.toObject = function(e3, r3) {
    var o3 = { typeUrl: t2.Message.getFieldWithDefault(r3, 1, ""), value: r3.getValue_asB64() };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.google.protobuf.Any.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.google.protobuf.Any();
    return proto.google.protobuf.Any.deserializeBinaryFromReader(o3, r3);
  }, proto.google.protobuf.Any.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setTypeUrl(r3);
          break;
        case 2:
          r3 = t3.readBytes();
          e3.setValue(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.google.protobuf.Any.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.google.protobuf.Any.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.google.protobuf.Any.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    (r3 = e3.getTypeUrl()).length > 0 && t3.writeString(1, r3), (r3 = e3.getValue_asU8()).length > 0 && t3.writeBytes(2, r3);
  }, proto.google.protobuf.Any.prototype.getTypeUrl = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.google.protobuf.Any.prototype.setTypeUrl = function(e3) {
    return t2.Message.setProto3StringField(this, 1, e3);
  }, proto.google.protobuf.Any.prototype.getValue = function() {
    return t2.Message.getFieldWithDefault(this, 2, "");
  }, proto.google.protobuf.Any.prototype.getValue_asB64 = function() {
    return t2.Message.bytesAsB64(this.getValue());
  }, proto.google.protobuf.Any.prototype.getValue_asU8 = function() {
    return t2.Message.bytesAsU8(this.getValue());
  }, proto.google.protobuf.Any.prototype.setValue = function(e3) {
    return t2.Message.setProto3BytesField(this, 2, e3);
  }, r2.object.extend(e2, proto.google.protobuf), proto.google.protobuf.Any.prototype.getTypeName = function() {
    return this.getTypeUrl().split("/").pop();
  }, proto.google.protobuf.Any.prototype.pack = function(e3, t3, r3) {
    r3 || (r3 = "type.googleapis.com/"), "/" != r3.substr(-1) ? this.setTypeUrl(r3 + "/" + t3) : this.setTypeUrl(r3 + t3), this.setValue(e3);
  }, proto.google.protobuf.Any.prototype.unpack = function(e3, t3) {
    return this.getTypeName() == t3 ? e3(this.getValue_asU8()) : null;
  };
}(any_pb);
var mediapipe_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.MediaPipeOptions", null, o2), proto.mediapipe.MediaPipeOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, 1, null, null);
  }, r2.inherits(proto.mediapipe.MediaPipeOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.MediaPipeOptions.displayName = "proto.mediapipe.MediaPipeOptions"), proto.mediapipe.MediaPipeOptions.extensions = {}, proto.mediapipe.MediaPipeOptions.extensionsBinary = {}, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.MediaPipeOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.MediaPipeOptions.toObject(e3, this);
  }, proto.mediapipe.MediaPipeOptions.toObject = function(e3, r3) {
    var o3 = {};
    return t2.Message.toObjectExtension(r3, o3, proto.mediapipe.MediaPipeOptions.extensions, proto.mediapipe.MediaPipeOptions.prototype.getExtension, e3), e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.MediaPipeOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.MediaPipeOptions();
    return proto.mediapipe.MediaPipeOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.MediaPipeOptions.deserializeBinaryFromReader = function(e3, r3) {
    for (; r3.nextField() && !r3.isEndGroup(); ) {
      r3.getFieldNumber();
      t2.Message.readBinaryExtension(e3, r3, proto.mediapipe.MediaPipeOptions.extensionsBinary, proto.mediapipe.MediaPipeOptions.prototype.getExtension, proto.mediapipe.MediaPipeOptions.prototype.setExtension);
    }
    return e3;
  }, proto.mediapipe.MediaPipeOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.MediaPipeOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.MediaPipeOptions.serializeBinaryToWriter = function(e3, r3) {
    t2.Message.serializeBinaryExtensions(e3, r3, proto.mediapipe.MediaPipeOptions.extensionsBinary, proto.mediapipe.MediaPipeOptions.prototype.getExtension);
  }, r2.object.extend(e2, proto.mediapipe);
}(mediapipe_options_pb);
var packet_factory_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.PacketFactoryConfig", null, o2), r2.exportSymbol("proto.mediapipe.PacketFactoryOptions", null, o2), r2.exportSymbol("proto.mediapipe.PacketManagerConfig", null, o2), proto.mediapipe.PacketFactoryOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, 1, null, null);
  }, r2.inherits(proto.mediapipe.PacketFactoryOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.PacketFactoryOptions.displayName = "proto.mediapipe.PacketFactoryOptions"), proto.mediapipe.PacketFactoryOptions.extensions = {}, proto.mediapipe.PacketFactoryOptions.extensionsBinary = {}, proto.mediapipe.PacketFactoryConfig = function(e3) {
    t2.Message.initialize(this, e3, 0, 500, null, null);
  }, r2.inherits(proto.mediapipe.PacketFactoryConfig, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.PacketFactoryConfig.displayName = "proto.mediapipe.PacketFactoryConfig"), proto.mediapipe.PacketManagerConfig = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.PacketManagerConfig.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.PacketManagerConfig, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.PacketManagerConfig.displayName = "proto.mediapipe.PacketManagerConfig"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.PacketFactoryOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.PacketFactoryOptions.toObject(e3, this);
  }, proto.mediapipe.PacketFactoryOptions.toObject = function(e3, r3) {
    var o3 = {};
    return t2.Message.toObjectExtension(r3, o3, proto.mediapipe.PacketFactoryOptions.extensions, proto.mediapipe.PacketFactoryOptions.prototype.getExtension, e3), e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.PacketFactoryOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.PacketFactoryOptions();
    return proto.mediapipe.PacketFactoryOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.PacketFactoryOptions.deserializeBinaryFromReader = function(e3, r3) {
    for (; r3.nextField() && !r3.isEndGroup(); ) {
      r3.getFieldNumber();
      t2.Message.readBinaryExtension(e3, r3, proto.mediapipe.PacketFactoryOptions.extensionsBinary, proto.mediapipe.PacketFactoryOptions.prototype.getExtension, proto.mediapipe.PacketFactoryOptions.prototype.setExtension);
    }
    return e3;
  }, proto.mediapipe.PacketFactoryOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.PacketFactoryOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.PacketFactoryOptions.serializeBinaryToWriter = function(e3, r3) {
    t2.Message.serializeBinaryExtensions(e3, r3, proto.mediapipe.PacketFactoryOptions.extensionsBinary, proto.mediapipe.PacketFactoryOptions.prototype.getExtension);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.PacketFactoryConfig.prototype.toObject = function(e3) {
    return proto.mediapipe.PacketFactoryConfig.toObject(e3, this);
  }, proto.mediapipe.PacketFactoryConfig.toObject = function(e3, r3) {
    var o3, i3 = { packetFactory: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, outputSidePacket: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, externalOutput: null == (o3 = t2.Message.getField(r3, 1002)) ? void 0 : o3, options: (o3 = r3.getOptions()) && proto.mediapipe.PacketFactoryOptions.toObject(e3, o3) };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.PacketFactoryConfig.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.PacketFactoryConfig();
    return proto.mediapipe.PacketFactoryConfig.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.PacketFactoryConfig.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setPacketFactory(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setOutputSidePacket(r3);
          break;
        case 1002:
          r3 = t3.readString();
          e3.setExternalOutput(r3);
          break;
        case 3:
          r3 = new proto.mediapipe.PacketFactoryOptions();
          t3.readMessage(r3, proto.mediapipe.PacketFactoryOptions.deserializeBinaryFromReader), e3.setOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.PacketFactoryConfig.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.PacketFactoryConfig.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.PacketFactoryConfig.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeString(2, o3), null != (o3 = t2.Message.getField(e3, 1002)) && r3.writeString(1002, o3), null != (o3 = e3.getOptions()) && r3.writeMessage(3, o3, proto.mediapipe.PacketFactoryOptions.serializeBinaryToWriter);
  }, proto.mediapipe.PacketFactoryConfig.prototype.getPacketFactory = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.PacketFactoryConfig.prototype.setPacketFactory = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.PacketFactoryConfig.prototype.clearPacketFactory = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.PacketFactoryConfig.prototype.hasPacketFactory = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.PacketFactoryConfig.prototype.getOutputSidePacket = function() {
    return t2.Message.getFieldWithDefault(this, 2, "");
  }, proto.mediapipe.PacketFactoryConfig.prototype.setOutputSidePacket = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.PacketFactoryConfig.prototype.clearOutputSidePacket = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.PacketFactoryConfig.prototype.hasOutputSidePacket = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.PacketFactoryConfig.prototype.getExternalOutput = function() {
    return t2.Message.getFieldWithDefault(this, 1002, "");
  }, proto.mediapipe.PacketFactoryConfig.prototype.setExternalOutput = function(e3) {
    return t2.Message.setField(this, 1002, e3);
  }, proto.mediapipe.PacketFactoryConfig.prototype.clearExternalOutput = function() {
    return t2.Message.setField(this, 1002, void 0);
  }, proto.mediapipe.PacketFactoryConfig.prototype.hasExternalOutput = function() {
    return null != t2.Message.getField(this, 1002);
  }, proto.mediapipe.PacketFactoryConfig.prototype.getOptions = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.PacketFactoryOptions, 3);
  }, proto.mediapipe.PacketFactoryConfig.prototype.setOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.PacketFactoryConfig.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.mediapipe.PacketFactoryConfig.prototype.hasOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.PacketManagerConfig.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.PacketManagerConfig.prototype.toObject = function(e3) {
    return proto.mediapipe.PacketManagerConfig.toObject(e3, this);
  }, proto.mediapipe.PacketManagerConfig.toObject = function(e3, r3) {
    var o3 = { packetList: t2.Message.toObjectList(r3.getPacketList(), proto.mediapipe.PacketFactoryConfig.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.PacketManagerConfig.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.PacketManagerConfig();
    return proto.mediapipe.PacketManagerConfig.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.PacketManagerConfig.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.PacketFactoryConfig();
        t3.readMessage(r3, proto.mediapipe.PacketFactoryConfig.deserializeBinaryFromReader), e3.addPacket(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.PacketManagerConfig.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.PacketManagerConfig.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.PacketManagerConfig.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getPacketList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.PacketFactoryConfig.serializeBinaryToWriter);
  }, proto.mediapipe.PacketManagerConfig.prototype.getPacketList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.PacketFactoryConfig, 1);
  }, proto.mediapipe.PacketManagerConfig.prototype.setPacketList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.PacketManagerConfig.prototype.addPacket = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.PacketFactoryConfig, r3);
  }, proto.mediapipe.PacketManagerConfig.prototype.clearPacketList = function() {
    return this.setPacketList([]);
  }, r2.object.extend(e2, proto.mediapipe);
}(packet_factory_pb);
var packet_generator_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.PacketGeneratorConfig", null, o2), r2.exportSymbol("proto.mediapipe.PacketGeneratorOptions", null, o2), proto.mediapipe.PacketGeneratorOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, 2, null, null);
  }, r2.inherits(proto.mediapipe.PacketGeneratorOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.PacketGeneratorOptions.displayName = "proto.mediapipe.PacketGeneratorOptions"), proto.mediapipe.PacketGeneratorOptions.extensions = {}, proto.mediapipe.PacketGeneratorOptions.extensionsBinary = {}, proto.mediapipe.PacketGeneratorConfig = function(e3) {
    t2.Message.initialize(this, e3, 0, 500, proto.mediapipe.PacketGeneratorConfig.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.PacketGeneratorConfig, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.PacketGeneratorConfig.displayName = "proto.mediapipe.PacketGeneratorConfig"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.PacketGeneratorOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.PacketGeneratorOptions.toObject(e3, this);
  }, proto.mediapipe.PacketGeneratorOptions.toObject = function(e3, r3) {
    var o3 = { mergeFields: t2.Message.getBooleanFieldWithDefault(r3, 1, true) };
    return t2.Message.toObjectExtension(r3, o3, proto.mediapipe.PacketGeneratorOptions.extensions, proto.mediapipe.PacketGeneratorOptions.prototype.getExtension, e3), e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.PacketGeneratorOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.PacketGeneratorOptions();
    return proto.mediapipe.PacketGeneratorOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.PacketGeneratorOptions.deserializeBinaryFromReader = function(e3, r3) {
    for (; r3.nextField() && !r3.isEndGroup(); ) {
      if (1 === r3.getFieldNumber()) {
        var o3 = r3.readBool();
        e3.setMergeFields(o3);
      } else
        t2.Message.readBinaryExtension(e3, r3, proto.mediapipe.PacketGeneratorOptions.extensionsBinary, proto.mediapipe.PacketGeneratorOptions.prototype.getExtension, proto.mediapipe.PacketGeneratorOptions.prototype.setExtension);
    }
    return e3;
  }, proto.mediapipe.PacketGeneratorOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.PacketGeneratorOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.PacketGeneratorOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeBool(1, o3), t2.Message.serializeBinaryExtensions(e3, r3, proto.mediapipe.PacketGeneratorOptions.extensionsBinary, proto.mediapipe.PacketGeneratorOptions.prototype.getExtension);
  }, proto.mediapipe.PacketGeneratorOptions.prototype.getMergeFields = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 1, true);
  }, proto.mediapipe.PacketGeneratorOptions.prototype.setMergeFields = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.PacketGeneratorOptions.prototype.clearMergeFields = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.PacketGeneratorOptions.prototype.hasMergeFields = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.PacketGeneratorConfig.repeatedFields_ = [2, 1002, 3, 1003], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.PacketGeneratorConfig.prototype.toObject = function(e3) {
    return proto.mediapipe.PacketGeneratorConfig.toObject(e3, this);
  }, proto.mediapipe.PacketGeneratorConfig.toObject = function(e3, r3) {
    var o3, i3 = { packetGenerator: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, inputSidePacketList: null == (o3 = t2.Message.getRepeatedField(r3, 2)) ? void 0 : o3, externalInputList: null == (o3 = t2.Message.getRepeatedField(r3, 1002)) ? void 0 : o3, outputSidePacketList: null == (o3 = t2.Message.getRepeatedField(r3, 3)) ? void 0 : o3, externalOutputList: null == (o3 = t2.Message.getRepeatedField(r3, 1003)) ? void 0 : o3, options: (o3 = r3.getOptions()) && proto.mediapipe.PacketGeneratorOptions.toObject(e3, o3) };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.PacketGeneratorConfig.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.PacketGeneratorConfig();
    return proto.mediapipe.PacketGeneratorConfig.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.PacketGeneratorConfig.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setPacketGenerator(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.addInputSidePacket(r3);
          break;
        case 1002:
          r3 = t3.readString();
          e3.addExternalInput(r3);
          break;
        case 3:
          r3 = t3.readString();
          e3.addOutputSidePacket(r3);
          break;
        case 1003:
          r3 = t3.readString();
          e3.addExternalOutput(r3);
          break;
        case 4:
          r3 = new proto.mediapipe.PacketGeneratorOptions();
          t3.readMessage(r3, proto.mediapipe.PacketGeneratorOptions.deserializeBinaryFromReader), e3.setOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.PacketGeneratorConfig.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.PacketGeneratorConfig.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.PacketGeneratorConfig.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), (o3 = e3.getInputSidePacketList()).length > 0 && r3.writeRepeatedString(2, o3), (o3 = e3.getExternalInputList()).length > 0 && r3.writeRepeatedString(1002, o3), (o3 = e3.getOutputSidePacketList()).length > 0 && r3.writeRepeatedString(3, o3), (o3 = e3.getExternalOutputList()).length > 0 && r3.writeRepeatedString(1003, o3), null != (o3 = e3.getOptions()) && r3.writeMessage(4, o3, proto.mediapipe.PacketGeneratorOptions.serializeBinaryToWriter);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.getPacketGenerator = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.PacketGeneratorConfig.prototype.setPacketGenerator = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.clearPacketGenerator = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.hasPacketGenerator = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.getInputSidePacketList = function() {
    return t2.Message.getRepeatedField(this, 2);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.setInputSidePacketList = function(e3) {
    return t2.Message.setField(this, 2, e3 || []);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.addInputSidePacket = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 2, e3, r3);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.clearInputSidePacketList = function() {
    return this.setInputSidePacketList([]);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.getExternalInputList = function() {
    return t2.Message.getRepeatedField(this, 1002);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.setExternalInputList = function(e3) {
    return t2.Message.setField(this, 1002, e3 || []);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.addExternalInput = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 1002, e3, r3);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.clearExternalInputList = function() {
    return this.setExternalInputList([]);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.getOutputSidePacketList = function() {
    return t2.Message.getRepeatedField(this, 3);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.setOutputSidePacketList = function(e3) {
    return t2.Message.setField(this, 3, e3 || []);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.addOutputSidePacket = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 3, e3, r3);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.clearOutputSidePacketList = function() {
    return this.setOutputSidePacketList([]);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.getExternalOutputList = function() {
    return t2.Message.getRepeatedField(this, 1003);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.setExternalOutputList = function(e3) {
    return t2.Message.setField(this, 1003, e3 || []);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.addExternalOutput = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 1003, e3, r3);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.clearExternalOutputList = function() {
    return this.setExternalOutputList([]);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.getOptions = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.PacketGeneratorOptions, 4);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.setOptions = function(e3) {
    return t2.Message.setWrapperField(this, 4, e3);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.mediapipe.PacketGeneratorConfig.prototype.hasOptions = function() {
    return null != t2.Message.getField(this, 4);
  }, r2.object.extend(e2, proto.mediapipe);
}(packet_generator_pb);
var status_handler_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = mediapipe_options_pb;
  r2.object.extend(proto, i3), r2.exportSymbol("proto.mediapipe.StatusHandlerConfig", null, o2), proto.mediapipe.StatusHandlerConfig = function(e3) {
    t2.Message.initialize(this, e3, 0, 500, proto.mediapipe.StatusHandlerConfig.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.StatusHandlerConfig, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.StatusHandlerConfig.displayName = "proto.mediapipe.StatusHandlerConfig"), proto.mediapipe.StatusHandlerConfig.repeatedFields_ = [2, 1002], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.StatusHandlerConfig.prototype.toObject = function(e3) {
    return proto.mediapipe.StatusHandlerConfig.toObject(e3, this);
  }, proto.mediapipe.StatusHandlerConfig.toObject = function(e3, r3) {
    var o3, a3 = { statusHandler: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, inputSidePacketList: null == (o3 = t2.Message.getRepeatedField(r3, 2)) ? void 0 : o3, externalInputList: null == (o3 = t2.Message.getRepeatedField(r3, 1002)) ? void 0 : o3, options: (o3 = r3.getOptions()) && i3.MediaPipeOptions.toObject(e3, o3) };
    return e3 && (a3.$jspbMessageInstance = r3), a3;
  }), proto.mediapipe.StatusHandlerConfig.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.StatusHandlerConfig();
    return proto.mediapipe.StatusHandlerConfig.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.StatusHandlerConfig.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setStatusHandler(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.addInputSidePacket(r3);
          break;
        case 1002:
          r3 = t3.readString();
          e3.addExternalInput(r3);
          break;
        case 3:
          r3 = new i3.MediaPipeOptions();
          t3.readMessage(r3, i3.MediaPipeOptions.deserializeBinaryFromReader), e3.setOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.StatusHandlerConfig.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.StatusHandlerConfig.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.StatusHandlerConfig.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), (o3 = e3.getInputSidePacketList()).length > 0 && r3.writeRepeatedString(2, o3), (o3 = e3.getExternalInputList()).length > 0 && r3.writeRepeatedString(1002, o3), null != (o3 = e3.getOptions()) && r3.writeMessage(3, o3, i3.MediaPipeOptions.serializeBinaryToWriter);
  }, proto.mediapipe.StatusHandlerConfig.prototype.getStatusHandler = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.StatusHandlerConfig.prototype.setStatusHandler = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.StatusHandlerConfig.prototype.clearStatusHandler = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.StatusHandlerConfig.prototype.hasStatusHandler = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.StatusHandlerConfig.prototype.getInputSidePacketList = function() {
    return t2.Message.getRepeatedField(this, 2);
  }, proto.mediapipe.StatusHandlerConfig.prototype.setInputSidePacketList = function(e3) {
    return t2.Message.setField(this, 2, e3 || []);
  }, proto.mediapipe.StatusHandlerConfig.prototype.addInputSidePacket = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 2, e3, r3);
  }, proto.mediapipe.StatusHandlerConfig.prototype.clearInputSidePacketList = function() {
    return this.setInputSidePacketList([]);
  }, proto.mediapipe.StatusHandlerConfig.prototype.getExternalInputList = function() {
    return t2.Message.getRepeatedField(this, 1002);
  }, proto.mediapipe.StatusHandlerConfig.prototype.setExternalInputList = function(e3) {
    return t2.Message.setField(this, 1002, e3 || []);
  }, proto.mediapipe.StatusHandlerConfig.prototype.addExternalInput = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 1002, e3, r3);
  }, proto.mediapipe.StatusHandlerConfig.prototype.clearExternalInputList = function() {
    return this.setExternalInputList([]);
  }, proto.mediapipe.StatusHandlerConfig.prototype.getOptions = function() {
    return t2.Message.getWrapperField(this, i3.MediaPipeOptions, 3);
  }, proto.mediapipe.StatusHandlerConfig.prototype.setOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.StatusHandlerConfig.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.mediapipe.StatusHandlerConfig.prototype.hasOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, r2.object.extend(e2, proto.mediapipe);
}(status_handler_pb);
var stream_handler_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = mediapipe_options_pb;
  r2.object.extend(proto, i3), r2.exportSymbol("proto.mediapipe.InputStreamHandlerConfig", null, o2), r2.exportSymbol("proto.mediapipe.OutputStreamHandlerConfig", null, o2), proto.mediapipe.InputStreamHandlerConfig = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.InputStreamHandlerConfig, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InputStreamHandlerConfig.displayName = "proto.mediapipe.InputStreamHandlerConfig"), proto.mediapipe.OutputStreamHandlerConfig = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.OutputStreamHandlerConfig.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.OutputStreamHandlerConfig, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.OutputStreamHandlerConfig.displayName = "proto.mediapipe.OutputStreamHandlerConfig"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InputStreamHandlerConfig.prototype.toObject = function(e3) {
    return proto.mediapipe.InputStreamHandlerConfig.toObject(e3, this);
  }, proto.mediapipe.InputStreamHandlerConfig.toObject = function(e3, r3) {
    var o3, a3 = { inputStreamHandler: t2.Message.getFieldWithDefault(r3, 1, "DefaultInputStreamHandler"), options: (o3 = r3.getOptions()) && i3.MediaPipeOptions.toObject(e3, o3) };
    return e3 && (a3.$jspbMessageInstance = r3), a3;
  }), proto.mediapipe.InputStreamHandlerConfig.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InputStreamHandlerConfig();
    return proto.mediapipe.InputStreamHandlerConfig.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InputStreamHandlerConfig.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setInputStreamHandler(r3);
          break;
        case 3:
          r3 = new i3.MediaPipeOptions();
          t3.readMessage(r3, i3.MediaPipeOptions.deserializeBinaryFromReader), e3.setOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.InputStreamHandlerConfig.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InputStreamHandlerConfig.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InputStreamHandlerConfig.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), null != (o3 = e3.getOptions()) && r3.writeMessage(3, o3, i3.MediaPipeOptions.serializeBinaryToWriter);
  }, proto.mediapipe.InputStreamHandlerConfig.prototype.getInputStreamHandler = function() {
    return t2.Message.getFieldWithDefault(this, 1, "DefaultInputStreamHandler");
  }, proto.mediapipe.InputStreamHandlerConfig.prototype.setInputStreamHandler = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.InputStreamHandlerConfig.prototype.clearInputStreamHandler = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.InputStreamHandlerConfig.prototype.hasInputStreamHandler = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.InputStreamHandlerConfig.prototype.getOptions = function() {
    return t2.Message.getWrapperField(this, i3.MediaPipeOptions, 3);
  }, proto.mediapipe.InputStreamHandlerConfig.prototype.setOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.InputStreamHandlerConfig.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.mediapipe.InputStreamHandlerConfig.prototype.hasOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.OutputStreamHandlerConfig.repeatedFields_ = [2], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.OutputStreamHandlerConfig.prototype.toObject = function(e3) {
    return proto.mediapipe.OutputStreamHandlerConfig.toObject(e3, this);
  }, proto.mediapipe.OutputStreamHandlerConfig.toObject = function(e3, r3) {
    var o3, a3 = { outputStreamHandler: t2.Message.getFieldWithDefault(r3, 1, "InOrderOutputStreamHandler"), inputSidePacketList: null == (o3 = t2.Message.getRepeatedField(r3, 2)) ? void 0 : o3, options: (o3 = r3.getOptions()) && i3.MediaPipeOptions.toObject(e3, o3) };
    return e3 && (a3.$jspbMessageInstance = r3), a3;
  }), proto.mediapipe.OutputStreamHandlerConfig.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.OutputStreamHandlerConfig();
    return proto.mediapipe.OutputStreamHandlerConfig.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.OutputStreamHandlerConfig.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setOutputStreamHandler(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.addInputSidePacket(r3);
          break;
        case 3:
          r3 = new i3.MediaPipeOptions();
          t3.readMessage(r3, i3.MediaPipeOptions.deserializeBinaryFromReader), e3.setOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.OutputStreamHandlerConfig.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.OutputStreamHandlerConfig.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), (o3 = e3.getInputSidePacketList()).length > 0 && r3.writeRepeatedString(2, o3), null != (o3 = e3.getOptions()) && r3.writeMessage(3, o3, i3.MediaPipeOptions.serializeBinaryToWriter);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.getOutputStreamHandler = function() {
    return t2.Message.getFieldWithDefault(this, 1, "InOrderOutputStreamHandler");
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.setOutputStreamHandler = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.clearOutputStreamHandler = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.hasOutputStreamHandler = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.getInputSidePacketList = function() {
    return t2.Message.getRepeatedField(this, 2);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.setInputSidePacketList = function(e3) {
    return t2.Message.setField(this, 2, e3 || []);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.addInputSidePacket = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 2, e3, r3);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.clearInputSidePacketList = function() {
    return this.setInputSidePacketList([]);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.getOptions = function() {
    return t2.Message.getWrapperField(this, i3.MediaPipeOptions, 3);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.setOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.mediapipe.OutputStreamHandlerConfig.prototype.hasOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, r2.object.extend(e2, proto.mediapipe);
}(stream_handler_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_options_pb;
  r2.object.extend(proto, i3);
  var a3 = any_pb;
  r2.object.extend(proto, a3);
  var n2 = mediapipe_options_pb;
  r2.object.extend(proto, n2);
  var s2 = packet_factory_pb;
  r2.object.extend(proto, s2);
  var p = packet_generator_pb;
  r2.object.extend(proto, p);
  var d2 = status_handler_pb;
  r2.object.extend(proto, d2);
  var l2 = stream_handler_pb;
  r2.object.extend(proto, l2), r2.exportSymbol("proto.mediapipe.CalculatorGraphConfig", null, o2), r2.exportSymbol("proto.mediapipe.CalculatorGraphConfig.Node", null, o2), r2.exportSymbol("proto.mediapipe.ExecutorConfig", null, o2), r2.exportSymbol("proto.mediapipe.InputCollection", null, o2), r2.exportSymbol("proto.mediapipe.InputCollection.InputType", null, o2), r2.exportSymbol("proto.mediapipe.InputCollectionSet", null, o2), r2.exportSymbol("proto.mediapipe.InputStreamInfo", null, o2), r2.exportSymbol("proto.mediapipe.ProfilerConfig", null, o2), proto.mediapipe.ExecutorConfig = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.ExecutorConfig, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.ExecutorConfig.displayName = "proto.mediapipe.ExecutorConfig"), proto.mediapipe.InputCollection = function(e3) {
    t2.Message.initialize(this, e3, 0, 500, proto.mediapipe.InputCollection.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.InputCollection, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InputCollection.displayName = "proto.mediapipe.InputCollection"), proto.mediapipe.InputCollectionSet = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.InputCollectionSet.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.InputCollectionSet, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InputCollectionSet.displayName = "proto.mediapipe.InputCollectionSet"), proto.mediapipe.InputStreamInfo = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.InputStreamInfo, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InputStreamInfo.displayName = "proto.mediapipe.InputStreamInfo"), proto.mediapipe.ProfilerConfig = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.ProfilerConfig.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.ProfilerConfig, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.ProfilerConfig.displayName = "proto.mediapipe.ProfilerConfig"), proto.mediapipe.CalculatorGraphConfig = function(e3) {
    t2.Message.initialize(this, e3, 0, 500, proto.mediapipe.CalculatorGraphConfig.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.CalculatorGraphConfig, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.CalculatorGraphConfig.displayName = "proto.mediapipe.CalculatorGraphConfig"), proto.mediapipe.CalculatorGraphConfig.Node = function(e3) {
    t2.Message.initialize(this, e3, 0, 500, proto.mediapipe.CalculatorGraphConfig.Node.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.CalculatorGraphConfig.Node, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.CalculatorGraphConfig.Node.displayName = "proto.mediapipe.CalculatorGraphConfig.Node"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.ExecutorConfig.prototype.toObject = function(e3) {
    return proto.mediapipe.ExecutorConfig.toObject(e3, this);
  }, proto.mediapipe.ExecutorConfig.toObject = function(e3, r3) {
    var o3, i4 = { name: t2.Message.getFieldWithDefault(r3, 1, ""), type: t2.Message.getFieldWithDefault(r3, 2, ""), options: (o3 = r3.getOptions()) && n2.MediaPipeOptions.toObject(e3, o3) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.ExecutorConfig.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.ExecutorConfig();
    return proto.mediapipe.ExecutorConfig.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.ExecutorConfig.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setName(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setType(r3);
          break;
        case 3:
          r3 = new n2.MediaPipeOptions();
          t3.readMessage(r3, n2.MediaPipeOptions.deserializeBinaryFromReader), e3.setOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.ExecutorConfig.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.ExecutorConfig.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.ExecutorConfig.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    (r3 = e3.getName()).length > 0 && t3.writeString(1, r3), (r3 = e3.getType()).length > 0 && t3.writeString(2, r3), null != (r3 = e3.getOptions()) && t3.writeMessage(3, r3, n2.MediaPipeOptions.serializeBinaryToWriter);
  }, proto.mediapipe.ExecutorConfig.prototype.getName = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.ExecutorConfig.prototype.setName = function(e3) {
    return t2.Message.setProto3StringField(this, 1, e3);
  }, proto.mediapipe.ExecutorConfig.prototype.getType = function() {
    return t2.Message.getFieldWithDefault(this, 2, "");
  }, proto.mediapipe.ExecutorConfig.prototype.setType = function(e3) {
    return t2.Message.setProto3StringField(this, 2, e3);
  }, proto.mediapipe.ExecutorConfig.prototype.getOptions = function() {
    return t2.Message.getWrapperField(this, n2.MediaPipeOptions, 3);
  }, proto.mediapipe.ExecutorConfig.prototype.setOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.ExecutorConfig.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.mediapipe.ExecutorConfig.prototype.hasOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.InputCollection.repeatedFields_ = [2, 1002], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InputCollection.prototype.toObject = function(e3) {
    return proto.mediapipe.InputCollection.toObject(e3, this);
  }, proto.mediapipe.InputCollection.toObject = function(e3, r3) {
    var o3, i4 = { name: t2.Message.getFieldWithDefault(r3, 1, ""), sidePacketNameList: null == (o3 = t2.Message.getRepeatedField(r3, 2)) ? void 0 : o3, externalInputNameList: null == (o3 = t2.Message.getRepeatedField(r3, 1002)) ? void 0 : o3, inputType: t2.Message.getFieldWithDefault(r3, 3, 0), fileName: t2.Message.getFieldWithDefault(r3, 4, "") };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.InputCollection.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InputCollection();
    return proto.mediapipe.InputCollection.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InputCollection.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setName(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.addSidePacketName(r3);
          break;
        case 1002:
          r3 = t3.readString();
          e3.addExternalInputName(r3);
          break;
        case 3:
          r3 = t3.readEnum();
          e3.setInputType(r3);
          break;
        case 4:
          r3 = t3.readString();
          e3.setFileName(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.InputCollection.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InputCollection.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InputCollection.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    (r3 = e3.getName()).length > 0 && t3.writeString(1, r3), (r3 = e3.getSidePacketNameList()).length > 0 && t3.writeRepeatedString(2, r3), (r3 = e3.getExternalInputNameList()).length > 0 && t3.writeRepeatedString(1002, r3), 0 !== (r3 = e3.getInputType()) && t3.writeEnum(3, r3), (r3 = e3.getFileName()).length > 0 && t3.writeString(4, r3);
  }, proto.mediapipe.InputCollection.InputType = { UNKNOWN: 0, RECORDIO: 1, FOREIGN_RECORDIO: 2, FOREIGN_CSV_TEXT: 3, INVALID_UPPER_BOUND: 4 }, proto.mediapipe.InputCollection.prototype.getName = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.InputCollection.prototype.setName = function(e3) {
    return t2.Message.setProto3StringField(this, 1, e3);
  }, proto.mediapipe.InputCollection.prototype.getSidePacketNameList = function() {
    return t2.Message.getRepeatedField(this, 2);
  }, proto.mediapipe.InputCollection.prototype.setSidePacketNameList = function(e3) {
    return t2.Message.setField(this, 2, e3 || []);
  }, proto.mediapipe.InputCollection.prototype.addSidePacketName = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 2, e3, r3);
  }, proto.mediapipe.InputCollection.prototype.clearSidePacketNameList = function() {
    return this.setSidePacketNameList([]);
  }, proto.mediapipe.InputCollection.prototype.getExternalInputNameList = function() {
    return t2.Message.getRepeatedField(this, 1002);
  }, proto.mediapipe.InputCollection.prototype.setExternalInputNameList = function(e3) {
    return t2.Message.setField(this, 1002, e3 || []);
  }, proto.mediapipe.InputCollection.prototype.addExternalInputName = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 1002, e3, r3);
  }, proto.mediapipe.InputCollection.prototype.clearExternalInputNameList = function() {
    return this.setExternalInputNameList([]);
  }, proto.mediapipe.InputCollection.prototype.getInputType = function() {
    return t2.Message.getFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.InputCollection.prototype.setInputType = function(e3) {
    return t2.Message.setProto3EnumField(this, 3, e3);
  }, proto.mediapipe.InputCollection.prototype.getFileName = function() {
    return t2.Message.getFieldWithDefault(this, 4, "");
  }, proto.mediapipe.InputCollection.prototype.setFileName = function(e3) {
    return t2.Message.setProto3StringField(this, 4, e3);
  }, proto.mediapipe.InputCollectionSet.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InputCollectionSet.prototype.toObject = function(e3) {
    return proto.mediapipe.InputCollectionSet.toObject(e3, this);
  }, proto.mediapipe.InputCollectionSet.toObject = function(e3, r3) {
    var o3 = { inputCollectionList: t2.Message.toObjectList(r3.getInputCollectionList(), proto.mediapipe.InputCollection.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.InputCollectionSet.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InputCollectionSet();
    return proto.mediapipe.InputCollectionSet.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InputCollectionSet.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.InputCollection();
        t3.readMessage(r3, proto.mediapipe.InputCollection.deserializeBinaryFromReader), e3.addInputCollection(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.InputCollectionSet.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InputCollectionSet.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InputCollectionSet.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getInputCollectionList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.InputCollection.serializeBinaryToWriter);
  }, proto.mediapipe.InputCollectionSet.prototype.getInputCollectionList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.InputCollection, 1);
  }, proto.mediapipe.InputCollectionSet.prototype.setInputCollectionList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.InputCollectionSet.prototype.addInputCollection = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.InputCollection, r3);
  }, proto.mediapipe.InputCollectionSet.prototype.clearInputCollectionList = function() {
    return this.setInputCollectionList([]);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InputStreamInfo.prototype.toObject = function(e3) {
    return proto.mediapipe.InputStreamInfo.toObject(e3, this);
  }, proto.mediapipe.InputStreamInfo.toObject = function(e3, r3) {
    var o3 = { tagIndex: t2.Message.getFieldWithDefault(r3, 1, ""), backEdge: t2.Message.getBooleanFieldWithDefault(r3, 2, false) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.InputStreamInfo.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InputStreamInfo();
    return proto.mediapipe.InputStreamInfo.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InputStreamInfo.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setTagIndex(r3);
          break;
        case 2:
          r3 = t3.readBool();
          e3.setBackEdge(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.InputStreamInfo.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InputStreamInfo.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InputStreamInfo.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    (r3 = e3.getTagIndex()).length > 0 && t3.writeString(1, r3), (r3 = e3.getBackEdge()) && t3.writeBool(2, r3);
  }, proto.mediapipe.InputStreamInfo.prototype.getTagIndex = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.InputStreamInfo.prototype.setTagIndex = function(e3) {
    return t2.Message.setProto3StringField(this, 1, e3);
  }, proto.mediapipe.InputStreamInfo.prototype.getBackEdge = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 2, false);
  }, proto.mediapipe.InputStreamInfo.prototype.setBackEdge = function(e3) {
    return t2.Message.setProto3BooleanField(this, 2, e3);
  }, proto.mediapipe.ProfilerConfig.repeatedFields_ = [8], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.ProfilerConfig.prototype.toObject = function(e3) {
    return proto.mediapipe.ProfilerConfig.toObject(e3, this);
  }, proto.mediapipe.ProfilerConfig.toObject = function(e3, r3) {
    var o3, i4 = { histogramIntervalSizeUsec: t2.Message.getFieldWithDefault(r3, 1, 0), numHistogramIntervals: t2.Message.getFieldWithDefault(r3, 2, 0), enableInputOutputLatency: t2.Message.getBooleanFieldWithDefault(r3, 3, false), enableProfiler: t2.Message.getBooleanFieldWithDefault(r3, 4, false), enableStreamLatency: t2.Message.getBooleanFieldWithDefault(r3, 5, false), usePacketTimestampForAddedPacket: t2.Message.getBooleanFieldWithDefault(r3, 6, false), traceLogCapacity: t2.Message.getFieldWithDefault(r3, 7, 0), traceEventTypesDisabledList: null == (o3 = t2.Message.getRepeatedField(r3, 8)) ? void 0 : o3, traceLogPath: t2.Message.getFieldWithDefault(r3, 9, ""), traceLogCount: t2.Message.getFieldWithDefault(r3, 10, 0), traceLogIntervalUsec: t2.Message.getFieldWithDefault(r3, 11, 0), traceLogMarginUsec: t2.Message.getFieldWithDefault(r3, 12, 0), traceLogDurationEvents: t2.Message.getBooleanFieldWithDefault(r3, 13, false), traceLogIntervalCount: t2.Message.getFieldWithDefault(r3, 14, 0), traceLogDisabled: t2.Message.getBooleanFieldWithDefault(r3, 15, false), traceEnabled: t2.Message.getBooleanFieldWithDefault(r3, 16, false), traceLogInstantEvents: t2.Message.getBooleanFieldWithDefault(r3, 17, false), calculatorFilter: t2.Message.getFieldWithDefault(r3, 18, "") };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.ProfilerConfig.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.ProfilerConfig();
    return proto.mediapipe.ProfilerConfig.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.ProfilerConfig.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt64();
          e3.setHistogramIntervalSizeUsec(r3);
          break;
        case 2:
          r3 = t3.readInt64();
          e3.setNumHistogramIntervals(r3);
          break;
        case 3:
          r3 = t3.readBool();
          e3.setEnableInputOutputLatency(r3);
          break;
        case 4:
          r3 = t3.readBool();
          e3.setEnableProfiler(r3);
          break;
        case 5:
          r3 = t3.readBool();
          e3.setEnableStreamLatency(r3);
          break;
        case 6:
          r3 = t3.readBool();
          e3.setUsePacketTimestampForAddedPacket(r3);
          break;
        case 7:
          r3 = t3.readInt64();
          e3.setTraceLogCapacity(r3);
          break;
        case 8:
          for (var o3 = t3.isDelimited() ? t3.readPackedInt32() : [t3.readInt32()], i4 = 0; i4 < o3.length; i4++)
            e3.addTraceEventTypesDisabled(o3[i4]);
          break;
        case 9:
          r3 = t3.readString();
          e3.setTraceLogPath(r3);
          break;
        case 10:
          r3 = t3.readInt32();
          e3.setTraceLogCount(r3);
          break;
        case 11:
          r3 = t3.readInt64();
          e3.setTraceLogIntervalUsec(r3);
          break;
        case 12:
          r3 = t3.readInt64();
          e3.setTraceLogMarginUsec(r3);
          break;
        case 13:
          r3 = t3.readBool();
          e3.setTraceLogDurationEvents(r3);
          break;
        case 14:
          r3 = t3.readInt32();
          e3.setTraceLogIntervalCount(r3);
          break;
        case 15:
          r3 = t3.readBool();
          e3.setTraceLogDisabled(r3);
          break;
        case 16:
          r3 = t3.readBool();
          e3.setTraceEnabled(r3);
          break;
        case 17:
          r3 = t3.readBool();
          e3.setTraceLogInstantEvents(r3);
          break;
        case 18:
          r3 = t3.readString();
          e3.setCalculatorFilter(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.ProfilerConfig.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.ProfilerConfig.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.ProfilerConfig.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    0 !== (r3 = e3.getHistogramIntervalSizeUsec()) && t3.writeInt64(1, r3), 0 !== (r3 = e3.getNumHistogramIntervals()) && t3.writeInt64(2, r3), (r3 = e3.getEnableInputOutputLatency()) && t3.writeBool(3, r3), (r3 = e3.getEnableProfiler()) && t3.writeBool(4, r3), (r3 = e3.getEnableStreamLatency()) && t3.writeBool(5, r3), (r3 = e3.getUsePacketTimestampForAddedPacket()) && t3.writeBool(6, r3), 0 !== (r3 = e3.getTraceLogCapacity()) && t3.writeInt64(7, r3), (r3 = e3.getTraceEventTypesDisabledList()).length > 0 && t3.writePackedInt32(8, r3), (r3 = e3.getTraceLogPath()).length > 0 && t3.writeString(9, r3), 0 !== (r3 = e3.getTraceLogCount()) && t3.writeInt32(10, r3), 0 !== (r3 = e3.getTraceLogIntervalUsec()) && t3.writeInt64(11, r3), 0 !== (r3 = e3.getTraceLogMarginUsec()) && t3.writeInt64(12, r3), (r3 = e3.getTraceLogDurationEvents()) && t3.writeBool(13, r3), 0 !== (r3 = e3.getTraceLogIntervalCount()) && t3.writeInt32(14, r3), (r3 = e3.getTraceLogDisabled()) && t3.writeBool(15, r3), (r3 = e3.getTraceEnabled()) && t3.writeBool(16, r3), (r3 = e3.getTraceLogInstantEvents()) && t3.writeBool(17, r3), (r3 = e3.getCalculatorFilter()).length > 0 && t3.writeString(18, r3);
  }, proto.mediapipe.ProfilerConfig.prototype.getHistogramIntervalSizeUsec = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.ProfilerConfig.prototype.setHistogramIntervalSizeUsec = function(e3) {
    return t2.Message.setProto3IntField(this, 1, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getNumHistogramIntervals = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.ProfilerConfig.prototype.setNumHistogramIntervals = function(e3) {
    return t2.Message.setProto3IntField(this, 2, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getEnableInputOutputLatency = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 3, false);
  }, proto.mediapipe.ProfilerConfig.prototype.setEnableInputOutputLatency = function(e3) {
    return t2.Message.setProto3BooleanField(this, 3, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getEnableProfiler = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 4, false);
  }, proto.mediapipe.ProfilerConfig.prototype.setEnableProfiler = function(e3) {
    return t2.Message.setProto3BooleanField(this, 4, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getEnableStreamLatency = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 5, false);
  }, proto.mediapipe.ProfilerConfig.prototype.setEnableStreamLatency = function(e3) {
    return t2.Message.setProto3BooleanField(this, 5, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getUsePacketTimestampForAddedPacket = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 6, false);
  }, proto.mediapipe.ProfilerConfig.prototype.setUsePacketTimestampForAddedPacket = function(e3) {
    return t2.Message.setProto3BooleanField(this, 6, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceLogCapacity = function() {
    return t2.Message.getFieldWithDefault(this, 7, 0);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceLogCapacity = function(e3) {
    return t2.Message.setProto3IntField(this, 7, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceEventTypesDisabledList = function() {
    return t2.Message.getRepeatedField(this, 8);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceEventTypesDisabledList = function(e3) {
    return t2.Message.setField(this, 8, e3 || []);
  }, proto.mediapipe.ProfilerConfig.prototype.addTraceEventTypesDisabled = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 8, e3, r3);
  }, proto.mediapipe.ProfilerConfig.prototype.clearTraceEventTypesDisabledList = function() {
    return this.setTraceEventTypesDisabledList([]);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceLogPath = function() {
    return t2.Message.getFieldWithDefault(this, 9, "");
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceLogPath = function(e3) {
    return t2.Message.setProto3StringField(this, 9, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceLogCount = function() {
    return t2.Message.getFieldWithDefault(this, 10, 0);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceLogCount = function(e3) {
    return t2.Message.setProto3IntField(this, 10, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceLogIntervalUsec = function() {
    return t2.Message.getFieldWithDefault(this, 11, 0);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceLogIntervalUsec = function(e3) {
    return t2.Message.setProto3IntField(this, 11, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceLogMarginUsec = function() {
    return t2.Message.getFieldWithDefault(this, 12, 0);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceLogMarginUsec = function(e3) {
    return t2.Message.setProto3IntField(this, 12, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceLogDurationEvents = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 13, false);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceLogDurationEvents = function(e3) {
    return t2.Message.setProto3BooleanField(this, 13, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceLogIntervalCount = function() {
    return t2.Message.getFieldWithDefault(this, 14, 0);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceLogIntervalCount = function(e3) {
    return t2.Message.setProto3IntField(this, 14, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceLogDisabled = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 15, false);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceLogDisabled = function(e3) {
    return t2.Message.setProto3BooleanField(this, 15, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceEnabled = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 16, false);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceEnabled = function(e3) {
    return t2.Message.setProto3BooleanField(this, 16, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getTraceLogInstantEvents = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 17, false);
  }, proto.mediapipe.ProfilerConfig.prototype.setTraceLogInstantEvents = function(e3) {
    return t2.Message.setProto3BooleanField(this, 17, e3);
  }, proto.mediapipe.ProfilerConfig.prototype.getCalculatorFilter = function() {
    return t2.Message.getFieldWithDefault(this, 18, "");
  }, proto.mediapipe.ProfilerConfig.prototype.setCalculatorFilter = function(e3) {
    return t2.Message.setProto3StringField(this, 18, e3);
  }, proto.mediapipe.CalculatorGraphConfig.repeatedFields_ = [1, 6, 7, 9, 10, 15, 16, 17, 14, 1002], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.CalculatorGraphConfig.prototype.toObject = function(e3) {
    return proto.mediapipe.CalculatorGraphConfig.toObject(e3, this);
  }, proto.mediapipe.CalculatorGraphConfig.toObject = function(e3, r3) {
    var o3, i4 = { nodeList: t2.Message.toObjectList(r3.getNodeList(), proto.mediapipe.CalculatorGraphConfig.Node.toObject, e3), packetFactoryList: t2.Message.toObjectList(r3.getPacketFactoryList(), s2.PacketFactoryConfig.toObject, e3), packetGeneratorList: t2.Message.toObjectList(r3.getPacketGeneratorList(), p.PacketGeneratorConfig.toObject, e3), numThreads: t2.Message.getFieldWithDefault(r3, 8, 0), statusHandlerList: t2.Message.toObjectList(r3.getStatusHandlerList(), d2.StatusHandlerConfig.toObject, e3), inputStreamList: null == (o3 = t2.Message.getRepeatedField(r3, 10)) ? void 0 : o3, outputStreamList: null == (o3 = t2.Message.getRepeatedField(r3, 15)) ? void 0 : o3, inputSidePacketList: null == (o3 = t2.Message.getRepeatedField(r3, 16)) ? void 0 : o3, outputSidePacketList: null == (o3 = t2.Message.getRepeatedField(r3, 17)) ? void 0 : o3, maxQueueSize: t2.Message.getFieldWithDefault(r3, 11, 0), reportDeadlock: t2.Message.getBooleanFieldWithDefault(r3, 21, false), inputStreamHandler: (o3 = r3.getInputStreamHandler()) && l2.InputStreamHandlerConfig.toObject(e3, o3), outputStreamHandler: (o3 = r3.getOutputStreamHandler()) && l2.OutputStreamHandlerConfig.toObject(e3, o3), executorList: t2.Message.toObjectList(r3.getExecutorList(), proto.mediapipe.ExecutorConfig.toObject, e3), profilerConfig: (o3 = r3.getProfilerConfig()) && proto.mediapipe.ProfilerConfig.toObject(e3, o3), pb_package: t2.Message.getFieldWithDefault(r3, 19, ""), type: t2.Message.getFieldWithDefault(r3, 20, ""), options: (o3 = r3.getOptions()) && n2.MediaPipeOptions.toObject(e3, o3), graphOptionsList: t2.Message.toObjectList(r3.getGraphOptionsList(), a3.Any.toObject, e3) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.CalculatorGraphConfig.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.CalculatorGraphConfig();
    return proto.mediapipe.CalculatorGraphConfig.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.CalculatorGraphConfig.Node();
          t3.readMessage(r3, proto.mediapipe.CalculatorGraphConfig.Node.deserializeBinaryFromReader), e3.addNode(r3);
          break;
        case 6:
          r3 = new s2.PacketFactoryConfig();
          t3.readMessage(r3, s2.PacketFactoryConfig.deserializeBinaryFromReader), e3.addPacketFactory(r3);
          break;
        case 7:
          r3 = new p.PacketGeneratorConfig();
          t3.readMessage(r3, p.PacketGeneratorConfig.deserializeBinaryFromReader), e3.addPacketGenerator(r3);
          break;
        case 8:
          r3 = t3.readInt32();
          e3.setNumThreads(r3);
          break;
        case 9:
          r3 = new d2.StatusHandlerConfig();
          t3.readMessage(r3, d2.StatusHandlerConfig.deserializeBinaryFromReader), e3.addStatusHandler(r3);
          break;
        case 10:
          r3 = t3.readString();
          e3.addInputStream(r3);
          break;
        case 15:
          r3 = t3.readString();
          e3.addOutputStream(r3);
          break;
        case 16:
          r3 = t3.readString();
          e3.addInputSidePacket(r3);
          break;
        case 17:
          r3 = t3.readString();
          e3.addOutputSidePacket(r3);
          break;
        case 11:
          r3 = t3.readInt32();
          e3.setMaxQueueSize(r3);
          break;
        case 21:
          r3 = t3.readBool();
          e3.setReportDeadlock(r3);
          break;
        case 12:
          r3 = new l2.InputStreamHandlerConfig();
          t3.readMessage(r3, l2.InputStreamHandlerConfig.deserializeBinaryFromReader), e3.setInputStreamHandler(r3);
          break;
        case 13:
          r3 = new l2.OutputStreamHandlerConfig();
          t3.readMessage(r3, l2.OutputStreamHandlerConfig.deserializeBinaryFromReader), e3.setOutputStreamHandler(r3);
          break;
        case 14:
          r3 = new proto.mediapipe.ExecutorConfig();
          t3.readMessage(r3, proto.mediapipe.ExecutorConfig.deserializeBinaryFromReader), e3.addExecutor(r3);
          break;
        case 18:
          r3 = new proto.mediapipe.ProfilerConfig();
          t3.readMessage(r3, proto.mediapipe.ProfilerConfig.deserializeBinaryFromReader), e3.setProfilerConfig(r3);
          break;
        case 19:
          r3 = t3.readString();
          e3.setPackage(r3);
          break;
        case 20:
          r3 = t3.readString();
          e3.setType(r3);
          break;
        case 1001:
          r3 = new n2.MediaPipeOptions();
          t3.readMessage(r3, n2.MediaPipeOptions.deserializeBinaryFromReader), e3.setOptions(r3);
          break;
        case 1002:
          r3 = new a3.Any();
          t3.readMessage(r3, a3.Any.deserializeBinaryFromReader), e3.addGraphOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.CalculatorGraphConfig.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.CalculatorGraphConfig.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.CalculatorGraphConfig.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    (r3 = e3.getNodeList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.CalculatorGraphConfig.Node.serializeBinaryToWriter), (r3 = e3.getPacketFactoryList()).length > 0 && t3.writeRepeatedMessage(6, r3, s2.PacketFactoryConfig.serializeBinaryToWriter), (r3 = e3.getPacketGeneratorList()).length > 0 && t3.writeRepeatedMessage(7, r3, p.PacketGeneratorConfig.serializeBinaryToWriter), 0 !== (r3 = e3.getNumThreads()) && t3.writeInt32(8, r3), (r3 = e3.getStatusHandlerList()).length > 0 && t3.writeRepeatedMessage(9, r3, d2.StatusHandlerConfig.serializeBinaryToWriter), (r3 = e3.getInputStreamList()).length > 0 && t3.writeRepeatedString(10, r3), (r3 = e3.getOutputStreamList()).length > 0 && t3.writeRepeatedString(15, r3), (r3 = e3.getInputSidePacketList()).length > 0 && t3.writeRepeatedString(16, r3), (r3 = e3.getOutputSidePacketList()).length > 0 && t3.writeRepeatedString(17, r3), 0 !== (r3 = e3.getMaxQueueSize()) && t3.writeInt32(11, r3), (r3 = e3.getReportDeadlock()) && t3.writeBool(21, r3), null != (r3 = e3.getInputStreamHandler()) && t3.writeMessage(12, r3, l2.InputStreamHandlerConfig.serializeBinaryToWriter), null != (r3 = e3.getOutputStreamHandler()) && t3.writeMessage(13, r3, l2.OutputStreamHandlerConfig.serializeBinaryToWriter), (r3 = e3.getExecutorList()).length > 0 && t3.writeRepeatedMessage(14, r3, proto.mediapipe.ExecutorConfig.serializeBinaryToWriter), null != (r3 = e3.getProfilerConfig()) && t3.writeMessage(18, r3, proto.mediapipe.ProfilerConfig.serializeBinaryToWriter), (r3 = e3.getPackage()).length > 0 && t3.writeString(19, r3), (r3 = e3.getType()).length > 0 && t3.writeString(20, r3), null != (r3 = e3.getOptions()) && t3.writeMessage(1001, r3, n2.MediaPipeOptions.serializeBinaryToWriter), (r3 = e3.getGraphOptionsList()).length > 0 && t3.writeRepeatedMessage(1002, r3, a3.Any.serializeBinaryToWriter);
  }, proto.mediapipe.CalculatorGraphConfig.Node.repeatedFields_ = [3, 4, 5, 6, 8, 13, 17, 1005], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.CalculatorGraphConfig.Node.prototype.toObject = function(e3) {
    return proto.mediapipe.CalculatorGraphConfig.Node.toObject(e3, this);
  }, proto.mediapipe.CalculatorGraphConfig.Node.toObject = function(e3, r3) {
    var o3, n3 = { name: t2.Message.getFieldWithDefault(r3, 1, ""), calculator: t2.Message.getFieldWithDefault(r3, 2, ""), inputStreamList: null == (o3 = t2.Message.getRepeatedField(r3, 3)) ? void 0 : o3, outputStreamList: null == (o3 = t2.Message.getRepeatedField(r3, 4)) ? void 0 : o3, inputSidePacketList: null == (o3 = t2.Message.getRepeatedField(r3, 5)) ? void 0 : o3, outputSidePacketList: null == (o3 = t2.Message.getRepeatedField(r3, 6)) ? void 0 : o3, options: (o3 = r3.getOptions()) && i3.CalculatorOptions.toObject(e3, o3), nodeOptionsList: t2.Message.toObjectList(r3.getNodeOptionsList(), a3.Any.toObject, e3), sourceLayer: t2.Message.getFieldWithDefault(r3, 9, 0), bufferSizeHint: t2.Message.getFieldWithDefault(r3, 10, 0), inputStreamHandler: (o3 = r3.getInputStreamHandler()) && l2.InputStreamHandlerConfig.toObject(e3, o3), outputStreamHandler: (o3 = r3.getOutputStreamHandler()) && l2.OutputStreamHandlerConfig.toObject(e3, o3), inputStreamInfoList: t2.Message.toObjectList(r3.getInputStreamInfoList(), proto.mediapipe.InputStreamInfo.toObject, e3), executor: t2.Message.getFieldWithDefault(r3, 14, ""), profilerConfig: (o3 = r3.getProfilerConfig()) && proto.mediapipe.ProfilerConfig.toObject(e3, o3), maxInFlight: t2.Message.getFieldWithDefault(r3, 16, 0), optionValueList: null == (o3 = t2.Message.getRepeatedField(r3, 17)) ? void 0 : o3, externalInputList: null == (o3 = t2.Message.getRepeatedField(r3, 1005)) ? void 0 : o3 };
    return e3 && (n3.$jspbMessageInstance = r3), n3;
  }), proto.mediapipe.CalculatorGraphConfig.Node.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.CalculatorGraphConfig.Node();
    return proto.mediapipe.CalculatorGraphConfig.Node.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setName(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setCalculator(r3);
          break;
        case 3:
          r3 = t3.readString();
          e3.addInputStream(r3);
          break;
        case 4:
          r3 = t3.readString();
          e3.addOutputStream(r3);
          break;
        case 5:
          r3 = t3.readString();
          e3.addInputSidePacket(r3);
          break;
        case 6:
          r3 = t3.readString();
          e3.addOutputSidePacket(r3);
          break;
        case 7:
          r3 = new i3.CalculatorOptions();
          t3.readMessage(r3, i3.CalculatorOptions.deserializeBinaryFromReader), e3.setOptions(r3);
          break;
        case 8:
          r3 = new a3.Any();
          t3.readMessage(r3, a3.Any.deserializeBinaryFromReader), e3.addNodeOptions(r3);
          break;
        case 9:
          r3 = t3.readInt32();
          e3.setSourceLayer(r3);
          break;
        case 10:
          r3 = t3.readInt32();
          e3.setBufferSizeHint(r3);
          break;
        case 11:
          r3 = new l2.InputStreamHandlerConfig();
          t3.readMessage(r3, l2.InputStreamHandlerConfig.deserializeBinaryFromReader), e3.setInputStreamHandler(r3);
          break;
        case 12:
          r3 = new l2.OutputStreamHandlerConfig();
          t3.readMessage(r3, l2.OutputStreamHandlerConfig.deserializeBinaryFromReader), e3.setOutputStreamHandler(r3);
          break;
        case 13:
          r3 = new proto.mediapipe.InputStreamInfo();
          t3.readMessage(r3, proto.mediapipe.InputStreamInfo.deserializeBinaryFromReader), e3.addInputStreamInfo(r3);
          break;
        case 14:
          r3 = t3.readString();
          e3.setExecutor(r3);
          break;
        case 15:
          r3 = new proto.mediapipe.ProfilerConfig();
          t3.readMessage(r3, proto.mediapipe.ProfilerConfig.deserializeBinaryFromReader), e3.setProfilerConfig(r3);
          break;
        case 16:
          r3 = t3.readInt32();
          e3.setMaxInFlight(r3);
          break;
        case 17:
          r3 = t3.readString();
          e3.addOptionValue(r3);
          break;
        case 1005:
          r3 = t3.readString();
          e3.addExternalInput(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.CalculatorGraphConfig.Node.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.CalculatorGraphConfig.Node.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    (r3 = e3.getName()).length > 0 && t3.writeString(1, r3), (r3 = e3.getCalculator()).length > 0 && t3.writeString(2, r3), (r3 = e3.getInputStreamList()).length > 0 && t3.writeRepeatedString(3, r3), (r3 = e3.getOutputStreamList()).length > 0 && t3.writeRepeatedString(4, r3), (r3 = e3.getInputSidePacketList()).length > 0 && t3.writeRepeatedString(5, r3), (r3 = e3.getOutputSidePacketList()).length > 0 && t3.writeRepeatedString(6, r3), null != (r3 = e3.getOptions()) && t3.writeMessage(7, r3, i3.CalculatorOptions.serializeBinaryToWriter), (r3 = e3.getNodeOptionsList()).length > 0 && t3.writeRepeatedMessage(8, r3, a3.Any.serializeBinaryToWriter), 0 !== (r3 = e3.getSourceLayer()) && t3.writeInt32(9, r3), 0 !== (r3 = e3.getBufferSizeHint()) && t3.writeInt32(10, r3), null != (r3 = e3.getInputStreamHandler()) && t3.writeMessage(11, r3, l2.InputStreamHandlerConfig.serializeBinaryToWriter), null != (r3 = e3.getOutputStreamHandler()) && t3.writeMessage(12, r3, l2.OutputStreamHandlerConfig.serializeBinaryToWriter), (r3 = e3.getInputStreamInfoList()).length > 0 && t3.writeRepeatedMessage(13, r3, proto.mediapipe.InputStreamInfo.serializeBinaryToWriter), (r3 = e3.getExecutor()).length > 0 && t3.writeString(14, r3), null != (r3 = e3.getProfilerConfig()) && t3.writeMessage(15, r3, proto.mediapipe.ProfilerConfig.serializeBinaryToWriter), 0 !== (r3 = e3.getMaxInFlight()) && t3.writeInt32(16, r3), (r3 = e3.getOptionValueList()).length > 0 && t3.writeRepeatedString(17, r3), (r3 = e3.getExternalInputList()).length > 0 && t3.writeRepeatedString(1005, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getName = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setName = function(e3) {
    return t2.Message.setProto3StringField(this, 1, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getCalculator = function() {
    return t2.Message.getFieldWithDefault(this, 2, "");
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setCalculator = function(e3) {
    return t2.Message.setProto3StringField(this, 2, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getInputStreamList = function() {
    return t2.Message.getRepeatedField(this, 3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setInputStreamList = function(e3) {
    return t2.Message.setField(this, 3, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.addInputStream = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 3, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearInputStreamList = function() {
    return this.setInputStreamList([]);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getOutputStreamList = function() {
    return t2.Message.getRepeatedField(this, 4);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setOutputStreamList = function(e3) {
    return t2.Message.setField(this, 4, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.addOutputStream = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 4, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearOutputStreamList = function() {
    return this.setOutputStreamList([]);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getInputSidePacketList = function() {
    return t2.Message.getRepeatedField(this, 5);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setInputSidePacketList = function(e3) {
    return t2.Message.setField(this, 5, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.addInputSidePacket = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 5, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearInputSidePacketList = function() {
    return this.setInputSidePacketList([]);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getOutputSidePacketList = function() {
    return t2.Message.getRepeatedField(this, 6);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setOutputSidePacketList = function(e3) {
    return t2.Message.setField(this, 6, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.addOutputSidePacket = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 6, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearOutputSidePacketList = function() {
    return this.setOutputSidePacketList([]);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getOptions = function() {
    return t2.Message.getWrapperField(this, i3.CalculatorOptions, 7);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setOptions = function(e3) {
    return t2.Message.setWrapperField(this, 7, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.hasOptions = function() {
    return null != t2.Message.getField(this, 7);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getNodeOptionsList = function() {
    return t2.Message.getRepeatedWrapperField(this, a3.Any, 8);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setNodeOptionsList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 8, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.addNodeOptions = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 8, e3, proto.google.protobuf.Any, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearNodeOptionsList = function() {
    return this.setNodeOptionsList([]);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getSourceLayer = function() {
    return t2.Message.getFieldWithDefault(this, 9, 0);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setSourceLayer = function(e3) {
    return t2.Message.setProto3IntField(this, 9, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getBufferSizeHint = function() {
    return t2.Message.getFieldWithDefault(this, 10, 0);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setBufferSizeHint = function(e3) {
    return t2.Message.setProto3IntField(this, 10, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getInputStreamHandler = function() {
    return t2.Message.getWrapperField(this, l2.InputStreamHandlerConfig, 11);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setInputStreamHandler = function(e3) {
    return t2.Message.setWrapperField(this, 11, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearInputStreamHandler = function() {
    return this.setInputStreamHandler(void 0);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.hasInputStreamHandler = function() {
    return null != t2.Message.getField(this, 11);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getOutputStreamHandler = function() {
    return t2.Message.getWrapperField(this, l2.OutputStreamHandlerConfig, 12);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setOutputStreamHandler = function(e3) {
    return t2.Message.setWrapperField(this, 12, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearOutputStreamHandler = function() {
    return this.setOutputStreamHandler(void 0);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.hasOutputStreamHandler = function() {
    return null != t2.Message.getField(this, 12);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getInputStreamInfoList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.InputStreamInfo, 13);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setInputStreamInfoList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 13, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.addInputStreamInfo = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 13, e3, proto.mediapipe.InputStreamInfo, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearInputStreamInfoList = function() {
    return this.setInputStreamInfoList([]);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getExecutor = function() {
    return t2.Message.getFieldWithDefault(this, 14, "");
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setExecutor = function(e3) {
    return t2.Message.setProto3StringField(this, 14, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getProfilerConfig = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.ProfilerConfig, 15);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setProfilerConfig = function(e3) {
    return t2.Message.setWrapperField(this, 15, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearProfilerConfig = function() {
    return this.setProfilerConfig(void 0);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.hasProfilerConfig = function() {
    return null != t2.Message.getField(this, 15);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getMaxInFlight = function() {
    return t2.Message.getFieldWithDefault(this, 16, 0);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setMaxInFlight = function(e3) {
    return t2.Message.setProto3IntField(this, 16, e3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getOptionValueList = function() {
    return t2.Message.getRepeatedField(this, 17);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setOptionValueList = function(e3) {
    return t2.Message.setField(this, 17, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.addOptionValue = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 17, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearOptionValueList = function() {
    return this.setOptionValueList([]);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.getExternalInputList = function() {
    return t2.Message.getRepeatedField(this, 1005);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.setExternalInputList = function(e3) {
    return t2.Message.setField(this, 1005, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.addExternalInput = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 1005, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.Node.prototype.clearExternalInputList = function() {
    return this.setExternalInputList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getNodeList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.CalculatorGraphConfig.Node, 1);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setNodeList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addNode = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.CalculatorGraphConfig.Node, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearNodeList = function() {
    return this.setNodeList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getPacketFactoryList = function() {
    return t2.Message.getRepeatedWrapperField(this, s2.PacketFactoryConfig, 6);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setPacketFactoryList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 6, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addPacketFactory = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 6, e3, proto.mediapipe.PacketFactoryConfig, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearPacketFactoryList = function() {
    return this.setPacketFactoryList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getPacketGeneratorList = function() {
    return t2.Message.getRepeatedWrapperField(this, p.PacketGeneratorConfig, 7);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setPacketGeneratorList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 7, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addPacketGenerator = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 7, e3, proto.mediapipe.PacketGeneratorConfig, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearPacketGeneratorList = function() {
    return this.setPacketGeneratorList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getNumThreads = function() {
    return t2.Message.getFieldWithDefault(this, 8, 0);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setNumThreads = function(e3) {
    return t2.Message.setProto3IntField(this, 8, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getStatusHandlerList = function() {
    return t2.Message.getRepeatedWrapperField(this, d2.StatusHandlerConfig, 9);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setStatusHandlerList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 9, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addStatusHandler = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 9, e3, proto.mediapipe.StatusHandlerConfig, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearStatusHandlerList = function() {
    return this.setStatusHandlerList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getInputStreamList = function() {
    return t2.Message.getRepeatedField(this, 10);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setInputStreamList = function(e3) {
    return t2.Message.setField(this, 10, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addInputStream = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 10, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearInputStreamList = function() {
    return this.setInputStreamList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getOutputStreamList = function() {
    return t2.Message.getRepeatedField(this, 15);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setOutputStreamList = function(e3) {
    return t2.Message.setField(this, 15, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addOutputStream = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 15, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearOutputStreamList = function() {
    return this.setOutputStreamList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getInputSidePacketList = function() {
    return t2.Message.getRepeatedField(this, 16);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setInputSidePacketList = function(e3) {
    return t2.Message.setField(this, 16, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addInputSidePacket = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 16, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearInputSidePacketList = function() {
    return this.setInputSidePacketList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getOutputSidePacketList = function() {
    return t2.Message.getRepeatedField(this, 17);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setOutputSidePacketList = function(e3) {
    return t2.Message.setField(this, 17, e3 || []);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addOutputSidePacket = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 17, e3, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearOutputSidePacketList = function() {
    return this.setOutputSidePacketList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getMaxQueueSize = function() {
    return t2.Message.getFieldWithDefault(this, 11, 0);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setMaxQueueSize = function(e3) {
    return t2.Message.setProto3IntField(this, 11, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getReportDeadlock = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 21, false);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setReportDeadlock = function(e3) {
    return t2.Message.setProto3BooleanField(this, 21, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getInputStreamHandler = function() {
    return t2.Message.getWrapperField(this, l2.InputStreamHandlerConfig, 12);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setInputStreamHandler = function(e3) {
    return t2.Message.setWrapperField(this, 12, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearInputStreamHandler = function() {
    return this.setInputStreamHandler(void 0);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.hasInputStreamHandler = function() {
    return null != t2.Message.getField(this, 12);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getOutputStreamHandler = function() {
    return t2.Message.getWrapperField(this, l2.OutputStreamHandlerConfig, 13);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setOutputStreamHandler = function(e3) {
    return t2.Message.setWrapperField(this, 13, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearOutputStreamHandler = function() {
    return this.setOutputStreamHandler(void 0);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.hasOutputStreamHandler = function() {
    return null != t2.Message.getField(this, 13);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getExecutorList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.ExecutorConfig, 14);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setExecutorList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 14, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addExecutor = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 14, e3, proto.mediapipe.ExecutorConfig, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearExecutorList = function() {
    return this.setExecutorList([]);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getProfilerConfig = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.ProfilerConfig, 18);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setProfilerConfig = function(e3) {
    return t2.Message.setWrapperField(this, 18, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearProfilerConfig = function() {
    return this.setProfilerConfig(void 0);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.hasProfilerConfig = function() {
    return null != t2.Message.getField(this, 18);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getPackage = function() {
    return t2.Message.getFieldWithDefault(this, 19, "");
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setPackage = function(e3) {
    return t2.Message.setProto3StringField(this, 19, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getType = function() {
    return t2.Message.getFieldWithDefault(this, 20, "");
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setType = function(e3) {
    return t2.Message.setProto3StringField(this, 20, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getOptions = function() {
    return t2.Message.getWrapperField(this, n2.MediaPipeOptions, 1001);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1001, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearOptions = function() {
    return this.setOptions(void 0);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.hasOptions = function() {
    return null != t2.Message.getField(this, 1001);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.getGraphOptionsList = function() {
    return t2.Message.getRepeatedWrapperField(this, a3.Any, 1002);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.setGraphOptionsList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1002, e3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.addGraphOptions = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1002, e3, proto.google.protobuf.Any, r3);
  }, proto.mediapipe.CalculatorGraphConfig.prototype.clearGraphOptionsList = function() {
    return this.setGraphOptionsList([]);
  }, r2.object.extend(e2, proto.mediapipe);
}(calculator_pb);
var detection_pb = {};
var location_data_pb = {};
var rasterization_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.Rasterization", null, o2), r2.exportSymbol("proto.mediapipe.Rasterization.Interval", null, o2), proto.mediapipe.Rasterization = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.Rasterization.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.Rasterization, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.Rasterization.displayName = "proto.mediapipe.Rasterization"), proto.mediapipe.Rasterization.Interval = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.Rasterization.Interval, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.Rasterization.Interval.displayName = "proto.mediapipe.Rasterization.Interval"), proto.mediapipe.Rasterization.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.Rasterization.prototype.toObject = function(e3) {
    return proto.mediapipe.Rasterization.toObject(e3, this);
  }, proto.mediapipe.Rasterization.toObject = function(e3, r3) {
    var o3 = { intervalList: t2.Message.toObjectList(r3.getIntervalList(), proto.mediapipe.Rasterization.Interval.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.Rasterization.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.Rasterization();
    return proto.mediapipe.Rasterization.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.Rasterization.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.Rasterization.Interval();
        t3.readMessage(r3, proto.mediapipe.Rasterization.Interval.deserializeBinaryFromReader), e3.addInterval(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.Rasterization.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.Rasterization.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.Rasterization.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getIntervalList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.Rasterization.Interval.serializeBinaryToWriter);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.Rasterization.Interval.prototype.toObject = function(e3) {
    return proto.mediapipe.Rasterization.Interval.toObject(e3, this);
  }, proto.mediapipe.Rasterization.Interval.toObject = function(e3, r3) {
    var o3, i3 = { y: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, leftX: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, rightX: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.Rasterization.Interval.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.Rasterization.Interval();
    return proto.mediapipe.Rasterization.Interval.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.Rasterization.Interval.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt32();
          e3.setY(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setLeftX(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setRightX(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.Rasterization.Interval.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.Rasterization.Interval.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.Rasterization.Interval.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3);
  }, proto.mediapipe.Rasterization.Interval.prototype.getY = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.Rasterization.Interval.prototype.setY = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.Rasterization.Interval.prototype.clearY = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.Rasterization.Interval.prototype.hasY = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.Rasterization.Interval.prototype.getLeftX = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.Rasterization.Interval.prototype.setLeftX = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.Rasterization.Interval.prototype.clearLeftX = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.Rasterization.Interval.prototype.hasLeftX = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.Rasterization.Interval.prototype.getRightX = function() {
    return t2.Message.getFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.Rasterization.Interval.prototype.setRightX = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.Rasterization.Interval.prototype.clearRightX = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.Rasterization.Interval.prototype.hasRightX = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.Rasterization.prototype.getIntervalList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.Rasterization.Interval, 1);
  }, proto.mediapipe.Rasterization.prototype.setIntervalList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.Rasterization.prototype.addInterval = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.Rasterization.Interval, r3);
  }, proto.mediapipe.Rasterization.prototype.clearIntervalList = function() {
    return this.setIntervalList([]);
  }, r2.object.extend(e2, proto.mediapipe);
}(rasterization_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = rasterization_pb;
  r2.object.extend(proto, i3), r2.exportSymbol("proto.mediapipe.LocationData", null, o2), r2.exportSymbol("proto.mediapipe.LocationData.BinaryMask", null, o2), r2.exportSymbol("proto.mediapipe.LocationData.BoundingBox", null, o2), r2.exportSymbol("proto.mediapipe.LocationData.Format", null, o2), r2.exportSymbol("proto.mediapipe.LocationData.RelativeBoundingBox", null, o2), r2.exportSymbol("proto.mediapipe.LocationData.RelativeKeypoint", null, o2), proto.mediapipe.LocationData = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.LocationData.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.LocationData, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.LocationData.displayName = "proto.mediapipe.LocationData"), proto.mediapipe.LocationData.BoundingBox = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.LocationData.BoundingBox, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.LocationData.BoundingBox.displayName = "proto.mediapipe.LocationData.BoundingBox"), proto.mediapipe.LocationData.RelativeBoundingBox = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.LocationData.RelativeBoundingBox, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.LocationData.RelativeBoundingBox.displayName = "proto.mediapipe.LocationData.RelativeBoundingBox"), proto.mediapipe.LocationData.BinaryMask = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.LocationData.BinaryMask, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.LocationData.BinaryMask.displayName = "proto.mediapipe.LocationData.BinaryMask"), proto.mediapipe.LocationData.RelativeKeypoint = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.LocationData.RelativeKeypoint, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.LocationData.RelativeKeypoint.displayName = "proto.mediapipe.LocationData.RelativeKeypoint"), proto.mediapipe.LocationData.repeatedFields_ = [5], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.LocationData.prototype.toObject = function(e3) {
    return proto.mediapipe.LocationData.toObject(e3, this);
  }, proto.mediapipe.LocationData.toObject = function(e3, r3) {
    var o3, i4 = { format: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, boundingBox: (o3 = r3.getBoundingBox()) && proto.mediapipe.LocationData.BoundingBox.toObject(e3, o3), relativeBoundingBox: (o3 = r3.getRelativeBoundingBox()) && proto.mediapipe.LocationData.RelativeBoundingBox.toObject(e3, o3), mask: (o3 = r3.getMask()) && proto.mediapipe.LocationData.BinaryMask.toObject(e3, o3), relativeKeypointsList: t2.Message.toObjectList(r3.getRelativeKeypointsList(), proto.mediapipe.LocationData.RelativeKeypoint.toObject, e3) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.LocationData.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.LocationData();
    return proto.mediapipe.LocationData.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.LocationData.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readEnum();
          e3.setFormat(r3);
          break;
        case 2:
          r3 = new proto.mediapipe.LocationData.BoundingBox();
          t3.readMessage(r3, proto.mediapipe.LocationData.BoundingBox.deserializeBinaryFromReader), e3.setBoundingBox(r3);
          break;
        case 3:
          r3 = new proto.mediapipe.LocationData.RelativeBoundingBox();
          t3.readMessage(r3, proto.mediapipe.LocationData.RelativeBoundingBox.deserializeBinaryFromReader), e3.setRelativeBoundingBox(r3);
          break;
        case 4:
          r3 = new proto.mediapipe.LocationData.BinaryMask();
          t3.readMessage(r3, proto.mediapipe.LocationData.BinaryMask.deserializeBinaryFromReader), e3.setMask(r3);
          break;
        case 5:
          r3 = new proto.mediapipe.LocationData.RelativeKeypoint();
          t3.readMessage(r3, proto.mediapipe.LocationData.RelativeKeypoint.deserializeBinaryFromReader), e3.addRelativeKeypoints(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.LocationData.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.LocationData.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.LocationData.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeEnum(1, o3), null != (o3 = e3.getBoundingBox()) && r3.writeMessage(2, o3, proto.mediapipe.LocationData.BoundingBox.serializeBinaryToWriter), null != (o3 = e3.getRelativeBoundingBox()) && r3.writeMessage(3, o3, proto.mediapipe.LocationData.RelativeBoundingBox.serializeBinaryToWriter), null != (o3 = e3.getMask()) && r3.writeMessage(4, o3, proto.mediapipe.LocationData.BinaryMask.serializeBinaryToWriter), (o3 = e3.getRelativeKeypointsList()).length > 0 && r3.writeRepeatedMessage(5, o3, proto.mediapipe.LocationData.RelativeKeypoint.serializeBinaryToWriter);
  }, proto.mediapipe.LocationData.Format = { GLOBAL: 0, BOUNDING_BOX: 1, RELATIVE_BOUNDING_BOX: 2, MASK: 3 }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.LocationData.BoundingBox.prototype.toObject = function(e3) {
    return proto.mediapipe.LocationData.BoundingBox.toObject(e3, this);
  }, proto.mediapipe.LocationData.BoundingBox.toObject = function(e3, r3) {
    var o3, i4 = { xmin: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, ymin: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, width: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3, height: null == (o3 = t2.Message.getField(r3, 4)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.LocationData.BoundingBox.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.LocationData.BoundingBox();
    return proto.mediapipe.LocationData.BoundingBox.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.LocationData.BoundingBox.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt32();
          e3.setXmin(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setYmin(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setWidth(r3);
          break;
        case 4:
          r3 = t3.readInt32();
          e3.setHeight(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.LocationData.BoundingBox.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.LocationData.BoundingBox.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.LocationData.BoundingBox.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeInt32(4, o3);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.getXmin = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.setXmin = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.clearXmin = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.hasXmin = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.getYmin = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.setYmin = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.clearYmin = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.hasYmin = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.getWidth = function() {
    return t2.Message.getFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.setWidth = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.clearWidth = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.hasWidth = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.getHeight = function() {
    return t2.Message.getFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.setHeight = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.clearHeight = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.LocationData.BoundingBox.prototype.hasHeight = function() {
    return null != t2.Message.getField(this, 4);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.LocationData.RelativeBoundingBox.prototype.toObject = function(e3) {
    return proto.mediapipe.LocationData.RelativeBoundingBox.toObject(e3, this);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.toObject = function(e3, r3) {
    var o3, i4 = { xmin: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, ymin: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, width: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, height: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.LocationData.RelativeBoundingBox.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.LocationData.RelativeBoundingBox();
    return proto.mediapipe.LocationData.RelativeBoundingBox.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readFloat();
          e3.setXmin(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setYmin(r3);
          break;
        case 3:
          r3 = t3.readFloat();
          e3.setWidth(r3);
          break;
        case 4:
          r3 = t3.readFloat();
          e3.setHeight(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.LocationData.RelativeBoundingBox.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.LocationData.RelativeBoundingBox.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeFloat(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeFloat(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeFloat(4, o3);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.getXmin = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.setXmin = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.clearXmin = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.hasXmin = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.getYmin = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.setYmin = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.clearYmin = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.hasYmin = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.getWidth = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.setWidth = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.clearWidth = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.hasWidth = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.getHeight = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.setHeight = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.clearHeight = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.LocationData.RelativeBoundingBox.prototype.hasHeight = function() {
    return null != t2.Message.getField(this, 4);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.LocationData.BinaryMask.prototype.toObject = function(e3) {
    return proto.mediapipe.LocationData.BinaryMask.toObject(e3, this);
  }, proto.mediapipe.LocationData.BinaryMask.toObject = function(e3, r3) {
    var o3, a3 = { width: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, height: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, rasterization: (o3 = r3.getRasterization()) && i3.Rasterization.toObject(e3, o3) };
    return e3 && (a3.$jspbMessageInstance = r3), a3;
  }), proto.mediapipe.LocationData.BinaryMask.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.LocationData.BinaryMask();
    return proto.mediapipe.LocationData.BinaryMask.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.LocationData.BinaryMask.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt32();
          e3.setWidth(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setHeight(r3);
          break;
        case 3:
          r3 = new i3.Rasterization();
          t3.readMessage(r3, i3.Rasterization.deserializeBinaryFromReader), e3.setRasterization(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.LocationData.BinaryMask.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.LocationData.BinaryMask.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.LocationData.BinaryMask.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), null != (o3 = e3.getRasterization()) && r3.writeMessage(3, o3, i3.Rasterization.serializeBinaryToWriter);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.getWidth = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.setWidth = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.clearWidth = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.hasWidth = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.getHeight = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.setHeight = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.clearHeight = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.hasHeight = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.getRasterization = function() {
    return t2.Message.getWrapperField(this, i3.Rasterization, 3);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.setRasterization = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.clearRasterization = function() {
    return this.setRasterization(void 0);
  }, proto.mediapipe.LocationData.BinaryMask.prototype.hasRasterization = function() {
    return null != t2.Message.getField(this, 3);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.LocationData.RelativeKeypoint.prototype.toObject = function(e3) {
    return proto.mediapipe.LocationData.RelativeKeypoint.toObject(e3, this);
  }, proto.mediapipe.LocationData.RelativeKeypoint.toObject = function(e3, r3) {
    var o3, i4 = { x: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, y: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, keypointLabel: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3, score: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.LocationData.RelativeKeypoint.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.LocationData.RelativeKeypoint();
    return proto.mediapipe.LocationData.RelativeKeypoint.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.LocationData.RelativeKeypoint.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readFloat();
          e3.setX(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setY(r3);
          break;
        case 3:
          r3 = t3.readString();
          e3.setKeypointLabel(r3);
          break;
        case 4:
          r3 = t3.readFloat();
          e3.setScore(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.LocationData.RelativeKeypoint.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.LocationData.RelativeKeypoint.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeFloat(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeString(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeFloat(4, o3);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.getX = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.setX = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.clearX = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.hasX = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.getY = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.setY = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.clearY = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.hasY = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.getKeypointLabel = function() {
    return t2.Message.getFieldWithDefault(this, 3, "");
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.setKeypointLabel = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.clearKeypointLabel = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.hasKeypointLabel = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.getScore = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.setScore = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.clearScore = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.LocationData.RelativeKeypoint.prototype.hasScore = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.LocationData.prototype.getFormat = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.LocationData.prototype.setFormat = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.LocationData.prototype.clearFormat = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.LocationData.prototype.hasFormat = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.LocationData.prototype.getBoundingBox = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.LocationData.BoundingBox, 2);
  }, proto.mediapipe.LocationData.prototype.setBoundingBox = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.LocationData.prototype.clearBoundingBox = function() {
    return this.setBoundingBox(void 0);
  }, proto.mediapipe.LocationData.prototype.hasBoundingBox = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.LocationData.prototype.getRelativeBoundingBox = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.LocationData.RelativeBoundingBox, 3);
  }, proto.mediapipe.LocationData.prototype.setRelativeBoundingBox = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.LocationData.prototype.clearRelativeBoundingBox = function() {
    return this.setRelativeBoundingBox(void 0);
  }, proto.mediapipe.LocationData.prototype.hasRelativeBoundingBox = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.LocationData.prototype.getMask = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.LocationData.BinaryMask, 4);
  }, proto.mediapipe.LocationData.prototype.setMask = function(e3) {
    return t2.Message.setWrapperField(this, 4, e3);
  }, proto.mediapipe.LocationData.prototype.clearMask = function() {
    return this.setMask(void 0);
  }, proto.mediapipe.LocationData.prototype.hasMask = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.LocationData.prototype.getRelativeKeypointsList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.LocationData.RelativeKeypoint, 5);
  }, proto.mediapipe.LocationData.prototype.setRelativeKeypointsList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 5, e3);
  }, proto.mediapipe.LocationData.prototype.addRelativeKeypoints = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 5, e3, proto.mediapipe.LocationData.RelativeKeypoint, r3);
  }, proto.mediapipe.LocationData.prototype.clearRelativeKeypointsList = function() {
    return this.setRelativeKeypointsList([]);
  }, r2.object.extend(e2, proto.mediapipe);
}(location_data_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = location_data_pb;
  r2.object.extend(proto, i3), r2.exportSymbol("proto.mediapipe.Detection", null, o2), r2.exportSymbol("proto.mediapipe.Detection.AssociatedDetection", null, o2), r2.exportSymbol("proto.mediapipe.DetectionList", null, o2), proto.mediapipe.Detection = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.Detection.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.Detection, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.Detection.displayName = "proto.mediapipe.Detection"), proto.mediapipe.Detection.AssociatedDetection = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.Detection.AssociatedDetection, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.Detection.AssociatedDetection.displayName = "proto.mediapipe.Detection.AssociatedDetection"), proto.mediapipe.DetectionList = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.DetectionList.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.DetectionList, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.DetectionList.displayName = "proto.mediapipe.DetectionList"), proto.mediapipe.Detection.repeatedFields_ = [1, 2, 3, 8, 9], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.Detection.prototype.toObject = function(e3) {
    return proto.mediapipe.Detection.toObject(e3, this);
  }, proto.mediapipe.Detection.toObject = function(e3, r3) {
    var o3, a3 = { labelList: null == (o3 = t2.Message.getRepeatedField(r3, 1)) ? void 0 : o3, labelIdList: null == (o3 = t2.Message.getRepeatedField(r3, 2)) ? void 0 : o3, scoreList: null == (o3 = t2.Message.getRepeatedFloatingPointField(r3, 3)) ? void 0 : o3, locationData: (o3 = r3.getLocationData()) && i3.LocationData.toObject(e3, o3), featureTag: null == (o3 = t2.Message.getField(r3, 5)) ? void 0 : o3, trackId: null == (o3 = t2.Message.getField(r3, 6)) ? void 0 : o3, detectionId: null == (o3 = t2.Message.getField(r3, 7)) ? void 0 : o3, associatedDetectionsList: t2.Message.toObjectList(r3.getAssociatedDetectionsList(), proto.mediapipe.Detection.AssociatedDetection.toObject, e3), displayNameList: null == (o3 = t2.Message.getRepeatedField(r3, 9)) ? void 0 : o3, timestampUsec: null == (o3 = t2.Message.getField(r3, 10)) ? void 0 : o3 };
    return e3 && (a3.$jspbMessageInstance = r3), a3;
  }), proto.mediapipe.Detection.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.Detection();
    return proto.mediapipe.Detection.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.Detection.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.addLabel(r3);
          break;
        case 2:
          for (var o3 = t3.isDelimited() ? t3.readPackedInt32() : [t3.readInt32()], a3 = 0; a3 < o3.length; a3++)
            e3.addLabelId(o3[a3]);
          break;
        case 3:
          for (o3 = t3.isDelimited() ? t3.readPackedFloat() : [t3.readFloat()], a3 = 0; a3 < o3.length; a3++)
            e3.addScore(o3[a3]);
          break;
        case 4:
          r3 = new i3.LocationData();
          t3.readMessage(r3, i3.LocationData.deserializeBinaryFromReader), e3.setLocationData(r3);
          break;
        case 5:
          r3 = t3.readString();
          e3.setFeatureTag(r3);
          break;
        case 6:
          r3 = t3.readString();
          e3.setTrackId(r3);
          break;
        case 7:
          r3 = t3.readInt64();
          e3.setDetectionId(r3);
          break;
        case 8:
          r3 = new proto.mediapipe.Detection.AssociatedDetection();
          t3.readMessage(r3, proto.mediapipe.Detection.AssociatedDetection.deserializeBinaryFromReader), e3.addAssociatedDetections(r3);
          break;
        case 9:
          r3 = t3.readString();
          e3.addDisplayName(r3);
          break;
        case 10:
          r3 = t3.readInt64();
          e3.setTimestampUsec(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.Detection.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.Detection.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.Detection.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    (o3 = e3.getLabelList()).length > 0 && r3.writeRepeatedString(1, o3), (o3 = e3.getLabelIdList()).length > 0 && r3.writePackedInt32(2, o3), (o3 = e3.getScoreList()).length > 0 && r3.writePackedFloat(3, o3), null != (o3 = e3.getLocationData()) && r3.writeMessage(4, o3, i3.LocationData.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeString(5, o3), null != (o3 = t2.Message.getField(e3, 6)) && r3.writeString(6, o3), null != (o3 = t2.Message.getField(e3, 7)) && r3.writeInt64(7, o3), (o3 = e3.getAssociatedDetectionsList()).length > 0 && r3.writeRepeatedMessage(8, o3, proto.mediapipe.Detection.AssociatedDetection.serializeBinaryToWriter), (o3 = e3.getDisplayNameList()).length > 0 && r3.writeRepeatedString(9, o3), null != (o3 = t2.Message.getField(e3, 10)) && r3.writeInt64(10, o3);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.Detection.AssociatedDetection.prototype.toObject = function(e3) {
    return proto.mediapipe.Detection.AssociatedDetection.toObject(e3, this);
  }, proto.mediapipe.Detection.AssociatedDetection.toObject = function(e3, r3) {
    var o3, i4 = { id: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, confidence: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.Detection.AssociatedDetection.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.Detection.AssociatedDetection();
    return proto.mediapipe.Detection.AssociatedDetection.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.Detection.AssociatedDetection.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt32();
          e3.setId(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setConfidence(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.Detection.AssociatedDetection.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.Detection.AssociatedDetection.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.Detection.AssociatedDetection.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3);
  }, proto.mediapipe.Detection.AssociatedDetection.prototype.getId = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.Detection.AssociatedDetection.prototype.setId = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.Detection.AssociatedDetection.prototype.clearId = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.Detection.AssociatedDetection.prototype.hasId = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.Detection.AssociatedDetection.prototype.getConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.Detection.AssociatedDetection.prototype.setConfidence = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.Detection.AssociatedDetection.prototype.clearConfidence = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.Detection.AssociatedDetection.prototype.hasConfidence = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.Detection.prototype.getLabelList = function() {
    return t2.Message.getRepeatedField(this, 1);
  }, proto.mediapipe.Detection.prototype.setLabelList = function(e3) {
    return t2.Message.setField(this, 1, e3 || []);
  }, proto.mediapipe.Detection.prototype.addLabel = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 1, e3, r3);
  }, proto.mediapipe.Detection.prototype.clearLabelList = function() {
    return this.setLabelList([]);
  }, proto.mediapipe.Detection.prototype.getLabelIdList = function() {
    return t2.Message.getRepeatedField(this, 2);
  }, proto.mediapipe.Detection.prototype.setLabelIdList = function(e3) {
    return t2.Message.setField(this, 2, e3 || []);
  }, proto.mediapipe.Detection.prototype.addLabelId = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 2, e3, r3);
  }, proto.mediapipe.Detection.prototype.clearLabelIdList = function() {
    return this.setLabelIdList([]);
  }, proto.mediapipe.Detection.prototype.getScoreList = function() {
    return t2.Message.getRepeatedFloatingPointField(this, 3);
  }, proto.mediapipe.Detection.prototype.setScoreList = function(e3) {
    return t2.Message.setField(this, 3, e3 || []);
  }, proto.mediapipe.Detection.prototype.addScore = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 3, e3, r3);
  }, proto.mediapipe.Detection.prototype.clearScoreList = function() {
    return this.setScoreList([]);
  }, proto.mediapipe.Detection.prototype.getLocationData = function() {
    return t2.Message.getWrapperField(this, i3.LocationData, 4);
  }, proto.mediapipe.Detection.prototype.setLocationData = function(e3) {
    return t2.Message.setWrapperField(this, 4, e3);
  }, proto.mediapipe.Detection.prototype.clearLocationData = function() {
    return this.setLocationData(void 0);
  }, proto.mediapipe.Detection.prototype.hasLocationData = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.Detection.prototype.getFeatureTag = function() {
    return t2.Message.getFieldWithDefault(this, 5, "");
  }, proto.mediapipe.Detection.prototype.setFeatureTag = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.Detection.prototype.clearFeatureTag = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.Detection.prototype.hasFeatureTag = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.Detection.prototype.getTrackId = function() {
    return t2.Message.getFieldWithDefault(this, 6, "");
  }, proto.mediapipe.Detection.prototype.setTrackId = function(e3) {
    return t2.Message.setField(this, 6, e3);
  }, proto.mediapipe.Detection.prototype.clearTrackId = function() {
    return t2.Message.setField(this, 6, void 0);
  }, proto.mediapipe.Detection.prototype.hasTrackId = function() {
    return null != t2.Message.getField(this, 6);
  }, proto.mediapipe.Detection.prototype.getDetectionId = function() {
    return t2.Message.getFieldWithDefault(this, 7, 0);
  }, proto.mediapipe.Detection.prototype.setDetectionId = function(e3) {
    return t2.Message.setField(this, 7, e3);
  }, proto.mediapipe.Detection.prototype.clearDetectionId = function() {
    return t2.Message.setField(this, 7, void 0);
  }, proto.mediapipe.Detection.prototype.hasDetectionId = function() {
    return null != t2.Message.getField(this, 7);
  }, proto.mediapipe.Detection.prototype.getAssociatedDetectionsList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.Detection.AssociatedDetection, 8);
  }, proto.mediapipe.Detection.prototype.setAssociatedDetectionsList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 8, e3);
  }, proto.mediapipe.Detection.prototype.addAssociatedDetections = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 8, e3, proto.mediapipe.Detection.AssociatedDetection, r3);
  }, proto.mediapipe.Detection.prototype.clearAssociatedDetectionsList = function() {
    return this.setAssociatedDetectionsList([]);
  }, proto.mediapipe.Detection.prototype.getDisplayNameList = function() {
    return t2.Message.getRepeatedField(this, 9);
  }, proto.mediapipe.Detection.prototype.setDisplayNameList = function(e3) {
    return t2.Message.setField(this, 9, e3 || []);
  }, proto.mediapipe.Detection.prototype.addDisplayName = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 9, e3, r3);
  }, proto.mediapipe.Detection.prototype.clearDisplayNameList = function() {
    return this.setDisplayNameList([]);
  }, proto.mediapipe.Detection.prototype.getTimestampUsec = function() {
    return t2.Message.getFieldWithDefault(this, 10, 0);
  }, proto.mediapipe.Detection.prototype.setTimestampUsec = function(e3) {
    return t2.Message.setField(this, 10, e3);
  }, proto.mediapipe.Detection.prototype.clearTimestampUsec = function() {
    return t2.Message.setField(this, 10, void 0);
  }, proto.mediapipe.Detection.prototype.hasTimestampUsec = function() {
    return null != t2.Message.getField(this, 10);
  }, proto.mediapipe.DetectionList.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.DetectionList.prototype.toObject = function(e3) {
    return proto.mediapipe.DetectionList.toObject(e3, this);
  }, proto.mediapipe.DetectionList.toObject = function(e3, r3) {
    var o3 = { detectionList: t2.Message.toObjectList(r3.getDetectionList(), proto.mediapipe.Detection.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.DetectionList.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.DetectionList();
    return proto.mediapipe.DetectionList.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.DetectionList.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.Detection();
        t3.readMessage(r3, proto.mediapipe.Detection.deserializeBinaryFromReader), e3.addDetection(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.DetectionList.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.DetectionList.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.DetectionList.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getDetectionList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.Detection.serializeBinaryToWriter);
  }, proto.mediapipe.DetectionList.prototype.getDetectionList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.Detection, 1);
  }, proto.mediapipe.DetectionList.prototype.setDetectionList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.DetectionList.prototype.addDetection = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.Detection, r3);
  }, proto.mediapipe.DetectionList.prototype.clearDetectionList = function() {
    return this.setDetectionList([]);
  }, r2.object.extend(e2, proto.mediapipe);
}(detection_pb);
var base_options_pb = {};
var acceleration_pb = {};
var inference_calculator_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3), r2.exportSymbol("proto.mediapipe.InferenceCalculatorOptions", null, o2), r2.exportSymbol("proto.mediapipe.InferenceCalculatorOptions.Delegate", null, o2), r2.exportSymbol("proto.mediapipe.InferenceCalculatorOptions.Delegate.DelegateCase", null, o2), r2.exportSymbol("proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu", null, o2), r2.exportSymbol("proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.Api", null, o2), r2.exportSymbol("proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.InferenceUsage", null, o2), r2.exportSymbol("proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi", null, o2), r2.exportSymbol("proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite", null, o2), r2.exportSymbol("proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack", null, o2), proto.mediapipe.InferenceCalculatorOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.InferenceCalculatorOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InferenceCalculatorOptions.displayName = "proto.mediapipe.InferenceCalculatorOptions"), proto.mediapipe.InferenceCalculatorOptions.Delegate = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, proto.mediapipe.InferenceCalculatorOptions.Delegate.oneofGroups_);
  }, r2.inherits(proto.mediapipe.InferenceCalculatorOptions.Delegate, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InferenceCalculatorOptions.Delegate.displayName = "proto.mediapipe.InferenceCalculatorOptions.Delegate"), proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.displayName = "proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite"), proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.displayName = "proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu"), proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.displayName = "proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi"), proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.displayName = "proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InferenceCalculatorOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.InferenceCalculatorOptions.toObject(e3, this);
  }, proto.mediapipe.InferenceCalculatorOptions.toObject = function(e3, r3) {
    var o3, i4 = { modelPath: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, useGpu: t2.Message.getBooleanFieldWithDefault(r3, 2, false), useNnapi: t2.Message.getBooleanFieldWithDefault(r3, 3, false), cpuNumThread: t2.Message.getFieldWithDefault(r3, 4, -1), delegate: (o3 = r3.getDelegate()) && proto.mediapipe.InferenceCalculatorOptions.Delegate.toObject(e3, o3) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.InferenceCalculatorOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InferenceCalculatorOptions();
    return proto.mediapipe.InferenceCalculatorOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InferenceCalculatorOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setModelPath(r3);
          break;
        case 2:
          r3 = t3.readBool();
          e3.setUseGpu(r3);
          break;
        case 3:
          r3 = t3.readBool();
          e3.setUseNnapi(r3);
          break;
        case 4:
          r3 = t3.readInt32();
          e3.setCpuNumThread(r3);
          break;
        case 5:
          r3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate();
          t3.readMessage(r3, proto.mediapipe.InferenceCalculatorOptions.Delegate.deserializeBinaryFromReader), e3.setDelegate(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InferenceCalculatorOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InferenceCalculatorOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeBool(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeBool(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeInt32(4, o3), null != (o3 = e3.getDelegate()) && r3.writeMessage(5, o3, proto.mediapipe.InferenceCalculatorOptions.Delegate.serializeBinaryToWriter);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.oneofGroups_ = [[1, 2, 3, 4]], proto.mediapipe.InferenceCalculatorOptions.Delegate.DelegateCase = { DELEGATE_NOT_SET: 0, TFLITE: 1, GPU: 2, NNAPI: 3, XNNPACK: 4 }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.getDelegateCase = function() {
    return t2.Message.computeOneofCase(this, proto.mediapipe.InferenceCalculatorOptions.Delegate.oneofGroups_[0]);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.toObject = function(e3) {
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.toObject(e3, this);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.toObject = function(e3, t3) {
    var r3, o3 = { tflite: (r3 = t3.getTflite()) && proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.toObject(e3, r3), gpu: (r3 = t3.getGpu()) && proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.toObject(e3, r3), nnapi: (r3 = t3.getNnapi()) && proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.toObject(e3, r3), xnnpack: (r3 = t3.getXnnpack()) && proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.InferenceCalculatorOptions.Delegate.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite();
          t3.readMessage(r3, proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.deserializeBinaryFromReader), e3.setTflite(r3);
          break;
        case 2:
          r3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu();
          t3.readMessage(r3, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.deserializeBinaryFromReader), e3.setGpu(r3);
          break;
        case 3:
          r3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi();
          t3.readMessage(r3, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.deserializeBinaryFromReader), e3.setNnapi(r3);
          break;
        case 4:
          r3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack();
          t3.readMessage(r3, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.deserializeBinaryFromReader), e3.setXnnpack(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getTflite()) && t3.writeMessage(1, r3, proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.serializeBinaryToWriter), null != (r3 = e3.getGpu()) && t3.writeMessage(2, r3, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.serializeBinaryToWriter), null != (r3 = e3.getNnapi()) && t3.writeMessage(3, r3, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.serializeBinaryToWriter), null != (r3 = e3.getXnnpack()) && t3.writeMessage(4, r3, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.serializeBinaryToWriter);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.prototype.toObject = function(e3) {
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.toObject(e3, this);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.toObject = function(e3, t3) {
    var r3 = {};
    return e3 && (r3.$jspbMessageInstance = t3), r3;
  }), proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      t3.getFieldNumber();
      t3.skipField();
    }
    return e3;
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite.serializeBinaryToWriter = function(e3, t3) {
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.toObject = function(e3) {
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.toObject(e3, this);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.toObject = function(e3, r3) {
    var o3, i4 = { useAdvancedGpuApi: t2.Message.getBooleanFieldWithDefault(r3, 1, false), api: t2.Message.getFieldWithDefault(r3, 4, 0), allowPrecisionLoss: t2.Message.getBooleanFieldWithDefault(r3, 3, true), cachedKernelPath: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, serializedModelDir: null == (o3 = t2.Message.getField(r3, 7)) ? void 0 : o3, modelToken: null == (o3 = t2.Message.getField(r3, 8)) ? void 0 : o3, usage: t2.Message.getFieldWithDefault(r3, 5, 2) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readBool();
          e3.setUseAdvancedGpuApi(r3);
          break;
        case 4:
          r3 = t3.readEnum();
          e3.setApi(r3);
          break;
        case 3:
          r3 = t3.readBool();
          e3.setAllowPrecisionLoss(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setCachedKernelPath(r3);
          break;
        case 7:
          r3 = t3.readString();
          e3.setSerializedModelDir(r3);
          break;
        case 8:
          r3 = t3.readString();
          e3.setModelToken(r3);
          break;
        case 5:
          r3 = t3.readEnum();
          e3.setUsage(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeBool(1, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeEnum(4, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeBool(3, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeString(2, o3), null != (o3 = t2.Message.getField(e3, 7)) && r3.writeString(7, o3), null != (o3 = t2.Message.getField(e3, 8)) && r3.writeString(8, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeEnum(5, o3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.Api = { ANY: 0, OPENGL: 1, OPENCL: 2 }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.InferenceUsage = { UNSPECIFIED: 0, FAST_SINGLE_ANSWER: 1, SUSTAINED_SPEED: 2 }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.getUseAdvancedGpuApi = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 1, false);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.setUseAdvancedGpuApi = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.clearUseAdvancedGpuApi = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.hasUseAdvancedGpuApi = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.getApi = function() {
    return t2.Message.getFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.setApi = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.clearApi = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.hasApi = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.getAllowPrecisionLoss = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 3, true);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.setAllowPrecisionLoss = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.clearAllowPrecisionLoss = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.hasAllowPrecisionLoss = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.getCachedKernelPath = function() {
    return t2.Message.getFieldWithDefault(this, 2, "");
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.setCachedKernelPath = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.clearCachedKernelPath = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.hasCachedKernelPath = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.getSerializedModelDir = function() {
    return t2.Message.getFieldWithDefault(this, 7, "");
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.setSerializedModelDir = function(e3) {
    return t2.Message.setField(this, 7, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.clearSerializedModelDir = function() {
    return t2.Message.setField(this, 7, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.hasSerializedModelDir = function() {
    return null != t2.Message.getField(this, 7);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.getModelToken = function() {
    return t2.Message.getFieldWithDefault(this, 8, "");
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.setModelToken = function(e3) {
    return t2.Message.setField(this, 8, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.clearModelToken = function() {
    return t2.Message.setField(this, 8, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.hasModelToken = function() {
    return null != t2.Message.getField(this, 8);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.getUsage = function() {
    return t2.Message.getFieldWithDefault(this, 5, 2);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.setUsage = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.clearUsage = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu.prototype.hasUsage = function() {
    return null != t2.Message.getField(this, 5);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.toObject = function(e3) {
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.toObject(e3, this);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.toObject = function(e3, r3) {
    var o3, i4 = { cacheDir: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, modelToken: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, acceleratorName: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setCacheDir(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setModelToken(r3);
          break;
        case 3:
          r3 = t3.readString();
          e3.setAcceleratorName(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeString(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeString(3, o3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.getCacheDir = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.setCacheDir = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.clearCacheDir = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.hasCacheDir = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.getModelToken = function() {
    return t2.Message.getFieldWithDefault(this, 2, "");
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.setModelToken = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.clearModelToken = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.hasModelToken = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.getAcceleratorName = function() {
    return t2.Message.getFieldWithDefault(this, 3, "");
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.setAcceleratorName = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.clearAcceleratorName = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi.prototype.hasAcceleratorName = function() {
    return null != t2.Message.getField(this, 3);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.prototype.toObject = function(e3) {
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.toObject(e3, this);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.toObject = function(e3, r3) {
    var o3 = { numThreads: t2.Message.getFieldWithDefault(r3, 1, -1) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = t3.readInt32();
        e3.setNumThreads(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.serializeBinaryToWriter = function(e3, r3) {
    var o3;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.prototype.getNumThreads = function() {
    return t2.Message.getFieldWithDefault(this, 1, -1);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.prototype.setNumThreads = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.prototype.clearNumThreads = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack.prototype.hasNumThreads = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.getTflite = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.InferenceCalculatorOptions.Delegate.TfLite, 1);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.setTflite = function(e3) {
    return t2.Message.setOneofWrapperField(this, 1, proto.mediapipe.InferenceCalculatorOptions.Delegate.oneofGroups_[0], e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.clearTflite = function() {
    return this.setTflite(void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.hasTflite = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.getGpu = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.InferenceCalculatorOptions.Delegate.Gpu, 2);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.setGpu = function(e3) {
    return t2.Message.setOneofWrapperField(this, 2, proto.mediapipe.InferenceCalculatorOptions.Delegate.oneofGroups_[0], e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.clearGpu = function() {
    return this.setGpu(void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.hasGpu = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.getNnapi = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.InferenceCalculatorOptions.Delegate.Nnapi, 3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.setNnapi = function(e3) {
    return t2.Message.setOneofWrapperField(this, 3, proto.mediapipe.InferenceCalculatorOptions.Delegate.oneofGroups_[0], e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.clearNnapi = function() {
    return this.setNnapi(void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.hasNnapi = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.getXnnpack = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.InferenceCalculatorOptions.Delegate.Xnnpack, 4);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.setXnnpack = function(e3) {
    return t2.Message.setOneofWrapperField(this, 4, proto.mediapipe.InferenceCalculatorOptions.Delegate.oneofGroups_[0], e3);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.clearXnnpack = function() {
    return this.setXnnpack(void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.Delegate.prototype.hasXnnpack = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.InferenceCalculatorOptions.ext = new t2.ExtensionFieldInfo(336783863, { ext: 0 }, proto.mediapipe.InferenceCalculatorOptions, proto.mediapipe.InferenceCalculatorOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[336783863] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.InferenceCalculatorOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.InferenceCalculatorOptions.serializeBinaryToWriter, proto.mediapipe.InferenceCalculatorOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[336783863] = proto.mediapipe.InferenceCalculatorOptions.ext, proto.mediapipe.InferenceCalculatorOptions.prototype.getModelPath = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.setModelPath = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.clearModelPath = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.hasModelPath = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.getUseGpu = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 2, false);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.setUseGpu = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.clearUseGpu = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.hasUseGpu = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.getUseNnapi = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 3, false);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.setUseNnapi = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.clearUseNnapi = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.hasUseNnapi = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.getCpuNumThread = function() {
    return t2.Message.getFieldWithDefault(this, 4, -1);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.setCpuNumThread = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.clearCpuNumThread = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.hasCpuNumThread = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.getDelegate = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.InferenceCalculatorOptions.Delegate, 5);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.setDelegate = function(e3) {
    return t2.Message.setWrapperField(this, 5, e3);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.clearDelegate = function() {
    return this.setDelegate(void 0);
  }, proto.mediapipe.InferenceCalculatorOptions.prototype.hasDelegate = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.InferenceCalculatorOptions.ext = new t2.ExtensionFieldInfo(336783863, { ext: 0 }, proto.mediapipe.InferenceCalculatorOptions, proto.mediapipe.InferenceCalculatorOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[336783863] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.InferenceCalculatorOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.InferenceCalculatorOptions.serializeBinaryToWriter, proto.mediapipe.InferenceCalculatorOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[336783863] = proto.mediapipe.InferenceCalculatorOptions.ext, r2.object.extend(e2, proto.mediapipe);
}(inference_calculator_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = inference_calculator_pb;
  r2.object.extend(proto, i3), r2.exportSymbol("proto.mediapipe.tasks.core.proto.Acceleration", null, o2), r2.exportSymbol("proto.mediapipe.tasks.core.proto.Acceleration.DelegateCase", null, o2), proto.mediapipe.tasks.core.proto.Acceleration = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, proto.mediapipe.tasks.core.proto.Acceleration.oneofGroups_);
  }, r2.inherits(proto.mediapipe.tasks.core.proto.Acceleration, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.core.proto.Acceleration.displayName = "proto.mediapipe.tasks.core.proto.Acceleration"), proto.mediapipe.tasks.core.proto.Acceleration.oneofGroups_ = [[1, 2, 4, 5]], proto.mediapipe.tasks.core.proto.Acceleration.DelegateCase = { DELEGATE_NOT_SET: 0, XNNPACK: 1, GPU: 2, TFLITE: 4, NNAPI: 5 }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.getDelegateCase = function() {
    return t2.Message.computeOneofCase(this, proto.mediapipe.tasks.core.proto.Acceleration.oneofGroups_[0]);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.core.proto.Acceleration.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.core.proto.Acceleration.toObject(e3, this);
  }, proto.mediapipe.tasks.core.proto.Acceleration.toObject = function(e3, t3) {
    var r3, o3 = { xnnpack: (r3 = t3.getXnnpack()) && i3.InferenceCalculatorOptions.Delegate.Xnnpack.toObject(e3, r3), gpu: (r3 = t3.getGpu()) && i3.InferenceCalculatorOptions.Delegate.Gpu.toObject(e3, r3), tflite: (r3 = t3.getTflite()) && i3.InferenceCalculatorOptions.Delegate.TfLite.toObject(e3, r3), nnapi: (r3 = t3.getNnapi()) && i3.InferenceCalculatorOptions.Delegate.Nnapi.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.core.proto.Acceleration.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.core.proto.Acceleration();
    return proto.mediapipe.tasks.core.proto.Acceleration.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.core.proto.Acceleration.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new i3.InferenceCalculatorOptions.Delegate.Xnnpack();
          t3.readMessage(r3, i3.InferenceCalculatorOptions.Delegate.Xnnpack.deserializeBinaryFromReader), e3.setXnnpack(r3);
          break;
        case 2:
          r3 = new i3.InferenceCalculatorOptions.Delegate.Gpu();
          t3.readMessage(r3, i3.InferenceCalculatorOptions.Delegate.Gpu.deserializeBinaryFromReader), e3.setGpu(r3);
          break;
        case 4:
          r3 = new i3.InferenceCalculatorOptions.Delegate.TfLite();
          t3.readMessage(r3, i3.InferenceCalculatorOptions.Delegate.TfLite.deserializeBinaryFromReader), e3.setTflite(r3);
          break;
        case 5:
          r3 = new i3.InferenceCalculatorOptions.Delegate.Nnapi();
          t3.readMessage(r3, i3.InferenceCalculatorOptions.Delegate.Nnapi.deserializeBinaryFromReader), e3.setNnapi(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.core.proto.Acceleration.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.core.proto.Acceleration.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getXnnpack()) && t3.writeMessage(1, r3, i3.InferenceCalculatorOptions.Delegate.Xnnpack.serializeBinaryToWriter), null != (r3 = e3.getGpu()) && t3.writeMessage(2, r3, i3.InferenceCalculatorOptions.Delegate.Gpu.serializeBinaryToWriter), null != (r3 = e3.getTflite()) && t3.writeMessage(4, r3, i3.InferenceCalculatorOptions.Delegate.TfLite.serializeBinaryToWriter), null != (r3 = e3.getNnapi()) && t3.writeMessage(5, r3, i3.InferenceCalculatorOptions.Delegate.Nnapi.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.getXnnpack = function() {
    return t2.Message.getWrapperField(this, i3.InferenceCalculatorOptions.Delegate.Xnnpack, 1);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.setXnnpack = function(e3) {
    return t2.Message.setOneofWrapperField(this, 1, proto.mediapipe.tasks.core.proto.Acceleration.oneofGroups_[0], e3);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.clearXnnpack = function() {
    return this.setXnnpack(void 0);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.hasXnnpack = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.getGpu = function() {
    return t2.Message.getWrapperField(this, i3.InferenceCalculatorOptions.Delegate.Gpu, 2);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.setGpu = function(e3) {
    return t2.Message.setOneofWrapperField(this, 2, proto.mediapipe.tasks.core.proto.Acceleration.oneofGroups_[0], e3);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.clearGpu = function() {
    return this.setGpu(void 0);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.hasGpu = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.getTflite = function() {
    return t2.Message.getWrapperField(this, i3.InferenceCalculatorOptions.Delegate.TfLite, 4);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.setTflite = function(e3) {
    return t2.Message.setOneofWrapperField(this, 4, proto.mediapipe.tasks.core.proto.Acceleration.oneofGroups_[0], e3);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.clearTflite = function() {
    return this.setTflite(void 0);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.hasTflite = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.getNnapi = function() {
    return t2.Message.getWrapperField(this, i3.InferenceCalculatorOptions.Delegate.Nnapi, 5);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.setNnapi = function(e3) {
    return t2.Message.setOneofWrapperField(this, 5, proto.mediapipe.tasks.core.proto.Acceleration.oneofGroups_[0], e3);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.clearNnapi = function() {
    return this.setNnapi(void 0);
  }, proto.mediapipe.tasks.core.proto.Acceleration.prototype.hasNnapi = function() {
    return null != t2.Message.getField(this, 5);
  }, r2.object.extend(e2, proto.mediapipe.tasks.core.proto);
}(acceleration_pb);
var external_file_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.tasks.core.proto.ExternalFile", null, o2), r2.exportSymbol("proto.mediapipe.tasks.core.proto.FileDescriptorMeta", null, o2), r2.exportSymbol("proto.mediapipe.tasks.core.proto.FilePointerMeta", null, o2), proto.mediapipe.tasks.core.proto.ExternalFile = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.core.proto.ExternalFile, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.core.proto.ExternalFile.displayName = "proto.mediapipe.tasks.core.proto.ExternalFile"), proto.mediapipe.tasks.core.proto.FileDescriptorMeta = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.core.proto.FileDescriptorMeta, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.core.proto.FileDescriptorMeta.displayName = "proto.mediapipe.tasks.core.proto.FileDescriptorMeta"), proto.mediapipe.tasks.core.proto.FilePointerMeta = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.core.proto.FilePointerMeta, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.core.proto.FilePointerMeta.displayName = "proto.mediapipe.tasks.core.proto.FilePointerMeta"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.core.proto.ExternalFile.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.core.proto.ExternalFile.toObject(e3, this);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.toObject = function(e3, r3) {
    var o3, i3 = { fileContent: r3.getFileContent_asB64(), fileName: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, fileDescriptorMeta: (o3 = r3.getFileDescriptorMeta()) && proto.mediapipe.tasks.core.proto.FileDescriptorMeta.toObject(e3, o3), filePointerMeta: (o3 = r3.getFilePointerMeta()) && proto.mediapipe.tasks.core.proto.FilePointerMeta.toObject(e3, o3) };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.core.proto.ExternalFile.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.core.proto.ExternalFile();
    return proto.mediapipe.tasks.core.proto.ExternalFile.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readBytes();
          e3.setFileContent(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setFileName(r3);
          break;
        case 3:
          r3 = new proto.mediapipe.tasks.core.proto.FileDescriptorMeta();
          t3.readMessage(r3, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.deserializeBinaryFromReader), e3.setFileDescriptorMeta(r3);
          break;
        case 4:
          r3 = new proto.mediapipe.tasks.core.proto.FilePointerMeta();
          t3.readMessage(r3, proto.mediapipe.tasks.core.proto.FilePointerMeta.deserializeBinaryFromReader), e3.setFilePointerMeta(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.core.proto.ExternalFile.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.core.proto.ExternalFile.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeBytes(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeString(2, o3), null != (o3 = e3.getFileDescriptorMeta()) && r3.writeMessage(3, o3, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.serializeBinaryToWriter), null != (o3 = e3.getFilePointerMeta()) && r3.writeMessage(4, o3, proto.mediapipe.tasks.core.proto.FilePointerMeta.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.getFileContent = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.getFileContent_asB64 = function() {
    return t2.Message.bytesAsB64(this.getFileContent());
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.getFileContent_asU8 = function() {
    return t2.Message.bytesAsU8(this.getFileContent());
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.setFileContent = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.clearFileContent = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.hasFileContent = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.getFileName = function() {
    return t2.Message.getFieldWithDefault(this, 2, "");
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.setFileName = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.clearFileName = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.hasFileName = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.getFileDescriptorMeta = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.tasks.core.proto.FileDescriptorMeta, 3);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.setFileDescriptorMeta = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.clearFileDescriptorMeta = function() {
    return this.setFileDescriptorMeta(void 0);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.hasFileDescriptorMeta = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.getFilePointerMeta = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.tasks.core.proto.FilePointerMeta, 4);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.setFilePointerMeta = function(e3) {
    return t2.Message.setWrapperField(this, 4, e3);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.clearFilePointerMeta = function() {
    return this.setFilePointerMeta(void 0);
  }, proto.mediapipe.tasks.core.proto.ExternalFile.prototype.hasFilePointerMeta = function() {
    return null != t2.Message.getField(this, 4);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.core.proto.FileDescriptorMeta.toObject(e3, this);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.toObject = function(e3, r3) {
    var o3, i3 = { fd: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, length: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, offset: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.core.proto.FileDescriptorMeta.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.core.proto.FileDescriptorMeta();
    return proto.mediapipe.tasks.core.proto.FileDescriptorMeta.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt32();
          e3.setFd(r3);
          break;
        case 2:
          r3 = t3.readInt64();
          e3.setLength(r3);
          break;
        case 3:
          r3 = t3.readInt64();
          e3.setOffset(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.core.proto.FileDescriptorMeta.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt64(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt64(3, o3);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.getFd = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.setFd = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.clearFd = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.hasFd = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.getLength = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.setLength = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.clearLength = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.hasLength = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.getOffset = function() {
    return t2.Message.getFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.setOffset = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.clearOffset = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.tasks.core.proto.FileDescriptorMeta.prototype.hasOffset = function() {
    return null != t2.Message.getField(this, 3);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.core.proto.FilePointerMeta.toObject(e3, this);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.toObject = function(e3, r3) {
    var o3, i3 = { pointer: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, length: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.core.proto.FilePointerMeta.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.core.proto.FilePointerMeta();
    return proto.mediapipe.tasks.core.proto.FilePointerMeta.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readUint64();
          e3.setPointer(r3);
          break;
        case 2:
          r3 = t3.readInt64();
          e3.setLength(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.core.proto.FilePointerMeta.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeUint64(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt64(2, o3);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.getPointer = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.setPointer = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.clearPointer = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.hasPointer = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.getLength = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.setLength = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.clearLength = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.core.proto.FilePointerMeta.prototype.hasLength = function() {
    return null != t2.Message.getField(this, 2);
  }, r2.object.extend(e2, proto.mediapipe.tasks.core.proto);
}(external_file_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = acceleration_pb;
  r2.object.extend(proto, i3);
  var a3 = external_file_pb;
  r2.object.extend(proto, a3), r2.exportSymbol("proto.mediapipe.tasks.core.proto.BaseOptions", null, o2), proto.mediapipe.tasks.core.proto.BaseOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.core.proto.BaseOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.core.proto.BaseOptions.displayName = "proto.mediapipe.tasks.core.proto.BaseOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.core.proto.BaseOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.core.proto.BaseOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.toObject = function(e3, r3) {
    var o3, n2 = { modelAsset: (o3 = r3.getModelAsset()) && a3.ExternalFile.toObject(e3, o3), useStreamMode: t2.Message.getBooleanFieldWithDefault(r3, 2, false), acceleration: (o3 = r3.getAcceleration()) && i3.Acceleration.toObject(e3, o3) };
    return e3 && (n2.$jspbMessageInstance = r3), n2;
  }), proto.mediapipe.tasks.core.proto.BaseOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.core.proto.BaseOptions();
    return proto.mediapipe.tasks.core.proto.BaseOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new a3.ExternalFile();
          t3.readMessage(r3, a3.ExternalFile.deserializeBinaryFromReader), e3.setModelAsset(r3);
          break;
        case 2:
          r3 = t3.readBool();
          e3.setUseStreamMode(r3);
          break;
        case 3:
          r3 = new i3.Acceleration();
          t3.readMessage(r3, i3.Acceleration.deserializeBinaryFromReader), e3.setAcceleration(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.core.proto.BaseOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.core.proto.BaseOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getModelAsset()) && r3.writeMessage(1, o3, a3.ExternalFile.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeBool(2, o3), null != (o3 = e3.getAcceleration()) && r3.writeMessage(3, o3, i3.Acceleration.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.getModelAsset = function() {
    return t2.Message.getWrapperField(this, a3.ExternalFile, 1);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.setModelAsset = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.clearModelAsset = function() {
    return this.setModelAsset(void 0);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.hasModelAsset = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.getUseStreamMode = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 2, false);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.setUseStreamMode = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.clearUseStreamMode = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.hasUseStreamMode = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.getAcceleration = function() {
    return t2.Message.getWrapperField(this, i3.Acceleration, 3);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.setAcceleration = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.clearAcceleration = function() {
    return this.setAcceleration(void 0);
  }, proto.mediapipe.tasks.core.proto.BaseOptions.prototype.hasAcceleration = function() {
    return null != t2.Message.getField(this, 3);
  }, r2.object.extend(e2, proto.mediapipe.tasks.core.proto);
}(base_options_pb);
var face_detector_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2), r2.exportSymbol("proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions", null, o2), proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.displayName = "proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), minDetectionConfidence: t2.Message.getFloatingPointFieldWithDefault(r3, 2, 0.5), minSuppressionThreshold: t2.Message.getFloatingPointFieldWithDefault(r3, 3, 0.5), numFaces: null == (o3 = t2.Message.getField(r3, 4)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions();
    return proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setMinDetectionConfidence(r3);
          break;
        case 3:
          r3 = t3.readFloat();
          e3.setMinSuppressionThreshold(r3);
          break;
        case 4:
          r3 = t3.readInt32();
          e3.setNumFaces(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeFloat(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeInt32(4, o3);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(502141897, { ext: 0 }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[502141897] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[502141897] = proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.ext, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.getMinDetectionConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0.5);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.setMinDetectionConfidence = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.clearMinDetectionConfidence = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.hasMinDetectionConfidence = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.getMinSuppressionThreshold = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0.5);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.setMinSuppressionThreshold = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.clearMinSuppressionThreshold = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.hasMinSuppressionThreshold = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.getNumFaces = function() {
    return t2.Message.getFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.setNumFaces = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.clearNumFaces = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.prototype.hasNumFaces = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(502141897, { ext: 0 }, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[502141897] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[502141897] = proto.mediapipe.tasks.vision.face_detector.proto.FaceDetectorGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.face_detector.proto);
}(face_detector_graph_options_pb);
var detection_result = {};
Object.defineProperty(detection_result, "__esModule", { value: true }), detection_result.convertFromDetectionProto = void 0;
var DEFAULT_CATEGORY_INDEX = -1;
function convertFromDetectionProto(e2) {
  var t2, r2, o2, i3, a3, n2, s2, p, d2, l2, g, c6, u;
  const m = e2.getScoreList(), f2 = e2.getLabelIdList(), h = e2.getLabelList(), y = e2.getDisplayNameList(), b = { categories: [], keypoints: [] };
  for (let e3 = 0; e3 < m.length; e3++)
    b.categories.push({ score: m[e3], index: null !== (t2 = f2[e3]) && void 0 !== t2 ? t2 : DEFAULT_CATEGORY_INDEX, categoryName: null !== (r2 = h[e3]) && void 0 !== r2 ? r2 : "", displayName: null !== (o2 = y[e3]) && void 0 !== o2 ? o2 : "" });
  const _ = null === (i3 = e2.getLocationData()) || void 0 === i3 ? void 0 : i3.getBoundingBox();
  if (_ && (b.boundingBox = { originX: null !== (a3 = _.getXmin()) && void 0 !== a3 ? a3 : 0, originY: null !== (n2 = _.getYmin()) && void 0 !== n2 ? n2 : 0, width: null !== (s2 = _.getWidth()) && void 0 !== s2 ? s2 : 0, height: null !== (p = _.getHeight()) && void 0 !== p ? p : 0 }), null === (d2 = e2.getLocationData()) || void 0 === d2 ? void 0 : d2.getRelativeKeypointsList().length)
    for (const t3 of e2.getLocationData().getRelativeKeypointsList())
      b.keypoints.push({ x: null !== (l2 = t3.getX()) && void 0 !== l2 ? l2 : 0, y: null !== (g = t3.getY()) && void 0 !== g ? g : 0, score: null !== (c6 = t3.getScore()) && void 0 !== c6 ? c6 : 0, label: null !== (u = t3.getKeypointLabel()) && void 0 !== u ? u : "" });
  return b;
}
detection_result.convertFromDetectionProto = convertFromDetectionProto;
var vision_task_runner = {};
var rect_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.NormalizedRect", null, o2), r2.exportSymbol("proto.mediapipe.Rect", null, o2), proto.mediapipe.Rect = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.Rect, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.Rect.displayName = "proto.mediapipe.Rect"), proto.mediapipe.NormalizedRect = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.NormalizedRect, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.NormalizedRect.displayName = "proto.mediapipe.NormalizedRect"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.Rect.prototype.toObject = function(e3) {
    return proto.mediapipe.Rect.toObject(e3, this);
  }, proto.mediapipe.Rect.toObject = function(e3, r3) {
    var o3, i3 = { xCenter: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, yCenter: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, height: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3, width: null == (o3 = t2.Message.getField(r3, 4)) ? void 0 : o3, rotation: t2.Message.getFloatingPointFieldWithDefault(r3, 5, 0), rectId: null == (o3 = t2.Message.getField(r3, 6)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.Rect.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.Rect();
    return proto.mediapipe.Rect.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.Rect.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt32();
          e3.setXCenter(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setYCenter(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setHeight(r3);
          break;
        case 4:
          r3 = t3.readInt32();
          e3.setWidth(r3);
          break;
        case 5:
          r3 = t3.readFloat();
          e3.setRotation(r3);
          break;
        case 6:
          r3 = t3.readInt64();
          e3.setRectId(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.Rect.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.Rect.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.Rect.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeInt32(4, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeFloat(5, o3), null != (o3 = t2.Message.getField(e3, 6)) && r3.writeInt64(6, o3);
  }, proto.mediapipe.Rect.prototype.getXCenter = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.Rect.prototype.setXCenter = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.Rect.prototype.clearXCenter = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.Rect.prototype.hasXCenter = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.Rect.prototype.getYCenter = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.Rect.prototype.setYCenter = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.Rect.prototype.clearYCenter = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.Rect.prototype.hasYCenter = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.Rect.prototype.getHeight = function() {
    return t2.Message.getFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.Rect.prototype.setHeight = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.Rect.prototype.clearHeight = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.Rect.prototype.hasHeight = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.Rect.prototype.getWidth = function() {
    return t2.Message.getFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.Rect.prototype.setWidth = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.Rect.prototype.clearWidth = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.Rect.prototype.hasWidth = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.Rect.prototype.getRotation = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 5, 0);
  }, proto.mediapipe.Rect.prototype.setRotation = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.Rect.prototype.clearRotation = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.Rect.prototype.hasRotation = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.Rect.prototype.getRectId = function() {
    return t2.Message.getFieldWithDefault(this, 6, 0);
  }, proto.mediapipe.Rect.prototype.setRectId = function(e3) {
    return t2.Message.setField(this, 6, e3);
  }, proto.mediapipe.Rect.prototype.clearRectId = function() {
    return t2.Message.setField(this, 6, void 0);
  }, proto.mediapipe.Rect.prototype.hasRectId = function() {
    return null != t2.Message.getField(this, 6);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.NormalizedRect.prototype.toObject = function(e3) {
    return proto.mediapipe.NormalizedRect.toObject(e3, this);
  }, proto.mediapipe.NormalizedRect.toObject = function(e3, r3) {
    var o3, i3 = { xCenter: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, yCenter: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, height: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, width: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3, rotation: t2.Message.getFloatingPointFieldWithDefault(r3, 5, 0), rectId: null == (o3 = t2.Message.getField(r3, 6)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.NormalizedRect.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.NormalizedRect();
    return proto.mediapipe.NormalizedRect.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.NormalizedRect.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readFloat();
          e3.setXCenter(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setYCenter(r3);
          break;
        case 3:
          r3 = t3.readFloat();
          e3.setHeight(r3);
          break;
        case 4:
          r3 = t3.readFloat();
          e3.setWidth(r3);
          break;
        case 5:
          r3 = t3.readFloat();
          e3.setRotation(r3);
          break;
        case 6:
          r3 = t3.readInt64();
          e3.setRectId(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.NormalizedRect.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.NormalizedRect.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.NormalizedRect.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeFloat(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeFloat(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeFloat(4, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeFloat(5, o3), null != (o3 = t2.Message.getField(e3, 6)) && r3.writeInt64(6, o3);
  }, proto.mediapipe.NormalizedRect.prototype.getXCenter = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.NormalizedRect.prototype.setXCenter = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.NormalizedRect.prototype.clearXCenter = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.NormalizedRect.prototype.hasXCenter = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.NormalizedRect.prototype.getYCenter = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.NormalizedRect.prototype.setYCenter = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.NormalizedRect.prototype.clearYCenter = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.NormalizedRect.prototype.hasYCenter = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.NormalizedRect.prototype.getHeight = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.NormalizedRect.prototype.setHeight = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.NormalizedRect.prototype.clearHeight = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.NormalizedRect.prototype.hasHeight = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.NormalizedRect.prototype.getWidth = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.NormalizedRect.prototype.setWidth = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.NormalizedRect.prototype.clearWidth = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.NormalizedRect.prototype.hasWidth = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.NormalizedRect.prototype.getRotation = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 5, 0);
  }, proto.mediapipe.NormalizedRect.prototype.setRotation = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.NormalizedRect.prototype.clearRotation = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.NormalizedRect.prototype.hasRotation = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.NormalizedRect.prototype.getRectId = function() {
    return t2.Message.getFieldWithDefault(this, 6, 0);
  }, proto.mediapipe.NormalizedRect.prototype.setRectId = function(e3) {
    return t2.Message.setField(this, 6, e3);
  }, proto.mediapipe.NormalizedRect.prototype.clearRectId = function() {
    return t2.Message.setField(this, 6, void 0);
  }, proto.mediapipe.NormalizedRect.prototype.hasRectId = function() {
    return null != t2.Message.getField(this, 6);
  }, r2.object.extend(e2, proto.mediapipe);
}(rect_pb);
var task_runner = {};
var graph_runner = {};
!function(e2) {
  Object.defineProperty(e2, "__esModule", { value: true }), e2.createGraphRunner = e2.createMediaPipeLib = e2.GraphRunner = e2.CALCULATOR_GRAPH_CONFIG_LISTENER_NAME = void 0;
  const t2 = platform_utils;
  e2.CALCULATOR_GRAPH_CONFIG_LISTENER_NAME = "__graph_config__";
  class r2 {
    constructor(e3, r3) {
      this.autoResizeCanvas = true, this.wasmModule = e3, this.audioPtr = null, this.audioSize = 0, this.hasMultiStreamSupport = "function" == typeof this.wasmModule._addIntToInputStream, void 0 !== r3 ? this.wasmModule.canvas = r3 : "undefined" == typeof OffscreenCanvas || (0, t2.isWebKit)() ? (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this.wasmModule.canvas = document.createElement("canvas")) : this.wasmModule.canvas = new OffscreenCanvas(1, 1);
    }
    async initializeGraph(e3) {
      const t3 = await fetch(e3), r3 = await t3.arrayBuffer(), o3 = !(e3.endsWith(".pbtxt") || e3.endsWith(".textproto"));
      this.setGraph(new Uint8Array(r3), o3);
    }
    setGraphFromString(e3) {
      this.setGraph(new TextEncoder().encode(e3), false);
    }
    setGraph(e3, t3) {
      const r3 = e3.length, o3 = this.wasmModule._malloc(r3);
      this.wasmModule.HEAPU8.set(e3, o3), t3 ? this.wasmModule._changeBinaryGraph(r3, o3) : this.wasmModule._changeTextGraph(r3, o3), this.wasmModule._free(o3);
    }
    configureAudio(e3, t3, r3, o3, i4) {
      this.wasmModule._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), o3 = o3 || "input_audio", this.wrapStringPtr(o3, (o4) => {
        i4 = i4 || "audio_header", this.wrapStringPtr(i4, (i5) => {
          this.wasmModule._configureAudio(o4, i5, e3, t3, r3);
        });
      });
    }
    setAutoResizeCanvas(e3) {
      this.autoResizeCanvas = e3;
    }
    setAutoRenderToScreen(e3) {
      this.wasmModule._setAutoRenderToScreen(e3);
    }
    bindTextureToStream(e3, t3) {
      if (!this.wasmModule.canvas)
        throw new Error("No OpenGL canvas configured.");
      t3 ? this.wasmModule._bindTextureToStream(t3) : console.assert(this.wasmModule._bindTextureToCanvas());
      const r3 = this.wasmModule.canvas.getContext("webgl2") || this.wasmModule.canvas.getContext("webgl");
      if (!r3)
        throw new Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
      let o3, i4;
      return r3.texImage2D(r3.TEXTURE_2D, 0, r3.RGBA, r3.RGBA, r3.UNSIGNED_BYTE, e3), e3.videoWidth ? (o3 = e3.videoWidth, i4 = e3.videoHeight) : e3.naturalWidth ? (o3 = e3.naturalWidth, i4 = e3.naturalHeight) : (o3 = e3.width, i4 = e3.height), !this.autoResizeCanvas || o3 === this.wasmModule.canvas.width && i4 === this.wasmModule.canvas.height || (this.wasmModule.canvas.width = o3, this.wasmModule.canvas.height = i4), [o3, i4];
    }
    processGl(e3, t3) {
      const [r3, o3] = this.bindTextureToStream(e3), i4 = this.wasmModule._malloc(16);
      this.wasmModule.HEAPU32[i4 / 4] = r3, this.wasmModule.HEAPU32[i4 / 4 + 1] = o3, this.wasmModule.HEAPF64[i4 / 8 + 1] = t3, this.wasmModule._processGl(i4), this.wasmModule._free(i4);
    }
    wrapStringPtr(e3, t3) {
      this.hasMultiStreamSupport || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
      const r3 = this.wasmModule.stringToNewUTF8(e3);
      t3(r3), this.wasmModule._free(r3);
    }
    wrapStringPtrPtr(e3, t3) {
      this.hasMultiStreamSupport || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
      const r3 = new Uint32Array(e3.length);
      for (let t4 = 0; t4 < e3.length; t4++)
        r3[t4] = this.wasmModule.stringToNewUTF8(e3[t4]);
      const o3 = this.wasmModule._malloc(4 * r3.length);
      this.wasmModule.HEAPU32.set(r3, o3 >> 2), t3(o3);
      for (const e4 of r3)
        this.wasmModule._free(e4);
      this.wasmModule._free(o3);
    }
    getCalculatorGraphConfig(t3, r3) {
      const o3 = e2.CALCULATOR_GRAPH_CONFIG_LISTENER_NAME;
      this.setListener(o3, (e3) => {
        t3(e3);
      }), this.wrapStringPtr(o3, (e3) => {
        this.wasmModule._getGraphConfig(e3, r3);
      }), delete this.wasmModule.simpleListeners[o3];
    }
    setListener(e3, t3) {
      this.wasmModule.simpleListeners = this.wasmModule.simpleListeners || {}, this.wasmModule.simpleListeners[e3] = t3;
    }
    setVectorListener(e3, t3) {
      let r3 = [];
      this.wasmModule.simpleListeners = this.wasmModule.simpleListeners || {}, this.wasmModule.simpleListeners[e3] = (e4, o3, i4) => {
        o3 ? (t3(r3, i4), r3 = []) : r3.push(e4);
      };
    }
    attachErrorListener(e3) {
      this.wasmModule.errorListener = e3;
    }
    attachEmptyPacketListener(e3, t3) {
      this.wasmModule.emptyPacketListeners = this.wasmModule.emptyPacketListeners || {}, this.wasmModule.emptyPacketListeners[e3] = t3;
    }
    addAudioToStream(e3, t3, r3) {
      this.addAudioToStreamWithShape(e3, 0, 0, t3, r3);
    }
    addAudioToStreamWithShape(e3, t3, r3, o3, i4) {
      const a3 = 4 * e3.length;
      this.audioSize !== a3 && (this.audioPtr && this.wasmModule._free(this.audioPtr), this.audioPtr = this.wasmModule._malloc(a3), this.audioSize = a3), this.wasmModule.HEAPF32.set(e3, this.audioPtr / 4), this.wrapStringPtr(o3, (e4) => {
        this.wasmModule._addAudioToInputStream(this.audioPtr, t3, r3, e4, i4);
      });
    }
    addGpuBufferToStream(e3, t3, r3) {
      this.wrapStringPtr(t3, (t4) => {
        const [o3, i4] = this.bindTextureToStream(e3, t4);
        this.wasmModule._addBoundTextureToStream(t4, o3, i4, r3);
      });
    }
    addBoolToStream(e3, t3, r3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wasmModule._addBoolToInputStream(e3, t4, r3);
      });
    }
    addDoubleToStream(e3, t3, r3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wasmModule._addDoubleToInputStream(e3, t4, r3);
      });
    }
    addFloatToStream(e3, t3, r3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wasmModule._addFloatToInputStream(e3, t4, r3);
      });
    }
    addIntToStream(e3, t3, r3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wasmModule._addIntToInputStream(e3, t4, r3);
      });
    }
    addStringToStream(e3, t3, r3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wrapStringPtr(e3, (e4) => {
          this.wasmModule._addStringToInputStream(e4, t4, r3);
        });
      });
    }
    addStringRecordToStream(e3, t3, r3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wrapStringPtrPtr(Object.keys(e3), (o3) => {
          this.wrapStringPtrPtr(Object.values(e3), (i4) => {
            this.wasmModule._addFlatHashMapToInputStream(o3, i4, Object.keys(e3).length, t4, r3);
          });
        });
      });
    }
    addProtoToStream(e3, t3, r3, o3) {
      this.wrapStringPtr(r3, (r4) => {
        this.wrapStringPtr(t3, (t4) => {
          const i4 = this.wasmModule._malloc(e3.length);
          this.wasmModule.HEAPU8.set(e3, i4), this.wasmModule._addProtoToInputStream(i4, e3.length, t4, r4, o3), this.wasmModule._free(i4);
        });
      });
    }
    addEmptyPacketToStream(e3, t3) {
      this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._addEmptyPacketToInputStream(e4, t3);
      });
    }
    addBoolToInputSidePacket(e3, t3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wasmModule._addBoolToInputSidePacket(e3, t4);
      });
    }
    addDoubleToInputSidePacket(e3, t3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wasmModule._addDoubleToInputSidePacket(e3, t4);
      });
    }
    addFloatToInputSidePacket(e3, t3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wasmModule._addFloatToInputSidePacket(e3, t4);
      });
    }
    addIntToInputSidePacket(e3, t3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wasmModule._addIntToInputSidePacket(e3, t4);
      });
    }
    addStringToInputSidePacket(e3, t3) {
      this.wrapStringPtr(t3, (t4) => {
        this.wrapStringPtr(e3, (e4) => {
          this.wasmModule._addStringToInputSidePacket(e4, t4);
        });
      });
    }
    addProtoToInputSidePacket(e3, t3, r3) {
      this.wrapStringPtr(r3, (r4) => {
        this.wrapStringPtr(t3, (t4) => {
          const o3 = this.wasmModule._malloc(e3.length);
          this.wasmModule.HEAPU8.set(e3, o3), this.wasmModule._addProtoToInputSidePacket(o3, e3.length, t4, r4), this.wasmModule._free(o3);
        });
      });
    }
    attachBoolListener(e3, t3) {
      this.setListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachBoolListener(e4);
      });
    }
    attachBoolVectorListener(e3, t3) {
      this.setVectorListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachBoolVectorListener(e4);
      });
    }
    attachIntListener(e3, t3) {
      this.setListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachIntListener(e4);
      });
    }
    attachIntVectorListener(e3, t3) {
      this.setVectorListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachIntVectorListener(e4);
      });
    }
    attachDoubleListener(e3, t3) {
      this.setListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachDoubleListener(e4);
      });
    }
    attachDoubleVectorListener(e3, t3) {
      this.setVectorListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachDoubleVectorListener(e4);
      });
    }
    attachFloatListener(e3, t3) {
      this.setListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachFloatListener(e4);
      });
    }
    attachFloatVectorListener(e3, t3) {
      this.setVectorListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachFloatVectorListener(e4);
      });
    }
    attachStringListener(e3, t3) {
      this.setListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachStringListener(e4);
      });
    }
    attachStringVectorListener(e3, t3) {
      this.setVectorListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachStringVectorListener(e4);
      });
    }
    attachProtoListener(e3, t3, r3) {
      this.setListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachProtoListener(e4, r3 || false);
      });
    }
    attachProtoVectorListener(e3, t3, r3) {
      this.setVectorListener(e3, t3), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachProtoVectorListener(e4, r3 || false);
      });
    }
    attachAudioListener(e3, t3, r3) {
      this.wasmModule._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), this.setListener(e3, (e4, r4) => {
        const o3 = new Float32Array(e4.buffer, e4.byteOffset, e4.length / 4);
        t3(o3, r4);
      }), this.wrapStringPtr(e3, (e4) => {
        this.wasmModule._attachAudioListener(e4, r3 || false);
      });
    }
    finishProcessing() {
      this.wasmModule._waitUntilIdle();
    }
    closeGraph() {
      this.wasmModule._closeGraph(), this.wasmModule.simpleListeners = void 0, this.wasmModule.emptyPacketListeners = void 0;
    }
  }
  async function o2(e3) {
    if ("function" != typeof importScripts) {
      const t3 = document.createElement("script");
      return t3.setAttribute("src", e3), t3.setAttribute("crossorigin", "anonymous"), new Promise((e4) => {
        t3.addEventListener("load", () => {
          e4();
        }, false), t3.addEventListener("error", () => {
          e4();
        }, false), document.body.appendChild(t3);
      });
    }
    importScripts(e3.toString());
  }
  async function i3(e3, t3, r3, i4, a3) {
    const n2 = [];
    if (t3 && n2.push(t3), r3 && n2.push(r3), n2.length && await Promise.all(n2.map(o2)), !self.ModuleFactory)
      throw new Error("ModuleFactory not set.");
    if (self.Module && a3) {
      const e4 = self.Module;
      e4.locateFile = a3.locateFile, a3.mainScriptUrlOrBlob && (e4.mainScriptUrlOrBlob = a3.mainScriptUrlOrBlob);
    }
    const s2 = await self.ModuleFactory(self.Module || a3);
    return self.ModuleFactory = self.Module = void 0, new e3(s2, i4);
  }
  e2.GraphRunner = r2, e2.createMediaPipeLib = i3, e2.createGraphRunner = async function(e3, t3, o3, a3) {
    return i3(r2, e3, t3, o3, a3);
  };
}(graph_runner);
var register_model_resources_graph_service = {};
function SupportModelResourcesGraphService(e2) {
  return class extends e2 {
    registerModelResourcesGraphService() {
      this.wasmModule._registerModelResourcesGraphService();
    }
  };
}
Object.defineProperty(register_model_resources_graph_service, "__esModule", { value: true }), register_model_resources_graph_service.SupportModelResourcesGraphService = void 0, register_model_resources_graph_service.SupportModelResourcesGraphService = SupportModelResourcesGraphService, Object.defineProperty(task_runner, "__esModule", { value: true }), task_runner.TaskRunner = task_runner.createTaskRunner = task_runner.CachedGraphRunner = void 0;
var inference_calculator_pb_1 = inference_calculator_pb;
var calculator_pb_1 = calculator_pb;
var acceleration_pb_1 = acceleration_pb;
var external_file_pb_1 = external_file_pb;
var graph_runner_1$1 = graph_runner;
var register_model_resources_graph_service_1$1 = register_model_resources_graph_service;
var NO_ASSETS = void 0;
var FREE_MEMORY_STREAM = "free_memory";
var UNUSED_STREAM_SUFFIX = "_unused_out";
var CachedGraphRunnerType = (0, register_model_resources_graph_service_1$1.SupportModelResourcesGraphService)(graph_runner_1$1.GraphRunner);
var CachedGraphRunner = class extends CachedGraphRunnerType {
};
async function createTaskRunner(e2, t2, r2, o2) {
  const i3 = { locateFile: () => r2.wasmBinaryPath.toString() }, a3 = await (0, graph_runner_1$1.createMediaPipeLib)(e2, r2.wasmLoaderPath, NO_ASSETS, t2, i3);
  return await a3.setOptions(o2), a3;
}
task_runner.CachedGraphRunner = CachedGraphRunner, task_runner.createTaskRunner = createTaskRunner;
var TaskRunner = class {
  static async createInstance(e2, t2, r2, o2) {
    return createTaskRunner(e2, t2, r2, o2);
  }
  constructor(e2) {
    this.graphRunner = e2, this.processingErrors = [], this.latestOutputTimestamp = 0, this.graphRunner.setAutoRenderToScreen(false);
  }
  applyOptions(e2) {
    var t2, r2, o2, i3, a3, n2;
    const s2 = e2.baseOptions || {};
    if ((null === (t2 = e2.baseOptions) || void 0 === t2 ? void 0 : t2.modelAssetBuffer) && (null === (r2 = e2.baseOptions) || void 0 === r2 ? void 0 : r2.modelAssetPath))
      throw new Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
    if (!((null === (o2 = this.baseOptions.getModelAsset()) || void 0 === o2 ? void 0 : o2.hasFileContent()) || (null === (i3 = this.baseOptions.getModelAsset()) || void 0 === i3 ? void 0 : i3.hasFileName()) || (null === (a3 = e2.baseOptions) || void 0 === a3 ? void 0 : a3.modelAssetBuffer) || (null === (n2 = e2.baseOptions) || void 0 === n2 ? void 0 : n2.modelAssetPath)))
      throw new Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
    return this.setAcceleration(s2), s2.modelAssetPath ? fetch(s2.modelAssetPath.toString()).then((e3) => {
      if (e3.ok)
        return e3.arrayBuffer();
      throw new Error(`Failed to fetch model: ${s2.modelAssetPath} (${e3.status})`);
    }).then((e3) => {
      try {
        this.graphRunner.wasmModule.FS_unlink("/model.dat");
      } catch (e4) {
      }
      this.graphRunner.wasmModule.FS_createDataFile("/", "model.dat", new Uint8Array(e3), true, false, false), this.setExternalFile("/model.dat"), this.refreshGraph(), this.onGraphRefreshed();
    }) : (this.setExternalFile(s2.modelAssetBuffer), this.refreshGraph(), this.onGraphRefreshed(), Promise.resolve());
  }
  onGraphRefreshed() {
  }
  getCalculatorGraphConfig() {
    let e2;
    if (this.graphRunner.getCalculatorGraphConfig((t2) => {
      e2 = calculator_pb_1.CalculatorGraphConfig.deserializeBinary(t2);
    }), !e2)
      throw new Error("Failed to retrieve CalculatorGraphConfig");
    return e2;
  }
  setGraph(e2, t2) {
    this.graphRunner.attachErrorListener((e3, t3) => {
      this.processingErrors.push(new Error(t3));
    }), this.graphRunner.registerModelResourcesGraphService(), this.graphRunner.setGraph(e2, t2), this.keepaliveNode = void 0, this.handleErrors();
  }
  finishProcessing() {
    this.graphRunner.finishProcessing(), this.handleErrors();
  }
  setLatestOutputTimestamp(e2) {
    this.latestOutputTimestamp = Math.max(this.latestOutputTimestamp, e2);
  }
  getSynctheticTimestamp() {
    return this.latestOutputTimestamp + 1;
  }
  handleErrors() {
    try {
      const e2 = this.processingErrors.length;
      if (1 === e2)
        throw new Error(this.processingErrors[0].message);
      if (e2 > 1)
        throw new Error("Encountered multiple errors: " + this.processingErrors.map((e3) => e3.message).join(", "));
    } finally {
      this.processingErrors = [];
    }
  }
  setExternalFile(e2) {
    const t2 = this.baseOptions.getModelAsset() || new external_file_pb_1.ExternalFile();
    "string" == typeof e2 ? (t2.setFileName(e2), t2.clearFileContent()) : e2 instanceof Uint8Array && (t2.setFileContent(e2), t2.clearFileName()), this.baseOptions.setModelAsset(t2);
  }
  setAcceleration(e2) {
    let t2 = this.baseOptions.getAcceleration();
    t2 || (t2 = new acceleration_pb_1.Acceleration(), t2.setTflite(new inference_calculator_pb_1.InferenceCalculatorOptions.Delegate.TfLite())), "delegate" in e2 && ("GPU" === e2.delegate ? t2.setGpu(new inference_calculator_pb_1.InferenceCalculatorOptions.Delegate.Gpu()) : t2.setTflite(new inference_calculator_pb_1.InferenceCalculatorOptions.Delegate.TfLite())), this.baseOptions.setAcceleration(t2);
  }
  addKeepaliveNode(e2) {
    this.keepaliveNode = new calculator_pb_1.CalculatorGraphConfig.Node(), this.keepaliveNode.setCalculator("PassThroughCalculator"), this.keepaliveNode.addInputStream(FREE_MEMORY_STREAM), this.keepaliveNode.addOutputStream(FREE_MEMORY_STREAM + UNUSED_STREAM_SUFFIX), e2.addInputStream(FREE_MEMORY_STREAM), e2.addNode(this.keepaliveNode);
  }
  keepStreamAlive(e2) {
    this.keepaliveNode.addInputStream(e2), this.keepaliveNode.addOutputStream(e2 + UNUSED_STREAM_SUFFIX);
  }
  freeKeepaliveStreams() {
    this.graphRunner.addBoolToStream(true, FREE_MEMORY_STREAM, this.latestOutputTimestamp);
  }
  close() {
    this.keepaliveNode = void 0, this.graphRunner.closeGraph();
  }
};
task_runner.TaskRunner = TaskRunner;
var graph_runner_image_lib = {};
function SupportImage(e2) {
  return class extends e2 {
    get wasmImageModule() {
      return this.wasmModule;
    }
    addGpuBufferAsImageToStream(e3, t2, r2) {
      this.wrapStringPtr(t2, (t3) => {
        const [o2, i3] = this.bindTextureToStream(e3, t3);
        this.wasmImageModule._addBoundTextureAsImageToStream(t3, o2, i3, r2);
      });
    }
    attachImageListener(e3, t2) {
      this.setListener(e3, t2), this.wrapStringPtr(e3, (e4) => {
        this.wasmImageModule._attachImageListener(e4);
      });
    }
    attachImageVectorListener(e3, t2) {
      this.setVectorListener(e3, t2), this.wrapStringPtr(e3, (e4) => {
        this.wasmImageModule._attachImageVectorListener(e4);
      });
    }
  };
}
Object.defineProperty(graph_runner_image_lib, "__esModule", { value: true }), graph_runner_image_lib.SupportImage = void 0, graph_runner_image_lib.SupportImage = SupportImage, Object.defineProperty(vision_task_runner, "__esModule", { value: true }), vision_task_runner.VisionTaskRunner = vision_task_runner.VisionGraphRunner = void 0;
var rect_pb_1 = rect_pb;
var task_runner_1 = task_runner;
var image_1$1 = image;
var image_shader_context_1 = image_shader_context;
var mask_1$1 = mask;
var graph_runner_1 = graph_runner;
var graph_runner_image_lib_1 = graph_runner_image_lib;
var platform_utils_1 = platform_utils;
var register_model_resources_graph_service_1 = register_model_resources_graph_service;
var GraphRunnerVisionType = (0, register_model_resources_graph_service_1.SupportModelResourcesGraphService)((0, graph_runner_image_lib_1.SupportImage)(graph_runner_1.GraphRunner));
var VisionGraphRunner = class extends GraphRunnerVisionType {
};
function createCanvas() {
  return "undefined" != typeof OffscreenCanvas && !(0, platform_utils_1.isWebKit)() ? void 0 : document.createElement("canvas");
}
vision_task_runner.VisionGraphRunner = VisionGraphRunner;
var VisionTaskRunner = class extends task_runner_1.TaskRunner {
  static async createVisionInstance(e2, t2, r2) {
    var o2;
    const i3 = null !== (o2 = r2.canvas) && void 0 !== o2 ? o2 : createCanvas();
    return task_runner_1.TaskRunner.createInstance(e2, i3, t2, r2);
  }
  constructor(e2, t2, r2, o2) {
    super(e2), this.graphRunner = e2, this.imageStreamName = t2, this.normRectStreamName = r2, this.roiAllowed = o2, this.shaderContext = new image_shader_context_1.MPImageShaderContext();
  }
  applyOptions(e2) {
    if ("runningMode" in e2) {
      const t2 = !!e2.runningMode && "IMAGE" !== e2.runningMode;
      this.baseOptions.setUseStreamMode(t2);
    }
    if (void 0 !== e2.canvas && this.graphRunner.wasmModule.canvas !== e2.canvas)
      throw new Error("You must create a new task to reset the canvas.");
    return super.applyOptions(e2);
  }
  processImageData(e2, t2) {
    var r2;
    if (null === (r2 = this.baseOptions) || void 0 === r2 ? void 0 : r2.getUseStreamMode())
      throw new Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
    this.process(e2, t2, this.getSynctheticTimestamp());
  }
  processVideoData(e2, t2, r2) {
    var o2;
    if (!(null === (o2 = this.baseOptions) || void 0 === o2 ? void 0 : o2.getUseStreamMode()))
      throw new Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
    this.process(e2, t2, r2);
  }
  getImageSourceSize(e2) {
    return void 0 !== e2.videoWidth ? [e2.videoWidth, e2.videoHeight] : void 0 !== e2.naturalWidth ? [e2.naturalWidth, e2.naturalHeight] : [e2.width, e2.height];
  }
  convertToNormalizedRect(e2, t2) {
    const r2 = new rect_pb_1.NormalizedRect();
    if (null == t2 ? void 0 : t2.regionOfInterest) {
      if (!this.roiAllowed)
        throw new Error("This task doesn't support region-of-interest.");
      const e3 = t2.regionOfInterest;
      if (e3.left >= e3.right || e3.top >= e3.bottom)
        throw new Error("Expected RectF with left < right and top < bottom.");
      if (e3.left < 0 || e3.top < 0 || e3.right > 1 || e3.bottom > 1)
        throw new Error("Expected RectF values to be in [0,1].");
      r2.setXCenter((e3.left + e3.right) / 2), r2.setYCenter((e3.top + e3.bottom) / 2), r2.setWidth(e3.right - e3.left), r2.setHeight(e3.bottom - e3.top);
    } else
      r2.setXCenter(0.5), r2.setYCenter(0.5), r2.setWidth(1), r2.setHeight(1);
    if (null == t2 ? void 0 : t2.rotationDegrees) {
      if ((null == t2 ? void 0 : t2.rotationDegrees) % 90 != 0)
        throw new Error("Expected rotation to be a multiple of 90°.");
      if (r2.setRotation(-Math.PI * t2.rotationDegrees / 180), (null == t2 ? void 0 : t2.rotationDegrees) % 180 != 0) {
        const [t3, o2] = this.getImageSourceSize(e2), i3 = r2.getHeight() * o2 / t3, a3 = r2.getWidth() * t3 / o2;
        r2.setWidth(i3), r2.setHeight(a3);
      }
    }
    return r2;
  }
  process(e2, t2, r2) {
    const o2 = this.convertToNormalizedRect(e2, t2);
    this.graphRunner.addProtoToStream(o2.serializeBinary(), "mediapipe.NormalizedRect", this.normRectStreamName, r2), this.graphRunner.addGpuBufferAsImageToStream(e2, this.imageStreamName, null != r2 ? r2 : performance.now()), this.finishProcessing();
  }
  convertToMPImage(e2, t2) {
    const { data: r2, width: o2, height: i3 } = e2, a3 = o2 * i3;
    let n2;
    if (r2 instanceof Uint8Array)
      if (r2.length === 3 * a3) {
        const e3 = new Uint8ClampedArray(4 * a3);
        for (let t3 = 0; t3 < a3; ++t3)
          e3[4 * t3] = r2[3 * t3], e3[4 * t3 + 1] = r2[3 * t3 + 1], e3[4 * t3 + 2] = r2[3 * t3 + 2], e3[4 * t3 + 3] = 255;
        n2 = new ImageData(e3, o2, i3);
      } else {
        if (r2.length !== 4 * a3)
          throw new Error("Unsupported channel count: " + r2.length / a3);
        n2 = new ImageData(new Uint8ClampedArray(r2.buffer, r2.byteOffset, r2.length), o2, i3);
      }
    else {
      if (!(r2 instanceof WebGLTexture))
        throw new Error(`Unsupported format: ${r2.constructor.name}`);
      n2 = r2;
    }
    const s2 = new image_1$1.MPImage([n2], false, false, this.graphRunner.wasmModule.canvas, this.shaderContext, o2, i3);
    return t2 ? s2.clone() : s2;
  }
  convertToMPMask(e2, t2) {
    const { data: r2, width: o2, height: i3 } = e2, a3 = o2 * i3;
    let n2;
    if (r2 instanceof Uint8Array || r2 instanceof Float32Array) {
      if (r2.length !== a3)
        throw new Error("Unsupported channel count: " + r2.length / a3);
      n2 = r2;
    } else
      n2 = r2;
    const s2 = new mask_1$1.MPMask([n2], false, this.graphRunner.wasmModule.canvas, this.shaderContext, o2, i3);
    return t2 ? s2.clone() : s2;
  }
  close() {
    this.shaderContext.close(), super.close();
  }
};
vision_task_runner.VisionTaskRunner = VisionTaskRunner;
var face_detector_options = {};
Object.defineProperty(face_detector_options, "__esModule", { value: true });
var face_detector_result = {};
Object.defineProperty(face_detector_result, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.FaceDetector = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = detection_pb, n2 = base_options_pb, s2 = face_detector_graph_options_pb, p = detection_result, d2 = vision_task_runner, l2 = "image_in", g = "norm_rect_in", c6 = "detections";
  r2(face_detector_options, e2), r2(face_detector_result, e2);
  class u extends d2.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return d2.VisionTaskRunner.createVisionInstance(u, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return d2.VisionTaskRunner.createVisionInstance(u, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static async createFromModelPath(e3, t3) {
      return d2.VisionTaskRunner.createVisionInstance(u, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new d2.VisionGraphRunner(e3, t3), l2, g, false), this.result = { detections: [] }, this.options = new s2.FaceDetectorGraphOptions(), this.options.setBaseOptions(new n2.BaseOptions()), this.options.setMinDetectionConfidence(0.5), this.options.setMinSuppressionThreshold(0.3);
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      var t3, r3;
      return "minDetectionConfidence" in e3 && this.options.setMinDetectionConfidence(null !== (t3 = e3.minDetectionConfidence) && void 0 !== t3 ? t3 : 0.5), "minSuppressionThreshold" in e3 && this.options.setMinSuppressionThreshold(null !== (r3 = e3.minSuppressionThreshold) && void 0 !== r3 ? r3 : 0.3), this.applyOptions(e3);
    }
    detect(e3, t3) {
      return this.result = { detections: [] }, this.processImageData(e3, t3), this.result;
    }
    detectForVideo(e3, t3, r3) {
      return this.result = { detections: [] }, this.processVideoData(e3, r3, t3), this.result;
    }
    addJsFaceDetections(e3) {
      for (const t3 of e3) {
        const e4 = a3.Detection.deserializeBinary(t3);
        this.result.detections.push((0, p.convertFromDetectionProto)(e4));
      }
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(l2), e3.addInputStream(g), e3.addOutputStream(c6);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(s2.FaceDetectorGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.face_detector.FaceDetectorGraph"), r3.addInputStream("IMAGE:" + l2), r3.addInputStream("NORM_RECT:" + g), r3.addOutputStream("DETECTIONS:" + c6), r3.setOptions(t3), e3.addNode(r3), this.graphRunner.attachProtoVectorListener(c6, (e4, t4) => {
        this.addJsFaceDetections(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(c6, (e4) => {
        this.setLatestOutputTimestamp(e4);
      });
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
  }
  e2.FaceDetector = u;
}(face_detector);
var face_landmarker = {};
var classification_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.Classification", null, o2), r2.exportSymbol("proto.mediapipe.ClassificationList", null, o2), r2.exportSymbol("proto.mediapipe.ClassificationListCollection", null, o2), proto.mediapipe.Classification = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.Classification, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.Classification.displayName = "proto.mediapipe.Classification"), proto.mediapipe.ClassificationList = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.ClassificationList.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.ClassificationList, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.ClassificationList.displayName = "proto.mediapipe.ClassificationList"), proto.mediapipe.ClassificationListCollection = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.ClassificationListCollection.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.ClassificationListCollection, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.ClassificationListCollection.displayName = "proto.mediapipe.ClassificationListCollection"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.Classification.prototype.toObject = function(e3) {
    return proto.mediapipe.Classification.toObject(e3, this);
  }, proto.mediapipe.Classification.toObject = function(e3, r3) {
    var o3, i3 = { index: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, score: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, label: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3, displayName: null == (o3 = t2.Message.getField(r3, 4)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.Classification.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.Classification();
    return proto.mediapipe.Classification.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.Classification.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt32();
          e3.setIndex(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setScore(r3);
          break;
        case 3:
          r3 = t3.readString();
          e3.setLabel(r3);
          break;
        case 4:
          r3 = t3.readString();
          e3.setDisplayName(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.Classification.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.Classification.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.Classification.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeString(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeString(4, o3);
  }, proto.mediapipe.Classification.prototype.getIndex = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.Classification.prototype.setIndex = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.Classification.prototype.clearIndex = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.Classification.prototype.hasIndex = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.Classification.prototype.getScore = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.Classification.prototype.setScore = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.Classification.prototype.clearScore = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.Classification.prototype.hasScore = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.Classification.prototype.getLabel = function() {
    return t2.Message.getFieldWithDefault(this, 3, "");
  }, proto.mediapipe.Classification.prototype.setLabel = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.Classification.prototype.clearLabel = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.Classification.prototype.hasLabel = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.Classification.prototype.getDisplayName = function() {
    return t2.Message.getFieldWithDefault(this, 4, "");
  }, proto.mediapipe.Classification.prototype.setDisplayName = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.Classification.prototype.clearDisplayName = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.Classification.prototype.hasDisplayName = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.ClassificationList.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.ClassificationList.prototype.toObject = function(e3) {
    return proto.mediapipe.ClassificationList.toObject(e3, this);
  }, proto.mediapipe.ClassificationList.toObject = function(e3, r3) {
    var o3 = { classificationList: t2.Message.toObjectList(r3.getClassificationList(), proto.mediapipe.Classification.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.ClassificationList.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.ClassificationList();
    return proto.mediapipe.ClassificationList.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.ClassificationList.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.Classification();
        t3.readMessage(r3, proto.mediapipe.Classification.deserializeBinaryFromReader), e3.addClassification(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.ClassificationList.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.ClassificationList.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.ClassificationList.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getClassificationList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.Classification.serializeBinaryToWriter);
  }, proto.mediapipe.ClassificationList.prototype.getClassificationList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.Classification, 1);
  }, proto.mediapipe.ClassificationList.prototype.setClassificationList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.ClassificationList.prototype.addClassification = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.Classification, r3);
  }, proto.mediapipe.ClassificationList.prototype.clearClassificationList = function() {
    return this.setClassificationList([]);
  }, proto.mediapipe.ClassificationListCollection.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.ClassificationListCollection.prototype.toObject = function(e3) {
    return proto.mediapipe.ClassificationListCollection.toObject(e3, this);
  }, proto.mediapipe.ClassificationListCollection.toObject = function(e3, r3) {
    var o3 = { classificationListList: t2.Message.toObjectList(r3.getClassificationListList(), proto.mediapipe.ClassificationList.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.ClassificationListCollection.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.ClassificationListCollection();
    return proto.mediapipe.ClassificationListCollection.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.ClassificationListCollection.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.ClassificationList();
        t3.readMessage(r3, proto.mediapipe.ClassificationList.deserializeBinaryFromReader), e3.addClassificationList(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.ClassificationListCollection.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.ClassificationListCollection.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.ClassificationListCollection.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getClassificationListList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.ClassificationList.serializeBinaryToWriter);
  }, proto.mediapipe.ClassificationListCollection.prototype.getClassificationListList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.ClassificationList, 1);
  }, proto.mediapipe.ClassificationListCollection.prototype.setClassificationListList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.ClassificationListCollection.prototype.addClassificationList = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.ClassificationList, r3);
  }, proto.mediapipe.ClassificationListCollection.prototype.clearClassificationListList = function() {
    return this.setClassificationListList([]);
  }, r2.object.extend(e2, proto.mediapipe);
}(classification_pb);
var landmark_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.Landmark", null, o2), r2.exportSymbol("proto.mediapipe.LandmarkList", null, o2), r2.exportSymbol("proto.mediapipe.LandmarkListCollection", null, o2), r2.exportSymbol("proto.mediapipe.NormalizedLandmark", null, o2), r2.exportSymbol("proto.mediapipe.NormalizedLandmarkList", null, o2), r2.exportSymbol("proto.mediapipe.NormalizedLandmarkListCollection", null, o2), proto.mediapipe.Landmark = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.Landmark, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.Landmark.displayName = "proto.mediapipe.Landmark"), proto.mediapipe.LandmarkList = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.LandmarkList.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.LandmarkList, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.LandmarkList.displayName = "proto.mediapipe.LandmarkList"), proto.mediapipe.LandmarkListCollection = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.LandmarkListCollection.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.LandmarkListCollection, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.LandmarkListCollection.displayName = "proto.mediapipe.LandmarkListCollection"), proto.mediapipe.NormalizedLandmark = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.NormalizedLandmark, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.NormalizedLandmark.displayName = "proto.mediapipe.NormalizedLandmark"), proto.mediapipe.NormalizedLandmarkList = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.NormalizedLandmarkList.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.NormalizedLandmarkList, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.NormalizedLandmarkList.displayName = "proto.mediapipe.NormalizedLandmarkList"), proto.mediapipe.NormalizedLandmarkListCollection = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.NormalizedLandmarkListCollection.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.NormalizedLandmarkListCollection, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.NormalizedLandmarkListCollection.displayName = "proto.mediapipe.NormalizedLandmarkListCollection"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.Landmark.prototype.toObject = function(e3) {
    return proto.mediapipe.Landmark.toObject(e3, this);
  }, proto.mediapipe.Landmark.toObject = function(e3, r3) {
    var o3, i3 = { x: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, y: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, z: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, visibility: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3, presence: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 5)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.Landmark.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.Landmark();
    return proto.mediapipe.Landmark.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.Landmark.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readFloat();
          e3.setX(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setY(r3);
          break;
        case 3:
          r3 = t3.readFloat();
          e3.setZ(r3);
          break;
        case 4:
          r3 = t3.readFloat();
          e3.setVisibility(r3);
          break;
        case 5:
          r3 = t3.readFloat();
          e3.setPresence(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.Landmark.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.Landmark.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.Landmark.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeFloat(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeFloat(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeFloat(4, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeFloat(5, o3);
  }, proto.mediapipe.Landmark.prototype.getX = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.Landmark.prototype.setX = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.Landmark.prototype.clearX = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.Landmark.prototype.hasX = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.Landmark.prototype.getY = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.Landmark.prototype.setY = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.Landmark.prototype.clearY = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.Landmark.prototype.hasY = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.Landmark.prototype.getZ = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.Landmark.prototype.setZ = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.Landmark.prototype.clearZ = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.Landmark.prototype.hasZ = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.Landmark.prototype.getVisibility = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.Landmark.prototype.setVisibility = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.Landmark.prototype.clearVisibility = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.Landmark.prototype.hasVisibility = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.Landmark.prototype.getPresence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 5, 0);
  }, proto.mediapipe.Landmark.prototype.setPresence = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.Landmark.prototype.clearPresence = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.Landmark.prototype.hasPresence = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.LandmarkList.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.LandmarkList.prototype.toObject = function(e3) {
    return proto.mediapipe.LandmarkList.toObject(e3, this);
  }, proto.mediapipe.LandmarkList.toObject = function(e3, r3) {
    var o3 = { landmarkList: t2.Message.toObjectList(r3.getLandmarkList(), proto.mediapipe.Landmark.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.LandmarkList.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.LandmarkList();
    return proto.mediapipe.LandmarkList.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.LandmarkList.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.Landmark();
        t3.readMessage(r3, proto.mediapipe.Landmark.deserializeBinaryFromReader), e3.addLandmark(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.LandmarkList.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.LandmarkList.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.LandmarkList.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getLandmarkList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.Landmark.serializeBinaryToWriter);
  }, proto.mediapipe.LandmarkList.prototype.getLandmarkList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.Landmark, 1);
  }, proto.mediapipe.LandmarkList.prototype.setLandmarkList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.LandmarkList.prototype.addLandmark = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.Landmark, r3);
  }, proto.mediapipe.LandmarkList.prototype.clearLandmarkList = function() {
    return this.setLandmarkList([]);
  }, proto.mediapipe.LandmarkListCollection.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.LandmarkListCollection.prototype.toObject = function(e3) {
    return proto.mediapipe.LandmarkListCollection.toObject(e3, this);
  }, proto.mediapipe.LandmarkListCollection.toObject = function(e3, r3) {
    var o3 = { landmarkListList: t2.Message.toObjectList(r3.getLandmarkListList(), proto.mediapipe.LandmarkList.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.LandmarkListCollection.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.LandmarkListCollection();
    return proto.mediapipe.LandmarkListCollection.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.LandmarkListCollection.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.LandmarkList();
        t3.readMessage(r3, proto.mediapipe.LandmarkList.deserializeBinaryFromReader), e3.addLandmarkList(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.LandmarkListCollection.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.LandmarkListCollection.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.LandmarkListCollection.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getLandmarkListList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.LandmarkList.serializeBinaryToWriter);
  }, proto.mediapipe.LandmarkListCollection.prototype.getLandmarkListList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.LandmarkList, 1);
  }, proto.mediapipe.LandmarkListCollection.prototype.setLandmarkListList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.LandmarkListCollection.prototype.addLandmarkList = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.LandmarkList, r3);
  }, proto.mediapipe.LandmarkListCollection.prototype.clearLandmarkListList = function() {
    return this.setLandmarkListList([]);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.NormalizedLandmark.prototype.toObject = function(e3) {
    return proto.mediapipe.NormalizedLandmark.toObject(e3, this);
  }, proto.mediapipe.NormalizedLandmark.toObject = function(e3, r3) {
    var o3, i3 = { x: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, y: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, z: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, visibility: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3, presence: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 5)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.NormalizedLandmark.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.NormalizedLandmark();
    return proto.mediapipe.NormalizedLandmark.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.NormalizedLandmark.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readFloat();
          e3.setX(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setY(r3);
          break;
        case 3:
          r3 = t3.readFloat();
          e3.setZ(r3);
          break;
        case 4:
          r3 = t3.readFloat();
          e3.setVisibility(r3);
          break;
        case 5:
          r3 = t3.readFloat();
          e3.setPresence(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.NormalizedLandmark.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.NormalizedLandmark.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.NormalizedLandmark.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeFloat(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeFloat(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeFloat(4, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeFloat(5, o3);
  }, proto.mediapipe.NormalizedLandmark.prototype.getX = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.setX = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.NormalizedLandmark.prototype.clearX = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.hasX = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.NormalizedLandmark.prototype.getY = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.setY = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.NormalizedLandmark.prototype.clearY = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.hasY = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.NormalizedLandmark.prototype.getZ = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.setZ = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.NormalizedLandmark.prototype.clearZ = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.hasZ = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.NormalizedLandmark.prototype.getVisibility = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.setVisibility = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.NormalizedLandmark.prototype.clearVisibility = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.hasVisibility = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.NormalizedLandmark.prototype.getPresence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 5, 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.setPresence = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.NormalizedLandmark.prototype.clearPresence = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.NormalizedLandmark.prototype.hasPresence = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.NormalizedLandmarkList.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.NormalizedLandmarkList.prototype.toObject = function(e3) {
    return proto.mediapipe.NormalizedLandmarkList.toObject(e3, this);
  }, proto.mediapipe.NormalizedLandmarkList.toObject = function(e3, r3) {
    var o3 = { landmarkList: t2.Message.toObjectList(r3.getLandmarkList(), proto.mediapipe.NormalizedLandmark.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.NormalizedLandmarkList.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.NormalizedLandmarkList();
    return proto.mediapipe.NormalizedLandmarkList.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.NormalizedLandmarkList.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.NormalizedLandmark();
        t3.readMessage(r3, proto.mediapipe.NormalizedLandmark.deserializeBinaryFromReader), e3.addLandmark(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.NormalizedLandmarkList.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.NormalizedLandmarkList.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.NormalizedLandmarkList.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getLandmarkList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.NormalizedLandmark.serializeBinaryToWriter);
  }, proto.mediapipe.NormalizedLandmarkList.prototype.getLandmarkList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.NormalizedLandmark, 1);
  }, proto.mediapipe.NormalizedLandmarkList.prototype.setLandmarkList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.NormalizedLandmarkList.prototype.addLandmark = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.NormalizedLandmark, r3);
  }, proto.mediapipe.NormalizedLandmarkList.prototype.clearLandmarkList = function() {
    return this.setLandmarkList([]);
  }, proto.mediapipe.NormalizedLandmarkListCollection.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.NormalizedLandmarkListCollection.prototype.toObject = function(e3) {
    return proto.mediapipe.NormalizedLandmarkListCollection.toObject(e3, this);
  }, proto.mediapipe.NormalizedLandmarkListCollection.toObject = function(e3, r3) {
    var o3 = { landmarkListList: t2.Message.toObjectList(r3.getLandmarkListList(), proto.mediapipe.NormalizedLandmarkList.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.NormalizedLandmarkListCollection.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.NormalizedLandmarkListCollection();
    return proto.mediapipe.NormalizedLandmarkListCollection.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.NormalizedLandmarkListCollection.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.NormalizedLandmarkList();
        t3.readMessage(r3, proto.mediapipe.NormalizedLandmarkList.deserializeBinaryFromReader), e3.addLandmarkList(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.NormalizedLandmarkListCollection.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.NormalizedLandmarkListCollection.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.NormalizedLandmarkListCollection.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getLandmarkListList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.NormalizedLandmarkList.serializeBinaryToWriter);
  }, proto.mediapipe.NormalizedLandmarkListCollection.prototype.getLandmarkListList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.NormalizedLandmarkList, 1);
  }, proto.mediapipe.NormalizedLandmarkListCollection.prototype.setLandmarkListList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.NormalizedLandmarkListCollection.prototype.addLandmarkList = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.NormalizedLandmarkList, r3);
  }, proto.mediapipe.NormalizedLandmarkListCollection.prototype.clearLandmarkListList = function() {
    return this.setLandmarkListList([]);
  }, r2.object.extend(e2, proto.mediapipe);
}(landmark_pb);
var face_geometry_pb = {};
var matrix_data_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.MatrixData", null, o2), r2.exportSymbol("proto.mediapipe.MatrixData.Layout", null, o2), proto.mediapipe.MatrixData = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.MatrixData.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.MatrixData, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.MatrixData.displayName = "proto.mediapipe.MatrixData"), proto.mediapipe.MatrixData.repeatedFields_ = [3], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.MatrixData.prototype.toObject = function(e3) {
    return proto.mediapipe.MatrixData.toObject(e3, this);
  }, proto.mediapipe.MatrixData.toObject = function(e3, r3) {
    var o3, i3 = { rows: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, cols: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, packedDataList: null == (o3 = t2.Message.getRepeatedFloatingPointField(r3, 3)) ? void 0 : o3, layout: t2.Message.getFieldWithDefault(r3, 4, 0) };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.MatrixData.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.MatrixData();
    return proto.mediapipe.MatrixData.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.MatrixData.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt32();
          e3.setRows(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setCols(r3);
          break;
        case 3:
          for (var o3 = t3.isDelimited() ? t3.readPackedFloat() : [t3.readFloat()], i3 = 0; i3 < o3.length; i3++)
            e3.addPackedData(o3[i3]);
          break;
        case 4:
          r3 = t3.readEnum();
          e3.setLayout(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.MatrixData.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.MatrixData.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.MatrixData.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), (o3 = e3.getPackedDataList()).length > 0 && r3.writePackedFloat(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeEnum(4, o3);
  }, proto.mediapipe.MatrixData.Layout = { COLUMN_MAJOR: 0, ROW_MAJOR: 1 }, proto.mediapipe.MatrixData.prototype.getRows = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.MatrixData.prototype.setRows = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.MatrixData.prototype.clearRows = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.MatrixData.prototype.hasRows = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.MatrixData.prototype.getCols = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.MatrixData.prototype.setCols = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.MatrixData.prototype.clearCols = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.MatrixData.prototype.hasCols = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.MatrixData.prototype.getPackedDataList = function() {
    return t2.Message.getRepeatedFloatingPointField(this, 3);
  }, proto.mediapipe.MatrixData.prototype.setPackedDataList = function(e3) {
    return t2.Message.setField(this, 3, e3 || []);
  }, proto.mediapipe.MatrixData.prototype.addPackedData = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 3, e3, r3);
  }, proto.mediapipe.MatrixData.prototype.clearPackedDataList = function() {
    return this.setPackedDataList([]);
  }, proto.mediapipe.MatrixData.prototype.getLayout = function() {
    return t2.Message.getFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.MatrixData.prototype.setLayout = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.MatrixData.prototype.clearLayout = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.MatrixData.prototype.hasLayout = function() {
    return null != t2.Message.getField(this, 4);
  }, r2.object.extend(e2, proto.mediapipe);
}(matrix_data_pb);
var mesh_3d_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d", null, o2), r2.exportSymbol("proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.PrimitiveType", null, o2), r2.exportSymbol("proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.VertexType", null, o2), proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.displayName = "proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d"), proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.repeatedFields_ = [3, 4], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.toObject = function(e3, r3) {
    var o3, i3 = { vertexType: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, primitiveType: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, vertexBufferList: null == (o3 = t2.Message.getRepeatedFloatingPointField(r3, 3)) ? void 0 : o3, indexBufferList: null == (o3 = t2.Message.getRepeatedField(r3, 4)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d();
    return proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readEnum();
          e3.setVertexType(r3);
          break;
        case 2:
          r3 = t3.readEnum();
          e3.setPrimitiveType(r3);
          break;
        case 3:
          for (var o3 = t3.isDelimited() ? t3.readPackedFloat() : [t3.readFloat()], i3 = 0; i3 < o3.length; i3++)
            e3.addVertexBuffer(o3[i3]);
          break;
        case 4:
          for (o3 = t3.isDelimited() ? t3.readPackedUint32() : [t3.readUint32()], i3 = 0; i3 < o3.length; i3++)
            e3.addIndexBuffer(o3[i3]);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeEnum(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeEnum(2, o3), (o3 = e3.getVertexBufferList()).length > 0 && r3.writeRepeatedFloat(3, o3), (o3 = e3.getIndexBufferList()).length > 0 && r3.writeRepeatedUint32(4, o3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.VertexType = { VERTEX_PT: 0 }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.PrimitiveType = { TRIANGLE: 0 }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.getVertexType = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.setVertexType = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.clearVertexType = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.hasVertexType = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.getPrimitiveType = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.setPrimitiveType = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.clearPrimitiveType = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.hasPrimitiveType = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.getVertexBufferList = function() {
    return t2.Message.getRepeatedFloatingPointField(this, 3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.setVertexBufferList = function(e3) {
    return t2.Message.setField(this, 3, e3 || []);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.addVertexBuffer = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 3, e3, r3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.clearVertexBufferList = function() {
    return this.setVertexBufferList([]);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.getIndexBufferList = function() {
    return t2.Message.getRepeatedField(this, 4);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.setIndexBufferList = function(e3) {
    return t2.Message.setField(this, 4, e3 || []);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.addIndexBuffer = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 4, e3, r3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.Mesh3d.prototype.clearIndexBufferList = function() {
    return this.setIndexBufferList([]);
  }, r2.object.extend(e2, proto.mediapipe.tasks.vision.face_geometry.proto);
}(mesh_3d_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = matrix_data_pb;
  r2.object.extend(proto, i3);
  var a3 = mesh_3d_pb;
  r2.object.extend(proto, a3), r2.exportSymbol("proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry", null, o2), proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.displayName = "proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.toObject = function(e3, t3) {
    var r3, o3 = { mesh: (r3 = t3.getMesh()) && a3.Mesh3d.toObject(e3, r3), poseTransformMatrix: (r3 = t3.getPoseTransformMatrix()) && i3.MatrixData.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry();
    return proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new a3.Mesh3d();
          t3.readMessage(r3, a3.Mesh3d.deserializeBinaryFromReader), e3.setMesh(r3);
          break;
        case 2:
          r3 = new i3.MatrixData();
          t3.readMessage(r3, i3.MatrixData.deserializeBinaryFromReader), e3.setPoseTransformMatrix(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getMesh()) && t3.writeMessage(1, r3, a3.Mesh3d.serializeBinaryToWriter), null != (r3 = e3.getPoseTransformMatrix()) && t3.writeMessage(2, r3, i3.MatrixData.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.getMesh = function() {
    return t2.Message.getWrapperField(this, a3.Mesh3d, 1);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.setMesh = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.clearMesh = function() {
    return this.setMesh(void 0);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.hasMesh = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.getPoseTransformMatrix = function() {
    return t2.Message.getWrapperField(this, i3.MatrixData, 2);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.setPoseTransformMatrix = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.clearPoseTransformMatrix = function() {
    return this.setPoseTransformMatrix(void 0);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometry.prototype.hasPoseTransformMatrix = function() {
    return null != t2.Message.getField(this, 2);
  }, r2.object.extend(e2, proto.mediapipe.tasks.vision.face_geometry.proto);
}(face_geometry_pb);
var face_landmarker_graph_options_pb = {};
var face_geometry_graph_options_pb = {};
var geometry_pipeline_calculator_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_options_pb;
  r2.object.extend(proto, i3);
  var a3 = external_file_pb;
  r2.object.extend(proto, a3), r2.exportSymbol("proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions", null, o2), proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.displayName = "proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.toObject = function(e3, t3) {
    var r3, o3 = { metadataFile: (r3 = t3.getMetadataFile()) && a3.ExternalFile.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions();
    return proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new a3.ExternalFile();
        t3.readMessage(r3, a3.ExternalFile.deserializeBinaryFromReader), e3.setMetadataFile(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    null != (r3 = e3.getMetadataFile()) && t3.writeMessage(1, r3, a3.ExternalFile.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.ext = new t2.ExtensionFieldInfo(512499200, { ext: 0 }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.toObject, 0), i3.CalculatorOptions.extensionsBinary[512499200] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.deserializeBinaryFromReader, false), i3.CalculatorOptions.extensions[512499200] = proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.ext, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.prototype.getMetadataFile = function() {
    return t2.Message.getWrapperField(this, a3.ExternalFile, 1);
  }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.prototype.setMetadataFile = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.prototype.clearMetadataFile = function() {
    return this.setMetadataFile(void 0);
  }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.prototype.hasMetadataFile = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.ext = new t2.ExtensionFieldInfo(512499200, { ext: 0 }, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.toObject, 0), i3.CalculatorOptions.extensionsBinary[512499200] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.deserializeBinaryFromReader, false), i3.CalculatorOptions.extensions[512499200] = proto.mediapipe.tasks.vision.face_geometry.FaceGeometryPipelineCalculatorOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.face_geometry);
}(geometry_pipeline_calculator_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_options_pb;
  r2.object.extend(proto, i3);
  var a3 = geometry_pipeline_calculator_pb;
  r2.object.extend(proto, a3), r2.exportSymbol("proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions", null, o2), proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.displayName = "proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.toObject = function(e3, t3) {
    var r3, o3 = { geometryPipelineOptions: (r3 = t3.getGeometryPipelineOptions()) && a3.FaceGeometryPipelineCalculatorOptions.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions();
    return proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new a3.FaceGeometryPipelineCalculatorOptions();
        t3.readMessage(r3, a3.FaceGeometryPipelineCalculatorOptions.deserializeBinaryFromReader), e3.setGeometryPipelineOptions(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    null != (r3 = e3.getGeometryPipelineOptions()) && t3.writeMessage(1, r3, a3.FaceGeometryPipelineCalculatorOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.ext = new t2.ExtensionFieldInfo(515723506, { ext: 0 }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.toObject, 0), i3.CalculatorOptions.extensionsBinary[515723506] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.deserializeBinaryFromReader, false), i3.CalculatorOptions.extensions[515723506] = proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.ext, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.prototype.getGeometryPipelineOptions = function() {
    return t2.Message.getWrapperField(this, a3.FaceGeometryPipelineCalculatorOptions, 1);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.prototype.setGeometryPipelineOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.prototype.clearGeometryPipelineOptions = function() {
    return this.setGeometryPipelineOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.prototype.hasGeometryPipelineOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.ext = new t2.ExtensionFieldInfo(515723506, { ext: 0 }, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.toObject, 0), i3.CalculatorOptions.extensionsBinary[515723506] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.deserializeBinaryFromReader, false), i3.CalculatorOptions.extensions[515723506] = proto.mediapipe.tasks.vision.face_geometry.proto.FaceGeometryGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.face_geometry.proto);
}(face_geometry_graph_options_pb);
var face_landmarks_detector_graph_options_pb = {};
var face_blendshapes_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2), r2.exportSymbol("proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions", null, o2), proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.displayName = "proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.toObject = function(e3, t3) {
    var r3, o3 = { baseOptions: (r3 = t3.getBaseOptions()) && n2.BaseOptions.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions();
    return proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new n2.BaseOptions();
        t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    null != (r3 = e3.getBaseOptions()) && t3.writeMessage(1, r3, n2.BaseOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.ext = new t2.ExtensionFieldInfo(508981768, { ext: 0 }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[508981768] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[508981768] = proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.ext, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.ext = new t2.ExtensionFieldInfo(508981768, { ext: 0 }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[508981768] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[508981768] = proto.mediapipe.tasks.vision.face_landmarker.proto.FaceBlendshapesGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.face_landmarker.proto);
}(face_blendshapes_graph_options_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2);
  var s2 = face_blendshapes_graph_options_pb;
  r2.object.extend(proto, s2), r2.exportSymbol("proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions", null, o2), proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.displayName = "proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), minDetectionConfidence: t2.Message.getFloatingPointFieldWithDefault(r3, 2, 0.5), smoothLandmarks: null == (o3 = t2.Message.getBooleanField(r3, 4)) ? void 0 : o3, faceBlendshapesGraphOptions: (o3 = r3.getFaceBlendshapesGraphOptions()) && s2.FaceBlendshapesGraphOptions.toObject(e3, o3) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions();
    return proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setMinDetectionConfidence(r3);
          break;
        case 4:
          r3 = t3.readBool();
          e3.setSmoothLandmarks(r3);
          break;
        case 3:
          r3 = new s2.FaceBlendshapesGraphOptions();
          t3.readMessage(r3, s2.FaceBlendshapesGraphOptions.deserializeBinaryFromReader), e3.setFaceBlendshapesGraphOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeBool(4, o3), null != (o3 = e3.getFaceBlendshapesGraphOptions()) && r3.writeMessage(3, o3, s2.FaceBlendshapesGraphOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(508968149, { ext: 0 }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[508968149] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[508968149] = proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.ext, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.getMinDetectionConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0.5);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.setMinDetectionConfidence = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.clearMinDetectionConfidence = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.hasMinDetectionConfidence = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.getSmoothLandmarks = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 4, false);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.setSmoothLandmarks = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.clearSmoothLandmarks = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.hasSmoothLandmarks = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.getFaceBlendshapesGraphOptions = function() {
    return t2.Message.getWrapperField(this, s2.FaceBlendshapesGraphOptions, 3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.setFaceBlendshapesGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.clearFaceBlendshapesGraphOptions = function() {
    return this.setFaceBlendshapesGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.prototype.hasFaceBlendshapesGraphOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(508968149, { ext: 0 }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[508968149] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[508968149] = proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarksDetectorGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.face_landmarker.proto);
}(face_landmarks_detector_graph_options_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2);
  var s2 = face_detector_graph_options_pb;
  r2.object.extend(proto, s2);
  var p = face_geometry_graph_options_pb;
  r2.object.extend(proto, p);
  var d2 = face_landmarks_detector_graph_options_pb;
  r2.object.extend(proto, d2), r2.exportSymbol("proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions", null, o2), proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.displayName = "proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), faceDetectorGraphOptions: (o3 = r3.getFaceDetectorGraphOptions()) && s2.FaceDetectorGraphOptions.toObject(e3, o3), faceLandmarksDetectorGraphOptions: (o3 = r3.getFaceLandmarksDetectorGraphOptions()) && d2.FaceLandmarksDetectorGraphOptions.toObject(e3, o3), minTrackingConfidence: t2.Message.getFloatingPointFieldWithDefault(r3, 4, 0.5), faceGeometryGraphOptions: (o3 = r3.getFaceGeometryGraphOptions()) && p.FaceGeometryGraphOptions.toObject(e3, o3) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions();
    return proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = new s2.FaceDetectorGraphOptions();
          t3.readMessage(r3, s2.FaceDetectorGraphOptions.deserializeBinaryFromReader), e3.setFaceDetectorGraphOptions(r3);
          break;
        case 3:
          r3 = new d2.FaceLandmarksDetectorGraphOptions();
          t3.readMessage(r3, d2.FaceLandmarksDetectorGraphOptions.deserializeBinaryFromReader), e3.setFaceLandmarksDetectorGraphOptions(r3);
          break;
        case 4:
          r3 = t3.readFloat();
          e3.setMinTrackingConfidence(r3);
          break;
        case 5:
          r3 = new p.FaceGeometryGraphOptions();
          t3.readMessage(r3, p.FaceGeometryGraphOptions.deserializeBinaryFromReader), e3.setFaceGeometryGraphOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = e3.getFaceDetectorGraphOptions()) && r3.writeMessage(2, o3, s2.FaceDetectorGraphOptions.serializeBinaryToWriter), null != (o3 = e3.getFaceLandmarksDetectorGraphOptions()) && r3.writeMessage(3, o3, d2.FaceLandmarksDetectorGraphOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeFloat(4, o3), null != (o3 = e3.getFaceGeometryGraphOptions()) && r3.writeMessage(5, o3, p.FaceGeometryGraphOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.ext = new t2.ExtensionFieldInfo(508968150, { ext: 0 }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[508968150] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[508968150] = proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.ext, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.getFaceDetectorGraphOptions = function() {
    return t2.Message.getWrapperField(this, s2.FaceDetectorGraphOptions, 2);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.setFaceDetectorGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.clearFaceDetectorGraphOptions = function() {
    return this.setFaceDetectorGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.hasFaceDetectorGraphOptions = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.getFaceLandmarksDetectorGraphOptions = function() {
    return t2.Message.getWrapperField(this, d2.FaceLandmarksDetectorGraphOptions, 3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.setFaceLandmarksDetectorGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.clearFaceLandmarksDetectorGraphOptions = function() {
    return this.setFaceLandmarksDetectorGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.hasFaceLandmarksDetectorGraphOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.getMinTrackingConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0.5);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.setMinTrackingConfidence = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.clearMinTrackingConfidence = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.hasMinTrackingConfidence = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.getFaceGeometryGraphOptions = function() {
    return t2.Message.getWrapperField(this, p.FaceGeometryGraphOptions, 5);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.setFaceGeometryGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 5, e3);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.clearFaceGeometryGraphOptions = function() {
    return this.setFaceGeometryGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.prototype.hasFaceGeometryGraphOptions = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.ext = new t2.ExtensionFieldInfo(508968150, { ext: 0 }, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[508968150] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[508968150] = proto.mediapipe.tasks.vision.face_landmarker.proto.FaceLandmarkerGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.face_landmarker.proto);
}(face_landmarker_graph_options_pb);
var classifier_result = {};
Object.defineProperty(classifier_result, "__esModule", { value: true }), classifier_result.convertFromClassificationResultProto = classifier_result.convertFromClassifications = void 0;
var DEFAULT_INDEX$1 = -1;
var DEFAULT_SCORE = 0;
function convertFromClassifications(e2, t2 = DEFAULT_INDEX$1, r2 = "") {
  return { categories: e2.map((e3) => {
    var t3, r3, o2, i3;
    return { index: null !== (t3 = e3.getIndex()) && void 0 !== t3 ? t3 : DEFAULT_INDEX$1, score: null !== (r3 = e3.getScore()) && void 0 !== r3 ? r3 : DEFAULT_SCORE, categoryName: null !== (o2 = e3.getLabel()) && void 0 !== o2 ? o2 : "", displayName: null !== (i3 = e3.getDisplayName()) && void 0 !== i3 ? i3 : "" };
  }), headIndex: t2, headName: r2 };
}
function convertFromClassificationsProto(e2) {
  var t2, r2;
  return convertFromClassifications(null !== (r2 = null === (t2 = e2.getClassificationList()) || void 0 === t2 ? void 0 : t2.getClassificationList()) && void 0 !== r2 ? r2 : [], e2.getHeadIndex(), e2.getHeadName());
}
function convertFromClassificationResultProto(e2) {
  const t2 = { classifications: e2.getClassificationsList().map((e3) => convertFromClassificationsProto(e3)) };
  return e2.hasTimestampMs() && (t2.timestampMs = e2.getTimestampMs()), t2;
}
classifier_result.convertFromClassifications = convertFromClassifications, classifier_result.convertFromClassificationResultProto = convertFromClassificationResultProto;
var landmark_result = {};
function convertToLandmarks(e2) {
  var t2, r2, o2;
  const i3 = [];
  for (const a3 of e2.getLandmarkList())
    i3.push({ x: null !== (t2 = a3.getX()) && void 0 !== t2 ? t2 : 0, y: null !== (r2 = a3.getY()) && void 0 !== r2 ? r2 : 0, z: null !== (o2 = a3.getZ()) && void 0 !== o2 ? o2 : 0 });
  return i3;
}
function convertToWorldLandmarks(e2) {
  var t2, r2, o2;
  const i3 = [];
  for (const a3 of e2.getLandmarkList())
    i3.push({ x: null !== (t2 = a3.getX()) && void 0 !== t2 ? t2 : 0, y: null !== (r2 = a3.getY()) && void 0 !== r2 ? r2 : 0, z: null !== (o2 = a3.getZ()) && void 0 !== o2 ? o2 : 0 });
  return i3;
}
Object.defineProperty(landmark_result, "__esModule", { value: true }), landmark_result.convertToWorldLandmarks = landmark_result.convertToLandmarks = void 0, landmark_result.convertToLandmarks = convertToLandmarks, landmark_result.convertToWorldLandmarks = convertToWorldLandmarks;
var face_landmarks_connections = {};
var exports2;
exports2 = face_landmarks_connections, Object.defineProperty(exports2, "__esModule", { value: true }), exports2.FACE_LANDMARKS_TESSELATION = exports2.FACE_LANDMARKS_CONTOURS = exports2.FACE_LANDMARKS_FACE_OVAL = exports2.FACE_LANDMARKS_RIGHT_IRIS = exports2.FACE_LANDMARKS_RIGHT_EYEBROW = exports2.FACE_LANDMARKS_RIGHT_EYE = exports2.FACE_LANDMARKS_LEFT_IRIS = exports2.FACE_LANDMARKS_LEFT_EYEBROW = exports2.FACE_LANDMARKS_LEFT_EYE = exports2.FACE_LANDMARKS_LIPS = void 0, exports2.FACE_LANDMARKS_LIPS = [{ start: 61, end: 146 }, { start: 146, end: 91 }, { start: 91, end: 181 }, { start: 181, end: 84 }, { start: 84, end: 17 }, { start: 17, end: 314 }, { start: 314, end: 405 }, { start: 405, end: 321 }, { start: 321, end: 375 }, { start: 375, end: 291 }, { start: 61, end: 185 }, { start: 185, end: 40 }, { start: 40, end: 39 }, { start: 39, end: 37 }, { start: 37, end: 0 }, { start: 0, end: 267 }, { start: 267, end: 269 }, { start: 269, end: 270 }, { start: 270, end: 409 }, { start: 409, end: 291 }, { start: 78, end: 95 }, { start: 95, end: 88 }, { start: 88, end: 178 }, { start: 178, end: 87 }, { start: 87, end: 14 }, { start: 14, end: 317 }, { start: 317, end: 402 }, { start: 402, end: 318 }, { start: 318, end: 324 }, { start: 324, end: 308 }, { start: 78, end: 191 }, { start: 191, end: 80 }, { start: 80, end: 81 }, { start: 81, end: 82 }, { start: 82, end: 13 }, { start: 13, end: 312 }, { start: 312, end: 311 }, { start: 311, end: 310 }, { start: 310, end: 415 }, { start: 415, end: 308 }], exports2.FACE_LANDMARKS_LEFT_EYE = [{ start: 263, end: 249 }, { start: 249, end: 390 }, { start: 390, end: 373 }, { start: 373, end: 374 }, { start: 374, end: 380 }, { start: 380, end: 381 }, { start: 381, end: 382 }, { start: 382, end: 362 }, { start: 263, end: 466 }, { start: 466, end: 388 }, { start: 388, end: 387 }, { start: 387, end: 386 }, { start: 386, end: 385 }, { start: 385, end: 384 }, { start: 384, end: 398 }, { start: 398, end: 362 }], exports2.FACE_LANDMARKS_LEFT_EYEBROW = [{ start: 276, end: 283 }, { start: 283, end: 282 }, { start: 282, end: 295 }, { start: 295, end: 285 }, { start: 300, end: 293 }, { start: 293, end: 334 }, { start: 334, end: 296 }, { start: 296, end: 336 }], exports2.FACE_LANDMARKS_LEFT_IRIS = [{ start: 474, end: 475 }, { start: 475, end: 476 }, { start: 476, end: 477 }, { start: 477, end: 474 }], exports2.FACE_LANDMARKS_RIGHT_EYE = [{ start: 33, end: 7 }, { start: 7, end: 163 }, { start: 163, end: 144 }, { start: 144, end: 145 }, { start: 145, end: 153 }, { start: 153, end: 154 }, { start: 154, end: 155 }, { start: 155, end: 133 }, { start: 33, end: 246 }, { start: 246, end: 161 }, { start: 161, end: 160 }, { start: 160, end: 159 }, { start: 159, end: 158 }, { start: 158, end: 157 }, { start: 157, end: 173 }, { start: 173, end: 133 }], exports2.FACE_LANDMARKS_RIGHT_EYEBROW = [{ start: 46, end: 53 }, { start: 53, end: 52 }, { start: 52, end: 65 }, { start: 65, end: 55 }, { start: 70, end: 63 }, { start: 63, end: 105 }, { start: 105, end: 66 }, { start: 66, end: 107 }], exports2.FACE_LANDMARKS_RIGHT_IRIS = [{ start: 469, end: 470 }, { start: 470, end: 471 }, { start: 471, end: 472 }, { start: 472, end: 469 }], exports2.FACE_LANDMARKS_FACE_OVAL = [{ start: 10, end: 338 }, { start: 338, end: 297 }, { start: 297, end: 332 }, { start: 332, end: 284 }, { start: 284, end: 251 }, { start: 251, end: 389 }, { start: 389, end: 356 }, { start: 356, end: 454 }, { start: 454, end: 323 }, { start: 323, end: 361 }, { start: 361, end: 288 }, { start: 288, end: 397 }, { start: 397, end: 365 }, { start: 365, end: 379 }, { start: 379, end: 378 }, { start: 378, end: 400 }, { start: 400, end: 377 }, { start: 377, end: 152 }, { start: 152, end: 148 }, { start: 148, end: 176 }, { start: 176, end: 149 }, { start: 149, end: 150 }, { start: 150, end: 136 }, { start: 136, end: 172 }, { start: 172, end: 58 }, { start: 58, end: 132 }, { start: 132, end: 93 }, { start: 93, end: 234 }, { start: 234, end: 127 }, { start: 127, end: 162 }, { start: 162, end: 21 }, { start: 21, end: 54 }, { start: 54, end: 103 }, { start: 103, end: 67 }, { start: 67, end: 109 }, { start: 109, end: 10 }], exports2.FACE_LANDMARKS_CONTOURS = [...exports2.FACE_LANDMARKS_LIPS, ...exports2.FACE_LANDMARKS_LEFT_EYE, ...exports2.FACE_LANDMARKS_LEFT_EYEBROW, ...exports2.FACE_LANDMARKS_RIGHT_EYE, ...exports2.FACE_LANDMARKS_RIGHT_EYEBROW, ...exports2.FACE_LANDMARKS_FACE_OVAL], exports2.FACE_LANDMARKS_TESSELATION = [{ start: 127, end: 34 }, { start: 34, end: 139 }, { start: 139, end: 127 }, { start: 11, end: 0 }, { start: 0, end: 37 }, { start: 37, end: 11 }, { start: 232, end: 231 }, { start: 231, end: 120 }, { start: 120, end: 232 }, { start: 72, end: 37 }, { start: 37, end: 39 }, { start: 39, end: 72 }, { start: 128, end: 121 }, { start: 121, end: 47 }, { start: 47, end: 128 }, { start: 232, end: 121 }, { start: 121, end: 128 }, { start: 128, end: 232 }, { start: 104, end: 69 }, { start: 69, end: 67 }, { start: 67, end: 104 }, { start: 175, end: 171 }, { start: 171, end: 148 }, { start: 148, end: 175 }, { start: 118, end: 50 }, { start: 50, end: 101 }, { start: 101, end: 118 }, { start: 73, end: 39 }, { start: 39, end: 40 }, { start: 40, end: 73 }, { start: 9, end: 151 }, { start: 151, end: 108 }, { start: 108, end: 9 }, { start: 48, end: 115 }, { start: 115, end: 131 }, { start: 131, end: 48 }, { start: 194, end: 204 }, { start: 204, end: 211 }, { start: 211, end: 194 }, { start: 74, end: 40 }, { start: 40, end: 185 }, { start: 185, end: 74 }, { start: 80, end: 42 }, { start: 42, end: 183 }, { start: 183, end: 80 }, { start: 40, end: 92 }, { start: 92, end: 186 }, { start: 186, end: 40 }, { start: 230, end: 229 }, { start: 229, end: 118 }, { start: 118, end: 230 }, { start: 202, end: 212 }, { start: 212, end: 214 }, { start: 214, end: 202 }, { start: 83, end: 18 }, { start: 18, end: 17 }, { start: 17, end: 83 }, { start: 76, end: 61 }, { start: 61, end: 146 }, { start: 146, end: 76 }, { start: 160, end: 29 }, { start: 29, end: 30 }, { start: 30, end: 160 }, { start: 56, end: 157 }, { start: 157, end: 173 }, { start: 173, end: 56 }, { start: 106, end: 204 }, { start: 204, end: 194 }, { start: 194, end: 106 }, { start: 135, end: 214 }, { start: 214, end: 192 }, { start: 192, end: 135 }, { start: 203, end: 165 }, { start: 165, end: 98 }, { start: 98, end: 203 }, { start: 21, end: 71 }, { start: 71, end: 68 }, { start: 68, end: 21 }, { start: 51, end: 45 }, { start: 45, end: 4 }, { start: 4, end: 51 }, { start: 144, end: 24 }, { start: 24, end: 23 }, { start: 23, end: 144 }, { start: 77, end: 146 }, { start: 146, end: 91 }, { start: 91, end: 77 }, { start: 205, end: 50 }, { start: 50, end: 187 }, { start: 187, end: 205 }, { start: 201, end: 200 }, { start: 200, end: 18 }, { start: 18, end: 201 }, { start: 91, end: 106 }, { start: 106, end: 182 }, { start: 182, end: 91 }, { start: 90, end: 91 }, { start: 91, end: 181 }, { start: 181, end: 90 }, { start: 85, end: 84 }, { start: 84, end: 17 }, { start: 17, end: 85 }, { start: 206, end: 203 }, { start: 203, end: 36 }, { start: 36, end: 206 }, { start: 148, end: 171 }, { start: 171, end: 140 }, { start: 140, end: 148 }, { start: 92, end: 40 }, { start: 40, end: 39 }, { start: 39, end: 92 }, { start: 193, end: 189 }, { start: 189, end: 244 }, { start: 244, end: 193 }, { start: 159, end: 158 }, { start: 158, end: 28 }, { start: 28, end: 159 }, { start: 247, end: 246 }, { start: 246, end: 161 }, { start: 161, end: 247 }, { start: 236, end: 3 }, { start: 3, end: 196 }, { start: 196, end: 236 }, { start: 54, end: 68 }, { start: 68, end: 104 }, { start: 104, end: 54 }, { start: 193, end: 168 }, { start: 168, end: 8 }, { start: 8, end: 193 }, { start: 117, end: 228 }, { start: 228, end: 31 }, { start: 31, end: 117 }, { start: 189, end: 193 }, { start: 193, end: 55 }, { start: 55, end: 189 }, { start: 98, end: 97 }, { start: 97, end: 99 }, { start: 99, end: 98 }, { start: 126, end: 47 }, { start: 47, end: 100 }, { start: 100, end: 126 }, { start: 166, end: 79 }, { start: 79, end: 218 }, { start: 218, end: 166 }, { start: 155, end: 154 }, { start: 154, end: 26 }, { start: 26, end: 155 }, { start: 209, end: 49 }, { start: 49, end: 131 }, { start: 131, end: 209 }, { start: 135, end: 136 }, { start: 136, end: 150 }, { start: 150, end: 135 }, { start: 47, end: 126 }, { start: 126, end: 217 }, { start: 217, end: 47 }, { start: 223, end: 52 }, { start: 52, end: 53 }, { start: 53, end: 223 }, { start: 45, end: 51 }, { start: 51, end: 134 }, { start: 134, end: 45 }, { start: 211, end: 170 }, { start: 170, end: 140 }, { start: 140, end: 211 }, { start: 67, end: 69 }, { start: 69, end: 108 }, { start: 108, end: 67 }, { start: 43, end: 106 }, { start: 106, end: 91 }, { start: 91, end: 43 }, { start: 230, end: 119 }, { start: 119, end: 120 }, { start: 120, end: 230 }, { start: 226, end: 130 }, { start: 130, end: 247 }, { start: 247, end: 226 }, { start: 63, end: 53 }, { start: 53, end: 52 }, { start: 52, end: 63 }, { start: 238, end: 20 }, { start: 20, end: 242 }, { start: 242, end: 238 }, { start: 46, end: 70 }, { start: 70, end: 156 }, { start: 156, end: 46 }, { start: 78, end: 62 }, { start: 62, end: 96 }, { start: 96, end: 78 }, { start: 46, end: 53 }, { start: 53, end: 63 }, { start: 63, end: 46 }, { start: 143, end: 34 }, { start: 34, end: 227 }, { start: 227, end: 143 }, { start: 123, end: 117 }, { start: 117, end: 111 }, { start: 111, end: 123 }, { start: 44, end: 125 }, { start: 125, end: 19 }, { start: 19, end: 44 }, { start: 236, end: 134 }, { start: 134, end: 51 }, { start: 51, end: 236 }, { start: 216, end: 206 }, { start: 206, end: 205 }, { start: 205, end: 216 }, { start: 154, end: 153 }, { start: 153, end: 22 }, { start: 22, end: 154 }, { start: 39, end: 37 }, { start: 37, end: 167 }, { start: 167, end: 39 }, { start: 200, end: 201 }, { start: 201, end: 208 }, { start: 208, end: 200 }, { start: 36, end: 142 }, { start: 142, end: 100 }, { start: 100, end: 36 }, { start: 57, end: 212 }, { start: 212, end: 202 }, { start: 202, end: 57 }, { start: 20, end: 60 }, { start: 60, end: 99 }, { start: 99, end: 20 }, { start: 28, end: 158 }, { start: 158, end: 157 }, { start: 157, end: 28 }, { start: 35, end: 226 }, { start: 226, end: 113 }, { start: 113, end: 35 }, { start: 160, end: 159 }, { start: 159, end: 27 }, { start: 27, end: 160 }, { start: 204, end: 202 }, { start: 202, end: 210 }, { start: 210, end: 204 }, { start: 113, end: 225 }, { start: 225, end: 46 }, { start: 46, end: 113 }, { start: 43, end: 202 }, { start: 202, end: 204 }, { start: 204, end: 43 }, { start: 62, end: 76 }, { start: 76, end: 77 }, { start: 77, end: 62 }, { start: 137, end: 123 }, { start: 123, end: 116 }, { start: 116, end: 137 }, { start: 41, end: 38 }, { start: 38, end: 72 }, { start: 72, end: 41 }, { start: 203, end: 129 }, { start: 129, end: 142 }, { start: 142, end: 203 }, { start: 64, end: 98 }, { start: 98, end: 240 }, { start: 240, end: 64 }, { start: 49, end: 102 }, { start: 102, end: 64 }, { start: 64, end: 49 }, { start: 41, end: 73 }, { start: 73, end: 74 }, { start: 74, end: 41 }, { start: 212, end: 216 }, { start: 216, end: 207 }, { start: 207, end: 212 }, { start: 42, end: 74 }, { start: 74, end: 184 }, { start: 184, end: 42 }, { start: 169, end: 170 }, { start: 170, end: 211 }, { start: 211, end: 169 }, { start: 170, end: 149 }, { start: 149, end: 176 }, { start: 176, end: 170 }, { start: 105, end: 66 }, { start: 66, end: 69 }, { start: 69, end: 105 }, { start: 122, end: 6 }, { start: 6, end: 168 }, { start: 168, end: 122 }, { start: 123, end: 147 }, { start: 147, end: 187 }, { start: 187, end: 123 }, { start: 96, end: 77 }, { start: 77, end: 90 }, { start: 90, end: 96 }, { start: 65, end: 55 }, { start: 55, end: 107 }, { start: 107, end: 65 }, { start: 89, end: 90 }, { start: 90, end: 180 }, { start: 180, end: 89 }, { start: 101, end: 100 }, { start: 100, end: 120 }, { start: 120, end: 101 }, { start: 63, end: 105 }, { start: 105, end: 104 }, { start: 104, end: 63 }, { start: 93, end: 137 }, { start: 137, end: 227 }, { start: 227, end: 93 }, { start: 15, end: 86 }, { start: 86, end: 85 }, { start: 85, end: 15 }, { start: 129, end: 102 }, { start: 102, end: 49 }, { start: 49, end: 129 }, { start: 14, end: 87 }, { start: 87, end: 86 }, { start: 86, end: 14 }, { start: 55, end: 8 }, { start: 8, end: 9 }, { start: 9, end: 55 }, { start: 100, end: 47 }, { start: 47, end: 121 }, { start: 121, end: 100 }, { start: 145, end: 23 }, { start: 23, end: 22 }, { start: 22, end: 145 }, { start: 88, end: 89 }, { start: 89, end: 179 }, { start: 179, end: 88 }, { start: 6, end: 122 }, { start: 122, end: 196 }, { start: 196, end: 6 }, { start: 88, end: 95 }, { start: 95, end: 96 }, { start: 96, end: 88 }, { start: 138, end: 172 }, { start: 172, end: 136 }, { start: 136, end: 138 }, { start: 215, end: 58 }, { start: 58, end: 172 }, { start: 172, end: 215 }, { start: 115, end: 48 }, { start: 48, end: 219 }, { start: 219, end: 115 }, { start: 42, end: 80 }, { start: 80, end: 81 }, { start: 81, end: 42 }, { start: 195, end: 3 }, { start: 3, end: 51 }, { start: 51, end: 195 }, { start: 43, end: 146 }, { start: 146, end: 61 }, { start: 61, end: 43 }, { start: 171, end: 175 }, { start: 175, end: 199 }, { start: 199, end: 171 }, { start: 81, end: 82 }, { start: 82, end: 38 }, { start: 38, end: 81 }, { start: 53, end: 46 }, { start: 46, end: 225 }, { start: 225, end: 53 }, { start: 144, end: 163 }, { start: 163, end: 110 }, { start: 110, end: 144 }, { start: 52, end: 65 }, { start: 65, end: 66 }, { start: 66, end: 52 }, { start: 229, end: 228 }, { start: 228, end: 117 }, { start: 117, end: 229 }, { start: 34, end: 127 }, { start: 127, end: 234 }, { start: 234, end: 34 }, { start: 107, end: 108 }, { start: 108, end: 69 }, { start: 69, end: 107 }, { start: 109, end: 108 }, { start: 108, end: 151 }, { start: 151, end: 109 }, { start: 48, end: 64 }, { start: 64, end: 235 }, { start: 235, end: 48 }, { start: 62, end: 78 }, { start: 78, end: 191 }, { start: 191, end: 62 }, { start: 129, end: 209 }, { start: 209, end: 126 }, { start: 126, end: 129 }, { start: 111, end: 35 }, { start: 35, end: 143 }, { start: 143, end: 111 }, { start: 117, end: 123 }, { start: 123, end: 50 }, { start: 50, end: 117 }, { start: 222, end: 65 }, { start: 65, end: 52 }, { start: 52, end: 222 }, { start: 19, end: 125 }, { start: 125, end: 141 }, { start: 141, end: 19 }, { start: 221, end: 55 }, { start: 55, end: 65 }, { start: 65, end: 221 }, { start: 3, end: 195 }, { start: 195, end: 197 }, { start: 197, end: 3 }, { start: 25, end: 7 }, { start: 7, end: 33 }, { start: 33, end: 25 }, { start: 220, end: 237 }, { start: 237, end: 44 }, { start: 44, end: 220 }, { start: 70, end: 71 }, { start: 71, end: 139 }, { start: 139, end: 70 }, { start: 122, end: 193 }, { start: 193, end: 245 }, { start: 245, end: 122 }, { start: 247, end: 130 }, { start: 130, end: 33 }, { start: 33, end: 247 }, { start: 71, end: 21 }, { start: 21, end: 162 }, { start: 162, end: 71 }, { start: 170, end: 169 }, { start: 169, end: 150 }, { start: 150, end: 170 }, { start: 188, end: 174 }, { start: 174, end: 196 }, { start: 196, end: 188 }, { start: 216, end: 186 }, { start: 186, end: 92 }, { start: 92, end: 216 }, { start: 2, end: 97 }, { start: 97, end: 167 }, { start: 167, end: 2 }, { start: 141, end: 125 }, { start: 125, end: 241 }, { start: 241, end: 141 }, { start: 164, end: 167 }, { start: 167, end: 37 }, { start: 37, end: 164 }, { start: 72, end: 38 }, { start: 38, end: 12 }, { start: 12, end: 72 }, { start: 38, end: 82 }, { start: 82, end: 13 }, { start: 13, end: 38 }, { start: 63, end: 68 }, { start: 68, end: 71 }, { start: 71, end: 63 }, { start: 226, end: 35 }, { start: 35, end: 111 }, { start: 111, end: 226 }, { start: 101, end: 50 }, { start: 50, end: 205 }, { start: 205, end: 101 }, { start: 206, end: 92 }, { start: 92, end: 165 }, { start: 165, end: 206 }, { start: 209, end: 198 }, { start: 198, end: 217 }, { start: 217, end: 209 }, { start: 165, end: 167 }, { start: 167, end: 97 }, { start: 97, end: 165 }, { start: 220, end: 115 }, { start: 115, end: 218 }, { start: 218, end: 220 }, { start: 133, end: 112 }, { start: 112, end: 243 }, { start: 243, end: 133 }, { start: 239, end: 238 }, { start: 238, end: 241 }, { start: 241, end: 239 }, { start: 214, end: 135 }, { start: 135, end: 169 }, { start: 169, end: 214 }, { start: 190, end: 173 }, { start: 173, end: 133 }, { start: 133, end: 190 }, { start: 171, end: 208 }, { start: 208, end: 32 }, { start: 32, end: 171 }, { start: 125, end: 44 }, { start: 44, end: 237 }, { start: 237, end: 125 }, { start: 86, end: 87 }, { start: 87, end: 178 }, { start: 178, end: 86 }, { start: 85, end: 86 }, { start: 86, end: 179 }, { start: 179, end: 85 }, { start: 84, end: 85 }, { start: 85, end: 180 }, { start: 180, end: 84 }, { start: 83, end: 84 }, { start: 84, end: 181 }, { start: 181, end: 83 }, { start: 201, end: 83 }, { start: 83, end: 182 }, { start: 182, end: 201 }, { start: 137, end: 93 }, { start: 93, end: 132 }, { start: 132, end: 137 }, { start: 76, end: 62 }, { start: 62, end: 183 }, { start: 183, end: 76 }, { start: 61, end: 76 }, { start: 76, end: 184 }, { start: 184, end: 61 }, { start: 57, end: 61 }, { start: 61, end: 185 }, { start: 185, end: 57 }, { start: 212, end: 57 }, { start: 57, end: 186 }, { start: 186, end: 212 }, { start: 214, end: 207 }, { start: 207, end: 187 }, { start: 187, end: 214 }, { start: 34, end: 143 }, { start: 143, end: 156 }, { start: 156, end: 34 }, { start: 79, end: 239 }, { start: 239, end: 237 }, { start: 237, end: 79 }, { start: 123, end: 137 }, { start: 137, end: 177 }, { start: 177, end: 123 }, { start: 44, end: 1 }, { start: 1, end: 4 }, { start: 4, end: 44 }, { start: 201, end: 194 }, { start: 194, end: 32 }, { start: 32, end: 201 }, { start: 64, end: 102 }, { start: 102, end: 129 }, { start: 129, end: 64 }, { start: 213, end: 215 }, { start: 215, end: 138 }, { start: 138, end: 213 }, { start: 59, end: 166 }, { start: 166, end: 219 }, { start: 219, end: 59 }, { start: 242, end: 99 }, { start: 99, end: 97 }, { start: 97, end: 242 }, { start: 2, end: 94 }, { start: 94, end: 141 }, { start: 141, end: 2 }, { start: 75, end: 59 }, { start: 59, end: 235 }, { start: 235, end: 75 }, { start: 24, end: 110 }, { start: 110, end: 228 }, { start: 228, end: 24 }, { start: 25, end: 130 }, { start: 130, end: 226 }, { start: 226, end: 25 }, { start: 23, end: 24 }, { start: 24, end: 229 }, { start: 229, end: 23 }, { start: 22, end: 23 }, { start: 23, end: 230 }, { start: 230, end: 22 }, { start: 26, end: 22 }, { start: 22, end: 231 }, { start: 231, end: 26 }, { start: 112, end: 26 }, { start: 26, end: 232 }, { start: 232, end: 112 }, { start: 189, end: 190 }, { start: 190, end: 243 }, { start: 243, end: 189 }, { start: 221, end: 56 }, { start: 56, end: 190 }, { start: 190, end: 221 }, { start: 28, end: 56 }, { start: 56, end: 221 }, { start: 221, end: 28 }, { start: 27, end: 28 }, { start: 28, end: 222 }, { start: 222, end: 27 }, { start: 29, end: 27 }, { start: 27, end: 223 }, { start: 223, end: 29 }, { start: 30, end: 29 }, { start: 29, end: 224 }, { start: 224, end: 30 }, { start: 247, end: 30 }, { start: 30, end: 225 }, { start: 225, end: 247 }, { start: 238, end: 79 }, { start: 79, end: 20 }, { start: 20, end: 238 }, { start: 166, end: 59 }, { start: 59, end: 75 }, { start: 75, end: 166 }, { start: 60, end: 75 }, { start: 75, end: 240 }, { start: 240, end: 60 }, { start: 147, end: 177 }, { start: 177, end: 215 }, { start: 215, end: 147 }, { start: 20, end: 79 }, { start: 79, end: 166 }, { start: 166, end: 20 }, { start: 187, end: 147 }, { start: 147, end: 213 }, { start: 213, end: 187 }, { start: 112, end: 233 }, { start: 233, end: 244 }, { start: 244, end: 112 }, { start: 233, end: 128 }, { start: 128, end: 245 }, { start: 245, end: 233 }, { start: 128, end: 114 }, { start: 114, end: 188 }, { start: 188, end: 128 }, { start: 114, end: 217 }, { start: 217, end: 174 }, { start: 174, end: 114 }, { start: 131, end: 115 }, { start: 115, end: 220 }, { start: 220, end: 131 }, { start: 217, end: 198 }, { start: 198, end: 236 }, { start: 236, end: 217 }, { start: 198, end: 131 }, { start: 131, end: 134 }, { start: 134, end: 198 }, { start: 177, end: 132 }, { start: 132, end: 58 }, { start: 58, end: 177 }, { start: 143, end: 35 }, { start: 35, end: 124 }, { start: 124, end: 143 }, { start: 110, end: 163 }, { start: 163, end: 7 }, { start: 7, end: 110 }, { start: 228, end: 110 }, { start: 110, end: 25 }, { start: 25, end: 228 }, { start: 356, end: 389 }, { start: 389, end: 368 }, { start: 368, end: 356 }, { start: 11, end: 302 }, { start: 302, end: 267 }, { start: 267, end: 11 }, { start: 452, end: 350 }, { start: 350, end: 349 }, { start: 349, end: 452 }, { start: 302, end: 303 }, { start: 303, end: 269 }, { start: 269, end: 302 }, { start: 357, end: 343 }, { start: 343, end: 277 }, { start: 277, end: 357 }, { start: 452, end: 453 }, { start: 453, end: 357 }, { start: 357, end: 452 }, { start: 333, end: 332 }, { start: 332, end: 297 }, { start: 297, end: 333 }, { start: 175, end: 152 }, { start: 152, end: 377 }, { start: 377, end: 175 }, { start: 347, end: 348 }, { start: 348, end: 330 }, { start: 330, end: 347 }, { start: 303, end: 304 }, { start: 304, end: 270 }, { start: 270, end: 303 }, { start: 9, end: 336 }, { start: 336, end: 337 }, { start: 337, end: 9 }, { start: 278, end: 279 }, { start: 279, end: 360 }, { start: 360, end: 278 }, { start: 418, end: 262 }, { start: 262, end: 431 }, { start: 431, end: 418 }, { start: 304, end: 408 }, { start: 408, end: 409 }, { start: 409, end: 304 }, { start: 310, end: 415 }, { start: 415, end: 407 }, { start: 407, end: 310 }, { start: 270, end: 409 }, { start: 409, end: 410 }, { start: 410, end: 270 }, { start: 450, end: 348 }, { start: 348, end: 347 }, { start: 347, end: 450 }, { start: 422, end: 430 }, { start: 430, end: 434 }, { start: 434, end: 422 }, { start: 313, end: 314 }, { start: 314, end: 17 }, { start: 17, end: 313 }, { start: 306, end: 307 }, { start: 307, end: 375 }, { start: 375, end: 306 }, { start: 387, end: 388 }, { start: 388, end: 260 }, { start: 260, end: 387 }, { start: 286, end: 414 }, { start: 414, end: 398 }, { start: 398, end: 286 }, { start: 335, end: 406 }, { start: 406, end: 418 }, { start: 418, end: 335 }, { start: 364, end: 367 }, { start: 367, end: 416 }, { start: 416, end: 364 }, { start: 423, end: 358 }, { start: 358, end: 327 }, { start: 327, end: 423 }, { start: 251, end: 284 }, { start: 284, end: 298 }, { start: 298, end: 251 }, { start: 281, end: 5 }, { start: 5, end: 4 }, { start: 4, end: 281 }, { start: 373, end: 374 }, { start: 374, end: 253 }, { start: 253, end: 373 }, { start: 307, end: 320 }, { start: 320, end: 321 }, { start: 321, end: 307 }, { start: 425, end: 427 }, { start: 427, end: 411 }, { start: 411, end: 425 }, { start: 421, end: 313 }, { start: 313, end: 18 }, { start: 18, end: 421 }, { start: 321, end: 405 }, { start: 405, end: 406 }, { start: 406, end: 321 }, { start: 320, end: 404 }, { start: 404, end: 405 }, { start: 405, end: 320 }, { start: 315, end: 16 }, { start: 16, end: 17 }, { start: 17, end: 315 }, { start: 426, end: 425 }, { start: 425, end: 266 }, { start: 266, end: 426 }, { start: 377, end: 400 }, { start: 400, end: 369 }, { start: 369, end: 377 }, { start: 322, end: 391 }, { start: 391, end: 269 }, { start: 269, end: 322 }, { start: 417, end: 465 }, { start: 465, end: 464 }, { start: 464, end: 417 }, { start: 386, end: 257 }, { start: 257, end: 258 }, { start: 258, end: 386 }, { start: 466, end: 260 }, { start: 260, end: 388 }, { start: 388, end: 466 }, { start: 456, end: 399 }, { start: 399, end: 419 }, { start: 419, end: 456 }, { start: 284, end: 332 }, { start: 332, end: 333 }, { start: 333, end: 284 }, { start: 417, end: 285 }, { start: 285, end: 8 }, { start: 8, end: 417 }, { start: 346, end: 340 }, { start: 340, end: 261 }, { start: 261, end: 346 }, { start: 413, end: 441 }, { start: 441, end: 285 }, { start: 285, end: 413 }, { start: 327, end: 460 }, { start: 460, end: 328 }, { start: 328, end: 327 }, { start: 355, end: 371 }, { start: 371, end: 329 }, { start: 329, end: 355 }, { start: 392, end: 439 }, { start: 439, end: 438 }, { start: 438, end: 392 }, { start: 382, end: 341 }, { start: 341, end: 256 }, { start: 256, end: 382 }, { start: 429, end: 420 }, { start: 420, end: 360 }, { start: 360, end: 429 }, { start: 364, end: 394 }, { start: 394, end: 379 }, { start: 379, end: 364 }, { start: 277, end: 343 }, { start: 343, end: 437 }, { start: 437, end: 277 }, { start: 443, end: 444 }, { start: 444, end: 283 }, { start: 283, end: 443 }, { start: 275, end: 440 }, { start: 440, end: 363 }, { start: 363, end: 275 }, { start: 431, end: 262 }, { start: 262, end: 369 }, { start: 369, end: 431 }, { start: 297, end: 338 }, { start: 338, end: 337 }, { start: 337, end: 297 }, { start: 273, end: 375 }, { start: 375, end: 321 }, { start: 321, end: 273 }, { start: 450, end: 451 }, { start: 451, end: 349 }, { start: 349, end: 450 }, { start: 446, end: 342 }, { start: 342, end: 467 }, { start: 467, end: 446 }, { start: 293, end: 334 }, { start: 334, end: 282 }, { start: 282, end: 293 }, { start: 458, end: 461 }, { start: 461, end: 462 }, { start: 462, end: 458 }, { start: 276, end: 353 }, { start: 353, end: 383 }, { start: 383, end: 276 }, { start: 308, end: 324 }, { start: 324, end: 325 }, { start: 325, end: 308 }, { start: 276, end: 300 }, { start: 300, end: 293 }, { start: 293, end: 276 }, { start: 372, end: 345 }, { start: 345, end: 447 }, { start: 447, end: 372 }, { start: 352, end: 345 }, { start: 345, end: 340 }, { start: 340, end: 352 }, { start: 274, end: 1 }, { start: 1, end: 19 }, { start: 19, end: 274 }, { start: 456, end: 248 }, { start: 248, end: 281 }, { start: 281, end: 456 }, { start: 436, end: 427 }, { start: 427, end: 425 }, { start: 425, end: 436 }, { start: 381, end: 256 }, { start: 256, end: 252 }, { start: 252, end: 381 }, { start: 269, end: 391 }, { start: 391, end: 393 }, { start: 393, end: 269 }, { start: 200, end: 199 }, { start: 199, end: 428 }, { start: 428, end: 200 }, { start: 266, end: 330 }, { start: 330, end: 329 }, { start: 329, end: 266 }, { start: 287, end: 273 }, { start: 273, end: 422 }, { start: 422, end: 287 }, { start: 250, end: 462 }, { start: 462, end: 328 }, { start: 328, end: 250 }, { start: 258, end: 286 }, { start: 286, end: 384 }, { start: 384, end: 258 }, { start: 265, end: 353 }, { start: 353, end: 342 }, { start: 342, end: 265 }, { start: 387, end: 259 }, { start: 259, end: 257 }, { start: 257, end: 387 }, { start: 424, end: 431 }, { start: 431, end: 430 }, { start: 430, end: 424 }, { start: 342, end: 353 }, { start: 353, end: 276 }, { start: 276, end: 342 }, { start: 273, end: 335 }, { start: 335, end: 424 }, { start: 424, end: 273 }, { start: 292, end: 325 }, { start: 325, end: 307 }, { start: 307, end: 292 }, { start: 366, end: 447 }, { start: 447, end: 345 }, { start: 345, end: 366 }, { start: 271, end: 303 }, { start: 303, end: 302 }, { start: 302, end: 271 }, { start: 423, end: 266 }, { start: 266, end: 371 }, { start: 371, end: 423 }, { start: 294, end: 455 }, { start: 455, end: 460 }, { start: 460, end: 294 }, { start: 279, end: 278 }, { start: 278, end: 294 }, { start: 294, end: 279 }, { start: 271, end: 272 }, { start: 272, end: 304 }, { start: 304, end: 271 }, { start: 432, end: 434 }, { start: 434, end: 427 }, { start: 427, end: 432 }, { start: 272, end: 407 }, { start: 407, end: 408 }, { start: 408, end: 272 }, { start: 394, end: 430 }, { start: 430, end: 431 }, { start: 431, end: 394 }, { start: 395, end: 369 }, { start: 369, end: 400 }, { start: 400, end: 395 }, { start: 334, end: 333 }, { start: 333, end: 299 }, { start: 299, end: 334 }, { start: 351, end: 417 }, { start: 417, end: 168 }, { start: 168, end: 351 }, { start: 352, end: 280 }, { start: 280, end: 411 }, { start: 411, end: 352 }, { start: 325, end: 319 }, { start: 319, end: 320 }, { start: 320, end: 325 }, { start: 295, end: 296 }, { start: 296, end: 336 }, { start: 336, end: 295 }, { start: 319, end: 403 }, { start: 403, end: 404 }, { start: 404, end: 319 }, { start: 330, end: 348 }, { start: 348, end: 349 }, { start: 349, end: 330 }, { start: 293, end: 298 }, { start: 298, end: 333 }, { start: 333, end: 293 }, { start: 323, end: 454 }, { start: 454, end: 447 }, { start: 447, end: 323 }, { start: 15, end: 16 }, { start: 16, end: 315 }, { start: 315, end: 15 }, { start: 358, end: 429 }, { start: 429, end: 279 }, { start: 279, end: 358 }, { start: 14, end: 15 }, { start: 15, end: 316 }, { start: 316, end: 14 }, { start: 285, end: 336 }, { start: 336, end: 9 }, { start: 9, end: 285 }, { start: 329, end: 349 }, { start: 349, end: 350 }, { start: 350, end: 329 }, { start: 374, end: 380 }, { start: 380, end: 252 }, { start: 252, end: 374 }, { start: 318, end: 402 }, { start: 402, end: 403 }, { start: 403, end: 318 }, { start: 6, end: 197 }, { start: 197, end: 419 }, { start: 419, end: 6 }, { start: 318, end: 319 }, { start: 319, end: 325 }, { start: 325, end: 318 }, { start: 367, end: 364 }, { start: 364, end: 365 }, { start: 365, end: 367 }, { start: 435, end: 367 }, { start: 367, end: 397 }, { start: 397, end: 435 }, { start: 344, end: 438 }, { start: 438, end: 439 }, { start: 439, end: 344 }, { start: 272, end: 271 }, { start: 271, end: 311 }, { start: 311, end: 272 }, { start: 195, end: 5 }, { start: 5, end: 281 }, { start: 281, end: 195 }, { start: 273, end: 287 }, { start: 287, end: 291 }, { start: 291, end: 273 }, { start: 396, end: 428 }, { start: 428, end: 199 }, { start: 199, end: 396 }, { start: 311, end: 271 }, { start: 271, end: 268 }, { start: 268, end: 311 }, { start: 283, end: 444 }, { start: 444, end: 445 }, { start: 445, end: 283 }, { start: 373, end: 254 }, { start: 254, end: 339 }, { start: 339, end: 373 }, { start: 282, end: 334 }, { start: 334, end: 296 }, { start: 296, end: 282 }, { start: 449, end: 347 }, { start: 347, end: 346 }, { start: 346, end: 449 }, { start: 264, end: 447 }, { start: 447, end: 454 }, { start: 454, end: 264 }, { start: 336, end: 296 }, { start: 296, end: 299 }, { start: 299, end: 336 }, { start: 338, end: 10 }, { start: 10, end: 151 }, { start: 151, end: 338 }, { start: 278, end: 439 }, { start: 439, end: 455 }, { start: 455, end: 278 }, { start: 292, end: 407 }, { start: 407, end: 415 }, { start: 415, end: 292 }, { start: 358, end: 371 }, { start: 371, end: 355 }, { start: 355, end: 358 }, { start: 340, end: 345 }, { start: 345, end: 372 }, { start: 372, end: 340 }, { start: 346, end: 347 }, { start: 347, end: 280 }, { start: 280, end: 346 }, { start: 442, end: 443 }, { start: 443, end: 282 }, { start: 282, end: 442 }, { start: 19, end: 94 }, { start: 94, end: 370 }, { start: 370, end: 19 }, { start: 441, end: 442 }, { start: 442, end: 295 }, { start: 295, end: 441 }, { start: 248, end: 419 }, { start: 419, end: 197 }, { start: 197, end: 248 }, { start: 263, end: 255 }, { start: 255, end: 359 }, { start: 359, end: 263 }, { start: 440, end: 275 }, { start: 275, end: 274 }, { start: 274, end: 440 }, { start: 300, end: 383 }, { start: 383, end: 368 }, { start: 368, end: 300 }, { start: 351, end: 412 }, { start: 412, end: 465 }, { start: 465, end: 351 }, { start: 263, end: 467 }, { start: 467, end: 466 }, { start: 466, end: 263 }, { start: 301, end: 368 }, { start: 368, end: 389 }, { start: 389, end: 301 }, { start: 395, end: 378 }, { start: 378, end: 379 }, { start: 379, end: 395 }, { start: 412, end: 351 }, { start: 351, end: 419 }, { start: 419, end: 412 }, { start: 436, end: 426 }, { start: 426, end: 322 }, { start: 322, end: 436 }, { start: 2, end: 164 }, { start: 164, end: 393 }, { start: 393, end: 2 }, { start: 370, end: 462 }, { start: 462, end: 461 }, { start: 461, end: 370 }, { start: 164, end: 0 }, { start: 0, end: 267 }, { start: 267, end: 164 }, { start: 302, end: 11 }, { start: 11, end: 12 }, { start: 12, end: 302 }, { start: 268, end: 12 }, { start: 12, end: 13 }, { start: 13, end: 268 }, { start: 293, end: 300 }, { start: 300, end: 301 }, { start: 301, end: 293 }, { start: 446, end: 261 }, { start: 261, end: 340 }, { start: 340, end: 446 }, { start: 330, end: 266 }, { start: 266, end: 425 }, { start: 425, end: 330 }, { start: 426, end: 423 }, { start: 423, end: 391 }, { start: 391, end: 426 }, { start: 429, end: 355 }, { start: 355, end: 437 }, { start: 437, end: 429 }, { start: 391, end: 327 }, { start: 327, end: 326 }, { start: 326, end: 391 }, { start: 440, end: 457 }, { start: 457, end: 438 }, { start: 438, end: 440 }, { start: 341, end: 382 }, { start: 382, end: 362 }, { start: 362, end: 341 }, { start: 459, end: 457 }, { start: 457, end: 461 }, { start: 461, end: 459 }, { start: 434, end: 430 }, { start: 430, end: 394 }, { start: 394, end: 434 }, { start: 414, end: 463 }, { start: 463, end: 362 }, { start: 362, end: 414 }, { start: 396, end: 369 }, { start: 369, end: 262 }, { start: 262, end: 396 }, { start: 354, end: 461 }, { start: 461, end: 457 }, { start: 457, end: 354 }, { start: 316, end: 403 }, { start: 403, end: 402 }, { start: 402, end: 316 }, { start: 315, end: 404 }, { start: 404, end: 403 }, { start: 403, end: 315 }, { start: 314, end: 405 }, { start: 405, end: 404 }, { start: 404, end: 314 }, { start: 313, end: 406 }, { start: 406, end: 405 }, { start: 405, end: 313 }, { start: 421, end: 418 }, { start: 418, end: 406 }, { start: 406, end: 421 }, { start: 366, end: 401 }, { start: 401, end: 361 }, { start: 361, end: 366 }, { start: 306, end: 408 }, { start: 408, end: 407 }, { start: 407, end: 306 }, { start: 291, end: 409 }, { start: 409, end: 408 }, { start: 408, end: 291 }, { start: 287, end: 410 }, { start: 410, end: 409 }, { start: 409, end: 287 }, { start: 432, end: 436 }, { start: 436, end: 410 }, { start: 410, end: 432 }, { start: 434, end: 416 }, { start: 416, end: 411 }, { start: 411, end: 434 }, { start: 264, end: 368 }, { start: 368, end: 383 }, { start: 383, end: 264 }, { start: 309, end: 438 }, { start: 438, end: 457 }, { start: 457, end: 309 }, { start: 352, end: 376 }, { start: 376, end: 401 }, { start: 401, end: 352 }, { start: 274, end: 275 }, { start: 275, end: 4 }, { start: 4, end: 274 }, { start: 421, end: 428 }, { start: 428, end: 262 }, { start: 262, end: 421 }, { start: 294, end: 327 }, { start: 327, end: 358 }, { start: 358, end: 294 }, { start: 433, end: 416 }, { start: 416, end: 367 }, { start: 367, end: 433 }, { start: 289, end: 455 }, { start: 455, end: 439 }, { start: 439, end: 289 }, { start: 462, end: 370 }, { start: 370, end: 326 }, { start: 326, end: 462 }, { start: 2, end: 326 }, { start: 326, end: 370 }, { start: 370, end: 2 }, { start: 305, end: 460 }, { start: 460, end: 455 }, { start: 455, end: 305 }, { start: 254, end: 449 }, { start: 449, end: 448 }, { start: 448, end: 254 }, { start: 255, end: 261 }, { start: 261, end: 446 }, { start: 446, end: 255 }, { start: 253, end: 450 }, { start: 450, end: 449 }, { start: 449, end: 253 }, { start: 252, end: 451 }, { start: 451, end: 450 }, { start: 450, end: 252 }, { start: 256, end: 452 }, { start: 452, end: 451 }, { start: 451, end: 256 }, { start: 341, end: 453 }, { start: 453, end: 452 }, { start: 452, end: 341 }, { start: 413, end: 464 }, { start: 464, end: 463 }, { start: 463, end: 413 }, { start: 441, end: 413 }, { start: 413, end: 414 }, { start: 414, end: 441 }, { start: 258, end: 442 }, { start: 442, end: 441 }, { start: 441, end: 258 }, { start: 257, end: 443 }, { start: 443, end: 442 }, { start: 442, end: 257 }, { start: 259, end: 444 }, { start: 444, end: 443 }, { start: 443, end: 259 }, { start: 260, end: 445 }, { start: 445, end: 444 }, { start: 444, end: 260 }, { start: 467, end: 342 }, { start: 342, end: 445 }, { start: 445, end: 467 }, { start: 459, end: 458 }, { start: 458, end: 250 }, { start: 250, end: 459 }, { start: 289, end: 392 }, { start: 392, end: 290 }, { start: 290, end: 289 }, { start: 290, end: 328 }, { start: 328, end: 460 }, { start: 460, end: 290 }, { start: 376, end: 433 }, { start: 433, end: 435 }, { start: 435, end: 376 }, { start: 250, end: 290 }, { start: 290, end: 392 }, { start: 392, end: 250 }, { start: 411, end: 416 }, { start: 416, end: 433 }, { start: 433, end: 411 }, { start: 341, end: 463 }, { start: 463, end: 464 }, { start: 464, end: 341 }, { start: 453, end: 464 }, { start: 464, end: 465 }, { start: 465, end: 453 }, { start: 357, end: 465 }, { start: 465, end: 412 }, { start: 412, end: 357 }, { start: 343, end: 412 }, { start: 412, end: 399 }, { start: 399, end: 343 }, { start: 360, end: 363 }, { start: 363, end: 440 }, { start: 440, end: 360 }, { start: 437, end: 399 }, { start: 399, end: 456 }, { start: 456, end: 437 }, { start: 420, end: 456 }, { start: 456, end: 363 }, { start: 363, end: 420 }, { start: 401, end: 435 }, { start: 435, end: 288 }, { start: 288, end: 401 }, { start: 372, end: 383 }, { start: 383, end: 353 }, { start: 353, end: 372 }, { start: 339, end: 255 }, { start: 255, end: 249 }, { start: 249, end: 339 }, { start: 448, end: 261 }, { start: 261, end: 255 }, { start: 255, end: 448 }, { start: 133, end: 243 }, { start: 243, end: 190 }, { start: 190, end: 133 }, { start: 133, end: 155 }, { start: 155, end: 112 }, { start: 112, end: 133 }, { start: 33, end: 246 }, { start: 246, end: 247 }, { start: 247, end: 33 }, { start: 33, end: 130 }, { start: 130, end: 25 }, { start: 25, end: 33 }, { start: 398, end: 384 }, { start: 384, end: 286 }, { start: 286, end: 398 }, { start: 362, end: 398 }, { start: 398, end: 414 }, { start: 414, end: 362 }, { start: 362, end: 463 }, { start: 463, end: 341 }, { start: 341, end: 362 }, { start: 263, end: 359 }, { start: 359, end: 467 }, { start: 467, end: 263 }, { start: 263, end: 249 }, { start: 249, end: 255 }, { start: 255, end: 263 }, { start: 466, end: 467 }, { start: 467, end: 260 }, { start: 260, end: 466 }, { start: 75, end: 60 }, { start: 60, end: 166 }, { start: 166, end: 75 }, { start: 238, end: 239 }, { start: 239, end: 79 }, { start: 79, end: 238 }, { start: 162, end: 127 }, { start: 127, end: 139 }, { start: 139, end: 162 }, { start: 72, end: 11 }, { start: 11, end: 37 }, { start: 37, end: 72 }, { start: 121, end: 232 }, { start: 232, end: 120 }, { start: 120, end: 121 }, { start: 73, end: 72 }, { start: 72, end: 39 }, { start: 39, end: 73 }, { start: 114, end: 128 }, { start: 128, end: 47 }, { start: 47, end: 114 }, { start: 233, end: 232 }, { start: 232, end: 128 }, { start: 128, end: 233 }, { start: 103, end: 104 }, { start: 104, end: 67 }, { start: 67, end: 103 }, { start: 152, end: 175 }, { start: 175, end: 148 }, { start: 148, end: 152 }, { start: 119, end: 118 }, { start: 118, end: 101 }, { start: 101, end: 119 }, { start: 74, end: 73 }, { start: 73, end: 40 }, { start: 40, end: 74 }, { start: 107, end: 9 }, { start: 9, end: 108 }, { start: 108, end: 107 }, { start: 49, end: 48 }, { start: 48, end: 131 }, { start: 131, end: 49 }, { start: 32, end: 194 }, { start: 194, end: 211 }, { start: 211, end: 32 }, { start: 184, end: 74 }, { start: 74, end: 185 }, { start: 185, end: 184 }, { start: 191, end: 80 }, { start: 80, end: 183 }, { start: 183, end: 191 }, { start: 185, end: 40 }, { start: 40, end: 186 }, { start: 186, end: 185 }, { start: 119, end: 230 }, { start: 230, end: 118 }, { start: 118, end: 119 }, { start: 210, end: 202 }, { start: 202, end: 214 }, { start: 214, end: 210 }, { start: 84, end: 83 }, { start: 83, end: 17 }, { start: 17, end: 84 }, { start: 77, end: 76 }, { start: 76, end: 146 }, { start: 146, end: 77 }, { start: 161, end: 160 }, { start: 160, end: 30 }, { start: 30, end: 161 }, { start: 190, end: 56 }, { start: 56, end: 173 }, { start: 173, end: 190 }, { start: 182, end: 106 }, { start: 106, end: 194 }, { start: 194, end: 182 }, { start: 138, end: 135 }, { start: 135, end: 192 }, { start: 192, end: 138 }, { start: 129, end: 203 }, { start: 203, end: 98 }, { start: 98, end: 129 }, { start: 54, end: 21 }, { start: 21, end: 68 }, { start: 68, end: 54 }, { start: 5, end: 51 }, { start: 51, end: 4 }, { start: 4, end: 5 }, { start: 145, end: 144 }, { start: 144, end: 23 }, { start: 23, end: 145 }, { start: 90, end: 77 }, { start: 77, end: 91 }, { start: 91, end: 90 }, { start: 207, end: 205 }, { start: 205, end: 187 }, { start: 187, end: 207 }, { start: 83, end: 201 }, { start: 201, end: 18 }, { start: 18, end: 83 }, { start: 181, end: 91 }, { start: 91, end: 182 }, { start: 182, end: 181 }, { start: 180, end: 90 }, { start: 90, end: 181 }, { start: 181, end: 180 }, { start: 16, end: 85 }, { start: 85, end: 17 }, { start: 17, end: 16 }, { start: 205, end: 206 }, { start: 206, end: 36 }, { start: 36, end: 205 }, { start: 176, end: 148 }, { start: 148, end: 140 }, { start: 140, end: 176 }, { start: 165, end: 92 }, { start: 92, end: 39 }, { start: 39, end: 165 }, { start: 245, end: 193 }, { start: 193, end: 244 }, { start: 244, end: 245 }, { start: 27, end: 159 }, { start: 159, end: 28 }, { start: 28, end: 27 }, { start: 30, end: 247 }, { start: 247, end: 161 }, { start: 161, end: 30 }, { start: 174, end: 236 }, { start: 236, end: 196 }, { start: 196, end: 174 }, { start: 103, end: 54 }, { start: 54, end: 104 }, { start: 104, end: 103 }, { start: 55, end: 193 }, { start: 193, end: 8 }, { start: 8, end: 55 }, { start: 111, end: 117 }, { start: 117, end: 31 }, { start: 31, end: 111 }, { start: 221, end: 189 }, { start: 189, end: 55 }, { start: 55, end: 221 }, { start: 240, end: 98 }, { start: 98, end: 99 }, { start: 99, end: 240 }, { start: 142, end: 126 }, { start: 126, end: 100 }, { start: 100, end: 142 }, { start: 219, end: 166 }, { start: 166, end: 218 }, { start: 218, end: 219 }, { start: 112, end: 155 }, { start: 155, end: 26 }, { start: 26, end: 112 }, { start: 198, end: 209 }, { start: 209, end: 131 }, { start: 131, end: 198 }, { start: 169, end: 135 }, { start: 135, end: 150 }, { start: 150, end: 169 }, { start: 114, end: 47 }, { start: 47, end: 217 }, { start: 217, end: 114 }, { start: 224, end: 223 }, { start: 223, end: 53 }, { start: 53, end: 224 }, { start: 220, end: 45 }, { start: 45, end: 134 }, { start: 134, end: 220 }, { start: 32, end: 211 }, { start: 211, end: 140 }, { start: 140, end: 32 }, { start: 109, end: 67 }, { start: 67, end: 108 }, { start: 108, end: 109 }, { start: 146, end: 43 }, { start: 43, end: 91 }, { start: 91, end: 146 }, { start: 231, end: 230 }, { start: 230, end: 120 }, { start: 120, end: 231 }, { start: 113, end: 226 }, { start: 226, end: 247 }, { start: 247, end: 113 }, { start: 105, end: 63 }, { start: 63, end: 52 }, { start: 52, end: 105 }, { start: 241, end: 238 }, { start: 238, end: 242 }, { start: 242, end: 241 }, { start: 124, end: 46 }, { start: 46, end: 156 }, { start: 156, end: 124 }, { start: 95, end: 78 }, { start: 78, end: 96 }, { start: 96, end: 95 }, { start: 70, end: 46 }, { start: 46, end: 63 }, { start: 63, end: 70 }, { start: 116, end: 143 }, { start: 143, end: 227 }, { start: 227, end: 116 }, { start: 116, end: 123 }, { start: 123, end: 111 }, { start: 111, end: 116 }, { start: 1, end: 44 }, { start: 44, end: 19 }, { start: 19, end: 1 }, { start: 3, end: 236 }, { start: 236, end: 51 }, { start: 51, end: 3 }, { start: 207, end: 216 }, { start: 216, end: 205 }, { start: 205, end: 207 }, { start: 26, end: 154 }, { start: 154, end: 22 }, { start: 22, end: 26 }, { start: 165, end: 39 }, { start: 39, end: 167 }, { start: 167, end: 165 }, { start: 199, end: 200 }, { start: 200, end: 208 }, { start: 208, end: 199 }, { start: 101, end: 36 }, { start: 36, end: 100 }, { start: 100, end: 101 }, { start: 43, end: 57 }, { start: 57, end: 202 }, { start: 202, end: 43 }, { start: 242, end: 20 }, { start: 20, end: 99 }, { start: 99, end: 242 }, { start: 56, end: 28 }, { start: 28, end: 157 }, { start: 157, end: 56 }, { start: 124, end: 35 }, { start: 35, end: 113 }, { start: 113, end: 124 }, { start: 29, end: 160 }, { start: 160, end: 27 }, { start: 27, end: 29 }, { start: 211, end: 204 }, { start: 204, end: 210 }, { start: 210, end: 211 }, { start: 124, end: 113 }, { start: 113, end: 46 }, { start: 46, end: 124 }, { start: 106, end: 43 }, { start: 43, end: 204 }, { start: 204, end: 106 }, { start: 96, end: 62 }, { start: 62, end: 77 }, { start: 77, end: 96 }, { start: 227, end: 137 }, { start: 137, end: 116 }, { start: 116, end: 227 }, { start: 73, end: 41 }, { start: 41, end: 72 }, { start: 72, end: 73 }, { start: 36, end: 203 }, { start: 203, end: 142 }, { start: 142, end: 36 }, { start: 235, end: 64 }, { start: 64, end: 240 }, { start: 240, end: 235 }, { start: 48, end: 49 }, { start: 49, end: 64 }, { start: 64, end: 48 }, { start: 42, end: 41 }, { start: 41, end: 74 }, { start: 74, end: 42 }, { start: 214, end: 212 }, { start: 212, end: 207 }, { start: 207, end: 214 }, { start: 183, end: 42 }, { start: 42, end: 184 }, { start: 184, end: 183 }, { start: 210, end: 169 }, { start: 169, end: 211 }, { start: 211, end: 210 }, { start: 140, end: 170 }, { start: 170, end: 176 }, { start: 176, end: 140 }, { start: 104, end: 105 }, { start: 105, end: 69 }, { start: 69, end: 104 }, { start: 193, end: 122 }, { start: 122, end: 168 }, { start: 168, end: 193 }, { start: 50, end: 123 }, { start: 123, end: 187 }, { start: 187, end: 50 }, { start: 89, end: 96 }, { start: 96, end: 90 }, { start: 90, end: 89 }, { start: 66, end: 65 }, { start: 65, end: 107 }, { start: 107, end: 66 }, { start: 179, end: 89 }, { start: 89, end: 180 }, { start: 180, end: 179 }, { start: 119, end: 101 }, { start: 101, end: 120 }, { start: 120, end: 119 }, { start: 68, end: 63 }, { start: 63, end: 104 }, { start: 104, end: 68 }, { start: 234, end: 93 }, { start: 93, end: 227 }, { start: 227, end: 234 }, { start: 16, end: 15 }, { start: 15, end: 85 }, { start: 85, end: 16 }, { start: 209, end: 129 }, { start: 129, end: 49 }, { start: 49, end: 209 }, { start: 15, end: 14 }, { start: 14, end: 86 }, { start: 86, end: 15 }, { start: 107, end: 55 }, { start: 55, end: 9 }, { start: 9, end: 107 }, { start: 120, end: 100 }, { start: 100, end: 121 }, { start: 121, end: 120 }, { start: 153, end: 145 }, { start: 145, end: 22 }, { start: 22, end: 153 }, { start: 178, end: 88 }, { start: 88, end: 179 }, { start: 179, end: 178 }, { start: 197, end: 6 }, { start: 6, end: 196 }, { start: 196, end: 197 }, { start: 89, end: 88 }, { start: 88, end: 96 }, { start: 96, end: 89 }, { start: 135, end: 138 }, { start: 138, end: 136 }, { start: 136, end: 135 }, { start: 138, end: 215 }, { start: 215, end: 172 }, { start: 172, end: 138 }, { start: 218, end: 115 }, { start: 115, end: 219 }, { start: 219, end: 218 }, { start: 41, end: 42 }, { start: 42, end: 81 }, { start: 81, end: 41 }, { start: 5, end: 195 }, { start: 195, end: 51 }, { start: 51, end: 5 }, { start: 57, end: 43 }, { start: 43, end: 61 }, { start: 61, end: 57 }, { start: 208, end: 171 }, { start: 171, end: 199 }, { start: 199, end: 208 }, { start: 41, end: 81 }, { start: 81, end: 38 }, { start: 38, end: 41 }, { start: 224, end: 53 }, { start: 53, end: 225 }, { start: 225, end: 224 }, { start: 24, end: 144 }, { start: 144, end: 110 }, { start: 110, end: 24 }, { start: 105, end: 52 }, { start: 52, end: 66 }, { start: 66, end: 105 }, { start: 118, end: 229 }, { start: 229, end: 117 }, { start: 117, end: 118 }, { start: 227, end: 34 }, { start: 34, end: 234 }, { start: 234, end: 227 }, { start: 66, end: 107 }, { start: 107, end: 69 }, { start: 69, end: 66 }, { start: 10, end: 109 }, { start: 109, end: 151 }, { start: 151, end: 10 }, { start: 219, end: 48 }, { start: 48, end: 235 }, { start: 235, end: 219 }, { start: 183, end: 62 }, { start: 62, end: 191 }, { start: 191, end: 183 }, { start: 142, end: 129 }, { start: 129, end: 126 }, { start: 126, end: 142 }, { start: 116, end: 111 }, { start: 111, end: 143 }, { start: 143, end: 116 }, { start: 118, end: 117 }, { start: 117, end: 50 }, { start: 50, end: 118 }, { start: 223, end: 222 }, { start: 222, end: 52 }, { start: 52, end: 223 }, { start: 94, end: 19 }, { start: 19, end: 141 }, { start: 141, end: 94 }, { start: 222, end: 221 }, { start: 221, end: 65 }, { start: 65, end: 222 }, { start: 196, end: 3 }, { start: 3, end: 197 }, { start: 197, end: 196 }, { start: 45, end: 220 }, { start: 220, end: 44 }, { start: 44, end: 45 }, { start: 156, end: 70 }, { start: 70, end: 139 }, { start: 139, end: 156 }, { start: 188, end: 122 }, { start: 122, end: 245 }, { start: 245, end: 188 }, { start: 139, end: 71 }, { start: 71, end: 162 }, { start: 162, end: 139 }, { start: 149, end: 170 }, { start: 170, end: 150 }, { start: 150, end: 149 }, { start: 122, end: 188 }, { start: 188, end: 196 }, { start: 196, end: 122 }, { start: 206, end: 216 }, { start: 216, end: 92 }, { start: 92, end: 206 }, { start: 164, end: 2 }, { start: 2, end: 167 }, { start: 167, end: 164 }, { start: 242, end: 141 }, { start: 141, end: 241 }, { start: 241, end: 242 }, { start: 0, end: 164 }, { start: 164, end: 37 }, { start: 37, end: 0 }, { start: 11, end: 72 }, { start: 72, end: 12 }, { start: 12, end: 11 }, { start: 12, end: 38 }, { start: 38, end: 13 }, { start: 13, end: 12 }, { start: 70, end: 63 }, { start: 63, end: 71 }, { start: 71, end: 70 }, { start: 31, end: 226 }, { start: 226, end: 111 }, { start: 111, end: 31 }, { start: 36, end: 101 }, { start: 101, end: 205 }, { start: 205, end: 36 }, { start: 203, end: 206 }, { start: 206, end: 165 }, { start: 165, end: 203 }, { start: 126, end: 209 }, { start: 209, end: 217 }, { start: 217, end: 126 }, { start: 98, end: 165 }, { start: 165, end: 97 }, { start: 97, end: 98 }, { start: 237, end: 220 }, { start: 220, end: 218 }, { start: 218, end: 237 }, { start: 237, end: 239 }, { start: 239, end: 241 }, { start: 241, end: 237 }, { start: 210, end: 214 }, { start: 214, end: 169 }, { start: 169, end: 210 }, { start: 140, end: 171 }, { start: 171, end: 32 }, { start: 32, end: 140 }, { start: 241, end: 125 }, { start: 125, end: 237 }, { start: 237, end: 241 }, { start: 179, end: 86 }, { start: 86, end: 178 }, { start: 178, end: 179 }, { start: 180, end: 85 }, { start: 85, end: 179 }, { start: 179, end: 180 }, { start: 181, end: 84 }, { start: 84, end: 180 }, { start: 180, end: 181 }, { start: 182, end: 83 }, { start: 83, end: 181 }, { start: 181, end: 182 }, { start: 194, end: 201 }, { start: 201, end: 182 }, { start: 182, end: 194 }, { start: 177, end: 137 }, { start: 137, end: 132 }, { start: 132, end: 177 }, { start: 184, end: 76 }, { start: 76, end: 183 }, { start: 183, end: 184 }, { start: 185, end: 61 }, { start: 61, end: 184 }, { start: 184, end: 185 }, { start: 186, end: 57 }, { start: 57, end: 185 }, { start: 185, end: 186 }, { start: 216, end: 212 }, { start: 212, end: 186 }, { start: 186, end: 216 }, { start: 192, end: 214 }, { start: 214, end: 187 }, { start: 187, end: 192 }, { start: 139, end: 34 }, { start: 34, end: 156 }, { start: 156, end: 139 }, { start: 218, end: 79 }, { start: 79, end: 237 }, { start: 237, end: 218 }, { start: 147, end: 123 }, { start: 123, end: 177 }, { start: 177, end: 147 }, { start: 45, end: 44 }, { start: 44, end: 4 }, { start: 4, end: 45 }, { start: 208, end: 201 }, { start: 201, end: 32 }, { start: 32, end: 208 }, { start: 98, end: 64 }, { start: 64, end: 129 }, { start: 129, end: 98 }, { start: 192, end: 213 }, { start: 213, end: 138 }, { start: 138, end: 192 }, { start: 235, end: 59 }, { start: 59, end: 219 }, { start: 219, end: 235 }, { start: 141, end: 242 }, { start: 242, end: 97 }, { start: 97, end: 141 }, { start: 97, end: 2 }, { start: 2, end: 141 }, { start: 141, end: 97 }, { start: 240, end: 75 }, { start: 75, end: 235 }, { start: 235, end: 240 }, { start: 229, end: 24 }, { start: 24, end: 228 }, { start: 228, end: 229 }, { start: 31, end: 25 }, { start: 25, end: 226 }, { start: 226, end: 31 }, { start: 230, end: 23 }, { start: 23, end: 229 }, { start: 229, end: 230 }, { start: 231, end: 22 }, { start: 22, end: 230 }, { start: 230, end: 231 }, { start: 232, end: 26 }, { start: 26, end: 231 }, { start: 231, end: 232 }, { start: 233, end: 112 }, { start: 112, end: 232 }, { start: 232, end: 233 }, { start: 244, end: 189 }, { start: 189, end: 243 }, { start: 243, end: 244 }, { start: 189, end: 221 }, { start: 221, end: 190 }, { start: 190, end: 189 }, { start: 222, end: 28 }, { start: 28, end: 221 }, { start: 221, end: 222 }, { start: 223, end: 27 }, { start: 27, end: 222 }, { start: 222, end: 223 }, { start: 224, end: 29 }, { start: 29, end: 223 }, { start: 223, end: 224 }, { start: 225, end: 30 }, { start: 30, end: 224 }, { start: 224, end: 225 }, { start: 113, end: 247 }, { start: 247, end: 225 }, { start: 225, end: 113 }, { start: 99, end: 60 }, { start: 60, end: 240 }, { start: 240, end: 99 }, { start: 213, end: 147 }, { start: 147, end: 215 }, { start: 215, end: 213 }, { start: 60, end: 20 }, { start: 20, end: 166 }, { start: 166, end: 60 }, { start: 192, end: 187 }, { start: 187, end: 213 }, { start: 213, end: 192 }, { start: 243, end: 112 }, { start: 112, end: 244 }, { start: 244, end: 243 }, { start: 244, end: 233 }, { start: 233, end: 245 }, { start: 245, end: 244 }, { start: 245, end: 128 }, { start: 128, end: 188 }, { start: 188, end: 245 }, { start: 188, end: 114 }, { start: 114, end: 174 }, { start: 174, end: 188 }, { start: 134, end: 131 }, { start: 131, end: 220 }, { start: 220, end: 134 }, { start: 174, end: 217 }, { start: 217, end: 236 }, { start: 236, end: 174 }, { start: 236, end: 198 }, { start: 198, end: 134 }, { start: 134, end: 236 }, { start: 215, end: 177 }, { start: 177, end: 58 }, { start: 58, end: 215 }, { start: 156, end: 143 }, { start: 143, end: 124 }, { start: 124, end: 156 }, { start: 25, end: 110 }, { start: 110, end: 7 }, { start: 7, end: 25 }, { start: 31, end: 228 }, { start: 228, end: 25 }, { start: 25, end: 31 }, { start: 264, end: 356 }, { start: 356, end: 368 }, { start: 368, end: 264 }, { start: 0, end: 11 }, { start: 11, end: 267 }, { start: 267, end: 0 }, { start: 451, end: 452 }, { start: 452, end: 349 }, { start: 349, end: 451 }, { start: 267, end: 302 }, { start: 302, end: 269 }, { start: 269, end: 267 }, { start: 350, end: 357 }, { start: 357, end: 277 }, { start: 277, end: 350 }, { start: 350, end: 452 }, { start: 452, end: 357 }, { start: 357, end: 350 }, { start: 299, end: 333 }, { start: 333, end: 297 }, { start: 297, end: 299 }, { start: 396, end: 175 }, { start: 175, end: 377 }, { start: 377, end: 396 }, { start: 280, end: 347 }, { start: 347, end: 330 }, { start: 330, end: 280 }, { start: 269, end: 303 }, { start: 303, end: 270 }, { start: 270, end: 269 }, { start: 151, end: 9 }, { start: 9, end: 337 }, { start: 337, end: 151 }, { start: 344, end: 278 }, { start: 278, end: 360 }, { start: 360, end: 344 }, { start: 424, end: 418 }, { start: 418, end: 431 }, { start: 431, end: 424 }, { start: 270, end: 304 }, { start: 304, end: 409 }, { start: 409, end: 270 }, { start: 272, end: 310 }, { start: 310, end: 407 }, { start: 407, end: 272 }, { start: 322, end: 270 }, { start: 270, end: 410 }, { start: 410, end: 322 }, { start: 449, end: 450 }, { start: 450, end: 347 }, { start: 347, end: 449 }, { start: 432, end: 422 }, { start: 422, end: 434 }, { start: 434, end: 432 }, { start: 18, end: 313 }, { start: 313, end: 17 }, { start: 17, end: 18 }, { start: 291, end: 306 }, { start: 306, end: 375 }, { start: 375, end: 291 }, { start: 259, end: 387 }, { start: 387, end: 260 }, { start: 260, end: 259 }, { start: 424, end: 335 }, { start: 335, end: 418 }, { start: 418, end: 424 }, { start: 434, end: 364 }, { start: 364, end: 416 }, { start: 416, end: 434 }, { start: 391, end: 423 }, { start: 423, end: 327 }, { start: 327, end: 391 }, { start: 301, end: 251 }, { start: 251, end: 298 }, { start: 298, end: 301 }, { start: 275, end: 281 }, { start: 281, end: 4 }, { start: 4, end: 275 }, { start: 254, end: 373 }, { start: 373, end: 253 }, { start: 253, end: 254 }, { start: 375, end: 307 }, { start: 307, end: 321 }, { start: 321, end: 375 }, { start: 280, end: 425 }, { start: 425, end: 411 }, { start: 411, end: 280 }, { start: 200, end: 421 }, { start: 421, end: 18 }, { start: 18, end: 200 }, { start: 335, end: 321 }, { start: 321, end: 406 }, { start: 406, end: 335 }, { start: 321, end: 320 }, { start: 320, end: 405 }, { start: 405, end: 321 }, { start: 314, end: 315 }, { start: 315, end: 17 }, { start: 17, end: 314 }, { start: 423, end: 426 }, { start: 426, end: 266 }, { start: 266, end: 423 }, { start: 396, end: 377 }, { start: 377, end: 369 }, { start: 369, end: 396 }, { start: 270, end: 322 }, { start: 322, end: 269 }, { start: 269, end: 270 }, { start: 413, end: 417 }, { start: 417, end: 464 }, { start: 464, end: 413 }, { start: 385, end: 386 }, { start: 386, end: 258 }, { start: 258, end: 385 }, { start: 248, end: 456 }, { start: 456, end: 419 }, { start: 419, end: 248 }, { start: 298, end: 284 }, { start: 284, end: 333 }, { start: 333, end: 298 }, { start: 168, end: 417 }, { start: 417, end: 8 }, { start: 8, end: 168 }, { start: 448, end: 346 }, { start: 346, end: 261 }, { start: 261, end: 448 }, { start: 417, end: 413 }, { start: 413, end: 285 }, { start: 285, end: 417 }, { start: 326, end: 327 }, { start: 327, end: 328 }, { start: 328, end: 326 }, { start: 277, end: 355 }, { start: 355, end: 329 }, { start: 329, end: 277 }, { start: 309, end: 392 }, { start: 392, end: 438 }, { start: 438, end: 309 }, { start: 381, end: 382 }, { start: 382, end: 256 }, { start: 256, end: 381 }, { start: 279, end: 429 }, { start: 429, end: 360 }, { start: 360, end: 279 }, { start: 365, end: 364 }, { start: 364, end: 379 }, { start: 379, end: 365 }, { start: 355, end: 277 }, { start: 277, end: 437 }, { start: 437, end: 355 }, { start: 282, end: 443 }, { start: 443, end: 283 }, { start: 283, end: 282 }, { start: 281, end: 275 }, { start: 275, end: 363 }, { start: 363, end: 281 }, { start: 395, end: 431 }, { start: 431, end: 369 }, { start: 369, end: 395 }, { start: 299, end: 297 }, { start: 297, end: 337 }, { start: 337, end: 299 }, { start: 335, end: 273 }, { start: 273, end: 321 }, { start: 321, end: 335 }, { start: 348, end: 450 }, { start: 450, end: 349 }, { start: 349, end: 348 }, { start: 359, end: 446 }, { start: 446, end: 467 }, { start: 467, end: 359 }, { start: 283, end: 293 }, { start: 293, end: 282 }, { start: 282, end: 283 }, { start: 250, end: 458 }, { start: 458, end: 462 }, { start: 462, end: 250 }, { start: 300, end: 276 }, { start: 276, end: 383 }, { start: 383, end: 300 }, { start: 292, end: 308 }, { start: 308, end: 325 }, { start: 325, end: 292 }, { start: 283, end: 276 }, { start: 276, end: 293 }, { start: 293, end: 283 }, { start: 264, end: 372 }, { start: 372, end: 447 }, { start: 447, end: 264 }, { start: 346, end: 352 }, { start: 352, end: 340 }, { start: 340, end: 346 }, { start: 354, end: 274 }, { start: 274, end: 19 }, { start: 19, end: 354 }, { start: 363, end: 456 }, { start: 456, end: 281 }, { start: 281, end: 363 }, { start: 426, end: 436 }, { start: 436, end: 425 }, { start: 425, end: 426 }, { start: 380, end: 381 }, { start: 381, end: 252 }, { start: 252, end: 380 }, { start: 267, end: 269 }, { start: 269, end: 393 }, { start: 393, end: 267 }, { start: 421, end: 200 }, { start: 200, end: 428 }, { start: 428, end: 421 }, { start: 371, end: 266 }, { start: 266, end: 329 }, { start: 329, end: 371 }, { start: 432, end: 287 }, { start: 287, end: 422 }, { start: 422, end: 432 }, { start: 290, end: 250 }, { start: 250, end: 328 }, { start: 328, end: 290 }, { start: 385, end: 258 }, { start: 258, end: 384 }, { start: 384, end: 385 }, { start: 446, end: 265 }, { start: 265, end: 342 }, { start: 342, end: 446 }, { start: 386, end: 387 }, { start: 387, end: 257 }, { start: 257, end: 386 }, { start: 422, end: 424 }, { start: 424, end: 430 }, { start: 430, end: 422 }, { start: 445, end: 342 }, { start: 342, end: 276 }, { start: 276, end: 445 }, { start: 422, end: 273 }, { start: 273, end: 424 }, { start: 424, end: 422 }, { start: 306, end: 292 }, { start: 292, end: 307 }, { start: 307, end: 306 }, { start: 352, end: 366 }, { start: 366, end: 345 }, { start: 345, end: 352 }, { start: 268, end: 271 }, { start: 271, end: 302 }, { start: 302, end: 268 }, { start: 358, end: 423 }, { start: 423, end: 371 }, { start: 371, end: 358 }, { start: 327, end: 294 }, { start: 294, end: 460 }, { start: 460, end: 327 }, { start: 331, end: 279 }, { start: 279, end: 294 }, { start: 294, end: 331 }, { start: 303, end: 271 }, { start: 271, end: 304 }, { start: 304, end: 303 }, { start: 436, end: 432 }, { start: 432, end: 427 }, { start: 427, end: 436 }, { start: 304, end: 272 }, { start: 272, end: 408 }, { start: 408, end: 304 }, { start: 395, end: 394 }, { start: 394, end: 431 }, { start: 431, end: 395 }, { start: 378, end: 395 }, { start: 395, end: 400 }, { start: 400, end: 378 }, { start: 296, end: 334 }, { start: 334, end: 299 }, { start: 299, end: 296 }, { start: 6, end: 351 }, { start: 351, end: 168 }, { start: 168, end: 6 }, { start: 376, end: 352 }, { start: 352, end: 411 }, { start: 411, end: 376 }, { start: 307, end: 325 }, { start: 325, end: 320 }, { start: 320, end: 307 }, { start: 285, end: 295 }, { start: 295, end: 336 }, { start: 336, end: 285 }, { start: 320, end: 319 }, { start: 319, end: 404 }, { start: 404, end: 320 }, { start: 329, end: 330 }, { start: 330, end: 349 }, { start: 349, end: 329 }, { start: 334, end: 293 }, { start: 293, end: 333 }, { start: 333, end: 334 }, { start: 366, end: 323 }, { start: 323, end: 447 }, { start: 447, end: 366 }, { start: 316, end: 15 }, { start: 15, end: 315 }, { start: 315, end: 316 }, { start: 331, end: 358 }, { start: 358, end: 279 }, { start: 279, end: 331 }, { start: 317, end: 14 }, { start: 14, end: 316 }, { start: 316, end: 317 }, { start: 8, end: 285 }, { start: 285, end: 9 }, { start: 9, end: 8 }, { start: 277, end: 329 }, { start: 329, end: 350 }, { start: 350, end: 277 }, { start: 253, end: 374 }, { start: 374, end: 252 }, { start: 252, end: 253 }, { start: 319, end: 318 }, { start: 318, end: 403 }, { start: 403, end: 319 }, { start: 351, end: 6 }, { start: 6, end: 419 }, { start: 419, end: 351 }, { start: 324, end: 318 }, { start: 318, end: 325 }, { start: 325, end: 324 }, { start: 397, end: 367 }, { start: 367, end: 365 }, { start: 365, end: 397 }, { start: 288, end: 435 }, { start: 435, end: 397 }, { start: 397, end: 288 }, { start: 278, end: 344 }, { start: 344, end: 439 }, { start: 439, end: 278 }, { start: 310, end: 272 }, { start: 272, end: 311 }, { start: 311, end: 310 }, { start: 248, end: 195 }, { start: 195, end: 281 }, { start: 281, end: 248 }, { start: 375, end: 273 }, { start: 273, end: 291 }, { start: 291, end: 375 }, { start: 175, end: 396 }, { start: 396, end: 199 }, { start: 199, end: 175 }, { start: 312, end: 311 }, { start: 311, end: 268 }, { start: 268, end: 312 }, { start: 276, end: 283 }, { start: 283, end: 445 }, { start: 445, end: 276 }, { start: 390, end: 373 }, { start: 373, end: 339 }, { start: 339, end: 390 }, { start: 295, end: 282 }, { start: 282, end: 296 }, { start: 296, end: 295 }, { start: 448, end: 449 }, { start: 449, end: 346 }, { start: 346, end: 448 }, { start: 356, end: 264 }, { start: 264, end: 454 }, { start: 454, end: 356 }, { start: 337, end: 336 }, { start: 336, end: 299 }, { start: 299, end: 337 }, { start: 337, end: 338 }, { start: 338, end: 151 }, { start: 151, end: 337 }, { start: 294, end: 278 }, { start: 278, end: 455 }, { start: 455, end: 294 }, { start: 308, end: 292 }, { start: 292, end: 415 }, { start: 415, end: 308 }, { start: 429, end: 358 }, { start: 358, end: 355 }, { start: 355, end: 429 }, { start: 265, end: 340 }, { start: 340, end: 372 }, { start: 372, end: 265 }, { start: 352, end: 346 }, { start: 346, end: 280 }, { start: 280, end: 352 }, { start: 295, end: 442 }, { start: 442, end: 282 }, { start: 282, end: 295 }, { start: 354, end: 19 }, { start: 19, end: 370 }, { start: 370, end: 354 }, { start: 285, end: 441 }, { start: 441, end: 295 }, { start: 295, end: 285 }, { start: 195, end: 248 }, { start: 248, end: 197 }, { start: 197, end: 195 }, { start: 457, end: 440 }, { start: 440, end: 274 }, { start: 274, end: 457 }, { start: 301, end: 300 }, { start: 300, end: 368 }, { start: 368, end: 301 }, { start: 417, end: 351 }, { start: 351, end: 465 }, { start: 465, end: 417 }, { start: 251, end: 301 }, { start: 301, end: 389 }, { start: 389, end: 251 }, { start: 394, end: 395 }, { start: 395, end: 379 }, { start: 379, end: 394 }, { start: 399, end: 412 }, { start: 412, end: 419 }, { start: 419, end: 399 }, { start: 410, end: 436 }, { start: 436, end: 322 }, { start: 322, end: 410 }, { start: 326, end: 2 }, { start: 2, end: 393 }, { start: 393, end: 326 }, { start: 354, end: 370 }, { start: 370, end: 461 }, { start: 461, end: 354 }, { start: 393, end: 164 }, { start: 164, end: 267 }, { start: 267, end: 393 }, { start: 268, end: 302 }, { start: 302, end: 12 }, { start: 12, end: 268 }, { start: 312, end: 268 }, { start: 268, end: 13 }, { start: 13, end: 312 }, { start: 298, end: 293 }, { start: 293, end: 301 }, { start: 301, end: 298 }, { start: 265, end: 446 }, { start: 446, end: 340 }, { start: 340, end: 265 }, { start: 280, end: 330 }, { start: 330, end: 425 }, { start: 425, end: 280 }, { start: 322, end: 426 }, { start: 426, end: 391 }, { start: 391, end: 322 }, { start: 420, end: 429 }, { start: 429, end: 437 }, { start: 437, end: 420 }, { start: 393, end: 391 }, { start: 391, end: 326 }, { start: 326, end: 393 }, { start: 344, end: 440 }, { start: 440, end: 438 }, { start: 438, end: 344 }, { start: 458, end: 459 }, { start: 459, end: 461 }, { start: 461, end: 458 }, { start: 364, end: 434 }, { start: 434, end: 394 }, { start: 394, end: 364 }, { start: 428, end: 396 }, { start: 396, end: 262 }, { start: 262, end: 428 }, { start: 274, end: 354 }, { start: 354, end: 457 }, { start: 457, end: 274 }, { start: 317, end: 316 }, { start: 316, end: 402 }, { start: 402, end: 317 }, { start: 316, end: 315 }, { start: 315, end: 403 }, { start: 403, end: 316 }, { start: 315, end: 314 }, { start: 314, end: 404 }, { start: 404, end: 315 }, { start: 314, end: 313 }, { start: 313, end: 405 }, { start: 405, end: 314 }, { start: 313, end: 421 }, { start: 421, end: 406 }, { start: 406, end: 313 }, { start: 323, end: 366 }, { start: 366, end: 361 }, { start: 361, end: 323 }, { start: 292, end: 306 }, { start: 306, end: 407 }, { start: 407, end: 292 }, { start: 306, end: 291 }, { start: 291, end: 408 }, { start: 408, end: 306 }, { start: 291, end: 287 }, { start: 287, end: 409 }, { start: 409, end: 291 }, { start: 287, end: 432 }, { start: 432, end: 410 }, { start: 410, end: 287 }, { start: 427, end: 434 }, { start: 434, end: 411 }, { start: 411, end: 427 }, { start: 372, end: 264 }, { start: 264, end: 383 }, { start: 383, end: 372 }, { start: 459, end: 309 }, { start: 309, end: 457 }, { start: 457, end: 459 }, { start: 366, end: 352 }, { start: 352, end: 401 }, { start: 401, end: 366 }, { start: 1, end: 274 }, { start: 274, end: 4 }, { start: 4, end: 1 }, { start: 418, end: 421 }, { start: 421, end: 262 }, { start: 262, end: 418 }, { start: 331, end: 294 }, { start: 294, end: 358 }, { start: 358, end: 331 }, { start: 435, end: 433 }, { start: 433, end: 367 }, { start: 367, end: 435 }, { start: 392, end: 289 }, { start: 289, end: 439 }, { start: 439, end: 392 }, { start: 328, end: 462 }, { start: 462, end: 326 }, { start: 326, end: 328 }, { start: 94, end: 2 }, { start: 2, end: 370 }, { start: 370, end: 94 }, { start: 289, end: 305 }, { start: 305, end: 455 }, { start: 455, end: 289 }, { start: 339, end: 254 }, { start: 254, end: 448 }, { start: 448, end: 339 }, { start: 359, end: 255 }, { start: 255, end: 446 }, { start: 446, end: 359 }, { start: 254, end: 253 }, { start: 253, end: 449 }, { start: 449, end: 254 }, { start: 253, end: 252 }, { start: 252, end: 450 }, { start: 450, end: 253 }, { start: 252, end: 256 }, { start: 256, end: 451 }, { start: 451, end: 252 }, { start: 256, end: 341 }, { start: 341, end: 452 }, { start: 452, end: 256 }, { start: 414, end: 413 }, { start: 413, end: 463 }, { start: 463, end: 414 }, { start: 286, end: 441 }, { start: 441, end: 414 }, { start: 414, end: 286 }, { start: 286, end: 258 }, { start: 258, end: 441 }, { start: 441, end: 286 }, { start: 258, end: 257 }, { start: 257, end: 442 }, { start: 442, end: 258 }, { start: 257, end: 259 }, { start: 259, end: 443 }, { start: 443, end: 257 }, { start: 259, end: 260 }, { start: 260, end: 444 }, { start: 444, end: 259 }, { start: 260, end: 467 }, { start: 467, end: 445 }, { start: 445, end: 260 }, { start: 309, end: 459 }, { start: 459, end: 250 }, { start: 250, end: 309 }, { start: 305, end: 289 }, { start: 289, end: 290 }, { start: 290, end: 305 }, { start: 305, end: 290 }, { start: 290, end: 460 }, { start: 460, end: 305 }, { start: 401, end: 376 }, { start: 376, end: 435 }, { start: 435, end: 401 }, { start: 309, end: 250 }, { start: 250, end: 392 }, { start: 392, end: 309 }, { start: 376, end: 411 }, { start: 411, end: 433 }, { start: 433, end: 376 }, { start: 453, end: 341 }, { start: 341, end: 464 }, { start: 464, end: 453 }, { start: 357, end: 453 }, { start: 453, end: 465 }, { start: 465, end: 357 }, { start: 343, end: 357 }, { start: 357, end: 412 }, { start: 412, end: 343 }, { start: 437, end: 343 }, { start: 343, end: 399 }, { start: 399, end: 437 }, { start: 344, end: 360 }, { start: 360, end: 440 }, { start: 440, end: 344 }, { start: 420, end: 437 }, { start: 437, end: 456 }, { start: 456, end: 420 }, { start: 360, end: 420 }, { start: 420, end: 363 }, { start: 363, end: 360 }, { start: 361, end: 401 }, { start: 401, end: 288 }, { start: 288, end: 361 }, { start: 265, end: 372 }, { start: 372, end: 353 }, { start: 353, end: 265 }, { start: 390, end: 339 }, { start: 339, end: 249 }, { start: 249, end: 390 }, { start: 339, end: 448 }, { start: 448, end: 255 }, { start: 255, end: 339 }];
var face_landmarker_options = {};
Object.defineProperty(face_landmarker_options, "__esModule", { value: true });
var face_landmarker_result = {};
Object.defineProperty(face_landmarker_result, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.FaceLandmarker = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = classification_pb, n2 = landmark_pb, s2 = base_options_pb, p = face_detector_graph_options_pb, d2 = face_geometry_pb, l2 = face_landmarker_graph_options_pb, g = face_landmarks_detector_graph_options_pb, c6 = classifier_result, u = landmark_result, m = vision_task_runner, f2 = face_landmarks_connections;
  r2(face_landmarker_options, e2), r2(face_landmarker_result, e2);
  const h = "image_in", y = "norm_rect", b = "face_landmarks", _ = "blendshapes", O = "face_geometry", F = 0.5;
  class M extends m.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return m.VisionTaskRunner.createVisionInstance(M, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return m.VisionTaskRunner.createVisionInstance(M, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static createFromModelPath(e3, t3) {
      return m.VisionTaskRunner.createVisionInstance(M, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new m.VisionGraphRunner(e3, t3), h, y, false), this.result = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] }, this.outputFaceBlendshapes = false, this.outputFacialTransformationMatrixes = false, this.options = new l2.FaceLandmarkerGraphOptions(), this.options.setBaseOptions(new s2.BaseOptions()), this.faceLandmarksDetectorGraphOptions = new g.FaceLandmarksDetectorGraphOptions(), this.options.setFaceLandmarksDetectorGraphOptions(this.faceLandmarksDetectorGraphOptions), this.faceDetectorGraphOptions = new p.FaceDetectorGraphOptions(), this.options.setFaceDetectorGraphOptions(this.faceDetectorGraphOptions), this.initDefaults();
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      var t3, r3, o3, i4;
      return "numFaces" in e3 && this.faceDetectorGraphOptions.setNumFaces(null !== (t3 = e3.numFaces) && void 0 !== t3 ? t3 : 1), "minFaceDetectionConfidence" in e3 && this.faceDetectorGraphOptions.setMinDetectionConfidence(null !== (r3 = e3.minFaceDetectionConfidence) && void 0 !== r3 ? r3 : F), "minTrackingConfidence" in e3 && this.options.setMinTrackingConfidence(null !== (o3 = e3.minTrackingConfidence) && void 0 !== o3 ? o3 : F), "minFacePresenceConfidence" in e3 && this.faceLandmarksDetectorGraphOptions.setMinDetectionConfidence(null !== (i4 = e3.minFacePresenceConfidence) && void 0 !== i4 ? i4 : F), "outputFaceBlendshapes" in e3 && (this.outputFaceBlendshapes = !!e3.outputFaceBlendshapes), "outputFacialTransformationMatrixes" in e3 && (this.outputFacialTransformationMatrixes = !!e3.outputFacialTransformationMatrixes), this.applyOptions(e3);
    }
    detect(e3, t3) {
      return this.resetResults(), this.processImageData(e3, t3), this.result;
    }
    detectForVideo(e3, t3, r3) {
      return this.resetResults(), this.processVideoData(e3, r3, t3), this.result;
    }
    resetResults() {
      this.result = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] };
    }
    initDefaults() {
      this.faceDetectorGraphOptions.setNumFaces(1), this.faceDetectorGraphOptions.setMinDetectionConfidence(F), this.faceLandmarksDetectorGraphOptions.setMinDetectionConfidence(F), this.options.setMinTrackingConfidence(F);
    }
    addJsLandmarks(e3) {
      for (const t3 of e3) {
        const e4 = n2.NormalizedLandmarkList.deserializeBinary(t3);
        this.result.faceLandmarks.push((0, u.convertToLandmarks)(e4));
      }
    }
    addBlenshape(e3) {
      var t3;
      if (this.outputFaceBlendshapes)
        for (const r3 of e3) {
          const e4 = a3.ClassificationList.deserializeBinary(r3);
          this.result.faceBlendshapes.push((0, c6.convertFromClassifications)(null !== (t3 = e4.getClassificationList()) && void 0 !== t3 ? t3 : []));
        }
    }
    addFacialTransformationMatrixes(e3) {
      var t3, r3, o3;
      if (this.outputFacialTransformationMatrixes)
        for (const i4 of e3) {
          const e4 = d2.FaceGeometry.deserializeBinary(i4).getPoseTransformMatrix();
          e4 && this.result.facialTransformationMatrixes.push({ rows: null !== (t3 = e4.getRows()) && void 0 !== t3 ? t3 : 0, columns: null !== (r3 = e4.getCols()) && void 0 !== r3 ? r3 : 0, data: null !== (o3 = e4.getPackedDataList()) && void 0 !== o3 ? o3 : [] });
        }
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(h), e3.addInputStream(y), e3.addOutputStream(b);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(l2.FaceLandmarkerGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"), r3.addInputStream("IMAGE:" + h), r3.addInputStream("NORM_RECT:" + y), r3.addOutputStream("NORM_LANDMARKS:" + b), r3.setOptions(t3), e3.addNode(r3), this.graphRunner.attachProtoVectorListener(b, (e4, t4) => {
        this.addJsLandmarks(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(b, (e4) => {
        this.setLatestOutputTimestamp(e4);
      }), this.outputFaceBlendshapes && (e3.addOutputStream(_), r3.addOutputStream("BLENDSHAPES:" + _), this.graphRunner.attachProtoVectorListener(_, (e4, t4) => {
        this.addBlenshape(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(_, (e4) => {
        this.setLatestOutputTimestamp(e4);
      })), this.outputFacialTransformationMatrixes && (e3.addOutputStream(O), r3.addOutputStream("FACE_GEOMETRY:" + O), this.graphRunner.attachProtoVectorListener(O, (e4, t4) => {
        this.addFacialTransformationMatrixes(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(O, (e4) => {
        this.setLatestOutputTimestamp(e4);
      }));
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
  }
  e2.FaceLandmarker = M, M.FACE_LANDMARKS_LIPS = f2.FACE_LANDMARKS_LIPS, M.FACE_LANDMARKS_LEFT_EYE = f2.FACE_LANDMARKS_LEFT_EYE, M.FACE_LANDMARKS_LEFT_EYEBROW = f2.FACE_LANDMARKS_LEFT_EYEBROW, M.FACE_LANDMARKS_LEFT_IRIS = f2.FACE_LANDMARKS_LEFT_IRIS, M.FACE_LANDMARKS_RIGHT_EYE = f2.FACE_LANDMARKS_RIGHT_EYE, M.FACE_LANDMARKS_RIGHT_EYEBROW = f2.FACE_LANDMARKS_RIGHT_EYEBROW, M.FACE_LANDMARKS_RIGHT_IRIS = f2.FACE_LANDMARKS_RIGHT_IRIS, M.FACE_LANDMARKS_FACE_OVAL = f2.FACE_LANDMARKS_FACE_OVAL, M.FACE_LANDMARKS_CONTOURS = f2.FACE_LANDMARKS_CONTOURS, M.FACE_LANDMARKS_TESSELATION = f2.FACE_LANDMARKS_TESSELATION;
}(face_landmarker);
var face_stylizer = {};
var face_stylizer_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2);
  var s2 = face_landmarker_graph_options_pb;
  r2.object.extend(proto, s2), r2.exportSymbol("proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions", null, o2), proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.displayName = "proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), faceLandmarkerGraphOptions: (o3 = r3.getFaceLandmarkerGraphOptions()) && s2.FaceLandmarkerGraphOptions.toObject(e3, o3), faceAlignmentSize: t2.Message.getFieldWithDefault(r3, 3, 256) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions();
    return proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = new s2.FaceLandmarkerGraphOptions();
          t3.readMessage(r3, s2.FaceLandmarkerGraphOptions.deserializeBinaryFromReader), e3.setFaceLandmarkerGraphOptions(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setFaceAlignmentSize(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = e3.getFaceLandmarkerGraphOptions()) && r3.writeMessage(2, o3, s2.FaceLandmarkerGraphOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.ext = new t2.ExtensionFieldInfo(513916220, { ext: 0 }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[513916220] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[513916220] = proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.ext, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.getFaceLandmarkerGraphOptions = function() {
    return t2.Message.getWrapperField(this, s2.FaceLandmarkerGraphOptions, 2);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.setFaceLandmarkerGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.clearFaceLandmarkerGraphOptions = function() {
    return this.setFaceLandmarkerGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.hasFaceLandmarkerGraphOptions = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.getFaceAlignmentSize = function() {
    return t2.Message.getFieldWithDefault(this, 3, 256);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.setFaceAlignmentSize = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.clearFaceAlignmentSize = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.prototype.hasFaceAlignmentSize = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.ext = new t2.ExtensionFieldInfo(513916220, { ext: 0 }, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[513916220] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[513916220] = proto.mediapipe.tasks.vision.face_stylizer.proto.FaceStylizerGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.face_stylizer.proto);
}(face_stylizer_graph_options_pb);
var face_stylizer_options = {};
Object.defineProperty(face_stylizer_options, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.FaceStylizer = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = base_options_pb, n2 = face_stylizer_graph_options_pb, s2 = vision_task_runner;
  r2(face_stylizer_options, e2);
  const p = "image_in", d2 = "norm_rect", l2 = "stylized_image";
  class g extends s2.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return s2.VisionTaskRunner.createVisionInstance(g, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return s2.VisionTaskRunner.createVisionInstance(g, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static createFromModelPath(e3, t3) {
      return s2.VisionTaskRunner.createVisionInstance(g, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new s2.VisionGraphRunner(e3, t3), p, d2, true), this.options = new n2.FaceStylizerGraphOptions(), this.options.setBaseOptions(new a3.BaseOptions());
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      return super.applyOptions(e3);
    }
    stylize(e3, t3, r3) {
      const o3 = "function" != typeof t3 ? t3 : {};
      if (this.userCallback = "function" == typeof t3 ? t3 : r3, this.processImageData(e3, null != o3 ? o3 : {}), !this.userCallback)
        return this.result;
    }
    stylizeForVideo(e3, t3, r3, o3) {
      const i4 = "function" != typeof r3 ? r3 : {};
      if (this.userCallback = "function" == typeof r3 ? r3 : o3, this.processVideoData(e3, i4, t3), this.userCallback = void 0, !this.userCallback)
        return this.result;
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(p), e3.addInputStream(d2), e3.addOutputStream(l2);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(n2.FaceStylizerGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"), r3.addInputStream("IMAGE:" + p), r3.addInputStream("NORM_RECT:" + d2), r3.addOutputStream("STYLIZED_IMAGE:" + l2), r3.setOptions(t3), e3.addNode(r3), this.graphRunner.attachImageListener(l2, (e4, t4) => {
        const r4 = this.convertToMPImage(e4, !this.userCallback);
        this.result = r4, this.userCallback && this.userCallback(r4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(l2, (e4) => {
        this.result = null, this.userCallback && this.userCallback(null), this.setLatestOutputTimestamp(e4);
      });
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
  }
  e2.FaceStylizer = g;
}(face_stylizer);
var gesture_recognizer = {};
var gesture_classifier_graph_options_pb = {};
var classifier_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.tasks.components.processors.proto.ClassifierOptions", null, o2), proto.mediapipe.tasks.components.processors.proto.ClassifierOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.tasks.components.processors.proto.ClassifierOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.displayName = "proto.mediapipe.tasks.components.processors.proto.ClassifierOptions"), proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.repeatedFields_ = [4, 5], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.toObject = function(e3, r3) {
    var o3, i3 = { displayNamesLocale: t2.Message.getFieldWithDefault(r3, 1, "en"), maxResults: t2.Message.getFieldWithDefault(r3, 2, -1), scoreThreshold: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, categoryAllowlistList: null == (o3 = t2.Message.getRepeatedField(r3, 4)) ? void 0 : o3, categoryDenylistList: null == (o3 = t2.Message.getRepeatedField(r3, 5)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.components.processors.proto.ClassifierOptions();
    return proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setDisplayNamesLocale(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setMaxResults(r3);
          break;
        case 3:
          r3 = t3.readFloat();
          e3.setScoreThreshold(r3);
          break;
        case 4:
          r3 = t3.readString();
          e3.addCategoryAllowlist(r3);
          break;
        case 5:
          r3 = t3.readString();
          e3.addCategoryDenylist(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeFloat(3, o3), (o3 = e3.getCategoryAllowlistList()).length > 0 && r3.writeRepeatedString(4, o3), (o3 = e3.getCategoryDenylistList()).length > 0 && r3.writeRepeatedString(5, o3);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.getDisplayNamesLocale = function() {
    return t2.Message.getFieldWithDefault(this, 1, "en");
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.setDisplayNamesLocale = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.clearDisplayNamesLocale = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.hasDisplayNamesLocale = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.getMaxResults = function() {
    return t2.Message.getFieldWithDefault(this, 2, -1);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.setMaxResults = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.clearMaxResults = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.hasMaxResults = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.getScoreThreshold = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.setScoreThreshold = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.clearScoreThreshold = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.hasScoreThreshold = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.getCategoryAllowlistList = function() {
    return t2.Message.getRepeatedField(this, 4);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.setCategoryAllowlistList = function(e3) {
    return t2.Message.setField(this, 4, e3 || []);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.addCategoryAllowlist = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 4, e3, r3);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.clearCategoryAllowlistList = function() {
    return this.setCategoryAllowlistList([]);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.getCategoryDenylistList = function() {
    return t2.Message.getRepeatedField(this, 5);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.setCategoryDenylistList = function(e3) {
    return t2.Message.setField(this, 5, e3 || []);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.addCategoryDenylist = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 5, e3, r3);
  }, proto.mediapipe.tasks.components.processors.proto.ClassifierOptions.prototype.clearCategoryDenylistList = function() {
    return this.setCategoryDenylistList([]);
  }, r2.object.extend(e2, proto.mediapipe.tasks.components.processors.proto);
}(classifier_options_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = classifier_options_pb;
  r2.object.extend(proto, n2);
  var s2 = base_options_pb;
  r2.object.extend(proto, s2), r2.exportSymbol("proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions", null, o2), proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.displayName = "proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.toObject = function(e3, t3) {
    var r3, o3 = { baseOptions: (r3 = t3.getBaseOptions()) && s2.BaseOptions.toObject(e3, r3), classifierOptions: (r3 = t3.getClassifierOptions()) && n2.ClassifierOptions.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions();
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new s2.BaseOptions();
          t3.readMessage(r3, s2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = new n2.ClassifierOptions();
          t3.readMessage(r3, n2.ClassifierOptions.deserializeBinaryFromReader), e3.setClassifierOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getBaseOptions()) && t3.writeMessage(1, r3, s2.BaseOptions.serializeBinaryToWriter), null != (r3 = e3.getClassifierOptions()) && t3.writeMessage(2, r3, n2.ClassifierOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.ext = new t2.ExtensionFieldInfo(478825465, { ext: 0 }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[478825465] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[478825465] = proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.ext, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, s2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.getClassifierOptions = function() {
    return t2.Message.getWrapperField(this, n2.ClassifierOptions, 2);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.setClassifierOptions = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.clearClassifierOptions = function() {
    return this.setClassifierOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.prototype.hasClassifierOptions = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.ext = new t2.ExtensionFieldInfo(478825465, { ext: 0 }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[478825465] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[478825465] = proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureClassifierGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.gesture_recognizer.proto);
}(gesture_classifier_graph_options_pb);
var gesture_recognizer_graph_options_pb = {};
var hand_gesture_recognizer_graph_options_pb = {};
var gesture_embedder_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2), r2.exportSymbol("proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions", null, o2), proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.displayName = "proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.toObject = function(e3, t3) {
    var r3, o3 = { baseOptions: (r3 = t3.getBaseOptions()) && n2.BaseOptions.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions();
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new n2.BaseOptions();
        t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    null != (r3 = e3.getBaseOptions()) && t3.writeMessage(1, r3, n2.BaseOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.ext = new t2.ExtensionFieldInfo(478825422, { ext: 0 }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[478825422] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[478825422] = proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.ext, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.ext = new t2.ExtensionFieldInfo(478825422, { ext: 0 }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[478825422] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[478825422] = proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureEmbedderGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.gesture_recognizer.proto);
}(gesture_embedder_graph_options_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2);
  var s2 = gesture_classifier_graph_options_pb;
  r2.object.extend(proto, s2);
  var p = gesture_embedder_graph_options_pb;
  r2.object.extend(proto, p), r2.exportSymbol("proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions", null, o2), proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.displayName = "proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.toObject = function(e3, t3) {
    var r3, o3 = { baseOptions: (r3 = t3.getBaseOptions()) && n2.BaseOptions.toObject(e3, r3), gestureEmbedderGraphOptions: (r3 = t3.getGestureEmbedderGraphOptions()) && p.GestureEmbedderGraphOptions.toObject(e3, r3), cannedGestureClassifierGraphOptions: (r3 = t3.getCannedGestureClassifierGraphOptions()) && s2.GestureClassifierGraphOptions.toObject(e3, r3), customGestureClassifierGraphOptions: (r3 = t3.getCustomGestureClassifierGraphOptions()) && s2.GestureClassifierGraphOptions.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions();
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = new p.GestureEmbedderGraphOptions();
          t3.readMessage(r3, p.GestureEmbedderGraphOptions.deserializeBinaryFromReader), e3.setGestureEmbedderGraphOptions(r3);
          break;
        case 3:
          r3 = new s2.GestureClassifierGraphOptions();
          t3.readMessage(r3, s2.GestureClassifierGraphOptions.deserializeBinaryFromReader), e3.setCannedGestureClassifierGraphOptions(r3);
          break;
        case 4:
          r3 = new s2.GestureClassifierGraphOptions();
          t3.readMessage(r3, s2.GestureClassifierGraphOptions.deserializeBinaryFromReader), e3.setCustomGestureClassifierGraphOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getBaseOptions()) && t3.writeMessage(1, r3, n2.BaseOptions.serializeBinaryToWriter), null != (r3 = e3.getGestureEmbedderGraphOptions()) && t3.writeMessage(2, r3, p.GestureEmbedderGraphOptions.serializeBinaryToWriter), null != (r3 = e3.getCannedGestureClassifierGraphOptions()) && t3.writeMessage(3, r3, s2.GestureClassifierGraphOptions.serializeBinaryToWriter), null != (r3 = e3.getCustomGestureClassifierGraphOptions()) && t3.writeMessage(4, r3, s2.GestureClassifierGraphOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.ext = new t2.ExtensionFieldInfo(463370452, { ext: 0 }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[463370452] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[463370452] = proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.ext, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.getGestureEmbedderGraphOptions = function() {
    return t2.Message.getWrapperField(this, p.GestureEmbedderGraphOptions, 2);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.setGestureEmbedderGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.clearGestureEmbedderGraphOptions = function() {
    return this.setGestureEmbedderGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.hasGestureEmbedderGraphOptions = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.getCannedGestureClassifierGraphOptions = function() {
    return t2.Message.getWrapperField(this, s2.GestureClassifierGraphOptions, 3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.setCannedGestureClassifierGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.clearCannedGestureClassifierGraphOptions = function() {
    return this.setCannedGestureClassifierGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.hasCannedGestureClassifierGraphOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.getCustomGestureClassifierGraphOptions = function() {
    return t2.Message.getWrapperField(this, s2.GestureClassifierGraphOptions, 4);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.setCustomGestureClassifierGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 4, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.clearCustomGestureClassifierGraphOptions = function() {
    return this.setCustomGestureClassifierGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.prototype.hasCustomGestureClassifierGraphOptions = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.ext = new t2.ExtensionFieldInfo(463370452, { ext: 0 }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[463370452] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[463370452] = proto.mediapipe.tasks.vision.gesture_recognizer.proto.HandGestureRecognizerGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.gesture_recognizer.proto);
}(hand_gesture_recognizer_graph_options_pb);
var hand_landmarker_graph_options_pb = {};
var hand_detector_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2), r2.exportSymbol("proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions", null, o2), proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.displayName = "proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), minDetectionConfidence: t2.Message.getFloatingPointFieldWithDefault(r3, 2, 0.5), numHands: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions();
    return proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setMinDetectionConfidence(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setNumHands(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(464864288, { ext: 0 }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[464864288] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[464864288] = proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.ext, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.getMinDetectionConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0.5);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.setMinDetectionConfidence = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.clearMinDetectionConfidence = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.hasMinDetectionConfidence = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.getNumHands = function() {
    return t2.Message.getFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.setNumHands = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.clearNumHands = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.prototype.hasNumHands = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(464864288, { ext: 0 }, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[464864288] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[464864288] = proto.mediapipe.tasks.vision.hand_detector.proto.HandDetectorGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.hand_detector.proto);
}(hand_detector_graph_options_pb);
var hand_landmarks_detector_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2), r2.exportSymbol("proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions", null, o2), proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.displayName = "proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), minDetectionConfidence: t2.Message.getFloatingPointFieldWithDefault(r3, 2, 0.5) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions();
    return proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setMinDetectionConfidence(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(474472470, { ext: 0 }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[474472470] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[474472470] = proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.ext, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.getMinDetectionConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0.5);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.setMinDetectionConfidence = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.clearMinDetectionConfidence = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.prototype.hasMinDetectionConfidence = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(474472470, { ext: 0 }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[474472470] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[474472470] = proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarksDetectorGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.hand_landmarker.proto);
}(hand_landmarks_detector_graph_options_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2);
  var s2 = hand_detector_graph_options_pb;
  r2.object.extend(proto, s2);
  var p = hand_landmarks_detector_graph_options_pb;
  r2.object.extend(proto, p), r2.exportSymbol("proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions", null, o2), proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.displayName = "proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), handDetectorGraphOptions: (o3 = r3.getHandDetectorGraphOptions()) && s2.HandDetectorGraphOptions.toObject(e3, o3), handLandmarksDetectorGraphOptions: (o3 = r3.getHandLandmarksDetectorGraphOptions()) && p.HandLandmarksDetectorGraphOptions.toObject(e3, o3), minTrackingConfidence: t2.Message.getFloatingPointFieldWithDefault(r3, 4, 0.5) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions();
    return proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = new s2.HandDetectorGraphOptions();
          t3.readMessage(r3, s2.HandDetectorGraphOptions.deserializeBinaryFromReader), e3.setHandDetectorGraphOptions(r3);
          break;
        case 3:
          r3 = new p.HandLandmarksDetectorGraphOptions();
          t3.readMessage(r3, p.HandLandmarksDetectorGraphOptions.deserializeBinaryFromReader), e3.setHandLandmarksDetectorGraphOptions(r3);
          break;
        case 4:
          r3 = t3.readFloat();
          e3.setMinTrackingConfidence(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = e3.getHandDetectorGraphOptions()) && r3.writeMessage(2, o3, s2.HandDetectorGraphOptions.serializeBinaryToWriter), null != (o3 = e3.getHandLandmarksDetectorGraphOptions()) && r3.writeMessage(3, o3, p.HandLandmarksDetectorGraphOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeFloat(4, o3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.ext = new t2.ExtensionFieldInfo(462713202, { ext: 0 }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[462713202] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[462713202] = proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.ext, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.getHandDetectorGraphOptions = function() {
    return t2.Message.getWrapperField(this, s2.HandDetectorGraphOptions, 2);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.setHandDetectorGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.clearHandDetectorGraphOptions = function() {
    return this.setHandDetectorGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.hasHandDetectorGraphOptions = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.getHandLandmarksDetectorGraphOptions = function() {
    return t2.Message.getWrapperField(this, p.HandLandmarksDetectorGraphOptions, 3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.setHandLandmarksDetectorGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.clearHandLandmarksDetectorGraphOptions = function() {
    return this.setHandLandmarksDetectorGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.hasHandLandmarksDetectorGraphOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.getMinTrackingConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0.5);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.setMinTrackingConfidence = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.clearMinTrackingConfidence = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.prototype.hasMinTrackingConfidence = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.ext = new t2.ExtensionFieldInfo(462713202, { ext: 0 }, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[462713202] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[462713202] = proto.mediapipe.tasks.vision.hand_landmarker.proto.HandLandmarkerGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.hand_landmarker.proto);
}(hand_landmarker_graph_options_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2);
  var s2 = hand_gesture_recognizer_graph_options_pb;
  r2.object.extend(proto, s2);
  var p = hand_landmarker_graph_options_pb;
  r2.object.extend(proto, p), r2.exportSymbol("proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions", null, o2), proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.displayName = "proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.toObject = function(e3, t3) {
    var r3, o3 = { baseOptions: (r3 = t3.getBaseOptions()) && n2.BaseOptions.toObject(e3, r3), handLandmarkerGraphOptions: (r3 = t3.getHandLandmarkerGraphOptions()) && p.HandLandmarkerGraphOptions.toObject(e3, r3), handGestureRecognizerGraphOptions: (r3 = t3.getHandGestureRecognizerGraphOptions()) && s2.HandGestureRecognizerGraphOptions.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions();
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = new p.HandLandmarkerGraphOptions();
          t3.readMessage(r3, p.HandLandmarkerGraphOptions.deserializeBinaryFromReader), e3.setHandLandmarkerGraphOptions(r3);
          break;
        case 3:
          r3 = new s2.HandGestureRecognizerGraphOptions();
          t3.readMessage(r3, s2.HandGestureRecognizerGraphOptions.deserializeBinaryFromReader), e3.setHandGestureRecognizerGraphOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getBaseOptions()) && t3.writeMessage(1, r3, n2.BaseOptions.serializeBinaryToWriter), null != (r3 = e3.getHandLandmarkerGraphOptions()) && t3.writeMessage(2, r3, p.HandLandmarkerGraphOptions.serializeBinaryToWriter), null != (r3 = e3.getHandGestureRecognizerGraphOptions()) && t3.writeMessage(3, r3, s2.HandGestureRecognizerGraphOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.ext = new t2.ExtensionFieldInfo(479097054, { ext: 0 }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[479097054] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[479097054] = proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.ext, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.getHandLandmarkerGraphOptions = function() {
    return t2.Message.getWrapperField(this, p.HandLandmarkerGraphOptions, 2);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.setHandLandmarkerGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.clearHandLandmarkerGraphOptions = function() {
    return this.setHandLandmarkerGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.hasHandLandmarkerGraphOptions = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.getHandGestureRecognizerGraphOptions = function() {
    return t2.Message.getWrapperField(this, s2.HandGestureRecognizerGraphOptions, 3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.setHandGestureRecognizerGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.clearHandGestureRecognizerGraphOptions = function() {
    return this.setHandGestureRecognizerGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.prototype.hasHandGestureRecognizerGraphOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.ext = new t2.ExtensionFieldInfo(479097054, { ext: 0 }, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[479097054] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[479097054] = proto.mediapipe.tasks.vision.gesture_recognizer.proto.GestureRecognizerGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.gesture_recognizer.proto);
}(gesture_recognizer_graph_options_pb);
var classifier_options = {};
Object.defineProperty(classifier_options, "__esModule", { value: true }), classifier_options.convertClassifierOptionsToProto = void 0;
var classifier_options_pb_1 = classifier_options_pb;
function convertClassifierOptionsToProto(e2, t2) {
  const r2 = t2 ? t2.clone() : new classifier_options_pb_1.ClassifierOptions();
  return void 0 !== e2.displayNamesLocale ? r2.setDisplayNamesLocale(e2.displayNamesLocale) : void 0 === e2.displayNamesLocale && r2.clearDisplayNamesLocale(), void 0 !== e2.maxResults ? r2.setMaxResults(e2.maxResults) : "maxResults" in e2 && r2.clearMaxResults(), void 0 !== e2.scoreThreshold ? r2.setScoreThreshold(e2.scoreThreshold) : "scoreThreshold" in e2 && r2.clearScoreThreshold(), void 0 !== e2.categoryAllowlist ? r2.setCategoryAllowlistList(e2.categoryAllowlist) : "categoryAllowlist" in e2 && r2.clearCategoryAllowlistList(), void 0 !== e2.categoryDenylist ? r2.setCategoryDenylistList(e2.categoryDenylist) : "categoryDenylist" in e2 && r2.clearCategoryDenylistList(), r2;
}
classifier_options.convertClassifierOptionsToProto = convertClassifierOptionsToProto;
var hand_landmarks_connections = {};
Object.defineProperty(hand_landmarks_connections, "__esModule", { value: true }), hand_landmarks_connections.HAND_CONNECTIONS = void 0, hand_landmarks_connections.HAND_CONNECTIONS = [{ start: 0, end: 1 }, { start: 1, end: 2 }, { start: 2, end: 3 }, { start: 3, end: 4 }, { start: 0, end: 5 }, { start: 5, end: 6 }, { start: 6, end: 7 }, { start: 7, end: 8 }, { start: 5, end: 9 }, { start: 9, end: 10 }, { start: 10, end: 11 }, { start: 11, end: 12 }, { start: 9, end: 13 }, { start: 13, end: 14 }, { start: 14, end: 15 }, { start: 15, end: 16 }, { start: 13, end: 17 }, { start: 0, end: 17 }, { start: 17, end: 18 }, { start: 18, end: 19 }, { start: 19, end: 20 }];
var gesture_recognizer_options = {};
Object.defineProperty(gesture_recognizer_options, "__esModule", { value: true });
var gesture_recognizer_result = {};
Object.defineProperty(gesture_recognizer_result, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.GestureRecognizer = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = classification_pb, n2 = landmark_pb, s2 = base_options_pb, p = gesture_classifier_graph_options_pb, d2 = gesture_recognizer_graph_options_pb, l2 = hand_gesture_recognizer_graph_options_pb, g = hand_detector_graph_options_pb, c6 = hand_landmarker_graph_options_pb, u = hand_landmarks_detector_graph_options_pb, m = classifier_options, f2 = vision_task_runner, h = hand_landmarks_connections;
  r2(gesture_recognizer_options, e2), r2(gesture_recognizer_result, e2);
  const y = "image_in", b = "norm_rect", _ = "hand_gestures", O = "hand_landmarks", F = "world_hand_landmarks", M = "handedness", R = 0.5;
  class v4 extends f2.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return f2.VisionTaskRunner.createVisionInstance(v4, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return f2.VisionTaskRunner.createVisionInstance(v4, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static createFromModelPath(e3, t3) {
      return f2.VisionTaskRunner.createVisionInstance(v4, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new f2.VisionGraphRunner(e3, t3), y, b, false), this.gestures = [], this.landmarks = [], this.worldLandmarks = [], this.handednesses = [], this.options = new d2.GestureRecognizerGraphOptions(), this.options.setBaseOptions(new s2.BaseOptions()), this.handLandmarkerGraphOptions = new c6.HandLandmarkerGraphOptions(), this.options.setHandLandmarkerGraphOptions(this.handLandmarkerGraphOptions), this.handLandmarksDetectorGraphOptions = new u.HandLandmarksDetectorGraphOptions(), this.handLandmarkerGraphOptions.setHandLandmarksDetectorGraphOptions(this.handLandmarksDetectorGraphOptions), this.handDetectorGraphOptions = new g.HandDetectorGraphOptions(), this.handLandmarkerGraphOptions.setHandDetectorGraphOptions(this.handDetectorGraphOptions), this.handGestureRecognizerGraphOptions = new l2.HandGestureRecognizerGraphOptions(), this.options.setHandGestureRecognizerGraphOptions(this.handGestureRecognizerGraphOptions), this.handDetectorGraphOptions.setMinDetectionConfidence(R), this.handLandmarkerGraphOptions.setMinTrackingConfidence(R), this.handLandmarksDetectorGraphOptions.setMinDetectionConfidence(R);
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      var t3, r3, o3, i4, a4, n3, s3, d3;
      if (this.handDetectorGraphOptions.setNumHands(null !== (t3 = e3.numHands) && void 0 !== t3 ? t3 : 1), "minHandDetectionConfidence" in e3 && this.handDetectorGraphOptions.setMinDetectionConfidence(null !== (r3 = e3.minHandDetectionConfidence) && void 0 !== r3 ? r3 : R), "minTrackingConfidence" in e3 && this.handLandmarkerGraphOptions.setMinTrackingConfidence(null !== (o3 = e3.minTrackingConfidence) && void 0 !== o3 ? o3 : R), "minHandPresenceConfidence" in e3 && this.handLandmarksDetectorGraphOptions.setMinDetectionConfidence(null !== (i4 = e3.minHandPresenceConfidence) && void 0 !== i4 ? i4 : R), e3.cannedGesturesClassifierOptions) {
        const t4 = new p.GestureClassifierGraphOptions();
        t4.setClassifierOptions((0, m.convertClassifierOptionsToProto)(e3.cannedGesturesClassifierOptions, null === (a4 = this.handGestureRecognizerGraphOptions.getCannedGestureClassifierGraphOptions()) || void 0 === a4 ? void 0 : a4.getClassifierOptions())), this.handGestureRecognizerGraphOptions.setCannedGestureClassifierGraphOptions(t4);
      } else
        void 0 === e3.cannedGesturesClassifierOptions && (null === (n3 = this.handGestureRecognizerGraphOptions.getCannedGestureClassifierGraphOptions()) || void 0 === n3 || n3.clearClassifierOptions());
      if (e3.customGesturesClassifierOptions) {
        const t4 = new p.GestureClassifierGraphOptions();
        t4.setClassifierOptions((0, m.convertClassifierOptionsToProto)(e3.customGesturesClassifierOptions, null === (s3 = this.handGestureRecognizerGraphOptions.getCustomGestureClassifierGraphOptions()) || void 0 === s3 ? void 0 : s3.getClassifierOptions())), this.handGestureRecognizerGraphOptions.setCustomGestureClassifierGraphOptions(t4);
      } else
        void 0 === e3.customGesturesClassifierOptions && (null === (d3 = this.handGestureRecognizerGraphOptions.getCustomGestureClassifierGraphOptions()) || void 0 === d3 || d3.clearClassifierOptions());
      return this.applyOptions(e3);
    }
    recognize(e3, t3) {
      return this.resetResults(), this.processImageData(e3, t3), this.processResults();
    }
    recognizeForVideo(e3, t3, r3) {
      return this.resetResults(), this.processVideoData(e3, r3, t3), this.processResults();
    }
    resetResults() {
      this.gestures = [], this.landmarks = [], this.worldLandmarks = [], this.handednesses = [];
    }
    processResults() {
      return 0 === this.gestures.length ? { gestures: [], landmarks: [], worldLandmarks: [], handednesses: [] } : { gestures: this.gestures, landmarks: this.landmarks, worldLandmarks: this.worldLandmarks, handednesses: this.handednesses };
    }
    toJsCategories(e3, t3 = true) {
      var r3, o3, i4;
      const n3 = [];
      for (const s3 of e3) {
        const e4 = a3.ClassificationList.deserializeBinary(s3), p2 = [];
        for (const a4 of e4.getClassificationList()) {
          const e5 = t3 && a4.hasIndex() ? a4.getIndex() : -1;
          p2.push({ score: null !== (r3 = a4.getScore()) && void 0 !== r3 ? r3 : 0, index: e5, categoryName: null !== (o3 = a4.getLabel()) && void 0 !== o3 ? o3 : "", displayName: null !== (i4 = a4.getDisplayName()) && void 0 !== i4 ? i4 : "" });
        }
        n3.push(p2);
      }
      return n3;
    }
    addJsLandmarks(e3) {
      var t3, r3, o3;
      for (const i4 of e3) {
        const e4 = n2.NormalizedLandmarkList.deserializeBinary(i4), a4 = [];
        for (const i5 of e4.getLandmarkList())
          a4.push({ x: null !== (t3 = i5.getX()) && void 0 !== t3 ? t3 : 0, y: null !== (r3 = i5.getY()) && void 0 !== r3 ? r3 : 0, z: null !== (o3 = i5.getZ()) && void 0 !== o3 ? o3 : 0 });
        this.landmarks.push(a4);
      }
    }
    adddJsWorldLandmarks(e3) {
      var t3, r3, o3;
      for (const i4 of e3) {
        const e4 = n2.LandmarkList.deserializeBinary(i4), a4 = [];
        for (const i5 of e4.getLandmarkList())
          a4.push({ x: null !== (t3 = i5.getX()) && void 0 !== t3 ? t3 : 0, y: null !== (r3 = i5.getY()) && void 0 !== r3 ? r3 : 0, z: null !== (o3 = i5.getZ()) && void 0 !== o3 ? o3 : 0 });
        this.worldLandmarks.push(a4);
      }
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(y), e3.addInputStream(b), e3.addOutputStream(_), e3.addOutputStream(O), e3.addOutputStream(F), e3.addOutputStream(M);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(d2.GestureRecognizerGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"), r3.addInputStream("IMAGE:" + y), r3.addInputStream("NORM_RECT:" + b), r3.addOutputStream("HAND_GESTURES:" + _), r3.addOutputStream("LANDMARKS:" + O), r3.addOutputStream("WORLD_LANDMARKS:" + F), r3.addOutputStream("HANDEDNESS:" + M), r3.setOptions(t3), e3.addNode(r3), this.graphRunner.attachProtoVectorListener(O, (e4, t4) => {
        this.addJsLandmarks(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(O, (e4) => {
        this.setLatestOutputTimestamp(e4);
      }), this.graphRunner.attachProtoVectorListener(F, (e4, t4) => {
        this.adddJsWorldLandmarks(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(F, (e4) => {
        this.setLatestOutputTimestamp(e4);
      }), this.graphRunner.attachProtoVectorListener(_, (e4, t4) => {
        this.gestures.push(...this.toJsCategories(e4, false)), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(_, (e4) => {
        this.setLatestOutputTimestamp(e4);
      }), this.graphRunner.attachProtoVectorListener(M, (e4, t4) => {
        this.handednesses.push(...this.toJsCategories(e4)), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(M, (e4) => {
        this.setLatestOutputTimestamp(e4);
      });
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
  }
  e2.GestureRecognizer = v4, v4.HAND_CONNECTIONS = h.HAND_CONNECTIONS;
}(gesture_recognizer);
var hand_landmarker = {};
var hand_landmarker_options = {};
Object.defineProperty(hand_landmarker_options, "__esModule", { value: true });
var hand_landmarker_result = {};
Object.defineProperty(hand_landmarker_result, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.HandLandmarker = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = classification_pb, n2 = landmark_pb, s2 = base_options_pb, p = hand_detector_graph_options_pb, d2 = hand_landmarker_graph_options_pb, l2 = hand_landmarks_detector_graph_options_pb, g = landmark_result, c6 = vision_task_runner, u = hand_landmarks_connections;
  r2(hand_landmarker_options, e2), r2(hand_landmarker_result, e2);
  const m = "image_in", f2 = "norm_rect", h = "hand_landmarks", y = "world_hand_landmarks", b = "handedness", _ = 0.5;
  class O extends c6.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return c6.VisionTaskRunner.createVisionInstance(O, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return c6.VisionTaskRunner.createVisionInstance(O, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static createFromModelPath(e3, t3) {
      return c6.VisionTaskRunner.createVisionInstance(O, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new c6.VisionGraphRunner(e3, t3), m, f2, false), this.landmarks = [], this.worldLandmarks = [], this.handednesses = [], this.options = new d2.HandLandmarkerGraphOptions(), this.options.setBaseOptions(new s2.BaseOptions()), this.handLandmarksDetectorGraphOptions = new l2.HandLandmarksDetectorGraphOptions(), this.options.setHandLandmarksDetectorGraphOptions(this.handLandmarksDetectorGraphOptions), this.handDetectorGraphOptions = new p.HandDetectorGraphOptions(), this.options.setHandDetectorGraphOptions(this.handDetectorGraphOptions), this.initDefaults();
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      var t3, r3, o3, i4;
      return "numHands" in e3 && this.handDetectorGraphOptions.setNumHands(null !== (t3 = e3.numHands) && void 0 !== t3 ? t3 : 1), "minHandDetectionConfidence" in e3 && this.handDetectorGraphOptions.setMinDetectionConfidence(null !== (r3 = e3.minHandDetectionConfidence) && void 0 !== r3 ? r3 : _), "minTrackingConfidence" in e3 && this.options.setMinTrackingConfidence(null !== (o3 = e3.minTrackingConfidence) && void 0 !== o3 ? o3 : _), "minHandPresenceConfidence" in e3 && this.handLandmarksDetectorGraphOptions.setMinDetectionConfidence(null !== (i4 = e3.minHandPresenceConfidence) && void 0 !== i4 ? i4 : _), this.applyOptions(e3);
    }
    detect(e3, t3) {
      return this.resetResults(), this.processImageData(e3, t3), this.processResults();
    }
    detectForVideo(e3, t3, r3) {
      return this.resetResults(), this.processVideoData(e3, r3, t3), this.processResults();
    }
    resetResults() {
      this.landmarks = [], this.worldLandmarks = [], this.handednesses = [];
    }
    processResults() {
      return { landmarks: this.landmarks, worldLandmarks: this.worldLandmarks, handednesses: this.handednesses };
    }
    initDefaults() {
      this.handDetectorGraphOptions.setNumHands(1), this.handDetectorGraphOptions.setMinDetectionConfidence(_), this.handLandmarksDetectorGraphOptions.setMinDetectionConfidence(_), this.options.setMinTrackingConfidence(_);
    }
    toJsCategories(e3) {
      var t3, r3, o3, i4;
      const n3 = [];
      for (const s3 of e3) {
        const e4 = a3.ClassificationList.deserializeBinary(s3), p2 = [];
        for (const a4 of e4.getClassificationList())
          p2.push({ score: null !== (t3 = a4.getScore()) && void 0 !== t3 ? t3 : 0, index: null !== (r3 = a4.getIndex()) && void 0 !== r3 ? r3 : -1, categoryName: null !== (o3 = a4.getLabel()) && void 0 !== o3 ? o3 : "", displayName: null !== (i4 = a4.getDisplayName()) && void 0 !== i4 ? i4 : "" });
        n3.push(p2);
      }
      return n3;
    }
    addJsLandmarks(e3) {
      for (const t3 of e3) {
        const e4 = n2.NormalizedLandmarkList.deserializeBinary(t3);
        this.landmarks.push((0, g.convertToLandmarks)(e4));
      }
    }
    adddJsWorldLandmarks(e3) {
      for (const t3 of e3) {
        const e4 = n2.LandmarkList.deserializeBinary(t3);
        this.worldLandmarks.push((0, g.convertToWorldLandmarks)(e4));
      }
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(m), e3.addInputStream(f2), e3.addOutputStream(h), e3.addOutputStream(y), e3.addOutputStream(b);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(d2.HandLandmarkerGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"), r3.addInputStream("IMAGE:" + m), r3.addInputStream("NORM_RECT:" + f2), r3.addOutputStream("LANDMARKS:" + h), r3.addOutputStream("WORLD_LANDMARKS:" + y), r3.addOutputStream("HANDEDNESS:" + b), r3.setOptions(t3), e3.addNode(r3), this.graphRunner.attachProtoVectorListener(h, (e4, t4) => {
        this.addJsLandmarks(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(h, (e4) => {
        this.setLatestOutputTimestamp(e4);
      }), this.graphRunner.attachProtoVectorListener(y, (e4, t4) => {
        this.adddJsWorldLandmarks(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(y, (e4) => {
        this.setLatestOutputTimestamp(e4);
      }), this.graphRunner.attachProtoVectorListener(b, (e4, t4) => {
        this.handednesses.push(...this.toJsCategories(e4)), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(b, (e4) => {
        this.setLatestOutputTimestamp(e4);
      });
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
  }
  e2.HandLandmarker = O, O.HAND_CONNECTIONS = u.HAND_CONNECTIONS;
}(hand_landmarker);
var image_classifier = {};
var classifications_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = classification_pb;
  r2.object.extend(proto, i3), r2.exportSymbol("proto.mediapipe.tasks.components.containers.proto.ClassificationResult", null, o2), r2.exportSymbol("proto.mediapipe.tasks.components.containers.proto.Classifications", null, o2), proto.mediapipe.tasks.components.containers.proto.Classifications = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.components.containers.proto.Classifications, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.components.containers.proto.Classifications.displayName = "proto.mediapipe.tasks.components.containers.proto.Classifications"), proto.mediapipe.tasks.components.containers.proto.ClassificationResult = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.tasks.components.containers.proto.ClassificationResult, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.components.containers.proto.ClassificationResult.displayName = "proto.mediapipe.tasks.components.containers.proto.ClassificationResult"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.components.containers.proto.Classifications.toObject(e3, this);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.toObject = function(e3, r3) {
    var o3, a3 = { classificationList: (o3 = r3.getClassificationList()) && i3.ClassificationList.toObject(e3, o3), headIndex: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, headName: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3 };
    return e3 && (a3.$jspbMessageInstance = r3), a3;
  }), proto.mediapipe.tasks.components.containers.proto.Classifications.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.components.containers.proto.Classifications();
    return proto.mediapipe.tasks.components.containers.proto.Classifications.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 4:
          var r3 = new i3.ClassificationList();
          t3.readMessage(r3, i3.ClassificationList.deserializeBinaryFromReader), e3.setClassificationList(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setHeadIndex(r3);
          break;
        case 3:
          r3 = t3.readString();
          e3.setHeadName(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.components.containers.proto.Classifications.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getClassificationList()) && r3.writeMessage(4, o3, i3.ClassificationList.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeString(3, o3);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.getClassificationList = function() {
    return t2.Message.getWrapperField(this, i3.ClassificationList, 4);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.setClassificationList = function(e3) {
    return t2.Message.setWrapperField(this, 4, e3);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.clearClassificationList = function() {
    return this.setClassificationList(void 0);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.hasClassificationList = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.getHeadIndex = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.setHeadIndex = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.clearHeadIndex = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.hasHeadIndex = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.getHeadName = function() {
    return t2.Message.getFieldWithDefault(this, 3, "");
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.setHeadName = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.clearHeadName = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.tasks.components.containers.proto.Classifications.prototype.hasHeadName = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.components.containers.proto.ClassificationResult.toObject(e3, this);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.toObject = function(e3, r3) {
    var o3, i4 = { classificationsList: t2.Message.toObjectList(r3.getClassificationsList(), proto.mediapipe.tasks.components.containers.proto.Classifications.toObject, e3), timestampMs: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.components.containers.proto.ClassificationResult.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.components.containers.proto.ClassificationResult();
    return proto.mediapipe.tasks.components.containers.proto.ClassificationResult.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.tasks.components.containers.proto.Classifications();
          t3.readMessage(r3, proto.mediapipe.tasks.components.containers.proto.Classifications.deserializeBinaryFromReader), e3.addClassifications(r3);
          break;
        case 2:
          r3 = t3.readInt64();
          e3.setTimestampMs(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.components.containers.proto.ClassificationResult.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    (o3 = e3.getClassificationsList()).length > 0 && r3.writeRepeatedMessage(1, o3, proto.mediapipe.tasks.components.containers.proto.Classifications.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt64(2, o3);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.getClassificationsList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.tasks.components.containers.proto.Classifications, 1);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.setClassificationsList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.addClassifications = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.tasks.components.containers.proto.Classifications, r3);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.clearClassificationsList = function() {
    return this.setClassificationsList([]);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.getTimestampMs = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.setTimestampMs = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.clearTimestampMs = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.components.containers.proto.ClassificationResult.prototype.hasTimestampMs = function() {
    return null != t2.Message.getField(this, 2);
  }, r2.object.extend(e2, proto.mediapipe.tasks.components.containers.proto);
}(classifications_pb);
var image_classifier_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = classifier_options_pb;
  r2.object.extend(proto, n2);
  var s2 = base_options_pb;
  r2.object.extend(proto, s2), r2.exportSymbol("proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions", null, o2), proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.displayName = "proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.toObject = function(e3, t3) {
    var r3, o3 = { baseOptions: (r3 = t3.getBaseOptions()) && s2.BaseOptions.toObject(e3, r3), classifierOptions: (r3 = t3.getClassifierOptions()) && n2.ClassifierOptions.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions();
    return proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new s2.BaseOptions();
          t3.readMessage(r3, s2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = new n2.ClassifierOptions();
          t3.readMessage(r3, n2.ClassifierOptions.deserializeBinaryFromReader), e3.setClassifierOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getBaseOptions()) && t3.writeMessage(1, r3, s2.BaseOptions.serializeBinaryToWriter), null != (r3 = e3.getClassifierOptions()) && t3.writeMessage(2, r3, n2.ClassifierOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.ext = new t2.ExtensionFieldInfo(456383383, { ext: 0 }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[456383383] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[456383383] = proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.ext, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, s2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.getClassifierOptions = function() {
    return t2.Message.getWrapperField(this, n2.ClassifierOptions, 2);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.setClassifierOptions = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.clearClassifierOptions = function() {
    return this.setClassifierOptions(void 0);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.prototype.hasClassifierOptions = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.ext = new t2.ExtensionFieldInfo(456383383, { ext: 0 }, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[456383383] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[456383383] = proto.mediapipe.tasks.vision.image_classifier.proto.ImageClassifierGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.image_classifier.proto);
}(image_classifier_graph_options_pb);
var image_classifier_options = {};
Object.defineProperty(image_classifier_options, "__esModule", { value: true });
var image_classifier_result = {};
Object.defineProperty(image_classifier_result, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.ImageClassifier = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = classifications_pb, n2 = base_options_pb, s2 = image_classifier_graph_options_pb, p = classifier_options, d2 = classifier_result, l2 = vision_task_runner, g = "input_image", c6 = "norm_rect", u = "classifications";
  r2(image_classifier_options, e2), r2(image_classifier_result, e2);
  class m extends l2.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return l2.VisionTaskRunner.createVisionInstance(m, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return l2.VisionTaskRunner.createVisionInstance(m, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static createFromModelPath(e3, t3) {
      return l2.VisionTaskRunner.createVisionInstance(m, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new l2.VisionGraphRunner(e3, t3), g, c6, true), this.classificationResult = { classifications: [] }, this.options = new s2.ImageClassifierGraphOptions(), this.options.setBaseOptions(new n2.BaseOptions());
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      return this.options.setClassifierOptions((0, p.convertClassifierOptionsToProto)(e3, this.options.getClassifierOptions())), this.applyOptions(e3);
    }
    classify(e3, t3) {
      return this.classificationResult = { classifications: [] }, this.processImageData(e3, t3), this.classificationResult;
    }
    classifyForVideo(e3, t3, r3) {
      return this.classificationResult = { classifications: [] }, this.processVideoData(e3, r3, t3), this.classificationResult;
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(g), e3.addInputStream(c6), e3.addOutputStream(u);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(s2.ImageClassifierGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"), r3.addInputStream("IMAGE:" + g), r3.addInputStream("NORM_RECT:" + c6), r3.addOutputStream("CLASSIFICATIONS:" + u), r3.setOptions(t3), e3.addNode(r3), this.graphRunner.attachProtoListener(u, (e4, t4) => {
        this.classificationResult = (0, d2.convertFromClassificationResultProto)(a3.ClassificationResult.deserializeBinary(e4)), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(u, (e4) => {
        this.setLatestOutputTimestamp(e4);
      });
      const n3 = e3.serializeBinary();
      this.setGraph(new Uint8Array(n3), true);
    }
  }
  e2.ImageClassifier = m;
}(image_classifier);
var image_embedder = {};
var embeddings_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.tasks.components.containers.proto.Embedding", null, o2), r2.exportSymbol("proto.mediapipe.tasks.components.containers.proto.Embedding.EmbeddingCase", null, o2), r2.exportSymbol("proto.mediapipe.tasks.components.containers.proto.EmbeddingResult", null, o2), r2.exportSymbol("proto.mediapipe.tasks.components.containers.proto.FloatEmbedding", null, o2), r2.exportSymbol("proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding", null, o2), proto.mediapipe.tasks.components.containers.proto.FloatEmbedding = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.tasks.components.containers.proto.FloatEmbedding, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.displayName = "proto.mediapipe.tasks.components.containers.proto.FloatEmbedding"), proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.displayName = "proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding"), proto.mediapipe.tasks.components.containers.proto.Embedding = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, proto.mediapipe.tasks.components.containers.proto.Embedding.oneofGroups_);
  }, r2.inherits(proto.mediapipe.tasks.components.containers.proto.Embedding, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.components.containers.proto.Embedding.displayName = "proto.mediapipe.tasks.components.containers.proto.Embedding"), proto.mediapipe.tasks.components.containers.proto.EmbeddingResult = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.tasks.components.containers.proto.EmbeddingResult, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.displayName = "proto.mediapipe.tasks.components.containers.proto.EmbeddingResult"), proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.toObject(e3, this);
  }, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.toObject = function(e3, r3) {
    var o3, i3 = { valuesList: null == (o3 = t2.Message.getRepeatedFloatingPointField(r3, 1)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.components.containers.proto.FloatEmbedding();
    return proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber())
        for (var r3 = t3.isDelimited() ? t3.readPackedFloat() : [t3.readFloat()], o3 = 0; o3 < r3.length; o3++)
          e3.addValues(r3[o3]);
      else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getValuesList()).length > 0 && t3.writePackedFloat(1, r3);
  }, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.prototype.getValuesList = function() {
    return t2.Message.getRepeatedFloatingPointField(this, 1);
  }, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.prototype.setValuesList = function(e3) {
    return t2.Message.setField(this, 1, e3 || []);
  }, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.prototype.addValues = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 1, e3, r3);
  }, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.prototype.clearValuesList = function() {
    return this.setValuesList([]);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.toObject(e3, this);
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.toObject = function(e3, t3) {
    var r3 = { values: t3.getValues_asB64() };
    return e3 && (r3.$jspbMessageInstance = t3), r3;
  }), proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding();
    return proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = t3.readBytes();
        e3.setValues(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.serializeBinaryToWriter = function(e3, r3) {
    var o3;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeBytes(1, o3);
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.prototype.getValues = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.prototype.getValues_asB64 = function() {
    return t2.Message.bytesAsB64(this.getValues());
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.prototype.getValues_asU8 = function() {
    return t2.Message.bytesAsU8(this.getValues());
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.prototype.setValues = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.prototype.clearValues = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.prototype.hasValues = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.oneofGroups_ = [[1, 2]], proto.mediapipe.tasks.components.containers.proto.Embedding.EmbeddingCase = { EMBEDDING_NOT_SET: 0, FLOAT_EMBEDDING: 1, QUANTIZED_EMBEDDING: 2 }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.getEmbeddingCase = function() {
    return t2.Message.computeOneofCase(this, proto.mediapipe.tasks.components.containers.proto.Embedding.oneofGroups_[0]);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.components.containers.proto.Embedding.toObject(e3, this);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.toObject = function(e3, r3) {
    var o3, i3 = { floatEmbedding: (o3 = r3.getFloatEmbedding()) && proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.toObject(e3, o3), quantizedEmbedding: (o3 = r3.getQuantizedEmbedding()) && proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.toObject(e3, o3), headIndex: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3, headName: null == (o3 = t2.Message.getField(r3, 4)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.components.containers.proto.Embedding.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.components.containers.proto.Embedding();
    return proto.mediapipe.tasks.components.containers.proto.Embedding.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.tasks.components.containers.proto.FloatEmbedding();
          t3.readMessage(r3, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.deserializeBinaryFromReader), e3.setFloatEmbedding(r3);
          break;
        case 2:
          r3 = new proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding();
          t3.readMessage(r3, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.deserializeBinaryFromReader), e3.setQuantizedEmbedding(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setHeadIndex(r3);
          break;
        case 4:
          r3 = t3.readString();
          e3.setHeadName(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.components.containers.proto.Embedding.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getFloatEmbedding()) && r3.writeMessage(1, o3, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding.serializeBinaryToWriter), null != (o3 = e3.getQuantizedEmbedding()) && r3.writeMessage(2, o3, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeString(4, o3);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.getFloatEmbedding = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.tasks.components.containers.proto.FloatEmbedding, 1);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.setFloatEmbedding = function(e3) {
    return t2.Message.setOneofWrapperField(this, 1, proto.mediapipe.tasks.components.containers.proto.Embedding.oneofGroups_[0], e3);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.clearFloatEmbedding = function() {
    return this.setFloatEmbedding(void 0);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.hasFloatEmbedding = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.getQuantizedEmbedding = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.tasks.components.containers.proto.QuantizedEmbedding, 2);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.setQuantizedEmbedding = function(e3) {
    return t2.Message.setOneofWrapperField(this, 2, proto.mediapipe.tasks.components.containers.proto.Embedding.oneofGroups_[0], e3);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.clearQuantizedEmbedding = function() {
    return this.setQuantizedEmbedding(void 0);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.hasQuantizedEmbedding = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.getHeadIndex = function() {
    return t2.Message.getFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.setHeadIndex = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.clearHeadIndex = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.hasHeadIndex = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.getHeadName = function() {
    return t2.Message.getFieldWithDefault(this, 4, "");
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.setHeadName = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.clearHeadName = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.tasks.components.containers.proto.Embedding.prototype.hasHeadName = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.toObject(e3, this);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.toObject = function(e3, r3) {
    var o3, i3 = { embeddingsList: t2.Message.toObjectList(r3.getEmbeddingsList(), proto.mediapipe.tasks.components.containers.proto.Embedding.toObject, e3), timestampMs: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.components.containers.proto.EmbeddingResult();
    return proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.tasks.components.containers.proto.Embedding();
          t3.readMessage(r3, proto.mediapipe.tasks.components.containers.proto.Embedding.deserializeBinaryFromReader), e3.addEmbeddings(r3);
          break;
        case 2:
          r3 = t3.readInt64();
          e3.setTimestampMs(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    (o3 = e3.getEmbeddingsList()).length > 0 && r3.writeRepeatedMessage(1, o3, proto.mediapipe.tasks.components.containers.proto.Embedding.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt64(2, o3);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.getEmbeddingsList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.tasks.components.containers.proto.Embedding, 1);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.setEmbeddingsList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.addEmbeddings = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.tasks.components.containers.proto.Embedding, r3);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.clearEmbeddingsList = function() {
    return this.setEmbeddingsList([]);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.getTimestampMs = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.setTimestampMs = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.clearTimestampMs = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.components.containers.proto.EmbeddingResult.prototype.hasTimestampMs = function() {
    return null != t2.Message.getField(this, 2);
  }, r2.object.extend(e2, proto.mediapipe.tasks.components.containers.proto);
}(embeddings_pb);
var image_embedder_graph_options_pb = {};
var embedder_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.tasks.components.processors.proto.EmbedderOptions", null, o2), proto.mediapipe.tasks.components.processors.proto.EmbedderOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.components.processors.proto.EmbedderOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.displayName = "proto.mediapipe.tasks.components.processors.proto.EmbedderOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.toObject = function(e3, r3) {
    var o3, i3 = { l2Normalize: null == (o3 = t2.Message.getBooleanField(r3, 1)) ? void 0 : o3, quantize: null == (o3 = t2.Message.getBooleanField(r3, 2)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.components.processors.proto.EmbedderOptions();
    return proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readBool();
          e3.setL2Normalize(r3);
          break;
        case 2:
          r3 = t3.readBool();
          e3.setQuantize(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeBool(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeBool(2, o3);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.getL2Normalize = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 1, false);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.setL2Normalize = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.clearL2Normalize = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.hasL2Normalize = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.getQuantize = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 2, false);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.setQuantize = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.clearQuantize = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.components.processors.proto.EmbedderOptions.prototype.hasQuantize = function() {
    return null != t2.Message.getField(this, 2);
  }, r2.object.extend(e2, proto.mediapipe.tasks.components.processors.proto);
}(embedder_options_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = embedder_options_pb;
  r2.object.extend(proto, n2);
  var s2 = base_options_pb;
  r2.object.extend(proto, s2), r2.exportSymbol("proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions", null, o2), proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.displayName = "proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.toObject = function(e3, t3) {
    var r3, o3 = { baseOptions: (r3 = t3.getBaseOptions()) && s2.BaseOptions.toObject(e3, r3), embedderOptions: (r3 = t3.getEmbedderOptions()) && n2.EmbedderOptions.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions();
    return proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new s2.BaseOptions();
          t3.readMessage(r3, s2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = new n2.EmbedderOptions();
          t3.readMessage(r3, n2.EmbedderOptions.deserializeBinaryFromReader), e3.setEmbedderOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getBaseOptions()) && t3.writeMessage(1, r3, s2.BaseOptions.serializeBinaryToWriter), null != (r3 = e3.getEmbedderOptions()) && t3.writeMessage(2, r3, n2.EmbedderOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.ext = new t2.ExtensionFieldInfo(476348187, { ext: 0 }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[476348187] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[476348187] = proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.ext, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, s2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.getEmbedderOptions = function() {
    return t2.Message.getWrapperField(this, n2.EmbedderOptions, 2);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.setEmbedderOptions = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.clearEmbedderOptions = function() {
    return this.setEmbedderOptions(void 0);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.prototype.hasEmbedderOptions = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.ext = new t2.ExtensionFieldInfo(476348187, { ext: 0 }, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[476348187] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[476348187] = proto.mediapipe.tasks.vision.image_embedder.proto.ImageEmbedderGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.image_embedder.proto);
}(image_embedder_graph_options_pb);
var embedder_options = {};
Object.defineProperty(embedder_options, "__esModule", { value: true }), embedder_options.convertEmbedderOptionsToProto = void 0;
var embedder_options_pb_1 = embedder_options_pb;
function convertEmbedderOptionsToProto(e2, t2) {
  const r2 = t2 ? t2.clone() : new embedder_options_pb_1.EmbedderOptions();
  return void 0 !== e2.l2Normalize ? r2.setL2Normalize(e2.l2Normalize) : "l2Normalize" in e2 && r2.clearL2Normalize(), void 0 !== e2.quantize ? r2.setQuantize(e2.quantize) : "quantize" in e2 && r2.clearQuantize(), r2;
}
embedder_options.convertEmbedderOptionsToProto = convertEmbedderOptionsToProto;
var embedder_result = {};
Object.defineProperty(embedder_result, "__esModule", { value: true }), embedder_result.convertFromEmbeddingResultProto = void 0;
var DEFAULT_INDEX = -1;
function convertFromEmbeddingsProto(e2) {
  var t2, r2, o2, i3;
  const a3 = { headIndex: null !== (t2 = e2.getHeadIndex()) && void 0 !== t2 ? t2 : DEFAULT_INDEX, headName: null !== (r2 = e2.getHeadName()) && void 0 !== r2 ? r2 : "" };
  if (e2.hasFloatEmbedding())
    a3.floatEmbedding = e2.getFloatEmbedding().getValuesList();
  else {
    const t3 = null !== (i3 = null === (o2 = e2.getQuantizedEmbedding()) || void 0 === o2 ? void 0 : o2.getValues()) && void 0 !== i3 ? i3 : "";
    a3.quantizedEmbedding = "string" == typeof t3 ? Uint8Array.from(atob(t3), (e3) => e3.charCodeAt(0)) : t3;
  }
  return a3;
}
function convertFromEmbeddingResultProto(e2) {
  return { embeddings: e2.getEmbeddingsList().map((e3) => convertFromEmbeddingsProto(e3)), timestampMs: e2.getTimestampMs() };
}
embedder_result.convertFromEmbeddingResultProto = convertFromEmbeddingResultProto;
var cosine_similarity = {};
function computeCosineSimilarity(e2, t2) {
  if (e2.floatEmbedding && t2.floatEmbedding)
    return compute(e2.floatEmbedding, t2.floatEmbedding);
  if (e2.quantizedEmbedding && t2.quantizedEmbedding)
    return compute(convertToBytes(e2.quantizedEmbedding), convertToBytes(t2.quantizedEmbedding));
  throw new Error("Cannot compute cosine similarity between quantized and float embeddings.");
}
function convertToBytes(e2) {
  return Array.from(e2, (e3) => e3 > 127 ? e3 - 256 : e3);
}
function compute(e2, t2) {
  if (e2.length !== t2.length)
    throw new Error(`Cannot compute cosine similarity between embeddings of different sizes (${e2.length} vs. ${t2.length}).`);
  let r2 = 0, o2 = 0, i3 = 0;
  for (let a3 = 0; a3 < e2.length; a3++)
    r2 += e2[a3] * t2[a3], o2 += e2[a3] * e2[a3], i3 += t2[a3] * t2[a3];
  if (o2 <= 0 || i3 <= 0)
    throw new Error("Cannot compute cosine similarity on embedding with 0 norm.");
  return r2 / Math.sqrt(o2 * i3);
}
Object.defineProperty(cosine_similarity, "__esModule", { value: true }), cosine_similarity.computeCosineSimilarity = void 0, cosine_similarity.computeCosineSimilarity = computeCosineSimilarity;
var image_embedder_options = {};
Object.defineProperty(image_embedder_options, "__esModule", { value: true });
var image_embedder_result = {};
Object.defineProperty(image_embedder_result, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.ImageEmbedder = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = embeddings_pb, n2 = base_options_pb, s2 = image_embedder_graph_options_pb, p = embedder_options, d2 = embedder_result, l2 = cosine_similarity, g = vision_task_runner, c6 = "image_in", u = "norm_rect", m = "embeddings_out";
  r2(image_embedder_options, e2), r2(image_embedder_result, e2);
  class f2 extends g.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return g.VisionTaskRunner.createVisionInstance(f2, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return g.VisionTaskRunner.createVisionInstance(f2, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static createFromModelPath(e3, t3) {
      return g.VisionTaskRunner.createVisionInstance(f2, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new g.VisionGraphRunner(e3, t3), c6, u, true), this.options = new s2.ImageEmbedderGraphOptions(), this.embeddings = { embeddings: [] }, this.options.setBaseOptions(new n2.BaseOptions());
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      return this.options.setEmbedderOptions((0, p.convertEmbedderOptionsToProto)(e3, this.options.getEmbedderOptions())), this.applyOptions(e3);
    }
    embed(e3, t3) {
      return this.processImageData(e3, t3), this.embeddings;
    }
    embedForVideo(e3, t3, r3) {
      return this.processVideoData(e3, r3, t3), this.embeddings;
    }
    static cosineSimilarity(e3, t3) {
      return (0, l2.computeCosineSimilarity)(e3, t3);
    }
    addJsImageEmdedding(e3) {
      const t3 = a3.EmbeddingResult.deserializeBinary(e3);
      this.embeddings = (0, d2.convertFromEmbeddingResultProto)(t3);
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(c6), e3.addInputStream(u), e3.addOutputStream(m);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(s2.ImageEmbedderGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"), r3.addInputStream("IMAGE:" + c6), r3.addInputStream("NORM_RECT:" + u), r3.addOutputStream("EMBEDDINGS:" + m), r3.setOptions(t3), e3.addNode(r3), this.graphRunner.attachProtoListener(m, (e4, t4) => {
        this.addJsImageEmdedding(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(m, (e4) => {
        this.setLatestOutputTimestamp(e4);
      });
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
  }
  e2.ImageEmbedder = f2;
}(image_embedder);
var image_segmenter = {};
var tensors_to_segmentation_calculator_pb = {};
var segmenter_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions", null, o2), r2.exportSymbol("proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.Activation", null, o2), r2.exportSymbol("proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.OutputType", null, o2), proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.displayName = "proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.toObject = function(e3, r3) {
    var o3, i3 = { outputType: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, activation: t2.Message.getFieldWithDefault(r3, 2, 0) };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions();
    return proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readEnum();
          e3.setOutputType(r3);
          break;
        case 2:
          r3 = t3.readEnum();
          e3.setActivation(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeEnum(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeEnum(2, o3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.OutputType = { UNSPECIFIED: 0, CATEGORY_MASK: 1, CONFIDENCE_MASK: 2 }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.Activation = { NONE: 0, SIGMOID: 1, SOFTMAX: 2 }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.getOutputType = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.setOutputType = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.clearOutputType = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.hasOutputType = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.getActivation = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.setActivation = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.clearActivation = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.SegmenterOptions.prototype.hasActivation = function() {
    return null != t2.Message.getField(this, 2);
  }, r2.object.extend(e2, proto.mediapipe.tasks.vision.image_segmenter.proto);
}(segmenter_options_pb);
var label_map_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.LabelMapItem", null, o2), proto.mediapipe.LabelMapItem = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.LabelMapItem.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.LabelMapItem, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.LabelMapItem.displayName = "proto.mediapipe.LabelMapItem"), proto.mediapipe.LabelMapItem.repeatedFields_ = [3], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.LabelMapItem.prototype.toObject = function(e3) {
    return proto.mediapipe.LabelMapItem.toObject(e3, this);
  }, proto.mediapipe.LabelMapItem.toObject = function(e3, r3) {
    var o3, i3 = { name: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, displayName: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, childNameList: null == (o3 = t2.Message.getRepeatedField(r3, 3)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.LabelMapItem.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.LabelMapItem();
    return proto.mediapipe.LabelMapItem.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.LabelMapItem.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setName(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setDisplayName(r3);
          break;
        case 3:
          r3 = t3.readString();
          e3.addChildName(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.LabelMapItem.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.LabelMapItem.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.LabelMapItem.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeString(2, o3), (o3 = e3.getChildNameList()).length > 0 && r3.writeRepeatedString(3, o3);
  }, proto.mediapipe.LabelMapItem.prototype.getName = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.LabelMapItem.prototype.setName = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.LabelMapItem.prototype.clearName = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.LabelMapItem.prototype.hasName = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.LabelMapItem.prototype.getDisplayName = function() {
    return t2.Message.getFieldWithDefault(this, 2, "");
  }, proto.mediapipe.LabelMapItem.prototype.setDisplayName = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.LabelMapItem.prototype.clearDisplayName = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.LabelMapItem.prototype.hasDisplayName = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.LabelMapItem.prototype.getChildNameList = function() {
    return t2.Message.getRepeatedField(this, 3);
  }, proto.mediapipe.LabelMapItem.prototype.setChildNameList = function(e3) {
    return t2.Message.setField(this, 3, e3 || []);
  }, proto.mediapipe.LabelMapItem.prototype.addChildName = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 3, e3, r3);
  }, proto.mediapipe.LabelMapItem.prototype.clearChildNameList = function() {
    return this.setChildNameList([]);
  }, r2.object.extend(e2, proto.mediapipe);
}(label_map_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_options_pb;
  r2.object.extend(proto, i3);
  var a3 = segmenter_options_pb;
  r2.object.extend(proto, a3);
  var n2 = label_map_pb;
  r2.object.extend(proto, n2), r2.exportSymbol("proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions", null, o2), proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.displayName = "proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.toObject = function(e3, t3) {
    var r3, o3 = { segmenterOptions: (r3 = t3.getSegmenterOptions()) && a3.SegmenterOptions.toObject(e3, r3), labelItemsMap: (r3 = t3.getLabelItemsMap()) ? r3.toObject(e3, proto.mediapipe.LabelMapItem.toObject) : [] };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions();
    return proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.deserializeBinaryFromReader = function(e3, r3) {
    for (; r3.nextField() && !r3.isEndGroup(); ) {
      switch (r3.getFieldNumber()) {
        case 1:
          var o3 = new a3.SegmenterOptions();
          r3.readMessage(o3, a3.SegmenterOptions.deserializeBinaryFromReader), e3.setSegmenterOptions(o3);
          break;
        case 2:
          o3 = e3.getLabelItemsMap();
          r3.readMessage(o3, function(e4, r4) {
            t2.Map.deserializeBinary(e4, r4, t2.BinaryReader.prototype.readInt64, t2.BinaryReader.prototype.readMessage, proto.mediapipe.LabelMapItem.deserializeBinaryFromReader, 0, new proto.mediapipe.LabelMapItem());
          });
          break;
        default:
          r3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getSegmenterOptions()) && r3.writeMessage(1, o3, a3.SegmenterOptions.serializeBinaryToWriter), (o3 = e3.getLabelItemsMap(true)) && o3.getLength() > 0 && o3.serializeBinary(2, r3, t2.BinaryWriter.prototype.writeInt64, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.LabelMapItem.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.ext = new t2.ExtensionFieldInfo(458105876, { ext: 0 }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.toObject, 0), i3.CalculatorOptions.extensionsBinary[458105876] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.serializeBinaryToWriter, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.deserializeBinaryFromReader, false), i3.CalculatorOptions.extensions[458105876] = proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.ext, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.prototype.getSegmenterOptions = function() {
    return t2.Message.getWrapperField(this, a3.SegmenterOptions, 1);
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.prototype.setSegmenterOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.prototype.clearSegmenterOptions = function() {
    return this.setSegmenterOptions(void 0);
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.prototype.hasSegmenterOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.prototype.getLabelItemsMap = function(e3) {
    return t2.Message.getMapField(this, 2, e3, proto.mediapipe.LabelMapItem);
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.prototype.clearLabelItemsMap = function() {
    return this.getLabelItemsMap().clear(), this;
  }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.ext = new t2.ExtensionFieldInfo(458105876, { ext: 0 }, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.toObject, 0), i3.CalculatorOptions.extensionsBinary[458105876] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.serializeBinaryToWriter, proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.deserializeBinaryFromReader, false), i3.CalculatorOptions.extensions[458105876] = proto.mediapipe.tasks.TensorsToSegmentationCalculatorOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks);
}(tensors_to_segmentation_calculator_pb);
var image_segmenter_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2);
  var s2 = segmenter_options_pb;
  r2.object.extend(proto, s2), r2.exportSymbol("proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions", null, o2), proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.displayName = "proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), displayNamesLocale: t2.Message.getFieldWithDefault(r3, 2, "en"), segmenterOptions: (o3 = r3.getSegmenterOptions()) && s2.SegmenterOptions.toObject(e3, o3) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions();
    return proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setDisplayNamesLocale(r3);
          break;
        case 3:
          r3 = new s2.SegmenterOptions();
          t3.readMessage(r3, s2.SegmenterOptions.deserializeBinaryFromReader), e3.setSegmenterOptions(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeString(2, o3), null != (o3 = e3.getSegmenterOptions()) && r3.writeMessage(3, o3, s2.SegmenterOptions.serializeBinaryToWriter);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.ext = new t2.ExtensionFieldInfo(458105758, { ext: 0 }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[458105758] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[458105758] = proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.ext, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.getDisplayNamesLocale = function() {
    return t2.Message.getFieldWithDefault(this, 2, "en");
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.setDisplayNamesLocale = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.clearDisplayNamesLocale = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.hasDisplayNamesLocale = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.getSegmenterOptions = function() {
    return t2.Message.getWrapperField(this, s2.SegmenterOptions, 3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.setSegmenterOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.clearSegmenterOptions = function() {
    return this.setSegmenterOptions(void 0);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.prototype.hasSegmenterOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.ext = new t2.ExtensionFieldInfo(458105758, { ext: 0 }, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[458105758] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[458105758] = proto.mediapipe.tasks.vision.image_segmenter.proto.ImageSegmenterGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.image_segmenter.proto);
}(image_segmenter_graph_options_pb);
var image_segmenter_result = {};
Object.defineProperty(image_segmenter_result, "__esModule", { value: true }), image_segmenter_result.ImageSegmenterResult = void 0;
var ImageSegmenterResult = class {
  constructor(e2, t2, r2) {
    this.confidenceMasks = e2, this.categoryMask = t2, this.qualityScores = r2;
  }
  close() {
    var e2, t2;
    null === (e2 = this.confidenceMasks) || void 0 === e2 || e2.forEach((e3) => {
      e3.close();
    }), null === (t2 = this.categoryMask) || void 0 === t2 || t2.close();
  }
};
image_segmenter_result.ImageSegmenterResult = ImageSegmenterResult;
var image_segmenter_options = {};
Object.defineProperty(image_segmenter_options, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.ImageSegmenter = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = base_options_pb, n2 = tensors_to_segmentation_calculator_pb, s2 = image_segmenter_graph_options_pb, p = segmenter_options_pb, d2 = vision_task_runner, l2 = image_segmenter_result;
  r2(image_segmenter_options, e2), r2(image_segmenter_result, e2);
  const g = "image_in", c6 = "norm_rect", u = "confidence_masks", m = "category_mask", f2 = "quality_scores", h = "mediapipe.tasks.TensorsToSegmentationCalculator";
  class y extends d2.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return d2.VisionTaskRunner.createVisionInstance(y, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return d2.VisionTaskRunner.createVisionInstance(y, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static createFromModelPath(e3, t3) {
      return d2.VisionTaskRunner.createVisionInstance(y, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new d2.VisionGraphRunner(e3, t3), g, c6, false), this.labels = [], this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.options = new s2.ImageSegmenterGraphOptions(), this.segmenterOptions = new p.SegmenterOptions(), this.options.setSegmenterOptions(this.segmenterOptions), this.options.setBaseOptions(new a3.BaseOptions());
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      var t3, r3;
      return void 0 !== e3.displayNamesLocale ? this.options.setDisplayNamesLocale(e3.displayNamesLocale) : "displayNamesLocale" in e3 && this.options.clearDisplayNamesLocale(), "outputCategoryMask" in e3 && (this.outputCategoryMask = null !== (t3 = e3.outputCategoryMask) && void 0 !== t3 && t3), "outputConfidenceMasks" in e3 && (this.outputConfidenceMasks = null === (r3 = e3.outputConfidenceMasks) || void 0 === r3 || r3), super.applyOptions(e3);
    }
    onGraphRefreshed() {
      this.populateLabels();
    }
    populateLabels() {
      var e3, t3, r3;
      const o3 = this.getCalculatorGraphConfig().getNodeList().filter((e4) => e4.getName().includes(h));
      if (this.labels = [], o3.length > 1)
        throw new Error(`The graph has more than one ${h}.`);
      if (1 === o3.length) {
        (null !== (r3 = null === (t3 = null === (e3 = o3[0].getOptions()) || void 0 === e3 ? void 0 : e3.getExtension(n2.TensorsToSegmentationCalculatorOptions.ext)) || void 0 === t3 ? void 0 : t3.getLabelItemsMap()) && void 0 !== r3 ? r3 : /* @__PURE__ */ new Map()).forEach((e4, t4) => {
          this.labels[Number(t4)] = e4.getName();
        });
      }
    }
    segment(e3, t3, r3) {
      const o3 = "function" != typeof t3 ? t3 : {};
      return this.userCallback = "function" == typeof t3 ? t3 : r3, this.reset(), this.processImageData(e3, o3), this.processResults();
    }
    segmentForVideo(e3, t3, r3, o3) {
      const i4 = "function" != typeof r3 ? r3 : {};
      return this.userCallback = "function" == typeof r3 ? r3 : o3, this.reset(), this.processVideoData(e3, i4, t3), this.processResults();
    }
    getLabels() {
      return this.labels;
    }
    reset() {
      this.categoryMask = void 0, this.confidenceMasks = void 0, this.qualityScores = void 0;
    }
    processResults() {
      try {
        const e3 = new l2.ImageSegmenterResult(this.confidenceMasks, this.categoryMask, this.qualityScores);
        if (!this.userCallback)
          return e3;
        this.userCallback(e3);
      } finally {
        this.freeKeepaliveStreams();
      }
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(g), e3.addInputStream(c6);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(s2.ImageSegmenterGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"), r3.addInputStream("IMAGE:" + g), r3.addInputStream("NORM_RECT:" + c6), r3.setOptions(t3), e3.addNode(r3), this.addKeepaliveNode(e3), this.outputConfidenceMasks && (e3.addOutputStream(u), r3.addOutputStream("CONFIDENCE_MASKS:" + u), this.keepStreamAlive(u), this.graphRunner.attachImageVectorListener(u, (e4, t4) => {
        this.confidenceMasks = e4.map((e5) => this.convertToMPMask(e5, !this.userCallback)), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(u, (e4) => {
        this.confidenceMasks = [], this.setLatestOutputTimestamp(e4);
      })), this.outputCategoryMask && (e3.addOutputStream(m), r3.addOutputStream("CATEGORY_MASK:" + m), this.keepStreamAlive(m), this.graphRunner.attachImageListener(m, (e4, t4) => {
        this.categoryMask = this.convertToMPMask(e4, !this.userCallback), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(m, (e4) => {
        this.categoryMask = void 0, this.setLatestOutputTimestamp(e4);
      })), e3.addOutputStream(f2), r3.addOutputStream("QUALITY_SCORES:" + f2), this.graphRunner.attachFloatVectorListener(f2, (e4, t4) => {
        this.qualityScores = e4, this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(f2, (e4) => {
        this.categoryMask = void 0, this.setLatestOutputTimestamp(e4);
      });
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
  }
  e2.ImageSegmenter = y;
}(image_segmenter);
var interactive_segmenter = {};
var color_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")();
  r2.exportSymbol("proto.mediapipe.Color", null, o2), r2.exportSymbol("proto.mediapipe.ColorMap", null, o2), proto.mediapipe.Color = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.Color, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.Color.displayName = "proto.mediapipe.Color"), proto.mediapipe.ColorMap = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.ColorMap, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.ColorMap.displayName = "proto.mediapipe.ColorMap"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.Color.prototype.toObject = function(e3) {
    return proto.mediapipe.Color.toObject(e3, this);
  }, proto.mediapipe.Color.toObject = function(e3, r3) {
    var o3, i3 = { r: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, g: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, b: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3 };
    return e3 && (i3.$jspbMessageInstance = r3), i3;
  }), proto.mediapipe.Color.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.Color();
    return proto.mediapipe.Color.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.Color.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readInt32();
          e3.setR(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setG(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setB(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.Color.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.Color.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.Color.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeInt32(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3);
  }, proto.mediapipe.Color.prototype.getR = function() {
    return t2.Message.getFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.Color.prototype.setR = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.Color.prototype.clearR = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.Color.prototype.hasR = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.Color.prototype.getG = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.Color.prototype.setG = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.Color.prototype.clearG = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.Color.prototype.hasG = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.Color.prototype.getB = function() {
    return t2.Message.getFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.Color.prototype.setB = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.Color.prototype.clearB = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.Color.prototype.hasB = function() {
    return null != t2.Message.getField(this, 3);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.ColorMap.prototype.toObject = function(e3) {
    return proto.mediapipe.ColorMap.toObject(e3, this);
  }, proto.mediapipe.ColorMap.toObject = function(e3, t3) {
    var r3, o3 = { labelToColorMap: (r3 = t3.getLabelToColorMap()) ? r3.toObject(e3, proto.mediapipe.Color.toObject) : [] };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.ColorMap.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.ColorMap();
    return proto.mediapipe.ColorMap.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.ColorMap.deserializeBinaryFromReader = function(e3, r3) {
    for (; r3.nextField() && !r3.isEndGroup(); ) {
      if (1 === r3.getFieldNumber()) {
        var o3 = e3.getLabelToColorMap();
        r3.readMessage(o3, function(e4, r4) {
          t2.Map.deserializeBinary(e4, r4, t2.BinaryReader.prototype.readString, t2.BinaryReader.prototype.readMessage, proto.mediapipe.Color.deserializeBinaryFromReader, "", new proto.mediapipe.Color());
        });
      } else
        r3.skipField();
    }
    return e3;
  }, proto.mediapipe.ColorMap.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.ColorMap.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.ColorMap.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    (o3 = e3.getLabelToColorMap(true)) && o3.getLength() > 0 && o3.serializeBinary(1, r3, t2.BinaryWriter.prototype.writeString, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.Color.serializeBinaryToWriter);
  }, proto.mediapipe.ColorMap.prototype.getLabelToColorMap = function(e3) {
    return t2.Message.getMapField(this, 1, e3, proto.mediapipe.Color);
  }, proto.mediapipe.ColorMap.prototype.clearLabelToColorMap = function() {
    return this.getLabelToColorMap().clear(), this;
  }, r2.object.extend(e2, proto.mediapipe);
}(color_pb);
var render_data_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = color_pb;
  r2.object.extend(proto, i3), r2.exportSymbol("proto.mediapipe.RenderAnnotation", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.Arrow", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.DataCase", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.FilledOval", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.FilledRectangle", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.FilledRoundedRectangle", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.GradientLine", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.Line", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.Line.LineType", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.Oval", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.Point", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.Rectangle", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.RoundedRectangle", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.Scribble", null, o2), r2.exportSymbol("proto.mediapipe.RenderAnnotation.Text", null, o2), r2.exportSymbol("proto.mediapipe.RenderData", null, o2), r2.exportSymbol("proto.mediapipe.RenderViewport", null, o2), proto.mediapipe.RenderData = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.RenderData.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.RenderData, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderData.displayName = "proto.mediapipe.RenderData"), proto.mediapipe.RenderAnnotation = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, proto.mediapipe.RenderAnnotation.oneofGroups_);
  }, r2.inherits(proto.mediapipe.RenderAnnotation, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.displayName = "proto.mediapipe.RenderAnnotation"), proto.mediapipe.RenderAnnotation.Rectangle = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.Rectangle, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.Rectangle.displayName = "proto.mediapipe.RenderAnnotation.Rectangle"), proto.mediapipe.RenderAnnotation.FilledRectangle = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.FilledRectangle, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.FilledRectangle.displayName = "proto.mediapipe.RenderAnnotation.FilledRectangle"), proto.mediapipe.RenderAnnotation.RoundedRectangle = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.RoundedRectangle, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.RoundedRectangle.displayName = "proto.mediapipe.RenderAnnotation.RoundedRectangle"), proto.mediapipe.RenderAnnotation.FilledRoundedRectangle = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.FilledRoundedRectangle, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.displayName = "proto.mediapipe.RenderAnnotation.FilledRoundedRectangle"), proto.mediapipe.RenderAnnotation.Oval = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.Oval, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.Oval.displayName = "proto.mediapipe.RenderAnnotation.Oval"), proto.mediapipe.RenderAnnotation.FilledOval = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.FilledOval, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.FilledOval.displayName = "proto.mediapipe.RenderAnnotation.FilledOval"), proto.mediapipe.RenderAnnotation.Point = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.Point, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.Point.displayName = "proto.mediapipe.RenderAnnotation.Point"), proto.mediapipe.RenderAnnotation.Line = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.Line, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.Line.displayName = "proto.mediapipe.RenderAnnotation.Line"), proto.mediapipe.RenderAnnotation.GradientLine = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.GradientLine, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.GradientLine.displayName = "proto.mediapipe.RenderAnnotation.GradientLine"), proto.mediapipe.RenderAnnotation.Scribble = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.RenderAnnotation.Scribble.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.Scribble, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.Scribble.displayName = "proto.mediapipe.RenderAnnotation.Scribble"), proto.mediapipe.RenderAnnotation.Arrow = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.Arrow, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.Arrow.displayName = "proto.mediapipe.RenderAnnotation.Arrow"), proto.mediapipe.RenderAnnotation.Text = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderAnnotation.Text, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderAnnotation.Text.displayName = "proto.mediapipe.RenderAnnotation.Text"), proto.mediapipe.RenderViewport = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.RenderViewport, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.RenderViewport.displayName = "proto.mediapipe.RenderViewport"), proto.mediapipe.RenderData.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderData.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderData.toObject(e3, this);
  }, proto.mediapipe.RenderData.toObject = function(e3, r3) {
    var o3, i4 = { renderAnnotationsList: t2.Message.toObjectList(r3.getRenderAnnotationsList(), proto.mediapipe.RenderAnnotation.toObject, e3), sceneClass: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, sceneViewport: (o3 = r3.getSceneViewport()) && proto.mediapipe.RenderViewport.toObject(e3, o3) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.RenderData.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderData();
    return proto.mediapipe.RenderData.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderData.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.RenderAnnotation();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.deserializeBinaryFromReader), e3.addRenderAnnotations(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setSceneClass(r3);
          break;
        case 3:
          r3 = new proto.mediapipe.RenderViewport();
          t3.readMessage(r3, proto.mediapipe.RenderViewport.deserializeBinaryFromReader), e3.setSceneViewport(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderData.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderData.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderData.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    (o3 = e3.getRenderAnnotationsList()).length > 0 && r3.writeRepeatedMessage(1, o3, proto.mediapipe.RenderAnnotation.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeString(2, o3), null != (o3 = e3.getSceneViewport()) && r3.writeMessage(3, o3, proto.mediapipe.RenderViewport.serializeBinaryToWriter);
  }, proto.mediapipe.RenderData.prototype.getRenderAnnotationsList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.RenderAnnotation, 1);
  }, proto.mediapipe.RenderData.prototype.setRenderAnnotationsList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.RenderData.prototype.addRenderAnnotations = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.RenderAnnotation, r3);
  }, proto.mediapipe.RenderData.prototype.clearRenderAnnotationsList = function() {
    return this.setRenderAnnotationsList([]);
  }, proto.mediapipe.RenderData.prototype.getSceneClass = function() {
    return t2.Message.getFieldWithDefault(this, 2, "");
  }, proto.mediapipe.RenderData.prototype.setSceneClass = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.RenderData.prototype.clearSceneClass = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.RenderData.prototype.hasSceneClass = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderData.prototype.getSceneViewport = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderViewport, 3);
  }, proto.mediapipe.RenderData.prototype.setSceneViewport = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.RenderData.prototype.clearSceneViewport = function() {
    return this.setSceneViewport(void 0);
  }, proto.mediapipe.RenderData.prototype.hasSceneViewport = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.RenderAnnotation.oneofGroups_ = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 15]], proto.mediapipe.RenderAnnotation.DataCase = { DATA_NOT_SET: 0, RECTANGLE: 1, FILLED_RECTANGLE: 2, OVAL: 3, FILLED_OVAL: 4, POINT: 5, LINE: 6, ARROW: 7, TEXT: 8, ROUNDED_RECTANGLE: 9, FILLED_ROUNDED_RECTANGLE: 10, GRADIENT_LINE: 14, SCRIBBLE: 15 }, proto.mediapipe.RenderAnnotation.prototype.getDataCase = function() {
    return t2.Message.computeOneofCase(this, proto.mediapipe.RenderAnnotation.oneofGroups_[0]);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.toObject = function(e3, r3) {
    var o3, a3 = { rectangle: (o3 = r3.getRectangle()) && proto.mediapipe.RenderAnnotation.Rectangle.toObject(e3, o3), filledRectangle: (o3 = r3.getFilledRectangle()) && proto.mediapipe.RenderAnnotation.FilledRectangle.toObject(e3, o3), oval: (o3 = r3.getOval()) && proto.mediapipe.RenderAnnotation.Oval.toObject(e3, o3), filledOval: (o3 = r3.getFilledOval()) && proto.mediapipe.RenderAnnotation.FilledOval.toObject(e3, o3), point: (o3 = r3.getPoint()) && proto.mediapipe.RenderAnnotation.Point.toObject(e3, o3), line: (o3 = r3.getLine()) && proto.mediapipe.RenderAnnotation.Line.toObject(e3, o3), arrow: (o3 = r3.getArrow()) && proto.mediapipe.RenderAnnotation.Arrow.toObject(e3, o3), text: (o3 = r3.getText()) && proto.mediapipe.RenderAnnotation.Text.toObject(e3, o3), roundedRectangle: (o3 = r3.getRoundedRectangle()) && proto.mediapipe.RenderAnnotation.RoundedRectangle.toObject(e3, o3), filledRoundedRectangle: (o3 = r3.getFilledRoundedRectangle()) && proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.toObject(e3, o3), gradientLine: (o3 = r3.getGradientLine()) && proto.mediapipe.RenderAnnotation.GradientLine.toObject(e3, o3), scribble: (o3 = r3.getScribble()) && proto.mediapipe.RenderAnnotation.Scribble.toObject(e3, o3), thickness: t2.Message.getFloatingPointFieldWithDefault(r3, 11, 1), color: (o3 = r3.getColor()) && i3.Color.toObject(e3, o3), sceneTag: null == (o3 = t2.Message.getField(r3, 13)) ? void 0 : o3 };
    return e3 && (a3.$jspbMessageInstance = r3), a3;
  }), proto.mediapipe.RenderAnnotation.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation();
    return proto.mediapipe.RenderAnnotation.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.RenderAnnotation.Rectangle();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Rectangle.deserializeBinaryFromReader), e3.setRectangle(r3);
          break;
        case 2:
          r3 = new proto.mediapipe.RenderAnnotation.FilledRectangle();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.FilledRectangle.deserializeBinaryFromReader), e3.setFilledRectangle(r3);
          break;
        case 3:
          r3 = new proto.mediapipe.RenderAnnotation.Oval();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Oval.deserializeBinaryFromReader), e3.setOval(r3);
          break;
        case 4:
          r3 = new proto.mediapipe.RenderAnnotation.FilledOval();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.FilledOval.deserializeBinaryFromReader), e3.setFilledOval(r3);
          break;
        case 5:
          r3 = new proto.mediapipe.RenderAnnotation.Point();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Point.deserializeBinaryFromReader), e3.setPoint(r3);
          break;
        case 6:
          r3 = new proto.mediapipe.RenderAnnotation.Line();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Line.deserializeBinaryFromReader), e3.setLine(r3);
          break;
        case 7:
          r3 = new proto.mediapipe.RenderAnnotation.Arrow();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Arrow.deserializeBinaryFromReader), e3.setArrow(r3);
          break;
        case 8:
          r3 = new proto.mediapipe.RenderAnnotation.Text();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Text.deserializeBinaryFromReader), e3.setText(r3);
          break;
        case 9:
          r3 = new proto.mediapipe.RenderAnnotation.RoundedRectangle();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.RoundedRectangle.deserializeBinaryFromReader), e3.setRoundedRectangle(r3);
          break;
        case 10:
          r3 = new proto.mediapipe.RenderAnnotation.FilledRoundedRectangle();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.deserializeBinaryFromReader), e3.setFilledRoundedRectangle(r3);
          break;
        case 14:
          r3 = new proto.mediapipe.RenderAnnotation.GradientLine();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.GradientLine.deserializeBinaryFromReader), e3.setGradientLine(r3);
          break;
        case 15:
          r3 = new proto.mediapipe.RenderAnnotation.Scribble();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Scribble.deserializeBinaryFromReader), e3.setScribble(r3);
          break;
        case 11:
          r3 = t3.readDouble();
          e3.setThickness(r3);
          break;
        case 12:
          r3 = new i3.Color();
          t3.readMessage(r3, i3.Color.deserializeBinaryFromReader), e3.setColor(r3);
          break;
        case 13:
          r3 = t3.readString();
          e3.setSceneTag(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getRectangle()) && r3.writeMessage(1, o3, proto.mediapipe.RenderAnnotation.Rectangle.serializeBinaryToWriter), null != (o3 = e3.getFilledRectangle()) && r3.writeMessage(2, o3, proto.mediapipe.RenderAnnotation.FilledRectangle.serializeBinaryToWriter), null != (o3 = e3.getOval()) && r3.writeMessage(3, o3, proto.mediapipe.RenderAnnotation.Oval.serializeBinaryToWriter), null != (o3 = e3.getFilledOval()) && r3.writeMessage(4, o3, proto.mediapipe.RenderAnnotation.FilledOval.serializeBinaryToWriter), null != (o3 = e3.getPoint()) && r3.writeMessage(5, o3, proto.mediapipe.RenderAnnotation.Point.serializeBinaryToWriter), null != (o3 = e3.getLine()) && r3.writeMessage(6, o3, proto.mediapipe.RenderAnnotation.Line.serializeBinaryToWriter), null != (o3 = e3.getArrow()) && r3.writeMessage(7, o3, proto.mediapipe.RenderAnnotation.Arrow.serializeBinaryToWriter), null != (o3 = e3.getText()) && r3.writeMessage(8, o3, proto.mediapipe.RenderAnnotation.Text.serializeBinaryToWriter), null != (o3 = e3.getRoundedRectangle()) && r3.writeMessage(9, o3, proto.mediapipe.RenderAnnotation.RoundedRectangle.serializeBinaryToWriter), null != (o3 = e3.getFilledRoundedRectangle()) && r3.writeMessage(10, o3, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.serializeBinaryToWriter), null != (o3 = e3.getGradientLine()) && r3.writeMessage(14, o3, proto.mediapipe.RenderAnnotation.GradientLine.serializeBinaryToWriter), null != (o3 = e3.getScribble()) && r3.writeMessage(15, o3, proto.mediapipe.RenderAnnotation.Scribble.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 11)) && r3.writeDouble(11, o3), null != (o3 = e3.getColor()) && r3.writeMessage(12, o3, i3.Color.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 13)) && r3.writeString(13, o3);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.Rectangle.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.Rectangle.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.Rectangle.toObject = function(e3, r3) {
    var o3, i4 = { left: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, top: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, right: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, bottom: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3, normalized: t2.Message.getBooleanFieldWithDefault(r3, 5, false), rotation: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 6)) ? void 0 : o3, topLeftThickness: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 7)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.RenderAnnotation.Rectangle.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.Rectangle();
    return proto.mediapipe.RenderAnnotation.Rectangle.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readDouble();
          e3.setLeft(r3);
          break;
        case 2:
          r3 = t3.readDouble();
          e3.setTop(r3);
          break;
        case 3:
          r3 = t3.readDouble();
          e3.setRight(r3);
          break;
        case 4:
          r3 = t3.readDouble();
          e3.setBottom(r3);
          break;
        case 5:
          r3 = t3.readBool();
          e3.setNormalized(r3);
          break;
        case 6:
          r3 = t3.readDouble();
          e3.setRotation(r3);
          break;
        case 7:
          r3 = t3.readDouble();
          e3.setTopLeftThickness(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.Rectangle.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.Rectangle.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeDouble(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeDouble(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeDouble(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeDouble(4, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeBool(5, o3), null != (o3 = t2.Message.getField(e3, 6)) && r3.writeDouble(6, o3), null != (o3 = t2.Message.getField(e3, 7)) && r3.writeDouble(7, o3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.getLeft = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.setLeft = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.clearLeft = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.hasLeft = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.getTop = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.setTop = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.clearTop = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.hasTop = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.getRight = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.setRight = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.clearRight = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.hasRight = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.getBottom = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.setBottom = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.clearBottom = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.hasBottom = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.getNormalized = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 5, false);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.setNormalized = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.clearNormalized = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.hasNormalized = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.getRotation = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 6, 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.setRotation = function(e3) {
    return t2.Message.setField(this, 6, e3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.clearRotation = function() {
    return t2.Message.setField(this, 6, void 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.hasRotation = function() {
    return null != t2.Message.getField(this, 6);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.getTopLeftThickness = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 7, 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.setTopLeftThickness = function(e3) {
    return t2.Message.setField(this, 7, e3);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.clearTopLeftThickness = function() {
    return t2.Message.setField(this, 7, void 0);
  }, proto.mediapipe.RenderAnnotation.Rectangle.prototype.hasTopLeftThickness = function() {
    return null != t2.Message.getField(this, 7);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.FilledRectangle.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.toObject = function(e3, t3) {
    var r3, o3 = { rectangle: (r3 = t3.getRectangle()) && proto.mediapipe.RenderAnnotation.Rectangle.toObject(e3, r3), fillColor: (r3 = t3.getFillColor()) && i3.Color.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.RenderAnnotation.FilledRectangle.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.FilledRectangle();
    return proto.mediapipe.RenderAnnotation.FilledRectangle.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.RenderAnnotation.Rectangle();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Rectangle.deserializeBinaryFromReader), e3.setRectangle(r3);
          break;
        case 2:
          r3 = new i3.Color();
          t3.readMessage(r3, i3.Color.deserializeBinaryFromReader), e3.setFillColor(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.FilledRectangle.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getRectangle()) && t3.writeMessage(1, r3, proto.mediapipe.RenderAnnotation.Rectangle.serializeBinaryToWriter), null != (r3 = e3.getFillColor()) && t3.writeMessage(2, r3, i3.Color.serializeBinaryToWriter);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.getRectangle = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Rectangle, 1);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.setRectangle = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.clearRectangle = function() {
    return this.setRectangle(void 0);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.hasRectangle = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.getFillColor = function() {
    return t2.Message.getWrapperField(this, i3.Color, 2);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.setFillColor = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.clearFillColor = function() {
    return this.setFillColor(void 0);
  }, proto.mediapipe.RenderAnnotation.FilledRectangle.prototype.hasFillColor = function() {
    return null != t2.Message.getField(this, 2);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.RoundedRectangle.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.toObject = function(e3, r3) {
    var o3, i4 = { rectangle: (o3 = r3.getRectangle()) && proto.mediapipe.RenderAnnotation.Rectangle.toObject(e3, o3), cornerRadius: t2.Message.getFieldWithDefault(r3, 2, 0), lineType: t2.Message.getFieldWithDefault(r3, 3, 4) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.RenderAnnotation.RoundedRectangle.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.RoundedRectangle();
    return proto.mediapipe.RenderAnnotation.RoundedRectangle.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.RenderAnnotation.Rectangle();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Rectangle.deserializeBinaryFromReader), e3.setRectangle(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setCornerRadius(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setLineType(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.RoundedRectangle.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getRectangle()) && r3.writeMessage(1, o3, proto.mediapipe.RenderAnnotation.Rectangle.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.getRectangle = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Rectangle, 1);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.setRectangle = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.clearRectangle = function() {
    return this.setRectangle(void 0);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.hasRectangle = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.getCornerRadius = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.setCornerRadius = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.clearCornerRadius = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.hasCornerRadius = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.getLineType = function() {
    return t2.Message.getFieldWithDefault(this, 3, 4);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.setLineType = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.clearLineType = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.RenderAnnotation.RoundedRectangle.prototype.hasLineType = function() {
    return null != t2.Message.getField(this, 3);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.toObject = function(e3, t3) {
    var r3, o3 = { roundedRectangle: (r3 = t3.getRoundedRectangle()) && proto.mediapipe.RenderAnnotation.RoundedRectangle.toObject(e3, r3), fillColor: (r3 = t3.getFillColor()) && i3.Color.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.FilledRoundedRectangle();
    return proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.RenderAnnotation.RoundedRectangle();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.RoundedRectangle.deserializeBinaryFromReader), e3.setRoundedRectangle(r3);
          break;
        case 2:
          r3 = new i3.Color();
          t3.readMessage(r3, i3.Color.deserializeBinaryFromReader), e3.setFillColor(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getRoundedRectangle()) && t3.writeMessage(1, r3, proto.mediapipe.RenderAnnotation.RoundedRectangle.serializeBinaryToWriter), null != (r3 = e3.getFillColor()) && t3.writeMessage(2, r3, i3.Color.serializeBinaryToWriter);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.getRoundedRectangle = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.RoundedRectangle, 1);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.setRoundedRectangle = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.clearRoundedRectangle = function() {
    return this.setRoundedRectangle(void 0);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.hasRoundedRectangle = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.getFillColor = function() {
    return t2.Message.getWrapperField(this, i3.Color, 2);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.setFillColor = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.clearFillColor = function() {
    return this.setFillColor(void 0);
  }, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle.prototype.hasFillColor = function() {
    return null != t2.Message.getField(this, 2);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.Oval.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.Oval.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.Oval.toObject = function(e3, t3) {
    var r3, o3 = { rectangle: (r3 = t3.getRectangle()) && proto.mediapipe.RenderAnnotation.Rectangle.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.RenderAnnotation.Oval.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.Oval();
    return proto.mediapipe.RenderAnnotation.Oval.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.Oval.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.RenderAnnotation.Rectangle();
        t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Rectangle.deserializeBinaryFromReader), e3.setRectangle(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.Oval.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.Oval.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.Oval.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    null != (r3 = e3.getRectangle()) && t3.writeMessage(1, r3, proto.mediapipe.RenderAnnotation.Rectangle.serializeBinaryToWriter);
  }, proto.mediapipe.RenderAnnotation.Oval.prototype.getRectangle = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Rectangle, 1);
  }, proto.mediapipe.RenderAnnotation.Oval.prototype.setRectangle = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.Oval.prototype.clearRectangle = function() {
    return this.setRectangle(void 0);
  }, proto.mediapipe.RenderAnnotation.Oval.prototype.hasRectangle = function() {
    return null != t2.Message.getField(this, 1);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.FilledOval.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.FilledOval.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.FilledOval.toObject = function(e3, t3) {
    var r3, o3 = { oval: (r3 = t3.getOval()) && proto.mediapipe.RenderAnnotation.Oval.toObject(e3, r3), fillColor: (r3 = t3.getFillColor()) && i3.Color.toObject(e3, r3) };
    return e3 && (o3.$jspbMessageInstance = t3), o3;
  }), proto.mediapipe.RenderAnnotation.FilledOval.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.FilledOval();
    return proto.mediapipe.RenderAnnotation.FilledOval.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.FilledOval.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new proto.mediapipe.RenderAnnotation.Oval();
          t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Oval.deserializeBinaryFromReader), e3.setOval(r3);
          break;
        case 2:
          r3 = new i3.Color();
          t3.readMessage(r3, i3.Color.deserializeBinaryFromReader), e3.setFillColor(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.FilledOval.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.FilledOval.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.FilledOval.serializeBinaryToWriter = function(e3, t3) {
    var r3 = void 0;
    null != (r3 = e3.getOval()) && t3.writeMessage(1, r3, proto.mediapipe.RenderAnnotation.Oval.serializeBinaryToWriter), null != (r3 = e3.getFillColor()) && t3.writeMessage(2, r3, i3.Color.serializeBinaryToWriter);
  }, proto.mediapipe.RenderAnnotation.FilledOval.prototype.getOval = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Oval, 1);
  }, proto.mediapipe.RenderAnnotation.FilledOval.prototype.setOval = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.FilledOval.prototype.clearOval = function() {
    return this.setOval(void 0);
  }, proto.mediapipe.RenderAnnotation.FilledOval.prototype.hasOval = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.FilledOval.prototype.getFillColor = function() {
    return t2.Message.getWrapperField(this, i3.Color, 2);
  }, proto.mediapipe.RenderAnnotation.FilledOval.prototype.setFillColor = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.FilledOval.prototype.clearFillColor = function() {
    return this.setFillColor(void 0);
  }, proto.mediapipe.RenderAnnotation.FilledOval.prototype.hasFillColor = function() {
    return null != t2.Message.getField(this, 2);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.Point.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.Point.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.Point.toObject = function(e3, r3) {
    var o3, i4 = { x: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, y: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, normalized: t2.Message.getBooleanFieldWithDefault(r3, 3, false) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.RenderAnnotation.Point.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.Point();
    return proto.mediapipe.RenderAnnotation.Point.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.Point.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readDouble();
          e3.setX(r3);
          break;
        case 2:
          r3 = t3.readDouble();
          e3.setY(r3);
          break;
        case 3:
          r3 = t3.readBool();
          e3.setNormalized(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.Point.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.Point.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.Point.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeDouble(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeDouble(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeBool(3, o3);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.getX = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.setX = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.clearX = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.hasX = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.getY = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.setY = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.clearY = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.hasY = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.getNormalized = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 3, false);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.setNormalized = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.clearNormalized = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.RenderAnnotation.Point.prototype.hasNormalized = function() {
    return null != t2.Message.getField(this, 3);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.Line.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.Line.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.Line.toObject = function(e3, r3) {
    var o3, i4 = { xStart: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, yStart: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, xEnd: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, yEnd: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3, normalized: t2.Message.getBooleanFieldWithDefault(r3, 5, false), lineType: t2.Message.getFieldWithDefault(r3, 6, 1) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.RenderAnnotation.Line.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.Line();
    return proto.mediapipe.RenderAnnotation.Line.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.Line.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readDouble();
          e3.setXStart(r3);
          break;
        case 2:
          r3 = t3.readDouble();
          e3.setYStart(r3);
          break;
        case 3:
          r3 = t3.readDouble();
          e3.setXEnd(r3);
          break;
        case 4:
          r3 = t3.readDouble();
          e3.setYEnd(r3);
          break;
        case 5:
          r3 = t3.readBool();
          e3.setNormalized(r3);
          break;
        case 6:
          r3 = t3.readEnum();
          e3.setLineType(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.Line.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.Line.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.Line.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeDouble(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeDouble(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeDouble(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeDouble(4, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeBool(5, o3), null != (o3 = t2.Message.getField(e3, 6)) && r3.writeEnum(6, o3);
  }, proto.mediapipe.RenderAnnotation.Line.LineType = { UNKNOWN: 0, SOLID: 1, DASHED: 2 }, proto.mediapipe.RenderAnnotation.Line.prototype.getXStart = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.setXStart = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.clearXStart = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.hasXStart = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.getYStart = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.setYStart = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.clearYStart = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.hasYStart = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.getXEnd = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.setXEnd = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.clearXEnd = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.hasXEnd = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.getYEnd = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.setYEnd = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.clearYEnd = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.hasYEnd = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.getNormalized = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 5, false);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.setNormalized = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.clearNormalized = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.hasNormalized = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.getLineType = function() {
    return t2.Message.getFieldWithDefault(this, 6, 1);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.setLineType = function(e3) {
    return t2.Message.setField(this, 6, e3);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.clearLineType = function() {
    return t2.Message.setField(this, 6, void 0);
  }, proto.mediapipe.RenderAnnotation.Line.prototype.hasLineType = function() {
    return null != t2.Message.getField(this, 6);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.GradientLine.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.GradientLine.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.GradientLine.toObject = function(e3, r3) {
    var o3, a3 = { xStart: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, yStart: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, xEnd: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, yEnd: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3, normalized: t2.Message.getBooleanFieldWithDefault(r3, 5, false), color1: (o3 = r3.getColor1()) && i3.Color.toObject(e3, o3), color2: (o3 = r3.getColor2()) && i3.Color.toObject(e3, o3) };
    return e3 && (a3.$jspbMessageInstance = r3), a3;
  }), proto.mediapipe.RenderAnnotation.GradientLine.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.GradientLine();
    return proto.mediapipe.RenderAnnotation.GradientLine.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.GradientLine.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readDouble();
          e3.setXStart(r3);
          break;
        case 2:
          r3 = t3.readDouble();
          e3.setYStart(r3);
          break;
        case 3:
          r3 = t3.readDouble();
          e3.setXEnd(r3);
          break;
        case 4:
          r3 = t3.readDouble();
          e3.setYEnd(r3);
          break;
        case 5:
          r3 = t3.readBool();
          e3.setNormalized(r3);
          break;
        case 6:
          r3 = new i3.Color();
          t3.readMessage(r3, i3.Color.deserializeBinaryFromReader), e3.setColor1(r3);
          break;
        case 7:
          r3 = new i3.Color();
          t3.readMessage(r3, i3.Color.deserializeBinaryFromReader), e3.setColor2(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.GradientLine.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.GradientLine.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeDouble(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeDouble(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeDouble(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeDouble(4, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeBool(5, o3), null != (o3 = e3.getColor1()) && r3.writeMessage(6, o3, i3.Color.serializeBinaryToWriter), null != (o3 = e3.getColor2()) && r3.writeMessage(7, o3, i3.Color.serializeBinaryToWriter);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.getXStart = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.setXStart = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.clearXStart = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.hasXStart = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.getYStart = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.setYStart = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.clearYStart = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.hasYStart = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.getXEnd = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.setXEnd = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.clearXEnd = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.hasXEnd = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.getYEnd = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.setYEnd = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.clearYEnd = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.hasYEnd = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.getNormalized = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 5, false);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.setNormalized = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.clearNormalized = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.hasNormalized = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.getColor1 = function() {
    return t2.Message.getWrapperField(this, i3.Color, 6);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.setColor1 = function(e3) {
    return t2.Message.setWrapperField(this, 6, e3);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.clearColor1 = function() {
    return this.setColor1(void 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.hasColor1 = function() {
    return null != t2.Message.getField(this, 6);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.getColor2 = function() {
    return t2.Message.getWrapperField(this, i3.Color, 7);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.setColor2 = function(e3) {
    return t2.Message.setWrapperField(this, 7, e3);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.clearColor2 = function() {
    return this.setColor2(void 0);
  }, proto.mediapipe.RenderAnnotation.GradientLine.prototype.hasColor2 = function() {
    return null != t2.Message.getField(this, 7);
  }, proto.mediapipe.RenderAnnotation.Scribble.repeatedFields_ = [1], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.Scribble.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.Scribble.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.Scribble.toObject = function(e3, r3) {
    var o3 = { pointList: t2.Message.toObjectList(r3.getPointList(), proto.mediapipe.RenderAnnotation.Point.toObject, e3) };
    return e3 && (o3.$jspbMessageInstance = r3), o3;
  }), proto.mediapipe.RenderAnnotation.Scribble.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.Scribble();
    return proto.mediapipe.RenderAnnotation.Scribble.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.Scribble.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      if (1 === t3.getFieldNumber()) {
        var r3 = new proto.mediapipe.RenderAnnotation.Point();
        t3.readMessage(r3, proto.mediapipe.RenderAnnotation.Point.deserializeBinaryFromReader), e3.addPoint(r3);
      } else
        t3.skipField();
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.Scribble.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.Scribble.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.Scribble.serializeBinaryToWriter = function(e3, t3) {
    var r3;
    (r3 = e3.getPointList()).length > 0 && t3.writeRepeatedMessage(1, r3, proto.mediapipe.RenderAnnotation.Point.serializeBinaryToWriter);
  }, proto.mediapipe.RenderAnnotation.Scribble.prototype.getPointList = function() {
    return t2.Message.getRepeatedWrapperField(this, proto.mediapipe.RenderAnnotation.Point, 1);
  }, proto.mediapipe.RenderAnnotation.Scribble.prototype.setPointList = function(e3) {
    return t2.Message.setRepeatedWrapperField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.Scribble.prototype.addPoint = function(e3, r3) {
    return t2.Message.addToRepeatedWrapperField(this, 1, e3, proto.mediapipe.RenderAnnotation.Point, r3);
  }, proto.mediapipe.RenderAnnotation.Scribble.prototype.clearPointList = function() {
    return this.setPointList([]);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.Arrow.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.Arrow.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.Arrow.toObject = function(e3, r3) {
    var o3, i4 = { xStart: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 1)) ? void 0 : o3, yStart: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, xEnd: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, yEnd: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3, normalized: t2.Message.getBooleanFieldWithDefault(r3, 5, false) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.RenderAnnotation.Arrow.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.Arrow();
    return proto.mediapipe.RenderAnnotation.Arrow.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.Arrow.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readDouble();
          e3.setXStart(r3);
          break;
        case 2:
          r3 = t3.readDouble();
          e3.setYStart(r3);
          break;
        case 3:
          r3 = t3.readDouble();
          e3.setXEnd(r3);
          break;
        case 4:
          r3 = t3.readDouble();
          e3.setYEnd(r3);
          break;
        case 5:
          r3 = t3.readBool();
          e3.setNormalized(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.Arrow.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.Arrow.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeDouble(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeDouble(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeDouble(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeDouble(4, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeBool(5, o3);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.getXStart = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 1, 0);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.setXStart = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.clearXStart = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.hasXStart = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.getYStart = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.setYStart = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.clearYStart = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.hasYStart = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.getXEnd = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.setXEnd = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.clearXEnd = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.hasXEnd = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.getYEnd = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.setYEnd = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.clearYEnd = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.hasYEnd = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.getNormalized = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 5, false);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.setNormalized = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.clearNormalized = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.RenderAnnotation.Arrow.prototype.hasNormalized = function() {
    return null != t2.Message.getField(this, 5);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderAnnotation.Text.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderAnnotation.Text.toObject(e3, this);
  }, proto.mediapipe.RenderAnnotation.Text.toObject = function(e3, r3) {
    var o3, a3 = { displayText: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, left: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 2)) ? void 0 : o3, baseline: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 3)) ? void 0 : o3, fontHeight: t2.Message.getFloatingPointFieldWithDefault(r3, 4, 8), normalized: t2.Message.getBooleanFieldWithDefault(r3, 5, false), fontFace: t2.Message.getFieldWithDefault(r3, 6, 0), centerHorizontally: t2.Message.getBooleanFieldWithDefault(r3, 7, false), centerVertically: t2.Message.getBooleanFieldWithDefault(r3, 8, false), outlineThickness: t2.Message.getFloatingPointFieldWithDefault(r3, 11, 0), outlineColor: (o3 = r3.getOutlineColor()) && i3.Color.toObject(e3, o3) };
    return e3 && (a3.$jspbMessageInstance = r3), a3;
  }), proto.mediapipe.RenderAnnotation.Text.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderAnnotation.Text();
    return proto.mediapipe.RenderAnnotation.Text.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderAnnotation.Text.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setDisplayText(r3);
          break;
        case 2:
          r3 = t3.readDouble();
          e3.setLeft(r3);
          break;
        case 3:
          r3 = t3.readDouble();
          e3.setBaseline(r3);
          break;
        case 4:
          r3 = t3.readDouble();
          e3.setFontHeight(r3);
          break;
        case 5:
          r3 = t3.readBool();
          e3.setNormalized(r3);
          break;
        case 6:
          r3 = t3.readInt32();
          e3.setFontFace(r3);
          break;
        case 7:
          r3 = t3.readBool();
          e3.setCenterHorizontally(r3);
          break;
        case 8:
          r3 = t3.readBool();
          e3.setCenterVertically(r3);
          break;
        case 11:
          r3 = t3.readDouble();
          e3.setOutlineThickness(r3);
          break;
        case 12:
          r3 = new i3.Color();
          t3.readMessage(r3, i3.Color.deserializeBinaryFromReader), e3.setOutlineColor(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderAnnotation.Text.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderAnnotation.Text.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderAnnotation.Text.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeDouble(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeDouble(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeDouble(4, o3), null != (o3 = t2.Message.getField(e3, 5)) && r3.writeBool(5, o3), null != (o3 = t2.Message.getField(e3, 6)) && r3.writeInt32(6, o3), null != (o3 = t2.Message.getField(e3, 7)) && r3.writeBool(7, o3), null != (o3 = t2.Message.getField(e3, 8)) && r3.writeBool(8, o3), null != (o3 = t2.Message.getField(e3, 11)) && r3.writeDouble(11, o3), null != (o3 = e3.getOutlineColor()) && r3.writeMessage(12, o3, i3.Color.serializeBinaryToWriter);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getDisplayText = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setDisplayText = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearDisplayText = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasDisplayText = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getLeft = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setLeft = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearLeft = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasLeft = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getBaseline = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setBaseline = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearBaseline = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasBaseline = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getFontHeight = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 8);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setFontHeight = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearFontHeight = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasFontHeight = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getNormalized = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 5, false);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setNormalized = function(e3) {
    return t2.Message.setField(this, 5, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearNormalized = function() {
    return t2.Message.setField(this, 5, void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasNormalized = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getFontFace = function() {
    return t2.Message.getFieldWithDefault(this, 6, 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setFontFace = function(e3) {
    return t2.Message.setField(this, 6, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearFontFace = function() {
    return t2.Message.setField(this, 6, void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasFontFace = function() {
    return null != t2.Message.getField(this, 6);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getCenterHorizontally = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 7, false);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setCenterHorizontally = function(e3) {
    return t2.Message.setField(this, 7, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearCenterHorizontally = function() {
    return t2.Message.setField(this, 7, void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasCenterHorizontally = function() {
    return null != t2.Message.getField(this, 7);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getCenterVertically = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 8, false);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setCenterVertically = function(e3) {
    return t2.Message.setField(this, 8, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearCenterVertically = function() {
    return t2.Message.setField(this, 8, void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasCenterVertically = function() {
    return null != t2.Message.getField(this, 8);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getOutlineThickness = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 11, 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setOutlineThickness = function(e3) {
    return t2.Message.setField(this, 11, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearOutlineThickness = function() {
    return t2.Message.setField(this, 11, void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasOutlineThickness = function() {
    return null != t2.Message.getField(this, 11);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.getOutlineColor = function() {
    return t2.Message.getWrapperField(this, i3.Color, 12);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.setOutlineColor = function(e3) {
    return t2.Message.setWrapperField(this, 12, e3);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.clearOutlineColor = function() {
    return this.setOutlineColor(void 0);
  }, proto.mediapipe.RenderAnnotation.Text.prototype.hasOutlineColor = function() {
    return null != t2.Message.getField(this, 12);
  }, proto.mediapipe.RenderAnnotation.prototype.getRectangle = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Rectangle, 1);
  }, proto.mediapipe.RenderAnnotation.prototype.setRectangle = function(e3) {
    return t2.Message.setOneofWrapperField(this, 1, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearRectangle = function() {
    return this.setRectangle(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasRectangle = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderAnnotation.prototype.getFilledRectangle = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.FilledRectangle, 2);
  }, proto.mediapipe.RenderAnnotation.prototype.setFilledRectangle = function(e3) {
    return t2.Message.setOneofWrapperField(this, 2, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearFilledRectangle = function() {
    return this.setFilledRectangle(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasFilledRectangle = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderAnnotation.prototype.getOval = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Oval, 3);
  }, proto.mediapipe.RenderAnnotation.prototype.setOval = function(e3) {
    return t2.Message.setOneofWrapperField(this, 3, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearOval = function() {
    return this.setOval(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasOval = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.RenderAnnotation.prototype.getFilledOval = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.FilledOval, 4);
  }, proto.mediapipe.RenderAnnotation.prototype.setFilledOval = function(e3) {
    return t2.Message.setOneofWrapperField(this, 4, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearFilledOval = function() {
    return this.setFilledOval(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasFilledOval = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.RenderAnnotation.prototype.getPoint = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Point, 5);
  }, proto.mediapipe.RenderAnnotation.prototype.setPoint = function(e3) {
    return t2.Message.setOneofWrapperField(this, 5, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearPoint = function() {
    return this.setPoint(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasPoint = function() {
    return null != t2.Message.getField(this, 5);
  }, proto.mediapipe.RenderAnnotation.prototype.getLine = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Line, 6);
  }, proto.mediapipe.RenderAnnotation.prototype.setLine = function(e3) {
    return t2.Message.setOneofWrapperField(this, 6, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearLine = function() {
    return this.setLine(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasLine = function() {
    return null != t2.Message.getField(this, 6);
  }, proto.mediapipe.RenderAnnotation.prototype.getArrow = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Arrow, 7);
  }, proto.mediapipe.RenderAnnotation.prototype.setArrow = function(e3) {
    return t2.Message.setOneofWrapperField(this, 7, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearArrow = function() {
    return this.setArrow(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasArrow = function() {
    return null != t2.Message.getField(this, 7);
  }, proto.mediapipe.RenderAnnotation.prototype.getText = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Text, 8);
  }, proto.mediapipe.RenderAnnotation.prototype.setText = function(e3) {
    return t2.Message.setOneofWrapperField(this, 8, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearText = function() {
    return this.setText(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasText = function() {
    return null != t2.Message.getField(this, 8);
  }, proto.mediapipe.RenderAnnotation.prototype.getRoundedRectangle = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.RoundedRectangle, 9);
  }, proto.mediapipe.RenderAnnotation.prototype.setRoundedRectangle = function(e3) {
    return t2.Message.setOneofWrapperField(this, 9, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearRoundedRectangle = function() {
    return this.setRoundedRectangle(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasRoundedRectangle = function() {
    return null != t2.Message.getField(this, 9);
  }, proto.mediapipe.RenderAnnotation.prototype.getFilledRoundedRectangle = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.FilledRoundedRectangle, 10);
  }, proto.mediapipe.RenderAnnotation.prototype.setFilledRoundedRectangle = function(e3) {
    return t2.Message.setOneofWrapperField(this, 10, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearFilledRoundedRectangle = function() {
    return this.setFilledRoundedRectangle(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasFilledRoundedRectangle = function() {
    return null != t2.Message.getField(this, 10);
  }, proto.mediapipe.RenderAnnotation.prototype.getGradientLine = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.GradientLine, 14);
  }, proto.mediapipe.RenderAnnotation.prototype.setGradientLine = function(e3) {
    return t2.Message.setOneofWrapperField(this, 14, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearGradientLine = function() {
    return this.setGradientLine(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasGradientLine = function() {
    return null != t2.Message.getField(this, 14);
  }, proto.mediapipe.RenderAnnotation.prototype.getScribble = function() {
    return t2.Message.getWrapperField(this, proto.mediapipe.RenderAnnotation.Scribble, 15);
  }, proto.mediapipe.RenderAnnotation.prototype.setScribble = function(e3) {
    return t2.Message.setOneofWrapperField(this, 15, proto.mediapipe.RenderAnnotation.oneofGroups_[0], e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearScribble = function() {
    return this.setScribble(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasScribble = function() {
    return null != t2.Message.getField(this, 15);
  }, proto.mediapipe.RenderAnnotation.prototype.getThickness = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 11, 1);
  }, proto.mediapipe.RenderAnnotation.prototype.setThickness = function(e3) {
    return t2.Message.setField(this, 11, e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearThickness = function() {
    return t2.Message.setField(this, 11, void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasThickness = function() {
    return null != t2.Message.getField(this, 11);
  }, proto.mediapipe.RenderAnnotation.prototype.getColor = function() {
    return t2.Message.getWrapperField(this, i3.Color, 12);
  }, proto.mediapipe.RenderAnnotation.prototype.setColor = function(e3) {
    return t2.Message.setWrapperField(this, 12, e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearColor = function() {
    return this.setColor(void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasColor = function() {
    return null != t2.Message.getField(this, 12);
  }, proto.mediapipe.RenderAnnotation.prototype.getSceneTag = function() {
    return t2.Message.getFieldWithDefault(this, 13, "");
  }, proto.mediapipe.RenderAnnotation.prototype.setSceneTag = function(e3) {
    return t2.Message.setField(this, 13, e3);
  }, proto.mediapipe.RenderAnnotation.prototype.clearSceneTag = function() {
    return t2.Message.setField(this, 13, void 0);
  }, proto.mediapipe.RenderAnnotation.prototype.hasSceneTag = function() {
    return null != t2.Message.getField(this, 13);
  }, t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.RenderViewport.prototype.toObject = function(e3) {
    return proto.mediapipe.RenderViewport.toObject(e3, this);
  }, proto.mediapipe.RenderViewport.toObject = function(e3, r3) {
    var o3, i4 = { id: null == (o3 = t2.Message.getField(r3, 1)) ? void 0 : o3, widthPx: null == (o3 = t2.Message.getField(r3, 2)) ? void 0 : o3, heightPx: null == (o3 = t2.Message.getField(r3, 3)) ? void 0 : o3, composeOnVideo: null == (o3 = t2.Message.getBooleanField(r3, 4)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.RenderViewport.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.RenderViewport();
    return proto.mediapipe.RenderViewport.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.RenderViewport.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = t3.readString();
          e3.setId(r3);
          break;
        case 2:
          r3 = t3.readInt32();
          e3.setWidthPx(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setHeightPx(r3);
          break;
        case 4:
          r3 = t3.readBool();
          e3.setComposeOnVideo(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.RenderViewport.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.RenderViewport.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.RenderViewport.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = t2.Message.getField(e3, 1)) && r3.writeString(1, o3), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeInt32(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeBool(4, o3);
  }, proto.mediapipe.RenderViewport.prototype.getId = function() {
    return t2.Message.getFieldWithDefault(this, 1, "");
  }, proto.mediapipe.RenderViewport.prototype.setId = function(e3) {
    return t2.Message.setField(this, 1, e3);
  }, proto.mediapipe.RenderViewport.prototype.clearId = function() {
    return t2.Message.setField(this, 1, void 0);
  }, proto.mediapipe.RenderViewport.prototype.hasId = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.RenderViewport.prototype.getWidthPx = function() {
    return t2.Message.getFieldWithDefault(this, 2, 0);
  }, proto.mediapipe.RenderViewport.prototype.setWidthPx = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.RenderViewport.prototype.clearWidthPx = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.RenderViewport.prototype.hasWidthPx = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.RenderViewport.prototype.getHeightPx = function() {
    return t2.Message.getFieldWithDefault(this, 3, 0);
  }, proto.mediapipe.RenderViewport.prototype.setHeightPx = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.RenderViewport.prototype.clearHeightPx = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.RenderViewport.prototype.hasHeightPx = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.RenderViewport.prototype.getComposeOnVideo = function() {
    return t2.Message.getBooleanFieldWithDefault(this, 4, false);
  }, proto.mediapipe.RenderViewport.prototype.setComposeOnVideo = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.RenderViewport.prototype.clearComposeOnVideo = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.RenderViewport.prototype.hasComposeOnVideo = function() {
    return null != t2.Message.getField(this, 4);
  }, r2.object.extend(e2, proto.mediapipe);
}(render_data_pb);
var interactive_segmenter_result = {};
Object.defineProperty(interactive_segmenter_result, "__esModule", { value: true }), interactive_segmenter_result.InteractiveSegmenterResult = void 0;
var InteractiveSegmenterResult = class {
  constructor(e2, t2, r2) {
    this.confidenceMasks = e2, this.categoryMask = t2, this.qualityScores = r2;
  }
  close() {
    var e2, t2;
    null === (e2 = this.confidenceMasks) || void 0 === e2 || e2.forEach((e3) => {
      e3.close();
    }), null === (t2 = this.categoryMask) || void 0 === t2 || t2.close();
  }
};
interactive_segmenter_result.InteractiveSegmenterResult = InteractiveSegmenterResult;
var interactive_segmenter_options = {};
Object.defineProperty(interactive_segmenter_options, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.InteractiveSegmenter = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = base_options_pb, n2 = image_segmenter_graph_options_pb, s2 = segmenter_options_pb, p = vision_task_runner, d2 = color_pb, l2 = render_data_pb, g = interactive_segmenter_result;
  r2(interactive_segmenter_options, e2), r2(interactive_segmenter_result, e2);
  const c6 = "image_in", u = "norm_rect_in", m = "roi_in", f2 = "confidence_masks", h = "category_mask", y = "quality_scores";
  class b extends p.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return p.VisionTaskRunner.createVisionInstance(b, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return p.VisionTaskRunner.createVisionInstance(b, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static createFromModelPath(e3, t3) {
      return p.VisionTaskRunner.createVisionInstance(b, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new p.VisionGraphRunner(e3, t3), c6, u, false), this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.options = new n2.ImageSegmenterGraphOptions(), this.segmenterOptions = new s2.SegmenterOptions(), this.options.setSegmenterOptions(this.segmenterOptions), this.options.setBaseOptions(new a3.BaseOptions());
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      var t3, r3;
      return "outputCategoryMask" in e3 && (this.outputCategoryMask = null !== (t3 = e3.outputCategoryMask) && void 0 !== t3 && t3), "outputConfidenceMasks" in e3 && (this.outputConfidenceMasks = null === (r3 = e3.outputConfidenceMasks) || void 0 === r3 || r3), super.applyOptions(e3);
    }
    segment(e3, t3, r3, o3) {
      const i4 = "function" != typeof r3 ? r3 : {};
      return this.userCallback = "function" == typeof r3 ? r3 : o3, this.reset(), this.processRenderData(t3, this.getSynctheticTimestamp()), this.processImageData(e3, i4), this.processResults();
    }
    reset() {
      this.confidenceMasks = void 0, this.categoryMask = void 0, this.qualityScores = void 0;
    }
    processResults() {
      try {
        const e3 = new g.InteractiveSegmenterResult(this.confidenceMasks, this.categoryMask, this.qualityScores);
        if (!this.userCallback)
          return e3;
        this.userCallback(e3);
      } finally {
        this.freeKeepaliveStreams();
      }
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(c6), e3.addInputStream(m), e3.addInputStream(u);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(n2.ImageSegmenterGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"), r3.addInputStream("IMAGE:" + c6), r3.addInputStream("ROI:" + m), r3.addInputStream("NORM_RECT:" + u), r3.setOptions(t3), e3.addNode(r3), this.addKeepaliveNode(e3), this.outputConfidenceMasks && (e3.addOutputStream(f2), r3.addOutputStream("CONFIDENCE_MASKS:" + f2), this.keepStreamAlive(f2), this.graphRunner.attachImageVectorListener(f2, (e4, t4) => {
        this.confidenceMasks = e4.map((e5) => this.convertToMPMask(e5, !this.userCallback)), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(f2, (e4) => {
        this.confidenceMasks = [], this.setLatestOutputTimestamp(e4);
      })), this.outputCategoryMask && (e3.addOutputStream(h), r3.addOutputStream("CATEGORY_MASK:" + h), this.keepStreamAlive(h), this.graphRunner.attachImageListener(h, (e4, t4) => {
        this.categoryMask = this.convertToMPMask(e4, !this.userCallback), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(h, (e4) => {
        this.categoryMask = void 0, this.setLatestOutputTimestamp(e4);
      })), e3.addOutputStream(y), r3.addOutputStream("QUALITY_SCORES:" + y), this.graphRunner.attachFloatVectorListener(y, (e4, t4) => {
        this.qualityScores = e4, this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(y, (e4) => {
        this.categoryMask = void 0, this.setLatestOutputTimestamp(e4);
      });
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
    processRenderData(e3, t3) {
      const r3 = new l2.RenderData(), o3 = new l2.RenderAnnotation(), i4 = new d2.Color();
      if (i4.setR(255), o3.setColor(i4), e3.keypoint && e3.scribble)
        throw new Error("Cannot provide both keypoint and scribble.");
      if (e3.keypoint) {
        const t4 = new l2.RenderAnnotation.Point();
        t4.setNormalized(true), t4.setX(e3.keypoint.x), t4.setY(e3.keypoint.y), o3.setPoint(t4);
      } else {
        if (!e3.scribble)
          throw new Error("Must provide either a keypoint or a scribble.");
        {
          const t4 = new l2.RenderAnnotation.Scribble();
          for (const r4 of e3.scribble) {
            const e4 = new l2.RenderAnnotation.Point();
            e4.setNormalized(true), e4.setX(r4.x), e4.setY(r4.y), t4.addPoint(e4);
          }
          o3.setScribble(t4);
        }
      }
      r3.addRenderAnnotations(o3), this.graphRunner.addProtoToStream(r3.serializeBinary(), "mediapipe.RenderData", m, t3);
    }
  }
  e2.InteractiveSegmenter = b;
}(interactive_segmenter);
var object_detector = {};
var object_detector_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2), r2.exportSymbol("proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions", null, o2), proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.repeatedFields_, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.displayName = "proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions"), proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.repeatedFields_ = [5, 6], t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), displayNamesLocale: t2.Message.getFieldWithDefault(r3, 2, "en"), maxResults: t2.Message.getFieldWithDefault(r3, 3, -1), scoreThreshold: null == (o3 = t2.Message.getOptionalFloatingPointField(r3, 4)) ? void 0 : o3, categoryAllowlistList: null == (o3 = t2.Message.getRepeatedField(r3, 5)) ? void 0 : o3, categoryDenylistList: null == (o3 = t2.Message.getRepeatedField(r3, 6)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions();
    return proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = t3.readString();
          e3.setDisplayNamesLocale(r3);
          break;
        case 3:
          r3 = t3.readInt32();
          e3.setMaxResults(r3);
          break;
        case 4:
          r3 = t3.readFloat();
          e3.setScoreThreshold(r3);
          break;
        case 5:
          r3 = t3.readString();
          e3.addCategoryAllowlist(r3);
          break;
        case 6:
          r3 = t3.readString();
          e3.addCategoryDenylist(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeString(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeInt32(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeFloat(4, o3), (o3 = e3.getCategoryAllowlistList()).length > 0 && r3.writeRepeatedString(5, o3), (o3 = e3.getCategoryDenylistList()).length > 0 && r3.writeRepeatedString(6, o3);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.ext = new t2.ExtensionFieldInfo(443442058, { ext: 0 }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[443442058] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[443442058] = proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.ext, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.getDisplayNamesLocale = function() {
    return t2.Message.getFieldWithDefault(this, 2, "en");
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.setDisplayNamesLocale = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.clearDisplayNamesLocale = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.hasDisplayNamesLocale = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.getMaxResults = function() {
    return t2.Message.getFieldWithDefault(this, 3, -1);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.setMaxResults = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.clearMaxResults = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.hasMaxResults = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.getScoreThreshold = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.setScoreThreshold = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.clearScoreThreshold = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.hasScoreThreshold = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.getCategoryAllowlistList = function() {
    return t2.Message.getRepeatedField(this, 5);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.setCategoryAllowlistList = function(e3) {
    return t2.Message.setField(this, 5, e3 || []);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.addCategoryAllowlist = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 5, e3, r3);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.clearCategoryAllowlistList = function() {
    return this.setCategoryAllowlistList([]);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.getCategoryDenylistList = function() {
    return t2.Message.getRepeatedField(this, 6);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.setCategoryDenylistList = function(e3) {
    return t2.Message.setField(this, 6, e3 || []);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.addCategoryDenylist = function(e3, r3) {
    return t2.Message.addToRepeatedField(this, 6, e3, r3);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.prototype.clearCategoryDenylistList = function() {
    return this.setCategoryDenylistList([]);
  }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.ext = new t2.ExtensionFieldInfo(443442058, { ext: 0 }, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[443442058] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[443442058] = proto.mediapipe.tasks.vision.object_detector.proto.ObjectDetectorOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.object_detector.proto);
}(object_detector_options_pb);
var object_detector_options = {};
Object.defineProperty(object_detector_options, "__esModule", { value: true });
var object_detector_result = {};
Object.defineProperty(object_detector_result, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.ObjectDetector = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = detection_pb, n2 = base_options_pb, s2 = object_detector_options_pb, p = detection_result, d2 = vision_task_runner, l2 = "input_frame_gpu", g = "norm_rect", c6 = "detections";
  r2(object_detector_options, e2), r2(object_detector_result, e2);
  class u extends d2.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return d2.VisionTaskRunner.createVisionInstance(u, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return d2.VisionTaskRunner.createVisionInstance(u, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static async createFromModelPath(e3, t3) {
      return d2.VisionTaskRunner.createVisionInstance(u, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new d2.VisionGraphRunner(e3, t3), l2, g, false), this.result = { detections: [] }, this.options = new s2.ObjectDetectorOptions(), this.options.setBaseOptions(new n2.BaseOptions());
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      return void 0 !== e3.displayNamesLocale ? this.options.setDisplayNamesLocale(e3.displayNamesLocale) : "displayNamesLocale" in e3 && this.options.clearDisplayNamesLocale(), void 0 !== e3.maxResults ? this.options.setMaxResults(e3.maxResults) : "maxResults" in e3 && this.options.clearMaxResults(), void 0 !== e3.scoreThreshold ? this.options.setScoreThreshold(e3.scoreThreshold) : "scoreThreshold" in e3 && this.options.clearScoreThreshold(), void 0 !== e3.categoryAllowlist ? this.options.setCategoryAllowlistList(e3.categoryAllowlist) : "categoryAllowlist" in e3 && this.options.clearCategoryAllowlistList(), void 0 !== e3.categoryDenylist ? this.options.setCategoryDenylistList(e3.categoryDenylist) : "categoryDenylist" in e3 && this.options.clearCategoryDenylistList(), this.applyOptions(e3);
    }
    detect(e3, t3) {
      return this.result = { detections: [] }, this.processImageData(e3, t3), this.result;
    }
    detectForVideo(e3, t3, r3) {
      return this.result = { detections: [] }, this.processVideoData(e3, r3, t3), this.result;
    }
    addJsObjectDetections(e3) {
      for (const t3 of e3) {
        const e4 = a3.Detection.deserializeBinary(t3);
        this.result.detections.push((0, p.convertFromDetectionProto)(e4));
      }
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(l2), e3.addInputStream(g), e3.addOutputStream(c6);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(s2.ObjectDetectorOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.ObjectDetectorGraph"), r3.addInputStream("IMAGE:" + l2), r3.addInputStream("NORM_RECT:" + g), r3.addOutputStream("DETECTIONS:" + c6), r3.setOptions(t3), e3.addNode(r3), this.graphRunner.attachProtoVectorListener(c6, (e4, t4) => {
        this.addJsObjectDetections(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(c6, (e4) => {
        this.setLatestOutputTimestamp(e4);
      });
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
  }
  e2.ObjectDetector = u;
}(object_detector);
var pose_landmarker = {};
var pose_detector_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2), r2.exportSymbol("proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions", null, o2), proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.displayName = "proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), minDetectionConfidence: t2.Message.getFloatingPointFieldWithDefault(r3, 2, 0.5), minSuppressionThreshold: t2.Message.getFloatingPointFieldWithDefault(r3, 3, 0.5), numPoses: null == (o3 = t2.Message.getField(r3, 4)) ? void 0 : o3 };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions();
    return proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setMinDetectionConfidence(r3);
          break;
        case 3:
          r3 = t3.readFloat();
          e3.setMinSuppressionThreshold(r3);
          break;
        case 4:
          r3 = t3.readInt32();
          e3.setNumPoses(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3), null != (o3 = t2.Message.getField(e3, 3)) && r3.writeFloat(3, o3), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeInt32(4, o3);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(514774813, { ext: 0 }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[514774813] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[514774813] = proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.ext, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.getMinDetectionConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0.5);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.setMinDetectionConfidence = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.clearMinDetectionConfidence = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.hasMinDetectionConfidence = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.getMinSuppressionThreshold = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 3, 0.5);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.setMinSuppressionThreshold = function(e3) {
    return t2.Message.setField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.clearMinSuppressionThreshold = function() {
    return t2.Message.setField(this, 3, void 0);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.hasMinSuppressionThreshold = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.getNumPoses = function() {
    return t2.Message.getFieldWithDefault(this, 4, 0);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.setNumPoses = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.clearNumPoses = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.prototype.hasNumPoses = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(514774813, { ext: 0 }, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[514774813] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[514774813] = proto.mediapipe.tasks.vision.pose_detector.proto.PoseDetectorGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.pose_detector.proto);
}(pose_detector_graph_options_pb);
var pose_landmarker_graph_options_pb = {};
var pose_landmarks_detector_graph_options_pb = {};
!function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2), r2.exportSymbol("proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions", null, o2), proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.displayName = "proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), minDetectionConfidence: t2.Message.getFloatingPointFieldWithDefault(r3, 2, 0.5) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions();
    return proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = t3.readFloat();
          e3.setMinDetectionConfidence(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 2)) && r3.writeFloat(2, o3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(518928384, { ext: 0 }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[518928384] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[518928384] = proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.ext, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.getMinDetectionConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 2, 0.5);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.setMinDetectionConfidence = function(e3) {
    return t2.Message.setField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.clearMinDetectionConfidence = function() {
    return t2.Message.setField(this, 2, void 0);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.prototype.hasMinDetectionConfidence = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.ext = new t2.ExtensionFieldInfo(518928384, { ext: 0 }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[518928384] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[518928384] = proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarksDetectorGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.pose_landmarker.proto);
}(pose_landmarks_detector_graph_options_pb), function(e2) {
  var t2 = googleProtobuf, r2 = t2, o2 = "undefined" != typeof globalThis && globalThis || "undefined" != typeof window && window || void 0 !== o2 && o2 || "undefined" != typeof self && self || (function() {
    return this;
  }).call(null) || Function("return this")(), i3 = calculator_pb;
  r2.object.extend(proto, i3);
  var a3 = calculator_options_pb;
  r2.object.extend(proto, a3);
  var n2 = base_options_pb;
  r2.object.extend(proto, n2);
  var s2 = pose_detector_graph_options_pb;
  r2.object.extend(proto, s2);
  var p = pose_landmarks_detector_graph_options_pb;
  r2.object.extend(proto, p), r2.exportSymbol("proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions", null, o2), proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions = function(e3) {
    t2.Message.initialize(this, e3, 0, -1, null, null);
  }, r2.inherits(proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions, t2.Message), r2.DEBUG && !COMPILED && (proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.displayName = "proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions"), t2.Message.GENERATE_TO_OBJECT && (proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.toObject = function(e3) {
    return proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.toObject(e3, this);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.toObject = function(e3, r3) {
    var o3, i4 = { baseOptions: (o3 = r3.getBaseOptions()) && n2.BaseOptions.toObject(e3, o3), poseDetectorGraphOptions: (o3 = r3.getPoseDetectorGraphOptions()) && s2.PoseDetectorGraphOptions.toObject(e3, o3), poseLandmarksDetectorGraphOptions: (o3 = r3.getPoseLandmarksDetectorGraphOptions()) && p.PoseLandmarksDetectorGraphOptions.toObject(e3, o3), minTrackingConfidence: t2.Message.getFloatingPointFieldWithDefault(r3, 4, 0.5) };
    return e3 && (i4.$jspbMessageInstance = r3), i4;
  }), proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.deserializeBinary = function(e3) {
    var r3 = new t2.BinaryReader(e3), o3 = new proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions();
    return proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.deserializeBinaryFromReader(o3, r3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.deserializeBinaryFromReader = function(e3, t3) {
    for (; t3.nextField() && !t3.isEndGroup(); ) {
      switch (t3.getFieldNumber()) {
        case 1:
          var r3 = new n2.BaseOptions();
          t3.readMessage(r3, n2.BaseOptions.deserializeBinaryFromReader), e3.setBaseOptions(r3);
          break;
        case 2:
          r3 = new s2.PoseDetectorGraphOptions();
          t3.readMessage(r3, s2.PoseDetectorGraphOptions.deserializeBinaryFromReader), e3.setPoseDetectorGraphOptions(r3);
          break;
        case 3:
          r3 = new p.PoseLandmarksDetectorGraphOptions();
          t3.readMessage(r3, p.PoseLandmarksDetectorGraphOptions.deserializeBinaryFromReader), e3.setPoseLandmarksDetectorGraphOptions(r3);
          break;
        case 4:
          r3 = t3.readFloat();
          e3.setMinTrackingConfidence(r3);
          break;
        default:
          t3.skipField();
      }
    }
    return e3;
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.serializeBinary = function() {
    var e3 = new t2.BinaryWriter();
    return proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.serializeBinaryToWriter(this, e3), e3.getResultBuffer();
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.serializeBinaryToWriter = function(e3, r3) {
    var o3 = void 0;
    null != (o3 = e3.getBaseOptions()) && r3.writeMessage(1, o3, n2.BaseOptions.serializeBinaryToWriter), null != (o3 = e3.getPoseDetectorGraphOptions()) && r3.writeMessage(2, o3, s2.PoseDetectorGraphOptions.serializeBinaryToWriter), null != (o3 = e3.getPoseLandmarksDetectorGraphOptions()) && r3.writeMessage(3, o3, p.PoseLandmarksDetectorGraphOptions.serializeBinaryToWriter), null != (o3 = t2.Message.getField(e3, 4)) && r3.writeFloat(4, o3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.ext = new t2.ExtensionFieldInfo(516587230, { ext: 0 }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[516587230] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[516587230] = proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.ext, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.getBaseOptions = function() {
    return t2.Message.getWrapperField(this, n2.BaseOptions, 1);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.setBaseOptions = function(e3) {
    return t2.Message.setWrapperField(this, 1, e3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.clearBaseOptions = function() {
    return this.setBaseOptions(void 0);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.hasBaseOptions = function() {
    return null != t2.Message.getField(this, 1);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.getPoseDetectorGraphOptions = function() {
    return t2.Message.getWrapperField(this, s2.PoseDetectorGraphOptions, 2);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.setPoseDetectorGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 2, e3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.clearPoseDetectorGraphOptions = function() {
    return this.setPoseDetectorGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.hasPoseDetectorGraphOptions = function() {
    return null != t2.Message.getField(this, 2);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.getPoseLandmarksDetectorGraphOptions = function() {
    return t2.Message.getWrapperField(this, p.PoseLandmarksDetectorGraphOptions, 3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.setPoseLandmarksDetectorGraphOptions = function(e3) {
    return t2.Message.setWrapperField(this, 3, e3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.clearPoseLandmarksDetectorGraphOptions = function() {
    return this.setPoseLandmarksDetectorGraphOptions(void 0);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.hasPoseLandmarksDetectorGraphOptions = function() {
    return null != t2.Message.getField(this, 3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.getMinTrackingConfidence = function() {
    return t2.Message.getFloatingPointFieldWithDefault(this, 4, 0.5);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.setMinTrackingConfidence = function(e3) {
    return t2.Message.setField(this, 4, e3);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.clearMinTrackingConfidence = function() {
    return t2.Message.setField(this, 4, void 0);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.prototype.hasMinTrackingConfidence = function() {
    return null != t2.Message.getField(this, 4);
  }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.ext = new t2.ExtensionFieldInfo(516587230, { ext: 0 }, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.toObject, 0), a3.CalculatorOptions.extensionsBinary[516587230] = new t2.ExtensionFieldBinaryInfo(proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.ext, t2.BinaryReader.prototype.readMessage, t2.BinaryWriter.prototype.writeMessage, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.serializeBinaryToWriter, proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.deserializeBinaryFromReader, false), a3.CalculatorOptions.extensions[516587230] = proto.mediapipe.tasks.vision.pose_landmarker.proto.PoseLandmarkerGraphOptions.ext, r2.object.extend(e2, proto.mediapipe.tasks.vision.pose_landmarker.proto);
}(pose_landmarker_graph_options_pb);
var pose_landmarker_result = {};
Object.defineProperty(pose_landmarker_result, "__esModule", { value: true }), pose_landmarker_result.PoseLandmarkerResult = void 0;
var PoseLandmarkerResult = class {
  constructor(e2, t2, r2) {
    this.landmarks = e2, this.worldLandmarks = t2, this.segmentationMasks = r2;
  }
  close() {
    var e2;
    null === (e2 = this.segmentationMasks) || void 0 === e2 || e2.forEach((e3) => {
      e3.close();
    });
  }
};
pose_landmarker_result.PoseLandmarkerResult = PoseLandmarkerResult;
var pose_landmarker_options = {};
Object.defineProperty(pose_landmarker_options, "__esModule", { value: true }), function(e2) {
  var t2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3);
    var i4 = Object.getOwnPropertyDescriptor(t3, r3);
    i4 && !("get" in i4 ? !t3.__esModule : i4.writable || i4.configurable) || (i4 = { enumerable: true, get: function() {
      return t3[r3];
    } }), Object.defineProperty(e3, o3, i4);
  } : function(e3, t3, r3, o3) {
    void 0 === o3 && (o3 = r3), e3[o3] = t3[r3];
  }), r2 = commonjsGlobal && commonjsGlobal.__exportStar || function(e3, r3) {
    for (var o3 in e3)
      "default" === o3 || Object.prototype.hasOwnProperty.call(r3, o3) || t2(r3, e3, o3);
  };
  Object.defineProperty(e2, "__esModule", { value: true }), e2.PoseLandmarker = void 0;
  const o2 = calculator_pb, i3 = calculator_options_pb, a3 = landmark_pb, n2 = base_options_pb, s2 = pose_detector_graph_options_pb, p = pose_landmarker_graph_options_pb, d2 = pose_landmarks_detector_graph_options_pb, l2 = landmark_result, g = vision_task_runner, c6 = pose_landmarker_result;
  r2(pose_landmarker_options, e2), r2(pose_landmarker_result, e2);
  const u = "image_in", m = "norm_rect", f2 = "normalized_landmarks", h = "world_landmarks", y = "segmentation_masks", b = 0.5;
  class _ extends g.VisionTaskRunner {
    static createFromOptions(e3, t3) {
      return g.VisionTaskRunner.createVisionInstance(_, e3, t3);
    }
    static createFromModelBuffer(e3, t3) {
      return g.VisionTaskRunner.createVisionInstance(_, e3, { baseOptions: { modelAssetBuffer: t3 } });
    }
    static createFromModelPath(e3, t3) {
      return g.VisionTaskRunner.createVisionInstance(_, e3, { baseOptions: { modelAssetPath: t3 } });
    }
    constructor(e3, t3) {
      super(new g.VisionGraphRunner(e3, t3), u, m, false), this.landmarks = [], this.worldLandmarks = [], this.outputSegmentationMasks = false, this.options = new p.PoseLandmarkerGraphOptions(), this.options.setBaseOptions(new n2.BaseOptions()), this.poseLandmarksDetectorGraphOptions = new d2.PoseLandmarksDetectorGraphOptions(), this.options.setPoseLandmarksDetectorGraphOptions(this.poseLandmarksDetectorGraphOptions), this.poseDetectorGraphOptions = new s2.PoseDetectorGraphOptions(), this.options.setPoseDetectorGraphOptions(this.poseDetectorGraphOptions), this.initDefaults();
    }
    get baseOptions() {
      return this.options.getBaseOptions();
    }
    set baseOptions(e3) {
      this.options.setBaseOptions(e3);
    }
    setOptions(e3) {
      var t3, r3, o3, i4, a4;
      return "numPoses" in e3 && this.poseDetectorGraphOptions.setNumPoses(null !== (t3 = e3.numPoses) && void 0 !== t3 ? t3 : 1), "minPoseDetectionConfidence" in e3 && this.poseDetectorGraphOptions.setMinDetectionConfidence(null !== (r3 = e3.minPoseDetectionConfidence) && void 0 !== r3 ? r3 : b), "minTrackingConfidence" in e3 && this.options.setMinTrackingConfidence(null !== (o3 = e3.minTrackingConfidence) && void 0 !== o3 ? o3 : b), "minPosePresenceConfidence" in e3 && this.poseLandmarksDetectorGraphOptions.setMinDetectionConfidence(null !== (i4 = e3.minPosePresenceConfidence) && void 0 !== i4 ? i4 : b), "outputSegmentationMasks" in e3 && (this.outputSegmentationMasks = null !== (a4 = e3.outputSegmentationMasks) && void 0 !== a4 && a4), this.applyOptions(e3);
    }
    detect(e3, t3, r3) {
      const o3 = "function" != typeof t3 ? t3 : {};
      return this.userCallback = "function" == typeof t3 ? t3 : r3, this.resetResults(), this.processImageData(e3, o3), this.processResults();
    }
    detectForVideo(e3, t3, r3, o3) {
      const i4 = "function" != typeof r3 ? r3 : {};
      return this.userCallback = "function" == typeof r3 ? r3 : o3, this.resetResults(), this.processVideoData(e3, i4, t3), this.processResults();
    }
    resetResults() {
      this.landmarks = [], this.worldLandmarks = [], this.segmentationMasks = void 0;
    }
    processResults() {
      try {
        const e3 = new c6.PoseLandmarkerResult(this.landmarks, this.worldLandmarks, this.segmentationMasks);
        if (!this.userCallback)
          return e3;
        this.userCallback(e3);
      } finally {
        this.freeKeepaliveStreams();
      }
    }
    initDefaults() {
      this.poseDetectorGraphOptions.setNumPoses(1), this.poseDetectorGraphOptions.setMinDetectionConfidence(b), this.poseLandmarksDetectorGraphOptions.setMinDetectionConfidence(b), this.options.setMinTrackingConfidence(b);
    }
    addJsLandmarks(e3) {
      this.landmarks = [];
      for (const t3 of e3) {
        const e4 = a3.NormalizedLandmarkList.deserializeBinary(t3);
        this.landmarks.push((0, l2.convertToLandmarks)(e4));
      }
    }
    adddJsWorldLandmarks(e3) {
      this.worldLandmarks = [];
      for (const t3 of e3) {
        const e4 = a3.LandmarkList.deserializeBinary(t3);
        this.worldLandmarks.push((0, l2.convertToWorldLandmarks)(e4));
      }
    }
    refreshGraph() {
      const e3 = new o2.CalculatorGraphConfig();
      e3.addInputStream(u), e3.addInputStream(m), e3.addOutputStream(f2), e3.addOutputStream(h), e3.addOutputStream(y);
      const t3 = new i3.CalculatorOptions();
      t3.setExtension(p.PoseLandmarkerGraphOptions.ext, this.options);
      const r3 = new o2.CalculatorGraphConfig.Node();
      r3.setCalculator("mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"), r3.addInputStream("IMAGE:" + u), r3.addInputStream("NORM_RECT:" + m), r3.addOutputStream("NORM_LANDMARKS:" + f2), r3.addOutputStream("WORLD_LANDMARKS:" + h), r3.setOptions(t3), e3.addNode(r3), this.addKeepaliveNode(e3), this.graphRunner.attachProtoVectorListener(f2, (e4, t4) => {
        this.addJsLandmarks(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(f2, (e4) => {
        this.landmarks = [], this.setLatestOutputTimestamp(e4);
      }), this.graphRunner.attachProtoVectorListener(h, (e4, t4) => {
        this.adddJsWorldLandmarks(e4), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(h, (e4) => {
        this.worldLandmarks = [], this.setLatestOutputTimestamp(e4);
      }), this.outputSegmentationMasks && (r3.addOutputStream("SEGMENTATION_MASK:" + y), this.keepStreamAlive(y), this.graphRunner.attachImageVectorListener(y, (e4, t4) => {
        this.segmentationMasks = e4.map((e5) => this.convertToMPMask(e5, !this.userCallback)), this.setLatestOutputTimestamp(t4);
      }), this.graphRunner.attachEmptyPacketListener(y, (e4) => {
        this.segmentationMasks = [], this.setLatestOutputTimestamp(e4);
      }));
      const a4 = e3.serializeBinary();
      this.setGraph(new Uint8Array(a4), true);
    }
  }
  e2.PoseLandmarker = _, _.POSE_CONNECTIONS = [{ start: 0, end: 1 }, { start: 1, end: 2 }, { start: 2, end: 3 }, { start: 3, end: 7 }, { start: 0, end: 4 }, { start: 4, end: 5 }, { start: 5, end: 6 }, { start: 6, end: 8 }, { start: 9, end: 10 }, { start: 11, end: 12 }, { start: 11, end: 13 }, { start: 13, end: 15 }, { start: 15, end: 17 }, { start: 15, end: 19 }, { start: 15, end: 21 }, { start: 17, end: 19 }, { start: 12, end: 14 }, { start: 14, end: 16 }, { start: 16, end: 18 }, { start: 16, end: 20 }, { start: 16, end: 22 }, { start: 18, end: 20 }, { start: 11, end: 23 }, { start: 12, end: 24 }, { start: 23, end: 24 }, { start: 23, end: 25 }, { start: 24, end: 26 }, { start: 25, end: 27 }, { start: 26, end: 28 }, { start: 27, end: 29 }, { start: 28, end: 30 }, { start: 29, end: 31 }, { start: 30, end: 32 }, { start: 27, end: 31 }, { start: 28, end: 32 }];
}(pose_landmarker), Object.defineProperty(vision, "__esModule", { value: true });
var PoseLandmarker_1 = vision.PoseLandmarker = ObjectDetector_1 = vision.ObjectDetector = InteractiveSegmenter_1 = vision.InteractiveSegmenter = ImageSegmenter_1 = vision.ImageSegmenter = ImageEmbedder_1 = vision.ImageEmbedder = ImageClassifier_1 = vision.ImageClassifier = HandLandmarker_1 = vision.HandLandmarker = GestureRecognizer_1 = vision.GestureRecognizer = FaceStylizer_1 = vision.FaceStylizer = FaceLandmarker_1 = vision.FaceLandmarker = FaceDetector_1 = vision.FaceDetector = MPMask_1 = vision.MPMask = MPImage_1 = vision.MPImage = FilesetResolver_1 = vision.FilesetResolver = DrawingUtils_1 = vision.DrawingUtils = void 0;
var fileset_resolver_1 = fileset_resolver;
var drawing_utils_1 = drawing_utils;
var image_1 = image;
var mask_1 = mask;
var face_detector_1 = face_detector;
var face_landmarker_1 = face_landmarker;
var face_stylizer_1 = face_stylizer;
var gesture_recognizer_1 = gesture_recognizer;
var hand_landmarker_1 = hand_landmarker;
var image_classifier_1 = image_classifier;
var image_embedder_1 = image_embedder;
var image_segmenter_1 = image_segmenter;
var interactive_segmenter_1 = interactive_segmenter;
var object_detector_1 = object_detector;
var pose_landmarker_1 = pose_landmarker;
var DrawingUtils = drawing_utils_1.DrawingUtils;
var DrawingUtils_1 = vision.DrawingUtils = DrawingUtils;
var FilesetResolver = fileset_resolver_1.FilesetResolver;
var FilesetResolver_1 = vision.FilesetResolver = FilesetResolver;
var MPImage = image_1.MPImage;
var MPImage_1 = vision.MPImage = MPImage;
var MPMask = mask_1.MPMask;
var MPMask_1 = vision.MPMask = MPMask;
var FaceDetector = face_detector_1.FaceDetector;
var FaceDetector_1 = vision.FaceDetector = FaceDetector;
var FaceLandmarker = face_landmarker_1.FaceLandmarker;
var FaceLandmarker_1 = vision.FaceLandmarker = FaceLandmarker;
var FaceStylizer = face_stylizer_1.FaceStylizer;
var FaceStylizer_1 = vision.FaceStylizer = FaceStylizer;
var GestureRecognizer = gesture_recognizer_1.GestureRecognizer;
var GestureRecognizer_1 = vision.GestureRecognizer = GestureRecognizer;
var HandLandmarker = hand_landmarker_1.HandLandmarker;
var HandLandmarker_1 = vision.HandLandmarker = HandLandmarker;
var ImageClassifier = image_classifier_1.ImageClassifier;
var ImageClassifier_1 = vision.ImageClassifier = ImageClassifier;
var ImageEmbedder = image_embedder_1.ImageEmbedder;
var ImageEmbedder_1 = vision.ImageEmbedder = ImageEmbedder;
var ImageSegmenter = image_segmenter_1.ImageSegmenter;
var ImageSegmenter_1 = vision.ImageSegmenter = ImageSegmenter;
var InteractiveSegmenter = interactive_segmenter_1.InteractiveSegmenter;
var InteractiveSegmenter_1 = vision.InteractiveSegmenter = InteractiveSegmenter;
var ObjectDetector = object_detector_1.ObjectDetector;
var ObjectDetector_1 = vision.ObjectDetector = ObjectDetector;
var PoseLandmarker = pose_landmarker_1.PoseLandmarker;
PoseLandmarker_1 = vision.PoseLandmarker = PoseLandmarker;

// node_modules/@react-three/drei/core/FaceLandmarker.js
var FaceLandmarkerContext = (0, import_react13.createContext)({});
var FaceLandmarkerDefaults = {
  basePath: "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.2-rc2/wasm",
  options: {
    baseOptions: {
      modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
      delegate: "GPU"
    },
    runningMode: "VIDEO",
    outputFaceBlendshapes: true,
    outputFacialTransformationMatrixes: true
  }
};
function FaceLandmarker2({
  basePath = FaceLandmarkerDefaults.basePath,
  options = FaceLandmarkerDefaults.options,
  children
}) {
  const opts = JSON.stringify(options);
  const faceLandmarker = suspend(async () => {
    return await FilesetResolver_1.forVisionTasks(basePath).then((vision2) => FaceLandmarker_1.createFromOptions(vision2, options));
  }, [basePath, opts]);
  (0, import_react13.useEffect)(() => {
    return () => {
      faceLandmarker == null ? void 0 : faceLandmarker.close();
      clear([basePath, opts]);
    };
  }, [faceLandmarker, basePath, opts]);
  return React50.createElement(FaceLandmarkerContext.Provider, {
    value: faceLandmarker
  }, children);
}
function useFaceLandmarker() {
  return (0, import_react13.useContext)(FaceLandmarkerContext);
}

// node_modules/@react-three/drei/core/FaceControls.js
function mean2(v12, v22) {
  return v12.clone().add(v22).multiplyScalar(0.5);
}
function localToLocal(objSrc, v4, objDst) {
  const v_world = objSrc.localToWorld(v4);
  return objDst.worldToLocal(v_world);
}
var FaceControlsContext = (0, import_react14.createContext)({});
var FaceControls = (0, import_react14.forwardRef)(({
  camera,
  autostart = true,
  webcam = true,
  webcamVideoTextureSrc,
  manualUpdate = false,
  manualDetect = false,
  onVideoFrame,
  smoothTime = 0.25,
  offset = true,
  offsetScalar = 80,
  eyes = false,
  eyesAsOrigin = true,
  depth = 0.15,
  debug = false,
  facemesh,
  makeDefault
}, fref) => {
  var _faces$facialTransfor, _faces$faceBlendshape;
  const scene = useThree((state) => state.scene);
  const defaultCamera = useThree((state) => state.camera);
  const set = useThree((state) => state.set);
  const get = useThree((state) => state.get);
  const explCamera = camera || defaultCamera;
  const webcamApiRef = (0, import_react14.useRef)(null);
  const facemeshApiRef = (0, import_react14.useRef)(null);
  const [target2] = (0, import_react14.useState)(() => new Object3D());
  const [irisRightDirPos] = (0, import_react14.useState)(() => new Vector3());
  const [irisLeftDirPos] = (0, import_react14.useState)(() => new Vector3());
  const [irisRightLookAt] = (0, import_react14.useState)(() => new Vector3());
  const [irisLeftLookAt] = (0, import_react14.useState)(() => new Vector3());
  const computeTarget = (0, import_react14.useCallback)(() => {
    target2.parent = explCamera.parent;
    const facemeshApi = facemeshApiRef.current;
    if (facemeshApi) {
      const {
        outerRef,
        eyeRightRef,
        eyeLeftRef
      } = facemeshApi;
      if (eyeRightRef.current && eyeLeftRef.current) {
        const {
          irisDirRef: irisRightDirRef
        } = eyeRightRef.current;
        const {
          irisDirRef: irisLeftDirRef
        } = eyeLeftRef.current;
        if (irisRightDirRef.current && irisLeftDirRef.current && outerRef.current) {
          irisRightDirPos.copy(localToLocal(irisRightDirRef.current, new Vector3(0, 0, 0), outerRef.current));
          irisLeftDirPos.copy(localToLocal(irisLeftDirRef.current, new Vector3(0, 0, 0), outerRef.current));
          target2.position.copy(localToLocal(outerRef.current, mean2(irisRightDirPos, irisLeftDirPos), explCamera.parent || scene));
          irisRightLookAt.copy(localToLocal(irisRightDirRef.current, new Vector3(0, 0, 1), outerRef.current));
          irisLeftLookAt.copy(localToLocal(irisLeftDirRef.current, new Vector3(0, 0, 1), outerRef.current));
          target2.lookAt(outerRef.current.localToWorld(mean2(irisRightLookAt, irisLeftLookAt)));
        }
      } else {
        if (outerRef.current) {
          target2.position.copy(localToLocal(outerRef.current, new Vector3(0, 0, 0), explCamera.parent || scene));
          target2.lookAt(outerRef.current.localToWorld(new Vector3(0, 0, 1)));
        }
      }
    }
    return target2;
  }, [explCamera, irisLeftDirPos, irisLeftLookAt, irisRightDirPos, irisRightLookAt, scene, target2]);
  const [current] = (0, import_react14.useState)(() => new Object3D());
  const update3 = (0, import_react14.useCallback)(function(delta, target3) {
    if (explCamera) {
      var _target;
      (_target = target3) !== null && _target !== void 0 ? _target : target3 = computeTarget();
      if (smoothTime > 0) {
        const eps2 = 1e-9;
        easing.damp3(current.position, target3.position, smoothTime, delta, void 0, void 0, eps2);
        easing.dampE(current.rotation, target3.rotation, smoothTime, delta, void 0, void 0, eps2);
      } else {
        current.position.copy(target3.position);
        current.rotation.copy(target3.rotation);
      }
      explCamera.position.copy(current.position);
      explCamera.rotation.copy(current.rotation);
    }
  }, [explCamera, computeTarget, smoothTime, current.position, current.rotation]);
  const [faces, setFaces] = (0, import_react14.useState)();
  const faceLandmarker = useFaceLandmarker();
  const detect = (0, import_react14.useCallback)((video, time) => {
    const faces2 = faceLandmarker == null ? void 0 : faceLandmarker.detectForVideo(video, time);
    setFaces(faces2);
  }, [faceLandmarker]);
  useFrame((_, delta) => {
    if (!manualUpdate) {
      update3(delta);
    }
  });
  const api = (0, import_react14.useMemo)(() => Object.assign(Object.create(EventDispatcher.prototype), {
    detect,
    computeTarget,
    update: update3,
    facemeshApiRef,
    webcamApiRef,
    // shorthands
    play: () => {
      var _webcamApiRef$current, _webcamApiRef$current2;
      (_webcamApiRef$current = webcamApiRef.current) == null ? void 0 : (_webcamApiRef$current2 = _webcamApiRef$current.videoTextureApiRef.current) == null ? void 0 : _webcamApiRef$current2.texture.source.data.play();
    },
    pause: () => {
      var _webcamApiRef$current3, _webcamApiRef$current4;
      (_webcamApiRef$current3 = webcamApiRef.current) == null ? void 0 : (_webcamApiRef$current4 = _webcamApiRef$current3.videoTextureApiRef.current) == null ? void 0 : _webcamApiRef$current4.texture.source.data.pause();
    }
  }), [detect, computeTarget, update3]);
  (0, import_react14.useImperativeHandle)(fref, () => api, [api]);
  (0, import_react14.useEffect)(() => {
    const onVideoFrameCb = (e2) => {
      if (!manualDetect)
        detect(e2.texture.source.data, e2.time);
      if (onVideoFrame)
        onVideoFrame(e2);
    };
    api.addEventListener("videoFrame", onVideoFrameCb);
    return () => {
      api.removeEventListener("videoFrame", onVideoFrameCb);
    };
  }, [api, detect, faceLandmarker, manualDetect, onVideoFrame]);
  (0, import_react14.useEffect)(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls: api
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, api, get, set]);
  const points = faces == null ? void 0 : faces.faceLandmarks[0];
  const facialTransformationMatrix = faces == null ? void 0 : (_faces$facialTransfor = faces.facialTransformationMatrixes) == null ? void 0 : _faces$facialTransfor[0];
  const faceBlendshapes = faces == null ? void 0 : (_faces$faceBlendshape = faces.faceBlendshapes) == null ? void 0 : _faces$faceBlendshape[0];
  return React51.createElement(FaceControlsContext.Provider, {
    value: api
  }, webcam && React51.createElement(import_react14.Suspense, {
    fallback: null
  }, React51.createElement(Webcam, {
    ref: webcamApiRef,
    autostart,
    videoTextureSrc: webcamVideoTextureSrc
  })), React51.createElement(Facemesh, _extends({
    ref: facemeshApiRef
  }, facemesh, {
    points,
    depth,
    facialTransformationMatrix,
    faceBlendshapes,
    eyes,
    eyesAsOrigin,
    offset,
    offsetScalar,
    debug,
    "rotation-z": Math.PI,
    visible: debug
  }), React51.createElement("meshBasicMaterial", {
    side: DoubleSide
  })));
});
var useFaceControls = () => (0, import_react14.useContext)(FaceControlsContext);
var Webcam = (0, import_react14.forwardRef)(({
  videoTextureSrc,
  autostart = true
}, fref) => {
  const videoTextureApiRef = (0, import_react14.useRef)(null);
  const faceControls = useFaceControls();
  const stream = suspend(async () => {
    return !videoTextureSrc ? await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: {
        facingMode: "user"
      }
    }) : Promise.resolve(null);
  }, [videoTextureSrc]);
  (0, import_react14.useEffect)(() => {
    faceControls.dispatchEvent({
      type: "stream",
      stream
    });
    return () => {
      stream == null ? void 0 : stream.getTracks().forEach((track) => track.stop());
      clear([videoTextureSrc]);
    };
  }, [stream, faceControls, videoTextureSrc]);
  const api = (0, import_react14.useMemo)(() => ({
    videoTextureApiRef
  }), []);
  (0, import_react14.useImperativeHandle)(fref, () => api, [api]);
  return React51.createElement(import_react14.Suspense, {
    fallback: null
  }, React51.createElement(VideoTexture2, {
    ref: videoTextureApiRef,
    src: videoTextureSrc || stream,
    start: autostart
  }));
});
var VideoTexture2 = (0, import_react14.forwardRef)(({
  src,
  start: start2
}, fref) => {
  const texture = useVideoTexture(src, {
    start: start2
  });
  const video = texture.source.data;
  const faceControls = useFaceControls();
  const onVideoFrame = (0, import_react14.useCallback)((time) => {
    faceControls.dispatchEvent({
      type: "videoFrame",
      texture,
      time
    });
  }, [texture, faceControls]);
  useVideoFrame(video, onVideoFrame);
  const api = (0, import_react14.useMemo)(() => ({
    texture
  }), [texture]);
  (0, import_react14.useImperativeHandle)(fref, () => api, [api]);
  return React51.createElement(React51.Fragment, null);
});
var useVideoFrame = (video, f2) => {
  (0, import_react14.useEffect)(() => {
    if (!video || !video.requestVideoFrameCallback)
      return;
    let handle;
    function callback(...args) {
      f2(...args);
      handle = video.requestVideoFrameCallback(callback);
    }
    video.requestVideoFrameCallback(callback);
    return () => video.cancelVideoFrameCallback(handle);
  }, [video, f2]);
};

// node_modules/@react-three/drei/core/GizmoHelper.js
var React53 = __toESM(require_react());

// node_modules/@react-three/drei/core/Hud.js
var React52 = __toESM(require_react());
function RenderHud({
  defaultScene,
  defaultCamera,
  renderPriority = 1
}) {
  const {
    gl,
    scene,
    camera
  } = useThree();
  let oldCLear;
  useFrame(() => {
    oldCLear = gl.autoClear;
    if (renderPriority === 1) {
      gl.autoClear = true;
      gl.render(defaultScene, defaultCamera);
    }
    gl.autoClear = false;
    gl.clearDepth();
    gl.render(scene, camera);
    gl.autoClear = oldCLear;
  }, renderPriority);
  return React52.createElement("group", {
    onPointerOver: () => null
  });
}
function Hud({
  children,
  renderPriority = 1
}) {
  const {
    scene: defaultScene,
    camera: defaultCamera
  } = useThree();
  const [hudScene] = React52.useState(() => new Scene());
  return React52.createElement(React52.Fragment, null, createPortal(React52.createElement(React52.Fragment, null, children, React52.createElement(RenderHud, {
    defaultScene,
    defaultCamera,
    renderPriority
  })), hudScene, {
    events: {
      priority: renderPriority + 1
    }
  }));
}

// node_modules/@react-three/drei/core/GizmoHelper.js
var Context = React53.createContext({});
var useGizmoContext = () => {
  return React53.useContext(Context);
};
var turnRate = 2 * Math.PI;
var dummy = new Object3D();
var matrix = new Matrix4();
var [q1, q2] = [new Quaternion(), new Quaternion()];
var target = new Vector3();
var targetPosition = new Vector3();
var isOrbitControls = (controls) => {
  return "minPolarAngle" in controls;
};
var GizmoHelper = ({
  alignment = "bottom-right",
  margin = [80, 80],
  renderPriority = 1,
  onUpdate,
  onTarget,
  children
}) => {
  const size = useThree((state) => state.size);
  const mainCamera = useThree((state) => state.camera);
  const defaultControls = useThree((state) => state.controls);
  const invalidate = useThree((state) => state.invalidate);
  const gizmoRef = React53.useRef();
  const virtualCam = React53.useRef(null);
  const animating = React53.useRef(false);
  const radius = React53.useRef(0);
  const focusPoint = React53.useRef(new Vector3(0, 0, 0));
  const defaultUp = React53.useRef(new Vector3(0, 0, 0));
  React53.useEffect(() => {
    defaultUp.current.copy(mainCamera.up);
  }, [mainCamera]);
  const tweenCamera = React53.useCallback((direction) => {
    animating.current = true;
    if (defaultControls || onTarget)
      focusPoint.current = (defaultControls == null ? void 0 : defaultControls.target) || (onTarget == null ? void 0 : onTarget());
    radius.current = mainCamera.position.distanceTo(target);
    q1.copy(mainCamera.quaternion);
    targetPosition.copy(direction).multiplyScalar(radius.current).add(target);
    dummy.lookAt(targetPosition);
    dummy.up.copy(mainCamera.up);
    q2.copy(dummy.quaternion);
    invalidate();
  }, [defaultControls, mainCamera, onTarget, invalidate]);
  useFrame((_, delta) => {
    if (virtualCam.current && gizmoRef.current) {
      var _gizmoRef$current;
      if (animating.current) {
        if (q1.angleTo(q2) < 0.01) {
          animating.current = false;
          if (isOrbitControls(defaultControls)) {
            mainCamera.up.copy(defaultUp.current);
          }
        } else {
          const step = delta * turnRate;
          q1.rotateTowards(q2, step);
          mainCamera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius.current).add(focusPoint.current);
          mainCamera.up.set(0, 1, 0).applyQuaternion(q1).normalize();
          mainCamera.quaternion.copy(q1);
          if (onUpdate)
            onUpdate();
          else if (defaultControls)
            defaultControls.update();
          invalidate();
        }
      }
      matrix.copy(mainCamera.matrix).invert();
      (_gizmoRef$current = gizmoRef.current) == null ? void 0 : _gizmoRef$current.quaternion.setFromRotationMatrix(matrix);
    }
  });
  const gizmoHelperContext = React53.useMemo(() => ({
    tweenCamera
  }), [tweenCamera]);
  const [marginX, marginY] = margin;
  const x = alignment.endsWith("-center") ? 0 : alignment.endsWith("-left") ? -size.width / 2 + marginX : size.width / 2 - marginX;
  const y = alignment.startsWith("center-") ? 0 : alignment.startsWith("top-") ? size.height / 2 - marginY : -size.height / 2 + marginY;
  return React53.createElement(Hud, {
    renderPriority
  }, React53.createElement(Context.Provider, {
    value: gizmoHelperContext
  }, React53.createElement(OrthographicCamera2, {
    makeDefault: true,
    ref: virtualCam,
    position: [0, 0, 200]
  }), React53.createElement("group", {
    ref: gizmoRef,
    position: [x, y, 0]
  }, children)));
};

// node_modules/@react-three/drei/core/GizmoViewcube.js
var React54 = __toESM(require_react());
var colors2 = {
  bg: "#f0f0f0",
  hover: "#999",
  text: "black",
  stroke: "black"
};
var defaultFaces = ["Right", "Left", "Top", "Bottom", "Front", "Back"];
var makePositionVector = (xyz) => new Vector3(...xyz).multiplyScalar(0.38);
var corners = [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]].map(makePositionVector);
var cornerDimensions = [0.25, 0.25, 0.25];
var edges = [[1, 1, 0], [1, 0, 1], [1, 0, -1], [1, -1, 0], [0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1], [-1, 1, 0], [-1, 0, 1], [-1, 0, -1], [-1, -1, 0]].map(makePositionVector);
var edgeDimensions = edges.map((edge) => edge.toArray().map((axis) => axis == 0 ? 0.5 : 0.25));
var FaceMaterial = ({
  hover,
  index,
  font = "20px Inter var, Arial, sans-serif",
  faces = defaultFaces,
  color = colors2.bg,
  hoverColor = colors2.hover,
  textColor = colors2.text,
  strokeColor = colors2.stroke,
  opacity = 1
}) => {
  const gl = useThree((state) => state.gl);
  const texture = React54.useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = 128;
    canvas.height = 128;
    const context10 = canvas.getContext("2d");
    context10.fillStyle = color;
    context10.fillRect(0, 0, canvas.width, canvas.height);
    context10.strokeStyle = strokeColor;
    context10.strokeRect(0, 0, canvas.width, canvas.height);
    context10.font = font;
    context10.textAlign = "center";
    context10.fillStyle = textColor;
    context10.fillText(faces[index].toUpperCase(), 64, 76);
    return new CanvasTexture(canvas);
  }, [index, faces, font, color, textColor, strokeColor]);
  return React54.createElement("meshLambertMaterial", {
    map: texture,
    "map-anisotropy": gl.capabilities.getMaxAnisotropy() || 1,
    attach: `material-${index}`,
    color: hover ? hoverColor : "white",
    transparent: true,
    opacity
  });
};
var FaceCube = (props) => {
  const {
    tweenCamera
  } = useGizmoContext();
  const [hover, setHover] = React54.useState(null);
  const handlePointerOut = (e2) => {
    e2.stopPropagation();
    setHover(null);
  };
  const handleClick = (e2) => {
    e2.stopPropagation();
    tweenCamera(e2.face.normal);
  };
  const handlePointerMove = (e2) => {
    e2.stopPropagation();
    setHover(Math.floor(e2.faceIndex / 2));
  };
  return React54.createElement("mesh", {
    onPointerOut: handlePointerOut,
    onPointerMove: handlePointerMove,
    onClick: props.onClick || handleClick
  }, [...Array(6)].map((_, index) => React54.createElement(FaceMaterial, _extends({
    key: index,
    index,
    hover: hover === index
  }, props))), React54.createElement("boxGeometry", null));
};
var EdgeCube = ({
  onClick,
  dimensions,
  position: position2,
  hoverColor = colors2.hover
}) => {
  const {
    tweenCamera
  } = useGizmoContext();
  const [hover, setHover] = React54.useState(false);
  const handlePointerOut = (e2) => {
    e2.stopPropagation();
    setHover(false);
  };
  const handlePointerOver = (e2) => {
    e2.stopPropagation();
    setHover(true);
  };
  const handleClick = (e2) => {
    e2.stopPropagation();
    tweenCamera(position2);
  };
  return React54.createElement("mesh", {
    scale: 1.01,
    position: position2,
    onPointerOver: handlePointerOver,
    onPointerOut: handlePointerOut,
    onClick: onClick || handleClick
  }, React54.createElement("meshBasicMaterial", {
    color: hover ? hoverColor : "white",
    transparent: true,
    opacity: 0.6,
    visible: hover
  }), React54.createElement("boxGeometry", {
    args: dimensions
  }));
};
var GizmoViewcube = (props) => {
  return React54.createElement("group", {
    scale: [60, 60, 60]
  }, React54.createElement(FaceCube, props), edges.map((edge, index) => React54.createElement(EdgeCube, _extends({
    key: index,
    position: edge,
    dimensions: edgeDimensions[index]
  }, props))), corners.map((corner, index) => React54.createElement(EdgeCube, _extends({
    key: index,
    position: corner,
    dimensions: cornerDimensions
  }, props))), React54.createElement("ambientLight", {
    intensity: 0.5
  }), React54.createElement("pointLight", {
    position: [10, 10, 10],
    intensity: 0.5
  }));
};

// node_modules/@react-three/drei/core/GizmoViewport.js
var React55 = __toESM(require_react());
function Axis({
  scale: scale2 = [0.8, 0.05, 0.05],
  color,
  rotation: rotation2
}) {
  return React55.createElement("group", {
    rotation: rotation2
  }, React55.createElement("mesh", {
    position: [0.4, 0, 0]
  }, React55.createElement("boxGeometry", {
    args: scale2
  }), React55.createElement("meshBasicMaterial", {
    color,
    toneMapped: false
  })));
}
function AxisHead({
  onClick,
  font,
  disabled,
  arcStyle,
  label,
  labelColor,
  axisHeadScale = 1,
  ...props
}) {
  const gl = useThree((state) => state.gl);
  const texture = React55.useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = 64;
    canvas.height = 64;
    const context10 = canvas.getContext("2d");
    context10.beginPath();
    context10.arc(32, 32, 16, 0, 2 * Math.PI);
    context10.closePath();
    context10.fillStyle = arcStyle;
    context10.fill();
    if (label) {
      context10.font = font;
      context10.textAlign = "center";
      context10.fillStyle = labelColor;
      context10.fillText(label, 32, 41);
    }
    return new CanvasTexture(canvas);
  }, [arcStyle, label, labelColor, font]);
  const [active, setActive] = React55.useState(false);
  const scale2 = (label ? 1 : 0.75) * (active ? 1.2 : 1) * axisHeadScale;
  const handlePointerOver = (e2) => {
    e2.stopPropagation();
    setActive(true);
  };
  const handlePointerOut = (e2) => {
    e2.stopPropagation();
    setActive(false);
  };
  return React55.createElement("sprite", _extends({
    scale: scale2,
    onPointerOver: !disabled ? handlePointerOver : void 0,
    onPointerOut: !disabled ? onClick || handlePointerOut : void 0
  }, props), React55.createElement("spriteMaterial", {
    map: texture,
    "map-anisotropy": gl.capabilities.getMaxAnisotropy() || 1,
    alphaTest: 0.3,
    opacity: label ? 1 : 0.75,
    toneMapped: false
  }));
}
var GizmoViewport = ({
  hideNegativeAxes,
  hideAxisHeads,
  disabled,
  font = "18px Inter var, Arial, sans-serif",
  axisColors = ["#ff2060", "#20df80", "#2080ff"],
  axisHeadScale = 1,
  axisScale,
  labels = ["X", "Y", "Z"],
  labelColor = "#000",
  onClick,
  ...props
}) => {
  const [colorX, colorY, colorZ] = axisColors;
  const {
    tweenCamera
  } = useGizmoContext();
  const axisHeadProps = {
    font,
    disabled,
    labelColor,
    onClick,
    axisHeadScale,
    onPointerDown: !disabled ? (e2) => {
      tweenCamera(e2.object.position);
      e2.stopPropagation();
    } : void 0
  };
  return React55.createElement("group", _extends({
    scale: 40
  }, props), React55.createElement(Axis, {
    color: colorX,
    rotation: [0, 0, 0],
    scale: axisScale
  }), React55.createElement(Axis, {
    color: colorY,
    rotation: [0, 0, Math.PI / 2],
    scale: axisScale
  }), React55.createElement(Axis, {
    color: colorZ,
    rotation: [0, -Math.PI / 2, 0],
    scale: axisScale
  }), !hideAxisHeads && React55.createElement(React55.Fragment, null, React55.createElement(AxisHead, _extends({
    arcStyle: colorX,
    position: [1, 0, 0],
    label: labels[0]
  }, axisHeadProps)), React55.createElement(AxisHead, _extends({
    arcStyle: colorY,
    position: [0, 1, 0],
    label: labels[1]
  }, axisHeadProps)), React55.createElement(AxisHead, _extends({
    arcStyle: colorZ,
    position: [0, 0, 1],
    label: labels[2]
  }, axisHeadProps)), !hideNegativeAxes && React55.createElement(React55.Fragment, null, React55.createElement(AxisHead, _extends({
    arcStyle: colorX,
    position: [-1, 0, 0]
  }, axisHeadProps)), React55.createElement(AxisHead, _extends({
    arcStyle: colorY,
    position: [0, -1, 0]
  }, axisHeadProps)), React55.createElement(AxisHead, _extends({
    arcStyle: colorZ,
    position: [0, 0, -1]
  }, axisHeadProps)))), React55.createElement("ambientLight", {
    intensity: 0.5
  }), React55.createElement("pointLight", {
    position: [10, 10, 10],
    intensity: 0.5
  }));
};

// node_modules/@react-three/drei/core/Grid.js
var React56 = __toESM(require_react());
var GridMaterial = shaderMaterial(
  {
    cellSize: 0.5,
    sectionSize: 1,
    fadeDistance: 100,
    fadeStrength: 1,
    cellThickness: 0.5,
    sectionThickness: 1,
    cellColor: new Color(),
    sectionColor: new Color(),
    infiniteGrid: false,
    followCamera: false
  },
  /* glsl */
  `
    varying vec3 worldPosition;
    uniform float fadeDistance;
    uniform bool infiniteGrid;
    uniform bool followCamera;

    void main() {
      worldPosition = position.xzy;
      if (infiniteGrid) worldPosition *= 1.0 + fadeDistance;
      if (followCamera) worldPosition.xz +=cameraPosition.xz;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(worldPosition, 1.0);
    }
  `,
  /* glsl */
  `
    varying vec3 worldPosition;
    uniform float cellSize;
    uniform float sectionSize;
    uniform vec3 cellColor;
    uniform vec3 sectionColor;
    uniform float fadeDistance;
    uniform float fadeStrength;
    uniform float cellThickness;
    uniform float sectionThickness;

    float getGrid(float size, float thickness) {
      vec2 r = worldPosition.xz / size;
      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
      float line = min(grid.x, grid.y) + 1. - thickness;
      return 1.0 - min(line, 1.);
    }

    void main() {
      float g1 = getGrid(cellSize, cellThickness);
      float g2 = getGrid(sectionSize, sectionThickness);

      float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / fadeDistance, 1.);
      vec3 color = mix(cellColor, sectionColor, min(1.,sectionThickness * g2));

      gl_FragColor = vec4(color, (g1 + g2) * pow(d,fadeStrength));
      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
      if (gl_FragColor.a <= 0.0) discard;

      #include <tonemapping_fragment>
      #include <encodings_fragment>
    }
  `
);
var Grid = React56.forwardRef(({
  args,
  cellColor = "#000000",
  sectionColor = "#2080ff",
  cellSize = 0.5,
  sectionSize = 1,
  followCamera = false,
  infiniteGrid = false,
  fadeDistance = 100,
  fadeStrength = 1,
  cellThickness = 0.5,
  sectionThickness = 1,
  side = BackSide,
  ...props
}, fRef) => {
  extend({
    GridMaterial
  });
  const uniforms1 = {
    cellSize,
    sectionSize,
    cellColor,
    sectionColor,
    cellThickness,
    sectionThickness
  };
  const uniforms2 = {
    fadeDistance,
    fadeStrength,
    infiniteGrid,
    followCamera
  };
  return React56.createElement("mesh", _extends({
    ref: fRef,
    frustumCulled: false
  }, props), React56.createElement("gridMaterial", _extends({
    transparent: true,
    "extensions-derivatives": true,
    side
  }, uniforms1, uniforms2)), React56.createElement("planeGeometry", {
    args
  }));
});

// node_modules/@react-three/drei/core/useCubeTexture.js
function useCubeTexture(files, {
  path
}) {
  const [cubeTexture] = useLoader(
    // @ts-ignore
    CubeTextureLoader,
    [files],
    (loader2) => loader2.setPath(path)
  );
  return cubeTexture;
}
useCubeTexture.preload = (files, {
  path
}) => useLoader.preload(
  // @ts-ignore
  CubeTextureLoader,
  [files],
  (loader2) => loader2.setPath(path)
);

// node_modules/@react-three/drei/core/useFBX.js
function useFBX(path) {
  return useLoader(FBXLoader, path);
}
useFBX.preload = (path) => useLoader.preload(FBXLoader, path);
useFBX.clear = (input) => useLoader.clear(FBXLoader, input);

// node_modules/@react-three/drei/core/useKTX2.js
var import_react15 = __toESM(require_react());
var cdn = "https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master";
function useKTX2(input, basisPath = `${cdn}/basis/`) {
  const gl = useThree((state) => state.gl);
  const textures = useLoader(KTX2Loader, IsObject(input) ? Object.values(input) : input, (loader2) => {
    loader2.detectSupport(gl);
    loader2.setTranscoderPath(basisPath);
  });
  (0, import_react15.useEffect)(() => {
    const array = Array.isArray(textures) ? textures : [textures];
    array.forEach(gl.initTexture);
  }, [gl, textures]);
  if (IsObject(input)) {
    const keys = Object.keys(input);
    const keyed = {};
    keys.forEach((key) => Object.assign(keyed, {
      [key]: textures[keys.indexOf(key)]
    }));
    return keyed;
  } else {
    return textures;
  }
}
useKTX2.preload = (url, basisPath = `${cdn}/basis/`) => useLoader.preload(KTX2Loader, url, (loader2) => {
  loader2.setTranscoderPath(basisPath);
});
useKTX2.clear = (input) => useLoader.clear(KTX2Loader, input);

// node_modules/@react-three/drei/core/Stats.js
var React58 = __toESM(require_react());
var import_stats = __toESM(require_stats_min());

// node_modules/@react-three/drei/helpers/useEffectfulState.js
var React57 = __toESM(require_react());
function call3(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref != null)
    ref.current = value;
}
function useEffectfulState(fn, deps = [], cb) {
  const [state, set] = React57.useState();
  React57.useLayoutEffect(() => {
    const value = fn();
    set(value);
    call3(cb, value);
    return () => call3(cb, null);
  }, deps);
  return state;
}

// node_modules/@react-three/drei/core/Stats.js
function Stats({
  showPanel = 0,
  className,
  parent
}) {
  const stats = useEffectfulState(() => new import_stats.default(), []);
  React58.useEffect(() => {
    if (stats) {
      const node = parent && parent.current || document.body;
      stats.showPanel(showPanel);
      node == null ? void 0 : node.appendChild(stats.dom);
      if (className)
        stats.dom.classList.add(...className.split(" ").filter((cls) => cls));
      const begin = addEffect(() => stats.begin());
      const end = addAfterEffect(() => stats.end());
      return () => {
        node == null ? void 0 : node.removeChild(stats.dom);
        begin();
        end();
      };
    }
  }, [parent, stats, className, showPanel]);
  return null;
}

// node_modules/@react-three/drei/core/useDepthBuffer.js
var React59 = __toESM(require_react());
function useDepthBuffer({
  size = 256,
  frames = Infinity
} = {}) {
  const dpr = useThree((state) => state.viewport.dpr);
  const {
    width,
    height
  } = useThree((state) => state.size);
  const w = size || width * dpr;
  const h = size || height * dpr;
  const depthConfig = React59.useMemo(() => {
    const depthTexture = new DepthTexture(w, h);
    depthTexture.format = DepthFormat;
    depthTexture.type = UnsignedShortType;
    return {
      depthTexture
    };
  }, [w, h]);
  let count = 0;
  const depthFBO = useFBO(w, h, depthConfig);
  useFrame((state) => {
    if (frames === Infinity || count < frames) {
      state.gl.setRenderTarget(depthFBO);
      state.gl.render(state.scene, state.camera);
      state.gl.setRenderTarget(null);
      count++;
    }
  });
  return depthFBO.depthTexture;
}

// node_modules/@react-three/drei/core/useAspect.js
function useAspect(width, height, factor = 1) {
  const v4 = useThree((state) => state.viewport);
  const adaptedHeight = height * (v4.aspect > width / height ? v4.width / width : v4.height / height);
  const adaptedWidth = width * (v4.aspect > width / height ? v4.width / width : v4.height / height);
  return [adaptedWidth * factor, adaptedHeight * factor, 1];
}

// node_modules/@react-three/drei/core/useCamera.js
var React60 = __toESM(require_react());
function useCamera(camera, props) {
  const pointer = useThree((state) => state.pointer);
  const [raycast2] = React60.useState(() => {
    const raycaster = new Raycaster();
    if (props)
      applyProps(raycaster, props, {});
    return function(_, intersects) {
      raycaster.setFromCamera(pointer, camera instanceof Camera ? camera : camera.current);
      const rc = this.constructor.prototype.raycast.bind(this);
      if (rc)
        rc(raycaster, intersects);
    };
  });
  return raycast2;
}

// node_modules/detect-gpu/dist/detect-gpu.esm.js
function e(e2, t2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(o2, a3) {
    function i3(e3) {
      try {
        d2(r2.next(e3));
      } catch (e4) {
        a3(e4);
      }
    }
    function c6(e3) {
      try {
        d2(r2.throw(e3));
      } catch (e4) {
        a3(e4);
      }
    }
    function d2(e3) {
      var t3;
      e3.done ? o2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
        e4(t3);
      })).then(i3, c6);
    }
    d2((r2 = r2.apply(e2, t2 || [])).next());
  });
}
var t = ["geforce 320m", "geforce 8600", "geforce 8600m gt", "geforce 8800 gs", "geforce 8800 gt", "geforce 9400", "geforce 9400m g", "geforce 9400m", "geforce 9600m gt", "geforce 9600m", "geforce fx go5200", "geforce gt 120", "geforce gt 130", "geforce gt 330m", "geforce gtx 285", "google swiftshader", "intel g41", "intel g45", "intel gma 4500mhd", "intel gma x3100", "intel hd 3000", "intel q45", "legacy", "mali-2", "mali-3", "mali-4", "quadro fx 1500", "quadro fx 4", "quadro fx 5", "radeon hd 2400", "radeon hd 2600", "radeon hd 4670", "radeon hd 4850", "radeon hd 4870", "radeon hd 5670", "radeon hd 5750", "radeon hd 6290", "radeon hd 6300", "radeon hd 6310", "radeon hd 6320", "radeon hd 6490m", "radeon hd 6630m", "radeon hd 6750m", "radeon hd 6770m", "radeon hd 6970m", "sgx 543", "sgx543"];
function n(e2) {
  return e2 = e2.toLowerCase().replace(/.*angle ?\((.+)\)(?: on vulkan [0-9.]+)?$/i, "$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g, "").replace(/(?:vulkan|opengl) \d+\.\d+(?:\.\d+)?(?: \((.*)\))?/, "$1");
}
var r = "undefined" == typeof window;
var o = (() => {
  if (r)
    return;
  const { userAgent: e2, platform: t2, maxTouchPoints: n2 } = window.navigator, o2 = /(iphone|ipod|ipad)/i.test(e2), a3 = "iPad" === t2 || "MacIntel" === t2 && n2 > 0 && !window.MSStream;
  return { isIpad: a3, isMobile: /android/i.test(e2) || o2 || a3, isSafari12: /Version\/12.+Safari/.test(e2) };
})();
function a2(e2, t2, n2) {
  if (!n2)
    return [t2];
  const r2 = function(e3) {
    const t3 = "\n    precision highp float;\n    attribute vec3 aPosition;\n    varying float vvv;\n    void main() {\n      vvv = 0.31622776601683794;\n      gl_Position = vec4(aPosition, 1.0);\n    }\n  ", n3 = "\n    precision highp float;\n    varying float vvv;\n    void main() {\n      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n      enc = fract(enc);\n      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n      gl_FragColor = enc;\n    }\n  ", r3 = e3.createShader(35633), o2 = e3.createShader(35632), a4 = e3.createProgram();
    if (!(o2 && r3 && a4))
      return;
    e3.shaderSource(r3, t3), e3.shaderSource(o2, n3), e3.compileShader(r3), e3.compileShader(o2), e3.attachShader(a4, r3), e3.attachShader(a4, o2), e3.linkProgram(a4), e3.detachShader(a4, r3), e3.detachShader(a4, o2), e3.deleteShader(r3), e3.deleteShader(o2), e3.useProgram(a4);
    const i4 = e3.createBuffer();
    e3.bindBuffer(34962, i4), e3.bufferData(34962, new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 35044);
    const c7 = e3.getAttribLocation(a4, "aPosition");
    e3.vertexAttribPointer(c7, 3, 5126, false, 0, 0), e3.enableVertexAttribArray(c7), e3.clearColor(1, 1, 1, 1), e3.clear(16384), e3.viewport(0, 0, 1, 1), e3.drawArrays(4, 0, 3);
    const d3 = new Uint8Array(4);
    return e3.readPixels(0, 0, 1, 1, 6408, 5121, d3), e3.deleteProgram(a4), e3.deleteBuffer(i4), d3.join("");
  }(e2), a3 = "801621810", i3 = "8016218135", c6 = "80162181161", d2 = (null == o ? void 0 : o.isIpad) ? [["a7", c6, 12], ["a8", i3, 15], ["a8x", i3, 15], ["a9", i3, 15], ["a9x", i3, 15], ["a10", i3, 15], ["a10x", i3, 15], ["a12", a3, 15], ["a12x", a3, 15], ["a12z", a3, 15], ["a14", a3, 15], ["m1", a3, 15]] : [["a7", c6, 12], ["a8", i3, 12], ["a9", i3, 15], ["a10", i3, 15], ["a11", a3, 15], ["a12", a3, 15], ["a13", a3, 15], ["a14", a3, 15]];
  let l2;
  "80162181255" === r2 ? l2 = d2.filter(([, , e3]) => e3 >= 14) : (l2 = d2.filter(([, e3]) => e3 === r2), l2.length || (l2 = d2));
  return l2.map(([e3]) => `apple ${e3} gpu`);
}
var i = class extends Error {
  constructor(e2) {
    super(e2), Object.setPrototypeOf(this, new.target.prototype);
  }
};
var c = [];
var d = [];
function l(e2, t2) {
  if (e2 === t2)
    return 0;
  const n2 = e2;
  e2.length > t2.length && (e2 = t2, t2 = n2);
  let r2 = e2.length, o2 = t2.length;
  for (; r2 > 0 && e2.charCodeAt(~-r2) === t2.charCodeAt(~-o2); )
    r2--, o2--;
  let a3, i3 = 0;
  for (; i3 < r2 && e2.charCodeAt(i3) === t2.charCodeAt(i3); )
    i3++;
  if (r2 -= i3, o2 -= i3, 0 === r2)
    return o2;
  let l2, s2, f2 = 0, u = 0, h = 0;
  for (; u < r2; )
    d[u] = e2.charCodeAt(i3 + u), c[u] = ++u;
  for (; h < o2; )
    for (a3 = t2.charCodeAt(i3 + h), l2 = h++, f2 = h, u = 0; u < r2; u++)
      s2 = a3 === d[u] ? l2 : l2 + 1, l2 = c[u], f2 = c[u] = l2 > f2 ? s2 > f2 ? f2 + 1 : s2 : s2 > l2 ? l2 + 1 : s2;
  return f2;
}
function s(e2) {
  return null != e2;
}
var f = ({ mobileTiers: c6 = [0, 15, 30, 60], desktopTiers: d2 = [0, 15, 30, 60], override: f2 = {}, glContext: u, failIfMajorPerformanceCaveat: h = false, benchmarksURL: g = "https://unpkg.com/detect-gpu@5.0.37/dist/benchmarks" } = {}) => e(void 0, void 0, void 0, function* () {
  const p = {};
  if (r)
    return { tier: 0, type: "SSR" };
  const { isIpad: m = !!(null == o ? void 0 : o.isIpad), isMobile: v4 = !!(null == o ? void 0 : o.isMobile), screenSize: w = window.screen, loadBenchmarks: x = (t2) => e(void 0, void 0, void 0, function* () {
    const e2 = yield fetch(`${g}/${t2}`).then((e3) => e3.json());
    if (parseInt(e2.shift().split(".")[0], 10) < 4)
      throw new i("Detect GPU benchmark data is out of date. Please update to version 4x");
    return e2;
  }) } = f2;
  let { renderer: A } = f2;
  const P = (e2, t2, n2, r2, o2) => ({ device: o2, fps: r2, gpu: n2, isMobile: v4, tier: e2, type: t2 });
  let b, S = "";
  if (A)
    A = n(A), b = [A];
  else {
    const e2 = u || function(e3, t3 = false) {
      const n2 = { alpha: false, antialias: false, depth: false, failIfMajorPerformanceCaveat: t3, powerPreference: "high-performance", stencil: false };
      e3 && delete n2.powerPreference;
      const r2 = window.document.createElement("canvas"), o2 = r2.getContext("webgl", n2) || r2.getContext("experimental-webgl", n2);
      return null != o2 ? o2 : void 0;
    }(null == o ? void 0 : o.isSafari12, h);
    if (!e2)
      return P(0, "WEBGL_UNSUPPORTED");
    const t2 = e2.getExtension("WEBGL_debug_renderer_info");
    if (t2 && (A = e2.getParameter(t2.UNMASKED_RENDERER_WEBGL)), !A)
      return P(1, "FALLBACK");
    S = A, A = n(A), b = function(e3, t3, n2) {
      return "apple gpu" === t3 ? a2(e3, t3, n2) : [t3];
    }(e2, A, v4);
  }
  const y = (yield Promise.all(b.map(function(t2) {
    var n2;
    return e(this, void 0, void 0, function* () {
      const e2 = ((e3) => {
        const t3 = v4 ? ["adreno", "apple", "mali-t", "mali", "nvidia", "powervr", "samsung"] : ["intel", "apple", "amd", "radeon", "nvidia", "geforce"];
        for (const n3 of t3)
          if (e3.includes(n3))
            return n3;
      })(t2);
      if (!e2)
        return;
      const r2 = `${v4 ? "m" : "d"}-${e2}${m ? "-ipad" : ""}.json`, o2 = p[r2] = null !== (n2 = p[r2]) && void 0 !== n2 ? n2 : x(r2);
      let a3;
      try {
        a3 = yield o2;
      } catch (e3) {
        if (e3 instanceof i)
          throw e3;
        return;
      }
      const c7 = function(e3) {
        var t3;
        const n3 = (e3 = e3.replace(/\([^)]+\)/, "")).match(/\d+/) || e3.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);
        return null !== (t3 = null == n3 ? void 0 : n3.join("").replace(/\W|amd/g, "")) && void 0 !== t3 ? t3 : "";
      }(t2);
      let d3 = a3.filter(([, e3]) => e3 === c7);
      d3.length || (d3 = a3.filter(([e3]) => e3.includes(t2)));
      const s2 = d3.length;
      if (0 === s2)
        return;
      const f3 = t2.split(/[.,()\[\]/\s]/g).sort().filter((e3, t3, n3) => 0 === t3 || e3 !== n3[t3 - 1]).join(" ");
      let u2, [h2, , , , g2] = s2 > 1 ? d3.map((e3) => [e3, l(f3, e3[2])]).sort(([, e3], [, t3]) => e3 - t3)[0][0] : d3[0], A2 = Number.MAX_VALUE;
      const { devicePixelRatio: P2 } = window, b2 = w.width * P2 * w.height * P2;
      for (const e3 of g2) {
        const [t3, n3] = e3, r3 = t3 * n3, o3 = Math.abs(b2 - r3);
        o3 < A2 && (A2 = o3, u2 = e3);
      }
      if (!u2)
        return;
      const [, , S2, y2] = u2;
      return [A2, S2, h2, y2];
    });
  }))).filter(s).sort(([e2 = Number.MAX_VALUE, t2], [n2 = Number.MAX_VALUE, r2]) => e2 === n2 ? t2 - r2 : e2 - n2);
  if (!y.length) {
    const e2 = t.find((e3) => A.includes(e3));
    return e2 ? P(0, "BLOCKLISTED", e2) : P(1, "FALLBACK", `${A} (${S})`);
  }
  const [, C, E, L] = y[0];
  if (-1 === C)
    return P(0, "BLOCKLISTED", E, C, L);
  const M = v4 ? c6 : d2;
  let $ = 0;
  for (let e2 = 0; e2 < M.length; e2++)
    C >= M[e2] && ($ = e2);
  return P($, "BENCHMARK", E, C, L);
});

// node_modules/@react-three/drei/core/useDetectGPU.js
var useDetectGPU = (props) => suspend(() => f(props), ["useDetectGPU"]);

// node_modules/@react-three/drei/core/useHelper.js
var React61 = __toESM(require_react());
function useHelper(object3D, helperConstructor, ...args) {
  const helper = React61.useRef();
  const scene = useThree((state) => state.scene);
  React61.useLayoutEffect(() => {
    let currentHelper = void 0;
    if (object3D && object3D != null && object3D.current && helperConstructor) {
      helper.current = currentHelper = new helperConstructor(object3D.current, ...args);
    }
    if (currentHelper) {
      scene.add(currentHelper);
      return () => {
        helper.current = void 0;
        scene.remove(currentHelper);
        currentHelper.dispose == null ? void 0 : currentHelper.dispose();
      };
    }
  }, [scene, helperConstructor, object3D, ...args]);
  useFrame(() => {
    var _helper$current;
    return void ((_helper$current = helper.current) == null ? void 0 : _helper$current.update == null ? void 0 : _helper$current.update());
  });
  return helper;
}

// node_modules/@react-three/drei/core/useBVH.js
var React62 = __toESM(require_react());

// node_modules/three-mesh-bvh/src/core/Constants.js
var CENTER = 0;
var AVERAGE = 1;
var SAH = 2;
var CONTAINED = 2;
var TRIANGLE_INTERSECT_COST = 1.25;
var TRAVERSAL_COST = 1;
var BYTES_PER_NODE = 6 * 4 + 4 + 4;
var IS_LEAFNODE_FLAG = 65535;
var FLOAT32_EPSILON = Math.pow(2, -24);
var SKIP_GENERATION = Symbol("SKIP_GENERATION");

// node_modules/three-mesh-bvh/src/core/build/geometryUtils.js
function getVertexCount(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount(geo) {
  return getVertexCount(geo) / 3;
}
function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i3 = 0; i3 < vertexCount; i3++) {
      index[i3] = i3;
    }
  }
}
function getFullGeometryRange(geo) {
  const triCount = getTriCount(geo);
  const drawRange = geo.drawRange;
  const start2 = drawRange.start / 3;
  const end = (drawRange.start + drawRange.count) / 3;
  const offset = Math.max(0, start2);
  const count = Math.min(triCount, end) - offset;
  return [{
    offset: Math.floor(offset),
    count: Math.floor(count)
  }];
}
function getRootIndexRanges(geo) {
  if (!geo.groups || !geo.groups.length) {
    return getFullGeometryRange(geo);
  }
  const ranges = [];
  const rangeBoundaries = /* @__PURE__ */ new Set();
  const drawRange = geo.drawRange;
  const drawRangeStart = drawRange.start / 3;
  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;
  for (const group of geo.groups) {
    const groupStart = group.start / 3;
    const groupEnd = (group.start + group.count) / 3;
    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));
    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a3, b) => a3 - b);
  for (let i3 = 0; i3 < sortedBoundaries.length - 1; i3++) {
    const start2 = sortedBoundaries[i3];
    const end = sortedBoundaries[i3 + 1];
    ranges.push({
      offset: Math.floor(start2),
      count: Math.floor(end - start2)
    });
  }
  return ranges;
}
function hasGroupGaps(geometry) {
  if (geometry.groups.length === 0) {
    return false;
  }
  const vertexCount = getTriCount(geometry);
  const groups = getRootIndexRanges(geometry).sort((a3, b) => a3.offset - b.offset);
  const finalGroup = groups[groups.length - 1];
  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);
  let total = 0;
  groups.forEach(({ count }) => total += count);
  return vertexCount !== total;
}

// node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js
function arrayToBox(nodeIndex32, array, target2) {
  target2.min.x = array[nodeIndex32];
  target2.min.y = array[nodeIndex32 + 1];
  target2.min.z = array[nodeIndex32 + 2];
  target2.max.x = array[nodeIndex32 + 3];
  target2.max.y = array[nodeIndex32 + 4];
  target2.max.z = array[nodeIndex32 + 5];
  return target2;
}
function makeEmptyBounds(target2) {
  target2[0] = target2[1] = target2[2] = Infinity;
  target2[3] = target2[4] = target2[5] = -Infinity;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i3 = 0; i3 < 3; i3++) {
    const dist = bounds[i3 + 3] - bounds[i3];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i3;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target2) {
  target2.set(source);
}
function unionBounds(a3, b, target2) {
  let aVal, bVal;
  for (let d2 = 0; d2 < 3; d2++) {
    const d3 = d2 + 3;
    aVal = a3[d2];
    bVal = b[d2];
    target2[d2] = aVal < bVal ? aVal : bVal;
    aVal = a3[d3];
    bVal = b[d3];
    target2[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d2 = 0; d2 < 3; d2++) {
    const tCenter = triangleBounds[startIndex + 2 * d2];
    const tHalf = triangleBounds[startIndex + 2 * d2 + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d2]) {
      bounds[d2] = tMin;
    }
    if (tMax > bounds[d2 + 3]) {
      bounds[d2 + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}

// node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js
function getBounds(triangleBounds, offset, count, target2, centroidTarget = null) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  const includeCentroid = centroidTarget !== null;
  for (let i3 = offset * 6, end = (offset + count) * 6; i3 < end; i3 += 6) {
    const cx = triangleBounds[i3 + 0];
    const hx = triangleBounds[i3 + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx)
      minx = lx;
    if (rx > maxx)
      maxx = rx;
    if (includeCentroid && cx < cminx)
      cminx = cx;
    if (includeCentroid && cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i3 + 2];
    const hy = triangleBounds[i3 + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny)
      miny = ly;
    if (ry > maxy)
      maxy = ry;
    if (includeCentroid && cy < cminy)
      cminy = cy;
    if (includeCentroid && cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i3 + 4];
    const hz = triangleBounds[i3 + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz)
      minz = lz;
    if (rz > maxz)
      maxz = rz;
    if (includeCentroid && cz < cminz)
      cminz = cz;
    if (includeCentroid && cz > cmaxz)
      cmaxz = cz;
  }
  target2[0] = minx;
  target2[1] = miny;
  target2[2] = minz;
  target2[3] = maxx;
  target2[4] = maxy;
  target2[5] = maxz;
  if (includeCentroid) {
    centroidTarget[0] = cminx;
    centroidTarget[1] = cminy;
    centroidTarget[2] = cminz;
    centroidTarget[3] = cmaxx;
    centroidTarget[4] = cmaxy;
    centroidTarget[5] = cmaxz;
  }
}
function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i3 = offset * 6, end = (offset + count) * 6; i3 < end; i3 += 6) {
    const cx = triangleBounds[i3 + 0];
    if (cx < cminx)
      cminx = cx;
    if (cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i3 + 2];
    if (cy < cminy)
      cminy = cy;
    if (cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i3 + 4];
    if (cz < cminz)
      cminz = cz;
    if (cz > cmaxz)
      cmaxz = cz;
  }
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function computeTriangleBounds(geo, fullBounds) {
  makeEmptyBounds(fullBounds);
  const posAttr = geo.attributes.position;
  const index = geo.index ? geo.index.array : null;
  const triCount = getTriCount(geo);
  const triangleBounds = new Float32Array(triCount * 6);
  const normalized = posAttr.normalized;
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  for (let tri = 0; tri < triCount; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    let ai = tri3 + 0;
    let bi = tri3 + 1;
    let ci = tri3 + 2;
    if (index) {
      ai = index[ai];
      bi = index[bi];
      ci = index[ci];
    }
    if (!normalized) {
      ai = ai * stride + bufferOffset;
      bi = bi * stride + bufferOffset;
      ci = ci * stride + bufferOffset;
    }
    for (let el = 0; el < 3; el++) {
      let a3, b, c6;
      if (normalized) {
        a3 = posAttr[getters[el]](ai);
        b = posAttr[getters[el]](bi);
        c6 = posAttr[getters[el]](ci);
      } else {
        a3 = posArr[ai + el];
        b = posArr[bi + el];
        c6 = posArr[ci + el];
      }
      let min = a3;
      if (b < min)
        min = b;
      if (c6 < min)
        min = c6;
      let max = a3;
      if (b > max)
        max = b;
      if (c6 > max)
        max = c6;
      const halfExtents = (max - min) / 2;
      const el2 = el * 2;
      triangleBounds[tri6 + el2 + 0] = min + halfExtents;
      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
      if (min < fullBounds[el])
        fullBounds[el] = min;
      if (max > fullBounds[el + 3])
        fullBounds[el + 3] = max;
    }
  }
  return triangleBounds;
}

// node_modules/three-mesh-bvh/src/core/build/splitUtils.js
var BIN_COUNT = 32;
var binsSort = (a3, b) => a3.candidate - b.candidate;
var sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
var leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a3 = 0; a3 < 3; a3++) {
      const axisLeft = centroidBoundingData[a3];
      const axisRight = centroidBoundingData[a3 + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b = 0;
        for (let c6 = cStart; c6 < cEnd; c6 += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c6 + 2 * a3];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d2 = 0; d2 < 3; d2++) {
            rightCacheBounds[d2] = Infinity;
            rightCacheBounds[d2 + 3] = -Infinity;
            leftCacheBounds[d2] = Infinity;
            leftCacheBounds[d2 + 3] = -Infinity;
            bounds[d2] = Infinity;
            bounds[d2 + 3] = -Infinity;
          }
          expandByTriangleBounds(c6, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c6 = cStart; c6 < cEnd; c6 += 6) {
          const center = triangleBounds[c6 + 2 * a3];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c6, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c6, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds2 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a3;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i3 = 0; i3 < BIN_COUNT; i3++) {
          const bin = sahBins[i3];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i3 * binWidth;
          const bounds = bin.bounds;
          for (let d2 = 0; d2 < 3; d2++) {
            bounds[d2] = Infinity;
            bounds[d2 + 3] = -Infinity;
          }
        }
        for (let c6 = cStart; c6 < cEnd; c6 += 6) {
          const triCenter = triangleBounds[c6 + 2 * a3];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT)
            binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c6, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i3 = BIN_COUNT - 2; i3 >= 0; i3--) {
          const bin = sahBins[i3];
          const nextBin = sahBins[i3 + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i3 = 0; i3 < BIN_COUNT - 1; i3++) {
          const bin = sahBins[i3];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i3 + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a3;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i3 = offset, end = offset + count; i3 < end; i3++) {
    avg += triangleBounds[i3 * 6 + axis * 2];
  }
  return avg / count;
}

// node_modules/three-mesh-bvh/src/core/MeshBVHNode.js
var MeshBVHNode = class {
  constructor() {
  }
};

// node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js
function partition(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i3 = 0; i3 < 3; i3++) {
        let t0 = index[left * 3 + i3];
        index[left * 3 + i3] = index[right * 3 + i3];
        index[right * 3 + i3] = t0;
      }
      for (let i3 = 0; i3 < 6; i3++) {
        let tb = triangleBounds[left * 6 + i3];
        triangleBounds[left * 6 + i3] = triangleBounds[right * 6 + i3];
        triangleBounds[right * 6 + i3] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js
function partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      let t2 = indirectBuffer[left];
      indirectBuffer[left] = indirectBuffer[right];
      indirectBuffer[right] = t2;
      for (let i3 = 0; i3 < 6; i3++) {
        let tb = triangleBounds[left * 6 + i3];
        triangleBounds[left * 6 + i3] = triangleBounds[right * 6 + i3];
        triangleBounds[right * 6 + i3] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/build/buildTree.js
function generateIndirectBuffer(geometry, useSharedArrayBuffer) {
  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;
  const useUint32 = triCount > 2 ** 16;
  const byteCount = useUint32 ? 4 : 2;
  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);
  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);
  for (let i3 = 0, l2 = indirectBuffer.length; i3 < l2; i3++) {
    indirectBuffer[i3] = i3;
  }
  return indirectBuffer;
}
function buildTree(bvh, options) {
  const geometry = bvh.geometry;
  const indexArray = geometry.index ? geometry.index.array : null;
  const maxDepth = options.maxDepth;
  const verbose = options.verbose;
  const maxLeafTris = options.maxLeafTris;
  const strategy = options.strategy;
  const onProgress = options.onProgress;
  const totalTriangles = getTriCount(geometry);
  const indirectBuffer = bvh._indirectBuffer;
  let reachedMaxDepth = false;
  const fullBounds = new Float32Array(6);
  const cacheCentroidBoundingData = new Float32Array(6);
  const triangleBounds = computeTriangleBounds(geometry, fullBounds);
  const partionFunc = options.indirect ? partition_indirect : partition;
  const roots = [];
  const ranges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);
  if (ranges.length === 1) {
    const range = ranges[0];
    const root = new MeshBVHNode();
    root.boundingData = fullBounds;
    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);
    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
    roots.push(root);
  } else {
    for (let range of ranges) {
      const root = new MeshBVHNode();
      root.boundingData = new Float32Array(6);
      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);
      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
      roots.push(root);
    }
  }
  return roots;
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geometry);
      }
    }
    if (count <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);
    if (split.axis === -1) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);
    if (splitOffset === offset || splitOffset === offset + count) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset;
      const lcount = splitOffset - offset;
      node.left = left;
      left.boundingData = new Float32Array(6);
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count - lcount;
      node.right = right;
      right.boundingData = new Float32Array(6);
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
}
function buildPackedTree(bvh, options) {
  const geometry = bvh.geometry;
  if (options.indirect) {
    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);
    if (hasGroupGaps(geometry) && !options.verbose) {
      console.warn(
        'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
      );
    }
  }
  if (!bvh._indirectBuffer) {
    ensureIndex(geometry, options);
  }
  const roots = buildTree(bvh, options);
  let float32Array;
  let uint32Array;
  let uint16Array;
  const packedRoots = [];
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let i3 = 0; i3 < roots.length; i3++) {
    const root = roots[i3];
    let nodeCount = countNodes(root);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    float32Array = new Float32Array(buffer);
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    populateBuffer(0, root);
    packedRoots.push(buffer);
  }
  bvh._roots = packedRoots;
  return;
  function countNodes(node) {
    if (node.count) {
      return 1;
    } else {
      return 1 + countNodes(node.left) + countNodes(node.right);
    }
  }
  function populateBuffer(byteOffset, node) {
    const stride4Offset = byteOffset / 4;
    const stride2Offset = byteOffset / 2;
    const isLeaf = !!node.count;
    const boundingData = node.boundingData;
    for (let i3 = 0; i3 < 6; i3++) {
      float32Array[stride4Offset + i3] = boundingData[i3];
    }
    if (isLeaf) {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    } else {
      const left = node.left;
      const right = node.right;
      const splitAxis = node.splitAxis;
      let nextUnusedPointer;
      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);
      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      }
      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);
      uint32Array[stride4Offset + 7] = splitAxis;
      return nextUnusedPointer;
    }
  }
}

// node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js
var SeparatingAxisBounds = class {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i3 = 0, l2 = points.length; i3 < l2; i3++) {
      const p = points[i3];
      const val = p[field];
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i3 = 0, l2 = points.length; i3 < l2; i3++) {
      const p = points[i3];
      const val = axis.dot(p);
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
};
SeparatingAxisBounds.prototype.setFromBox = function() {
  const p = new Vector3();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y + boxMax.y * (1 - y);
          p.z = boxMin.z * z + boxMax.z * (1 - z);
          const val = axis.dot(p);
          min = Math.min(val, min);
          max = Math.max(val, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
}();
var areIntersecting = function() {
  const cacheSatBounds = new SeparatingAxisBounds();
  return function areIntersecting2(shape1, shape2) {
    const points1 = shape1.points;
    const satAxes1 = shape1.satAxes;
    const satBounds1 = shape1.satBounds;
    const points2 = shape2.points;
    const satAxes2 = shape2.satAxes;
    const satBounds2 = shape2.satBounds;
    for (let i3 = 0; i3 < 3; i3++) {
      const sb = satBounds1[i3];
      const sa = satAxes1[i3];
      cacheSatBounds.setFromPoints(sa, points2);
      if (sb.isSeparated(cacheSatBounds))
        return false;
    }
    for (let i3 = 0; i3 < 3; i3++) {
      const sb = satBounds2[i3];
      const sa = satAxes2[i3];
      cacheSatBounds.setFromPoints(sa, points1);
      if (sb.isSeparated(cacheSatBounds))
        return false;
    }
  };
}();

// node_modules/three-mesh-bvh/src/math/MathUtilities.js
var closestPointLineToLine = function() {
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const v02 = new Vector3();
  return function closestPointLineToLine2(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v22 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v22);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d2, d22;
    if (denom !== 0) {
      d2 = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d2 = 0;
    }
    d22 = (d0232 + d2 * d3210) / d3232;
    result.x = d2;
    result.y = d22;
  };
}();
var closestPointsSegmentToSegment = function() {
  const paramResult = new Vector2();
  const temp14 = new Vector3();
  const temp23 = new Vector3();
  return function closestPointsSegmentToSegment2(l1, l2, target1, target2) {
    closestPointLineToLine(l1, l2, paramResult);
    let d2 = paramResult.x;
    let d22 = paramResult.y;
    if (d2 >= 0 && d2 <= 1 && d22 >= 0 && d22 <= 1) {
      l1.at(d2, target1);
      l2.at(d22, target2);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d22 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d22 >= 0 && d22 <= 1) {
      if (d2 < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d2 < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d22 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp14;
      const closestPoint2 = temp23;
      l1.closestPointToPoint(p2, true, temp14);
      l2.closestPointToPoint(p, true, temp23);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
}();
var sphereIntersectTriangle = function() {
  const closestPointTemp = new Vector3();
  const projectedPointTemp = new Vector3();
  const planeTemp = new Plane();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle2(sphere, triangle4) {
    const { radius, center } = sphere;
    const { a: a3, b, c: c6 } = triangle4;
    lineTemp.start = a3;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius)
      return true;
    lineTemp.start = a3;
    lineTemp.end = c6;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius)
      return true;
    lineTemp.start = b;
    lineTemp.end = c6;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius)
      return true;
    const plane = triangle4.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle4.containsPoint(pp);
      if (cp)
        return true;
    }
    return false;
  };
}();

// node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js
var ZERO_EPSILON = 1e-15;
function isNearZero(value) {
  return Math.abs(value) < ZERO_EPSILON;
}
var ExtendedTriangle = class extends Triangle {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector3());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere();
    this.plane = new Plane();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere) {
    return sphereIntersectTriangle(sphere, this);
  }
  update() {
    const a3 = this.a;
    const b = this.b;
    const c6 = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a3, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c6);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c6, a3);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a3);
    this.needsUpdate = false;
  }
};
ExtendedTriangle.prototype.closestPointToSegment = function() {
  const point1 = new Vector3();
  const point2 = new Vector3();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start: start2, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i3 = 0; i3 < 3; i3++) {
      const nexti = (i3 + 1) % 3;
      edge.start.copy(points[i3]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
    }
    this.closestPointToPoint(start2, point1);
    distSq = start2.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(start2);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
ExtendedTriangle.prototype.intersectsTriangle = function() {
  const saTri2 = new ExtendedTriangle();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  const dir = new Vector3();
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const tempDir = new Vector3();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  const tempPoint = new Vector3();
  function triIntersectPlane(tri, plane, targetEdge) {
    const points = tri.points;
    let count = 0;
    let startPointIntersection = -1;
    for (let i3 = 0; i3 < 3; i3++) {
      const { start: start2, end } = edge;
      start2.copy(points[i3]);
      end.copy(points[(i3 + 1) % 3]);
      edge.delta(dir);
      const startIntersects = isNearZero(plane.distanceToPoint(start2));
      if (isNearZero(plane.normal.dot(dir)) && startIntersects) {
        targetEdge.copy(edge);
        count = 2;
        break;
      }
      const doesIntersect = plane.intersectLine(edge, tempPoint);
      if (!doesIntersect && startIntersects) {
        tempPoint.copy(start2);
      }
      if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {
        if (count <= 1) {
          const point = count === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          if (startIntersects) {
            startPointIntersection = count;
          }
        } else if (count >= 2) {
          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          count = 2;
          break;
        }
        count++;
        if (count === 2 && startPointIntersection === -1) {
          break;
        }
      }
    }
    return count;
  }
  return function intersectsTriangle(other, target2 = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
      const satBounds1 = this.satBounds;
      const satAxes1 = this.satAxes;
      arr2[0] = other.a;
      arr2[1] = other.b;
      arr2[2] = other.c;
      for (let i3 = 0; i3 < 4; i3++) {
        const sb = satBounds1[i3];
        const sa = satAxes1[i3];
        cachedSatBounds.setFromPoints(sa, arr2);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      const satBounds2 = other.satBounds;
      const satAxes2 = other.satAxes;
      arr1[0] = this.a;
      arr1[1] = this.b;
      arr1[2] = this.c;
      for (let i3 = 0; i3 < 4; i3++) {
        const sb = satBounds2[i3];
        const sa = satAxes2[i3];
        cachedSatBounds.setFromPoints(sa, arr1);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      for (let i3 = 0; i3 < 4; i3++) {
        const sa1 = satAxes1[i3];
        for (let i22 = 0; i22 < 4; i22++) {
          const sa2 = satAxes2[i22];
          cachedAxis.crossVectors(sa1, sa2);
          cachedSatBounds.setFromPoints(cachedAxis, arr1);
          cachedSatBounds2.setFromPoints(cachedAxis, arr2);
          if (cachedSatBounds.isSeparated(cachedSatBounds2))
            return false;
        }
      }
      if (target2) {
        if (!suppressLog) {
          console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        }
        target2.start.set(0, 0, 0);
        target2.end.set(0, 0, 0);
      }
      return true;
    } else {
      const count1 = triIntersectPlane(this, plane2, edge1);
      if (count1 === 1 && other.containsPoint(edge1.end)) {
        if (target2) {
          target2.start.copy(edge1.end);
          target2.end.copy(edge1.end);
        }
        return true;
      } else if (count1 !== 2) {
        return false;
      }
      const count2 = triIntersectPlane(other, plane1, edge2);
      if (count2 === 1 && this.containsPoint(edge2.end)) {
        if (target2) {
          target2.start.copy(edge2.end);
          target2.end.copy(edge2.end);
        }
        return true;
      } else if (count2 !== 2) {
        return false;
      }
      edge1.delta(dir1);
      edge2.delta(dir2);
      if (dir1.dot(dir2) < 0) {
        let tmp = edge2.start;
        edge2.start = edge2.end;
        edge2.end = tmp;
      }
      const s1 = edge1.start.dot(dir1);
      const e1 = edge1.end.dot(dir1);
      const s2 = edge2.start.dot(dir1);
      const e2 = edge2.end.dot(dir1);
      const separated1 = e1 < s2;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
        return false;
      }
      if (target2) {
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target2.start.copy(edge1.start);
        } else {
          target2.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target2.end.copy(edge1.end);
        } else {
          target2.end.copy(edge2.end);
        }
      }
      return true;
    }
  };
}();
ExtendedTriangle.prototype.distanceToPoint = function() {
  const target2 = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target2);
    return point.distanceTo(target2);
  };
}();
ExtendedTriangle.prototype.distanceToTriangle = function() {
  const point = new Vector3();
  const point2 = new Vector3();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1)
          lineTarget.getCenter(target1);
        if (target2)
          lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i3 = 0; i3 < 3; i3++) {
      let dist;
      const field = cornerFields[i3];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(point);
        if (target2)
          target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(thisVec);
        if (target2)
          target2.copy(point);
      }
    }
    for (let i3 = 0; i3 < 3; i3++) {
      const f11 = cornerFields[i3];
      const f12 = cornerFields[(i3 + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i22 = 0; i22 < 3; i22++) {
        const f21 = cornerFields[i22];
        const f22 = cornerFields[(i22 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point);
          if (target2)
            target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/math/OrientedBox.js
var OrientedBox = class {
  constructor(min, max, matrix2) {
    this.isOrientedBox = true;
    this.min = new Vector3();
    this.max = new Vector3();
    this.matrix = new Matrix4();
    this.invMatrix = new Matrix4();
    this.points = new Array(8).fill().map(() => new Vector3());
    this.satAxes = new Array(3).fill().map(() => new Vector3());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
    if (min)
      this.min.copy(min);
    if (max)
      this.max.copy(max);
    if (matrix2)
      this.matrix.copy(matrix2);
  }
  set(min, max, matrix2) {
    this.min.copy(min);
    this.max.copy(max);
    this.matrix.copy(matrix2);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
};
OrientedBox.prototype.update = function() {
  return function update3() {
    const matrix2 = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          const i3 = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;
          const v4 = points[i3];
          v4.x = x ? max.x : min.x;
          v4.y = y ? max.y : min.y;
          v4.z = z ? max.z : min.z;
          v4.applyMatrix4(matrix2);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i3 = 0; i3 < 3; i3++) {
      const axis = satAxes[i3];
      const sb = satBounds[i3];
      const index = 1 << i3;
      const pi = points[index];
      axis.subVectors(minVec, pi);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds))
      return false;
    for (let i3 = 0; i3 < 3; i3++) {
      const axis = satAxes[i3];
      const sb = satBounds[i3];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds))
        return false;
    }
    return true;
  };
}();
OrientedBox.prototype.intersectsTriangle = function() {
  const saTri = new ExtendedTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  return function intersectsTriangle(triangle4) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle4.isExtendedTriangle) {
      saTri.copy(triangle4);
      saTri.update();
      triangle4 = saTri;
    } else if (triangle4.needsUpdate) {
      triangle4.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle4.a;
    pointsArr[1] = triangle4.b;
    pointsArr[2] = triangle4.c;
    for (let i3 = 0; i3 < 3; i3++) {
      const sb = satBounds[i3];
      const sa = satAxes[i3];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    const triSatBounds = triangle4.satBounds;
    const triSatAxes = triangle4.satAxes;
    const points = this.points;
    for (let i3 = 0; i3 < 3; i3++) {
      const sb = triSatBounds[i3];
      const sa = triSatAxes[i3];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    for (let i3 = 0; i3 < 3; i3++) {
      const sa1 = satAxes[i3];
      for (let i22 = 0; i22 < 4; i22++) {
        const sa2 = triSatAxes[i22];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2))
          return false;
      }
    }
    return true;
  };
}();
OrientedBox.prototype.closestPointToPoint = function() {
  return function closestPointToPoint2(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox.prototype.distanceToPoint = function() {
  const target2 = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target2);
    return point.distanceTo(target2);
  };
}();
OrientedBox.prototype.distanceToBox = function() {
  const xyzFields = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector3();
  const point2 = new Vector3();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i3 = 0; i3 < 8; i3++) {
      const p = points[i3];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(p);
        if (target2)
          target2.copy(point2);
        if (dist < threshold2)
          return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i3 = 0; i3 < 3; i3++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i22 = 0; i22 <= 1; i22++) {
          const nextIndex = (i3 + 1) % 3;
          const nextIndex2 = (i3 + 2) % 3;
          const index = i1 << nextIndex | i22 << nextIndex2;
          const index2 = 1 << i3 | i1 << nextIndex | i22 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields[i3];
          const f2 = xyzFields[nextIndex];
          const f3 = xyzFields[nextIndex2];
          const line2 = segments2[count];
          const start2 = line2.start;
          const end = line2.end;
          start2[f1] = min[f1];
          start2[f2] = i1 ? min[f2] : max[f2];
          start2[f3] = i22 ? min[f3] : max[f2];
          end[f1] = max[f1];
          end[f2] = i1 ? min[f2] : max[f2];
          end[f3] = i22 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          point2.x = x ? max.x : min.x;
          point2.y = y ? max.y : min.y;
          point2.z = z ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1)
              target1.copy(point1);
            if (target2)
              target2.copy(point2);
            if (dist < threshold2)
              return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i3 = 0; i3 < 12; i3++) {
      const l1 = segments1[i3];
      for (let i22 = 0; i22 < 12; i22++) {
        const l2 = segments2[i22];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point1);
          if (target2)
            target2.copy(point2);
          if (dist < threshold2)
            return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/utils/PrimitivePool.js
var PrimitivePool = class {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives2 = this._primitives;
    if (primitives2.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives2.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
};

// node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js
var ExtendedTrianglePoolBase = class extends PrimitivePool {
  constructor() {
    super(() => new ExtendedTriangle());
  }
};
var ExtendedTrianglePool = new ExtendedTrianglePoolBase();

// node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js
function IS_LEAF(n16, uint16Array) {
  return uint16Array[n16 + 15] === 65535;
}
function OFFSET(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function COUNT(n16, uint16Array) {
  return uint16Array[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + 8;
}
function RIGHT_NODE(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function SPLIT_AXIS(n32, uint32Array) {
  return uint32Array[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}

// node_modules/three-mesh-bvh/src/core/utils/BufferStack.js
var _BufferStack = class {
  constructor() {
    this.float32Array = null;
    this.uint16Array = null;
    this.uint32Array = null;
    const stack = [];
    let prevBuffer = null;
    this.setBuffer = (buffer) => {
      if (prevBuffer) {
        stack.push(prevBuffer);
      }
      prevBuffer = buffer;
      this.float32Array = new Float32Array(buffer);
      this.uint16Array = new Uint16Array(buffer);
      this.uint32Array = new Uint32Array(buffer);
    };
    this.clearBuffer = () => {
      prevBuffer = null;
      this.float32Array = null;
      this.uint16Array = null;
      this.uint32Array = null;
      if (stack.length !== 0) {
        this.setBuffer(stack.pop());
      }
    };
  }
};
var BufferStack = new _BufferStack();

// node_modules/three-mesh-bvh/src/core/cast/shapecast.js
var _box1;
var _box2;
var boxStack = [];
var boxPool = new PrimitivePool(() => new Box3());
function shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {
  _box1 = boxPool.getPrimitive();
  _box2 = boxPool.getPrimitive();
  boxStack.push(_box1, _box2);
  BufferStack.setBuffer(bvh._roots[root]);
  const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
  BufferStack.clearBuffer();
  boxPool.releasePrimitive(_box1);
  boxPool.releasePrimitive(_box2);
  boxStack.pop();
  boxStack.pop();
  const length = boxStack.length;
  if (length > 0) {
    _box2 = boxStack[length - 1];
    _box1 = boxStack[length - 2];
  }
  return result;
}
function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);
    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);
  } else {
    let getLeftOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2);
    }, getRightEndOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array2);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2) + COUNT(nodeIndex162, uint16Array2);
    };
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array);
    let c12 = left;
    let c22 = right;
    let score1, score2;
    let box1, box2;
    if (nodeScoreFunc) {
      box1 = _box1;
      box2 = _box2;
      arrayToBox(BOUNDING_DATA_INDEX(c12), float32Array, box1);
      arrayToBox(BOUNDING_DATA_INDEX(c22), float32Array, box2);
      score1 = nodeScoreFunc(box1);
      score2 = nodeScoreFunc(box2);
      if (score2 < score1) {
        c12 = right;
        c22 = left;
        const temp5 = score1;
        score1 = score2;
        score2 = temp5;
        box1 = box2;
      }
    }
    if (!box1) {
      box1 = _box1;
      arrayToBox(BOUNDING_DATA_INDEX(c12), float32Array, box1);
    }
    const isC1Leaf = IS_LEAF(c12 * 2, uint16Array);
    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c12);
    let c1StopTraversal;
    if (c1Intersection === CONTAINED) {
      const offset = getLeftOffset(c12);
      const end = getRightEndOffset(c12);
      const count = end - offset;
      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c12, box1);
    } else {
      c1StopTraversal = c1Intersection && shapecastTraverse(
        c12,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c1StopTraversal)
      return true;
    box2 = _box2;
    arrayToBox(BOUNDING_DATA_INDEX(c22), float32Array, box2);
    const isC2Leaf = IS_LEAF(c22 * 2, uint16Array);
    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c22);
    let c2StopTraversal;
    if (c2Intersection === CONTAINED) {
      const offset = getLeftOffset(c22);
      const end = getRightEndOffset(c22);
      const count = end - offset;
      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c22, box2);
    } else {
      c2StopTraversal = c2Intersection && shapecastTraverse(
        c22,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c2StopTraversal)
      return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js
var temp = new Vector3();
var temp1 = new Vector3();
function closestPointToPoint(bvh, point, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  const minThresholdSq = minThreshold * minThreshold;
  const maxThresholdSq = maxThreshold * maxThreshold;
  let closestDistanceSq = Infinity;
  let closestDistanceTriIndex = null;
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        temp.copy(point).clamp(box.min, box.max);
        return temp.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp);
        const distSq = point.distanceToSquared(temp);
        if (distSq < closestDistanceSq) {
          temp1.copy(temp);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    }
  );
  if (closestDistanceSq === Infinity)
    return null;
  const closestDistance = Math.sqrt(closestDistanceSq);
  if (!target2.point)
    target2.point = temp1.clone();
  else
    target2.point.copy(temp1);
  target2.distance = closestDistance, target2.faceIndex = closestDistanceTriIndex;
  return target2;
}

// node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _normalA = new Vector3();
var _normalB = new Vector3();
var _normalC = new Vector3();
var _intersectionPoint = new Vector3();
function checkIntersection(ray4, pA, pB, pC, point, side) {
  let intersect;
  if (side === BackSide) {
    intersect = ray4.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray4.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  const distance = ray4.origin.distanceTo(point);
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray4, position2, normal2, uv, uv1, a3, b, c6, side) {
  _vA.fromBufferAttribute(position2, a3);
  _vB.fromBufferAttribute(position2, b);
  _vC.fromBufferAttribute(position2, c6);
  const intersection3 = checkIntersection(ray4, _vA, _vB, _vC, _intersectionPoint, side);
  if (intersection3) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a3);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c6);
      intersection3.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv1) {
      _uvA.fromBufferAttribute(uv1, a3);
      _uvB.fromBufferAttribute(uv1, b);
      _uvC.fromBufferAttribute(uv1, c6);
      intersection3.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (normal2) {
      _normalA.fromBufferAttribute(normal2, a3);
      _normalB.fromBufferAttribute(normal2, b);
      _normalC.fromBufferAttribute(normal2, c6);
      intersection3.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3());
      if (intersection3.normal.dot(ray4.direction) > 0) {
        intersection3.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a: a3,
      b,
      c: c6,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection3.face = face;
    intersection3.faceIndex = a3;
  }
  return intersection3;
}
function intersectTri(geo, side, ray4, tri, intersections) {
  const triOffset = tri * 3;
  let a3 = triOffset + 0;
  let b = triOffset + 1;
  let c6 = triOffset + 2;
  const index = geo.index;
  if (geo.index) {
    a3 = index.getX(a3);
    b = index.getX(b);
    c6 = index.getX(c6);
  }
  const { position: position2, normal: normal2, uv, uv1 } = geo.attributes;
  const intersection3 = checkBufferGeometryIntersection(ray4, position2, normal2, uv, uv1, a3, b, c6, side);
  if (intersection3) {
    intersection3.faceIndex = tri;
    if (intersections)
      intersections.push(intersection3);
    return intersection3;
  }
  return null;
}

// node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js
function setTriangle(tri, i3, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i3;
  let i1 = i3 + 1;
  let i22 = i3 + 2;
  if (index) {
    i0 = index.getX(i0);
    i1 = index.getX(i1);
    i22 = index.getX(i22);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i22);
  tc.y = pos.getY(i22);
  tc.z = pos.getZ(i22);
}
var tempV1 = new Vector3();
var tempV2 = new Vector3();
var tempV3 = new Vector3();
var tempUV1 = new Vector2();
var tempUV2 = new Vector2();
var tempUV3 = new Vector2();

// node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js
function intersectTris(bvh, side, ray4, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i3 = offset, end = offset + count; i3 < end; i3++) {
    intersectTri(geometry, side, ray4, i3, intersections);
  }
}
function intersectClosestTri(bvh, side, ray4, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i3 = offset, end = offset + count; i3 < end; i3++) {
    let intersection3;
    intersection3 = intersectTri(geometry, side, ray4, i3);
    if (intersection3 && intersection3.distance < dist) {
      res = intersection3;
      dist = intersection3.distance;
    }
  }
  return res;
}
function iterateOverTriangles(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle4) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i3 = offset, l2 = count + offset; i3 < l2; i3++) {
    let tri;
    tri = i3;
    setTriangle(triangle4, tri * 3, index, pos);
    triangle4.needsUpdate = true;
    if (intersectsTriangleFunc(triangle4, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}

// node_modules/three-mesh-bvh/src/core/cast/refit.generated.js
function refit(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i3 = 0, l2 = roots.length; i3 < l2; i3++) {
    buffer = roots[i3];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i3 = 3 * offset, l2 = 3 * (offset + count); i3 < l2; i3++) {
        let index = indexArr[i3];
        const x = posAttr.getX(index);
        const y = posAttr.getY(index);
        const z = posAttr.getZ(index);
        if (x < minx)
          minx = x;
        if (x > maxx)
          maxx = x;
        if (y < miny)
          miny = y;
        if (y > maxy)
          maxy = y;
        if (z < minz)
          minz = z;
        if (z > maxz)
          maxz = z;
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i3 = 0; i3 < 3; i3++) {
          const lefti = left + i3;
          const righti = right + i3;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i3] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i3 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js
var _boundingBox = new Box3();
function intersectRay(nodeIndex32, array, ray4, target2) {
  arrayToBox(nodeIndex32, array, _boundingBox);
  return ray4.intersectBox(_boundingBox, target2);
}

// node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js
function intersectTris_indirect(bvh, side, ray4, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i3 = offset, end = offset + count; i3 < end; i3++) {
    let vi = _indirectBuffer ? _indirectBuffer[i3] : i3;
    intersectTri(geometry, side, ray4, vi, intersections);
  }
}
function intersectClosestTri_indirect(bvh, side, ray4, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i3 = offset, end = offset + count; i3 < end; i3++) {
    let intersection3;
    intersection3 = intersectTri(geometry, side, ray4, _indirectBuffer ? _indirectBuffer[i3] : i3);
    if (intersection3 && intersection3.distance < dist) {
      res = intersection3;
      dist = intersection3.distance;
    }
  }
  return res;
}
function iterateOverTriangles_indirect(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle4) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i3 = offset, l2 = count + offset; i3 < l2; i3++) {
    let tri;
    tri = bvh.resolveTriangleIndex(i3);
    setTriangle(triangle4, tri * 3, index, pos);
    triangle4.needsUpdate = true;
    if (intersectsTriangleFunc(triangle4, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}

// node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js
var _boxIntersection = new Vector3();
function raycast(bvh, root, side, ray4, intersects) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast(0, bvh, side, ray4, intersects);
  BufferStack.clearBuffer();
}
function _raycast(nodeIndex32, bvh, side, ray4, intersects) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris(bvh, side, ray4, offset, count, intersects);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray4, _boxIntersection)) {
      _raycast(leftIndex, bvh, side, ray4, intersects);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray4, _boxIntersection)) {
      _raycast(rightIndex, bvh, side, ray4, intersects);
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js
var _boxIntersection2 = new Vector3();
var _xyzFields = ["x", "y", "z"];
function raycastFirst(bvh, root, side, ray4) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst(0, bvh, side, ray4);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst(nodeIndex32, bvh, side, ray4) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri(bvh, side, ray4, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields[splitAxis];
    const rayDir = ray4.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c12, c22;
    if (leftToRight) {
      c12 = LEFT_NODE(nodeIndex32);
      c22 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c12 = RIGHT_NODE(nodeIndex32, uint32Array);
      c22 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c12, float32Array, ray4, _boxIntersection2);
    const c1Result = c1Intersection ? _raycastFirst(c12, bvh, side, ray4) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c22 + splitAxis] : (
        // min bounding data
        point >= float32Array[c22 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c22, float32Array, ray4, _boxIntersection2);
    const c2Result = c2Intersection ? _raycastFirst(c22, bvh, side, ray4) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js
var boundingBox = new Box3();
var triangle = new ExtendedTriangle();
var triangle2 = new ExtendedTriangle();
var invertedMat = new Matrix4();
var obb = new OrientedBox();
var obb2 = new OrientedBox();
function intersectsGeometry(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);
      obb2.matrix.copy(invertedMat);
      obb2.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i3 = offset * 3, l2 = (count + offset) * 3; i3 < l2; i3 += 3) {
            setTriangle(triangle2, i3, thisIndex, thisPos);
            triangle2.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i3 = offset * 3, l2 = (count + offset) * 3; i3 < l2; i3 += 3) {
        setTriangle(triangle, i3, thisIndex, thisPos);
        triangle.a.applyMatrix4(invertedMat);
        triangle.b.applyMatrix4(invertedMat);
        triangle.c.applyMatrix4(invertedMat);
        triangle.needsUpdate = true;
        for (let i22 = 0, l22 = index.count; i22 < l22; i22 += 3) {
          setTriangle(triangle2, i22, index, pos);
          triangle2.needsUpdate = true;
          if (triangle.intersectsTriangle(triangle2)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);
    const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);
    const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js
var tempMatrix = new Matrix4();
var obb3 = new OrientedBox();
var obb22 = new OrientedBox();
var temp12 = new Vector3();
var temp2 = new Vector3();
var temp3 = new Vector3();
var temp4 = new Vector3();
function closestPointToGeometry(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb3.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle4 = ExtendedTrianglePool.getPrimitive();
  const triangle23 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp12;
  let tempTargetDest1 = temp2;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3;
    tempTargetDest2 = temp4;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix.copy(geometryToBvh).invert();
  obb22.matrix.copy(tempMatrix);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb3.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb22.min.copy(box.min);
            obb22.max.copy(box.max);
            obb22.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb22.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i22 = otherOffset, l2 = otherOffset + otherCount; i22 < l2; i22++) {
                setTriangle(triangle23, 3 * i22, otherIndex, otherPos);
                triangle23.a.applyMatrix4(geometryToBvh);
                triangle23.b.applyMatrix4(geometryToBvh);
                triangle23.c.applyMatrix4(geometryToBvh);
                triangle23.needsUpdate = true;
                for (let i3 = offset, l3 = offset + count; i3 < l3; i3++) {
                  setTriangle(triangle4, 3 * i3, index, pos);
                  triangle4.needsUpdate = true;
                  const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i3;
                    closestDistanceOtherTriIndex = i22;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i22 = 0, l2 = triCount; i22 < l2; i22++) {
            setTriangle(triangle23, 3 * i22, otherIndex, otherPos);
            triangle23.a.applyMatrix4(geometryToBvh);
            triangle23.b.applyMatrix4(geometryToBvh);
            triangle23.c.applyMatrix4(geometryToBvh);
            triangle23.needsUpdate = true;
            for (let i3 = offset, l3 = offset + count; i3 < l3; i3++) {
              setTriangle(triangle4, 3 * i3, index, pos);
              triangle4.needsUpdate = true;
              const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i3;
                closestDistanceOtherTriIndex = i22;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle4);
  ExtendedTrianglePool.releasePrimitive(triangle23);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix);
    tempTargetDest1.applyMatrix4(tempMatrix);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}

// node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js
function refit_indirect(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i3 = 0, l2 = roots.length; i3 < l2; i3++) {
    buffer = roots[i3];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i3 = offset, l2 = offset + count; i3 < l2; i3++) {
        const t2 = 3 * bvh.resolveTriangleIndex(i3);
        for (let j = 0; j < 3; j++) {
          let index = t2 + j;
          index = indexArr ? indexArr[index] : index;
          const x = posAttr.getX(index);
          const y = posAttr.getY(index);
          const z = posAttr.getZ(index);
          if (x < minx)
            minx = x;
          if (x > maxx)
            maxx = x;
          if (y < miny)
            miny = y;
          if (y > maxy)
            maxy = y;
          if (z < minz)
            minz = z;
          if (z > maxz)
            maxz = z;
        }
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i3 = 0; i3 < 3; i3++) {
          const lefti = left + i3;
          const righti = right + i3;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i3] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i3 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js
var _boxIntersection3 = new Vector3();
function raycast_indirect(bvh, root, side, ray4, intersects) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast2(0, bvh, side, ray4, intersects);
  BufferStack.clearBuffer();
}
function _raycast2(nodeIndex32, bvh, side, ray4, intersects) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris_indirect(bvh, side, ray4, offset, count, intersects);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray4, _boxIntersection3)) {
      _raycast2(leftIndex, bvh, side, ray4, intersects);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray4, _boxIntersection3)) {
      _raycast2(rightIndex, bvh, side, ray4, intersects);
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js
var _boxIntersection4 = new Vector3();
var _xyzFields2 = ["x", "y", "z"];
function raycastFirst_indirect(bvh, root, side, ray4) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst2(0, bvh, side, ray4);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst2(nodeIndex32, bvh, side, ray4) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri_indirect(bvh, side, ray4, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields2[splitAxis];
    const rayDir = ray4.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c12, c22;
    if (leftToRight) {
      c12 = LEFT_NODE(nodeIndex32);
      c22 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c12 = RIGHT_NODE(nodeIndex32, uint32Array);
      c22 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c12, float32Array, ray4, _boxIntersection4);
    const c1Result = c1Intersection ? _raycastFirst2(c12, bvh, side, ray4) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c22 + splitAxis] : (
        // min bounding data
        point >= float32Array[c22 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c22, float32Array, ray4, _boxIntersection4);
    const c2Result = c2Intersection ? _raycastFirst2(c22, bvh, side, ray4) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js
var boundingBox2 = new Box3();
var triangle3 = new ExtendedTriangle();
var triangle22 = new ExtendedTriangle();
var invertedMat2 = new Matrix4();
var obb4 = new OrientedBox();
var obb23 = new OrientedBox();
function intersectsGeometry_indirect(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry2(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry2(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb4.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb4;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat2.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb23);
      obb23.matrix.copy(invertedMat2);
      obb23.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb23.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i3 = offset, l2 = count + offset; i3 < l2; i3++) {
            setTriangle(triangle22, 3 * bvh.resolveTriangleIndex(i3), thisIndex, thisPos);
            triangle22.needsUpdate = true;
            if (tri.intersectsTriangle(triangle22)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i3 = offset, l2 = count + offset; i3 < l2; i3++) {
        const ti = bvh.resolveTriangleIndex(i3);
        setTriangle(triangle3, 3 * ti, thisIndex, thisPos);
        triangle3.a.applyMatrix4(invertedMat2);
        triangle3.b.applyMatrix4(invertedMat2);
        triangle3.c.applyMatrix4(invertedMat2);
        triangle3.needsUpdate = true;
        for (let i22 = 0, l22 = index.count; i22 < l22; i22 += 3) {
          setTriangle(triangle22, i22, index, pos);
          triangle22.needsUpdate = true;
          if (triangle3.intersectsTriangle(triangle22)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox2);
    const leftIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox2);
    const rightIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js
var tempMatrix2 = new Matrix4();
var obb5 = new OrientedBox();
var obb24 = new OrientedBox();
var temp13 = new Vector3();
var temp22 = new Vector3();
var temp32 = new Vector3();
var temp42 = new Vector3();
function closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb5.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb5.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle4 = ExtendedTrianglePool.getPrimitive();
  const triangle23 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp13;
  let tempTargetDest1 = temp22;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp32;
    tempTargetDest2 = temp42;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix2.copy(geometryToBvh).invert();
  obb24.matrix.copy(tempMatrix2);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb5.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb24.min.copy(box.min);
            obb24.max.copy(box.max);
            obb24.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb24.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i22 = otherOffset, l2 = otherOffset + otherCount; i22 < l2; i22++) {
                const ti2 = otherBvh.resolveTriangleIndex(i22);
                setTriangle(triangle23, 3 * ti2, otherIndex, otherPos);
                triangle23.a.applyMatrix4(geometryToBvh);
                triangle23.b.applyMatrix4(geometryToBvh);
                triangle23.c.applyMatrix4(geometryToBvh);
                triangle23.needsUpdate = true;
                for (let i3 = offset, l3 = offset + count; i3 < l3; i3++) {
                  const ti = bvh.resolveTriangleIndex(i3);
                  setTriangle(triangle4, 3 * ti, index, pos);
                  triangle4.needsUpdate = true;
                  const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i3;
                    closestDistanceOtherTriIndex = i22;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i22 = 0, l2 = triCount; i22 < l2; i22++) {
            setTriangle(triangle23, 3 * i22, otherIndex, otherPos);
            triangle23.a.applyMatrix4(geometryToBvh);
            triangle23.b.applyMatrix4(geometryToBvh);
            triangle23.c.applyMatrix4(geometryToBvh);
            triangle23.needsUpdate = true;
            for (let i3 = offset, l3 = offset + count; i3 < l3; i3++) {
              const ti = bvh.resolveTriangleIndex(i3);
              setTriangle(triangle4, 3 * ti, index, pos);
              triangle4.needsUpdate = true;
              const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i3;
                closestDistanceOtherTriIndex = i22;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle4);
  ExtendedTrianglePool.releasePrimitive(triangle23);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix2);
    tempTargetDest1.applyMatrix4(tempMatrix2);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}

// node_modules/three-mesh-bvh/src/utils/BufferUtils.js
function isSharedArrayBufferSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}

// node_modules/three-mesh-bvh/src/core/cast/bvhcast.js
var _bufferStack1 = new BufferStack.constructor();
var _bufferStack2 = new BufferStack.constructor();
var _boxPool = new PrimitivePool(() => new Box3());
var _leftBox1 = new Box3();
var _rightBox1 = new Box3();
var _leftBox2 = new Box3();
var _rightBox2 = new Box3();
var _active = false;
function bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {
  if (_active) {
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  }
  _active = true;
  const roots = bvh._roots;
  const otherRoots = otherBvh._roots;
  let result;
  let offset1 = 0;
  let offset2 = 0;
  const invMat = new Matrix4().copy(matrixToLocal).invert();
  for (let i3 = 0, il = roots.length; i3 < il; i3++) {
    _bufferStack1.setBuffer(roots[i3]);
    offset2 = 0;
    const localBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);
    localBox.applyMatrix4(invMat);
    for (let j = 0, jl = otherRoots.length; j < jl; j++) {
      _bufferStack2.setBuffer(otherRoots[i3]);
      result = _traverse(
        0,
        0,
        matrixToLocal,
        invMat,
        intersectsRanges,
        offset1,
        offset2,
        0,
        0,
        localBox
      );
      _bufferStack2.clearBuffer();
      offset2 += otherRoots[j].length;
      if (result) {
        break;
      }
    }
    _boxPool.releasePrimitive(localBox);
    _bufferStack1.clearBuffer();
    offset1 += roots[i3].length;
    if (result) {
      break;
    }
  }
  _active = false;
  return result;
}
function _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset = 0, node2IndexByteOffset = 0, depth1 = 0, depth2 = 0, currBox = null, reversed = false) {
  let bufferStack1, bufferStack2;
  if (reversed) {
    bufferStack1 = _bufferStack2;
    bufferStack2 = _bufferStack1;
  } else {
    bufferStack1 = _bufferStack1;
    bufferStack2 = _bufferStack2;
  }
  const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;
  const node1Index16 = node1Index32 * 2;
  const node2Index16 = node2Index32 * 2;
  const isLeaf1 = IS_LEAF(node1Index16, uint16Array1);
  const isLeaf2 = IS_LEAF(node2Index16, uint16Array2);
  let result = false;
  if (isLeaf2 && isLeaf1) {
    if (reversed) {
      result = intersectsRangesFunc(
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        depth2,
        node2IndexByteOffset + node2Index32,
        depth1,
        node1IndexByteOffset + node1Index32
      );
    } else {
      result = intersectsRangesFunc(
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        depth1,
        node1IndexByteOffset + node1Index32,
        depth2,
        node2IndexByteOffset + node2Index32
      );
    }
  } else if (isLeaf2) {
    const newBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);
    newBox.applyMatrix4(matrix2to1);
    const cl1 = LEFT_NODE(node1Index32);
    const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
    const intersectCl1 = newBox.intersectsBox(_leftBox1);
    const intersectCr1 = newBox.intersectsBox(_rightBox1);
    result = intersectCl1 && _traverse(
      node2Index32,
      cl1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    ) || intersectCr1 && _traverse(
      node2Index32,
      cr1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    );
    _boxPool.releasePrimitive(newBox);
  } else {
    const cl2 = LEFT_NODE(node2Index32);
    const cr2 = RIGHT_NODE(node2Index32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);
    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);
    const leftIntersects = currBox.intersectsBox(_leftBox2);
    const rightIntersects = currBox.intersectsBox(_rightBox2);
    if (leftIntersects && rightIntersects) {
      result = _traverse(
        node1Index32,
        cl2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      ) || _traverse(
        node1Index32,
        cr2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      );
    } else if (leftIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cl2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_leftBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cl2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cl2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    } else if (rightIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cr2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_rightBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cr2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cr2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    }
  }
  return result;
}

// node_modules/three-mesh-bvh/src/core/MeshBVH.js
var obb6 = new OrientedBox();
var tempBox = new Box3();
var MeshBVH = class _MeshBVH {
  static serialize(bvh, options = {}) {
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indirectBuffer = bvh._indirectBuffer;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root) => root.slice()),
        index: indexAttribute.array.slice(),
        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute.array,
        indirectBuffer
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    options = {
      setIndex: true,
      indirect: Boolean(data.indirectBuffer),
      ...options
    };
    const { index, roots, indirectBuffer } = data;
    const bvh = new _MeshBVH(geometry, { ...options, [SKIP_GENERATION]: true });
    bvh._roots = roots;
    bvh._indirectBuffer = indirectBuffer || null;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      strategy: CENTER,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this.geometry = geometry;
    this._roots = null;
    this._indirectBuffer = null;
    if (!options[SKIP_GENERATION]) {
      buildPackedTree(this, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box3());
      }
    }
    const { _indirectBuffer } = this;
    this.resolveTriangleIndex = options.indirect ? (i3) => _indirectBuffer[i3] : (i3) => i3;
  }
  refit(nodeIndices = null) {
    const refitFunc = this.indirect ? refit_indirect : refit;
    return refitFunc(this, nodeIndices);
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array = new Uint32Array(buffer);
    const uint16Array = new Uint16Array(buffer);
    _traverse2(0);
    function _traverse2(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE / 4;
        const right = uint32Array[node32Index + 6];
        const splitAxis = uint32Array[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse2(left, depth + 1);
          _traverse2(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray4, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFunc = this.indirect ? raycast_indirect : raycast;
    for (let i3 = 0, l2 = roots.length; i3 < l2; i3++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i3].materialIndex].side : side;
      const startCount = intersects.length;
      raycastFunc(this, i3, materialSide, ray4, intersects);
      if (isArrayMaterial) {
        const materialIndex = groups[i3].materialIndex;
        for (let j = startCount, jl = intersects.length; j < jl; j++) {
          intersects[j].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects;
  }
  raycastFirst(ray4, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;
    for (let i3 = 0, l2 = roots.length; i3 < l2; i3++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i3].materialIndex].side : side;
      const result = raycastFirstFunc(this, i3, materialSide, ray4);
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i3].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    let result = false;
    const roots = this._roots;
    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
    for (let i3 = 0, l2 = roots.length; i3 < l2; i3++) {
      result = intersectsGeometryFunc(this, i3, otherGeometry, geomToMesh);
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks) {
    const triangle4 = ExtendedTrianglePool.getPrimitive();
    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle4);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle4);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i3 = 0, l2 = roots.length; i3 < l2; i3++) {
      const root = roots[i3];
      result = shapecast(this, i3, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      if (result) {
        break;
      }
      byteOffset += root.byteLength;
    }
    ExtendedTrianglePool.releasePrimitive(triangle4);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const triangle1 = ExtendedTrianglePool.getPrimitive();
    const indexAttr1 = this.geometry.index;
    const positionAttr1 = this.geometry.attributes.position;
    const assignTriangle1 = this.indirect ? (i1) => {
      const ti = this.resolveTriangleIndex(i1);
      setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);
    } : (i1) => {
      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);
    };
    const triangle23 = ExtendedTrianglePool.getPrimitive();
    const indexAttr2 = otherBvh.geometry.index;
    const positionAttr2 = otherBvh.geometry.attributes.position;
    const assignTriangle2 = otherBvh.indirect ? (i22) => {
      const ti2 = otherBvh.resolveTriangleIndex(i22);
      setTriangle(triangle23, ti2 * 3, indexAttr2, positionAttr2);
    } : (i22) => {
      setTriangle(triangle23, i22 * 3, indexAttr2, positionAttr2);
    };
    if (intersectsTriangles) {
      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {
        for (let i22 = offset2, l2 = offset2 + count2; i22 < l2; i22++) {
          assignTriangle2(i22);
          triangle23.a.applyMatrix4(matrixToLocal);
          triangle23.b.applyMatrix4(matrixToLocal);
          triangle23.c.applyMatrix4(matrixToLocal);
          triangle23.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            assignTriangle1(i1);
            triangle1.needsUpdate = true;
            if (intersectsTriangles(triangle1, triangle23, i1, i22, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb6.set(box.min, box.max, boxToMesh);
    obb6.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb6.intersectsBox(box2),
        intersectsTriangle: (tri) => obb6.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;
    return closestPointToGeometryFunc(
      this,
      otherGeometry,
      geometryToBvh,
      target1,
      target2,
      minThreshold,
      maxThreshold
    );
  }
  closestPointToPoint(point, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    return closestPointToPoint(
      this,
      point,
      target2,
      minThreshold,
      maxThreshold
    );
  }
  getBoundingBox(target2) {
    target2.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target2.union(tempBox);
    });
    return target2;
  }
};

// node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js
var boundingBox3 = new Box3();

// node_modules/three-mesh-bvh/src/debug/Debug.js
var _box12 = new Box3();
var _box22 = new Box3();
var _vec = new Vector3();

// node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js
function convertRaycastIntersect(hit, object, raycaster) {
  if (hit === null) {
    return null;
  }
  hit.point.applyMatrix4(object.matrixWorld);
  hit.distance = hit.point.distanceTo(raycaster.ray.origin);
  hit.object = object;
  if (hit.distance < raycaster.near || hit.distance > raycaster.far) {
    return null;
  } else {
    return hit;
  }
}

// node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js
var ray = new Ray();
var tmpInverseMatrix = new Matrix4();
var origMeshRaycastFunc = Mesh.prototype.raycast;
function acceleratedRaycast(raycaster, intersects) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    tmpInverseMatrix.copy(this.matrixWorld).invert();
    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
    const bvh = this.geometry.boundsTree;
    if (raycaster.firstHitOnly === true) {
      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material), this, raycaster);
      if (hit) {
        intersects.push(hit);
      }
    } else {
      const hits = bvh.raycast(ray, this.material);
      for (let i3 = 0, l2 = hits.length; i3 < l2; i3++) {
        const hit = convertRaycastIntersect(hits[i3], this, raycaster);
        if (hit) {
          intersects.push(hit);
        }
      }
    }
  } else {
    origMeshRaycastFunc.call(this, raycaster, intersects);
  }
}
function computeBoundsTree(options) {
  this.boundsTree = new MeshBVH(this, options);
  return this.boundsTree;
}
function disposeBoundsTree() {
  this.boundsTree = null;
}

// node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js
function countToStringFormat(count) {
  switch (count) {
    case 1:
      return "R";
    case 2:
      return "RG";
    case 3:
      return "RGBA";
    case 4:
      return "RGBA";
  }
  throw new Error();
}
function countToFormat(count) {
  switch (count) {
    case 1:
      return RedFormat;
    case 2:
      return RGFormat;
    case 3:
      return RGBAFormat;
    case 4:
      return RGBAFormat;
  }
}
function countToIntFormat(count) {
  switch (count) {
    case 1:
      return RedIntegerFormat;
    case 2:
      return RGIntegerFormat;
    case 3:
      return RGBAIntegerFormat;
    case 4:
      return RGBAIntegerFormat;
  }
}
var VertexAttributeTexture = class extends DataTexture {
  constructor() {
    super();
    this.minFilter = NearestFilter;
    this.magFilter = NearestFilter;
    this.generateMipmaps = false;
    this.overrideItemSize = null;
    this._forcedType = null;
  }
  updateFrom(attr) {
    const overrideItemSize = this.overrideItemSize;
    const originalItemSize = attr.itemSize;
    const originalCount = attr.count;
    if (overrideItemSize !== null) {
      if (originalItemSize * originalCount % overrideItemSize !== 0) {
        throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");
      }
      attr.itemSize = overrideItemSize;
      attr.count = originalCount * originalItemSize / overrideItemSize;
    }
    const itemSize = attr.itemSize;
    const count = attr.count;
    const normalized = attr.normalized;
    const originalBufferCons = attr.array.constructor;
    const byteCount = originalBufferCons.BYTES_PER_ELEMENT;
    let targetType = this._forcedType;
    let finalStride = itemSize;
    if (targetType === null) {
      switch (originalBufferCons) {
        case Float32Array:
          targetType = FloatType;
          break;
        case Uint8Array:
        case Uint16Array:
        case Uint32Array:
          targetType = UnsignedIntType;
          break;
        case Int8Array:
        case Int16Array:
        case Int32Array:
          targetType = IntType;
          break;
      }
    }
    let type, format, normalizeValue, targetBufferCons;
    let internalFormat = countToStringFormat(itemSize);
    switch (targetType) {
      case FloatType:
        normalizeValue = 1;
        format = countToFormat(itemSize);
        if (normalized && byteCount === 1) {
          targetBufferCons = originalBufferCons;
          internalFormat += "8";
          if (originalBufferCons === Uint8Array) {
            type = UnsignedByteType;
          } else {
            type = ByteType;
            internalFormat += "_SNORM";
          }
        } else {
          targetBufferCons = Float32Array;
          internalFormat += "32F";
          type = FloatType;
        }
        break;
      case IntType:
        internalFormat += byteCount * 8 + "I";
        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1;
        format = countToIntFormat(itemSize);
        if (byteCount === 1) {
          targetBufferCons = Int8Array;
          type = ByteType;
        } else if (byteCount === 2) {
          targetBufferCons = Int16Array;
          type = ShortType;
        } else {
          targetBufferCons = Int32Array;
          type = IntType;
        }
        break;
      case UnsignedIntType:
        internalFormat += byteCount * 8 + "UI";
        normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1;
        format = countToIntFormat(itemSize);
        if (byteCount === 1) {
          targetBufferCons = Uint8Array;
          type = UnsignedByteType;
        } else if (byteCount === 2) {
          targetBufferCons = Uint16Array;
          type = UnsignedShortType;
        } else {
          targetBufferCons = Uint32Array;
          type = UnsignedIntType;
        }
        break;
    }
    if (finalStride === 3 && (format === RGBAFormat || format === RGBAIntegerFormat)) {
      finalStride = 4;
    }
    const dimension = Math.ceil(Math.sqrt(count));
    const length = finalStride * dimension * dimension;
    const dataArray = new targetBufferCons(length);
    const originalNormalized = attr.normalized;
    attr.normalized = false;
    for (let i3 = 0; i3 < count; i3++) {
      const ii = finalStride * i3;
      dataArray[ii] = attr.getX(i3) / normalizeValue;
      if (itemSize >= 2) {
        dataArray[ii + 1] = attr.getY(i3) / normalizeValue;
      }
      if (itemSize >= 3) {
        dataArray[ii + 2] = attr.getZ(i3) / normalizeValue;
        if (finalStride === 4) {
          dataArray[ii + 3] = 1;
        }
      }
      if (itemSize >= 4) {
        dataArray[ii + 3] = attr.getW(i3) / normalizeValue;
      }
    }
    attr.normalized = originalNormalized;
    this.internalFormat = internalFormat;
    this.format = format;
    this.type = type;
    this.image.width = dimension;
    this.image.height = dimension;
    this.image.data = dataArray;
    this.needsUpdate = true;
    this.dispose();
    attr.itemSize = originalItemSize;
    attr.count = originalCount;
  }
};
var UIntVertexAttributeTexture = class extends VertexAttributeTexture {
  constructor() {
    super();
    this._forcedType = UnsignedIntType;
  }
};
var FloatVertexAttributeTexture = class extends VertexAttributeTexture {
  constructor() {
    super();
    this._forcedType = FloatType;
  }
};

// node_modules/three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js
var MeshBVHUniformStruct = class {
  constructor() {
    this.index = new UIntVertexAttributeTexture();
    this.position = new FloatVertexAttributeTexture();
    this.bvhBounds = new DataTexture();
    this.bvhContents = new DataTexture();
    this._cachedIndexAttr = null;
    this.index.overrideItemSize = 3;
  }
  updateFrom(bvh) {
    const { geometry } = bvh;
    bvhToTextures(bvh, this.bvhBounds, this.bvhContents);
    this.position.updateFrom(geometry.attributes.position);
    if (bvh.indirect) {
      const indirectBuffer = bvh._indirectBuffer;
      if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== indirectBuffer.length) {
        if (geometry.index) {
          this._cachedIndexAttr = geometry.index.clone();
        } else {
          const array = getIndexArray(getVertexCount(geometry));
          this._cachedIndexAttr = new BufferAttribute(array, 1, false);
        }
      }
      dereferenceIndex(geometry, indirectBuffer, this._cachedIndexAttr);
      this.index.updateFrom(this._cachedIndexAttr);
    } else {
      this.index.updateFrom(geometry.index);
    }
  }
  dispose() {
    const { index, position: position2, bvhBounds, bvhContents } = this;
    if (index)
      index.dispose();
    if (position2)
      position2.dispose();
    if (bvhBounds)
      bvhBounds.dispose();
    if (bvhContents)
      bvhContents.dispose();
  }
};
function dereferenceIndex(geometry, indirectBuffer, target2) {
  const unpacked = target2.array;
  const indexArray = geometry.index ? geometry.index.array : null;
  for (let i3 = 0, l2 = indirectBuffer.length; i3 < l2; i3++) {
    const i32 = 3 * i3;
    const v32 = 3 * indirectBuffer[i3];
    for (let c6 = 0; c6 < 3; c6++) {
      unpacked[i32 + c6] = indexArray ? indexArray[v32 + c6] : v32 + c6;
    }
  }
}
function bvhToTextures(bvh, boundsTexture, contentsTexture) {
  const roots = bvh._roots;
  if (roots.length !== 1) {
    throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");
  }
  const root = roots[0];
  const uint16Array = new Uint16Array(root);
  const uint32Array = new Uint32Array(root);
  const float32Array = new Float32Array(root);
  const nodeCount = root.byteLength / BYTES_PER_NODE;
  const boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));
  const boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);
  const contentsDimension = Math.ceil(Math.sqrt(nodeCount));
  const contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);
  for (let i3 = 0; i3 < nodeCount; i3++) {
    const nodeIndex32 = i3 * BYTES_PER_NODE / 4;
    const nodeIndex16 = nodeIndex32 * 2;
    const boundsIndex = BOUNDING_DATA_INDEX(nodeIndex32);
    for (let b = 0; b < 3; b++) {
      boundsArray[8 * i3 + 0 + b] = float32Array[boundsIndex + 0 + b];
      boundsArray[8 * i3 + 4 + b] = float32Array[boundsIndex + 3 + b];
    }
    if (IS_LEAF(nodeIndex16, uint16Array)) {
      const count = COUNT(nodeIndex16, uint16Array);
      const offset = OFFSET(nodeIndex32, uint32Array);
      const mergedLeafCount = 4294901760 | count;
      contentsArray[i3 * 2 + 0] = mergedLeafCount;
      contentsArray[i3 * 2 + 1] = offset;
    } else {
      const rightIndex = 4 * RIGHT_NODE(nodeIndex32, uint32Array) / BYTES_PER_NODE;
      const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
      contentsArray[i3 * 2 + 0] = splitAxis;
      contentsArray[i3 * 2 + 1] = rightIndex;
    }
  }
  boundsTexture.image.data = boundsArray;
  boundsTexture.image.width = boundsDimension;
  boundsTexture.image.height = boundsDimension;
  boundsTexture.format = RGBAFormat;
  boundsTexture.type = FloatType;
  boundsTexture.internalFormat = "RGBA32F";
  boundsTexture.minFilter = NearestFilter;
  boundsTexture.magFilter = NearestFilter;
  boundsTexture.generateMipmaps = false;
  boundsTexture.needsUpdate = true;
  boundsTexture.dispose();
  contentsTexture.image.data = contentsArray;
  contentsTexture.image.width = contentsDimension;
  contentsTexture.image.height = contentsDimension;
  contentsTexture.format = RGIntegerFormat;
  contentsTexture.type = UnsignedIntType;
  contentsTexture.internalFormat = "RG32UI";
  contentsTexture.minFilter = NearestFilter;
  contentsTexture.magFilter = NearestFilter;
  contentsTexture.generateMipmaps = false;
  contentsTexture.needsUpdate = true;
  contentsTexture.dispose();
}

// node_modules/three-mesh-bvh/src/gpu/shaderFunctions.js
var shaderStructs = (
  /* glsl */
  `
#ifndef TRI_INTERSECT_EPSILON
#define TRI_INTERSECT_EPSILON 1e-5
#endif

#ifndef INFINITY
#define INFINITY 1e20
#endif

struct BVH {

	usampler2D index;
	sampler2D position;

	sampler2D bvhBounds;
	usampler2D bvhContents;

};
`
);
var shaderIntersectFunction = (
  /* glsl */
  `

// Utilities
uvec4 uTexelFetch1D( usampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

ivec4 iTexelFetch1D( isampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 texelFetch1D( sampler2D tex, uint index ) {

	uint width = uint( textureSize( tex, 0 ).x );
	uvec2 uv;
	uv.x = index % width;
	uv.y = index / width;

	return texelFetch( tex, ivec2( uv ), 0 );

}

vec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {

	return
		barycoord.x * texelFetch1D( tex, faceIndices.x ) +
		barycoord.y * texelFetch1D( tex, faceIndices.y ) +
		barycoord.z * texelFetch1D( tex, faceIndices.z );

}

void ndcToCameraRay(
	vec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,
	out vec3 rayOrigin, out vec3 rayDirection
) {

	// get camera look direction and near plane for camera clipping
	vec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );
	vec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );
	float near = abs( nearVector.z / nearVector.w );

	// get the camera direction and position from camera matrices
	vec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );
	direction /= direction.w;
	direction = cameraWorld * direction - origin;

	// slide the origin along the ray until it sits at the near clip plane position
	origin.xyz += direction.xyz * near / dot( direction, lookDirection );

	rayOrigin = origin.xyz;
	rayDirection = direction.xyz;

}

// Raycasting
float intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {

	// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/
	// https://tavianator.com/2011/ray_box.html
	vec3 invDir = 1.0 / rayDirection;

	// find intersection distances for each plane
	vec3 tMinPlane = invDir * ( boundsMin - rayOrigin );
	vec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );

	// get the min and max distances from each intersection
	vec3 tMinHit = min( tMaxPlane, tMinPlane );
	vec3 tMaxHit = max( tMaxPlane, tMinPlane );

	// get the furthest hit distance
	vec2 t = max( tMinHit.xx, tMinHit.yz );
	float t0 = max( t.x, t.y );

	// get the minimum hit distance
	t = min( tMaxHit.xx, tMaxHit.yz );
	float t1 = min( t.x, t.y );

	// set distance to 0.0 if the ray starts inside the box
	float dist = max( t0, 0.0 );

	return t1 >= dist ? dist : INFINITY;

}

bool intersectsTriangle(
	vec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,
	out vec3 barycoord, out vec3 norm, out float dist, out float side
) {

	// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d
	vec3 edge1 = b - a;
	vec3 edge2 = c - a;
	norm = cross( edge1, edge2 );

	float det = - dot( rayDirection, norm );
	float invdet = 1.0 / det;

	vec3 AO = rayOrigin - a;
	vec3 DAO = cross( AO, rayDirection );

	vec4 uvt;
	uvt.x = dot( edge2, DAO ) * invdet;
	uvt.y = - dot( edge1, DAO ) * invdet;
	uvt.z = dot( AO, norm ) * invdet;
	uvt.w = 1.0 - uvt.x - uvt.y;

	// set the hit information
	barycoord = uvt.wxy; // arranged in A, B, C order
	dist = uvt.z;
	side = sign( det );
	norm = side * normalize( norm );

	// add an epsilon to avoid misses between triangles
	uvt += vec4( TRI_INTERSECT_EPSILON );

	return all( greaterThanEqual( uvt, vec4( 0.0 ) ) );

}

bool intersectTriangles(
	BVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,
	inout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	bool found = false;
	vec3 localBarycoord, localNormal;
	float localDist, localSide;
	for ( uint i = offset, l = offset + count; i < l; i ++ ) {

		uvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;
		vec3 a = texelFetch1D( bvh.position, indices.x ).rgb;
		vec3 b = texelFetch1D( bvh.position, indices.y ).rgb;
		vec3 c = texelFetch1D( bvh.position, indices.z ).rgb;

		if (
			intersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )
			&& localDist < minDistance
		) {

			found = true;
			minDistance = localDist;

			faceIndices = uvec4( indices.xyz, i );
			faceNormal = localNormal;

			side = localSide;
			barycoord = localBarycoord;
			dist = localDist;

		}

	}

	return found;

}

float intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {

	vec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;
	vec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;
	return intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );

}

bool bvhIntersectFirstHit(
	BVH bvh, vec3 rayOrigin, vec3 rayDirection,

	// output variables
	inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,
	inout float side, inout float dist
) {

	// stack needs to be twice as long as the deepest tree we expect because
	// we push both the left and right child onto the stack every traversal
	int ptr = 0;
	uint stack[ 60 ];
	stack[ 0 ] = 0u;

	float triangleDistance = 1e20;
	bool found = false;
	while ( ptr > - 1 && ptr < 60 ) {

		uint currNodeIndex = stack[ ptr ];
		ptr --;

		// check if we intersect the current bounds
		float boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );
		if ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {

			continue;

		}

		uvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;
		bool isLeaf = bool( boundsInfo.x & 0xffff0000u );

		if ( isLeaf ) {

			uint count = boundsInfo.x & 0x0000ffffu;
			uint offset = boundsInfo.y;

			found = intersectTriangles(
				bvh, rayOrigin, rayDirection, offset, count, triangleDistance,
				faceIndices, faceNormal, barycoord, side, dist
			) || found;

		} else {

			uint leftIndex = currNodeIndex + 1u;
			uint splitAxis = boundsInfo.x & 0x0000ffffu;
			uint rightIndex = boundsInfo.y;

			bool leftToRight = rayDirection[ splitAxis ] >= 0.0;
			uint c1 = leftToRight ? leftIndex : rightIndex;
			uint c2 = leftToRight ? rightIndex : leftIndex;

			// set c2 in the stack so we traverse it later. We need to keep track of a pointer in
			// the stack while we traverse. The second pointer added is the one that will be
			// traversed first
			ptr ++;
			stack[ ptr ] = c2;

			ptr ++;
			stack[ ptr ] = c1;

		}

	}

	return found;

}
`
);

// node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js
var _positionVector = new Vector3();
var _normalVector = new Vector3();
var _tangentVector = new Vector3();
var _tangentVector4 = new Vector4();
var _morphVector = new Vector3();
var _temp = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _matrix = new Matrix4();
var _boneMatrix = new Matrix4();

// node_modules/@react-three/drei/core/useBVH.js
var isMesh = (child) => child.isMesh;
function useBVH(mesh, options) {
  options = {
    strategy: SAH,
    verbose: false,
    setBoundingBox: true,
    maxDepth: 40,
    maxLeafTris: 10,
    ...options
  };
  React62.useEffect(() => {
    if (mesh.current) {
      mesh.current.raycast = acceleratedRaycast;
      const geometry = mesh.current.geometry;
      geometry.computeBoundsTree = computeBoundsTree;
      geometry.disposeBoundsTree = disposeBoundsTree;
      geometry.computeBoundsTree(options);
      return () => {
        if (geometry.boundsTree) {
          geometry.disposeBoundsTree();
        }
      };
    }
  }, [mesh, JSON.stringify(options)]);
}
var Bvh = React62.forwardRef(({
  enabled = true,
  firstHitOnly = false,
  children,
  strategy = SAH,
  verbose = false,
  setBoundingBox = true,
  maxDepth = 40,
  maxLeafTris = 10,
  ...props
}, fref) => {
  const ref = React62.useRef(null);
  const raycaster = useThree((state) => state.raycaster);
  React62.useImperativeHandle(fref, () => ref.current, []);
  React62.useEffect(() => {
    if (enabled) {
      const options = {
        strategy,
        verbose,
        setBoundingBox,
        maxDepth,
        maxLeafTris
      };
      const group = ref.current;
      raycaster.firstHitOnly = firstHitOnly;
      group.traverse((child) => {
        if (isMesh(child) && !child.geometry.boundsTree && child.raycast === Mesh.prototype.raycast) {
          child.raycast = acceleratedRaycast;
          child.geometry.computeBoundsTree = computeBoundsTree;
          child.geometry.disposeBoundsTree = disposeBoundsTree;
          child.geometry.computeBoundsTree(options);
        }
      });
      return () => {
        delete raycaster.firstHitOnly;
        group.traverse((child) => {
          if (isMesh(child) && child.geometry.boundsTree) {
            child.geometry.disposeBoundsTree();
            child.raycast = Mesh.prototype.raycast;
          }
        });
      };
    }
  });
  return React62.createElement("group", _extends({
    ref
  }, props), children);
});

// node_modules/@react-three/drei/core/useContextBridge.js
var React63 = __toESM(require_react());
function useContextBridge(...contexts) {
  const cRef = React63.useRef([]);
  cRef.current = contexts.map((context10) => React63.useContext(context10));
  return React63.useMemo(() => ({
    children
  }) => contexts.reduceRight(
    (acc, Context2, i3) => React63.createElement(Context2.Provider, {
      value: cRef.current[i3],
      children: acc
    }),
    children
    /*
     * done this way in reference to:
     * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/44572#issuecomment-625878049
     * https://github.com/microsoft/TypeScript/issues/14729
     */
  ), []);
}

// node_modules/@react-three/drei/core/useAnimations.js
var React64 = __toESM(require_react());
function useAnimations(clips, root) {
  const ref = React64.useRef();
  const [actualRef] = React64.useState(() => root ? root instanceof Object3D ? {
    current: root
  } : root : ref);
  const [mixer] = React64.useState(() => new AnimationMixer(void 0));
  React64.useLayoutEffect(() => void (mixer._root = actualRef.current), [mixer, root]);
  const lazyActions = React64.useRef({});
  const [api] = React64.useState(() => {
    const actions = {};
    clips.forEach((clip) => Object.defineProperty(actions, clip.name, {
      enumerable: true,
      get() {
        if (actualRef.current) {
          return lazyActions.current[clip.name] || (lazyActions.current[clip.name] = mixer.clipAction(clip, actualRef.current));
        }
      },
      configurable: true
    }));
    return {
      ref: actualRef,
      clips,
      actions,
      names: clips.map((c6) => c6.name),
      mixer
    };
  });
  useFrame((state, delta) => mixer.update(delta));
  React64.useEffect(() => {
    const currentRoot = actualRef.current;
    return () => {
      lazyActions.current = {};
      Object.values(api.actions).forEach((action) => {
        if (currentRoot) {
          mixer.uncacheAction(action, currentRoot);
        }
      });
    };
  }, [clips]);
  React64.useEffect(() => {
    return () => {
      mixer.stopAllAction();
    };
  }, [mixer]);
  return api;
}

// node_modules/@react-three/drei/core/useIntersect.js
var React65 = __toESM(require_react());
function useIntersect(onChange) {
  const ref = React65.useRef(null);
  const check = React65.useRef(false);
  const temp5 = React65.useRef(false);
  const callback = React65.useRef(onChange);
  React65.useLayoutEffect(() => void (callback.current = onChange), [onChange]);
  React65.useEffect(() => {
    const obj = ref.current;
    if (obj) {
      const unsub1 = addEffect(() => {
        check.current = false;
        return true;
      });
      const oldOnRender = obj.onBeforeRender;
      obj.onBeforeRender = () => check.current = true;
      const unsub2 = addAfterEffect(() => {
        if (check.current !== temp5.current)
          callback.current == null ? void 0 : callback.current(temp5.current = check.current);
        return true;
      });
      return () => {
        obj.onBeforeRender = oldOnRender;
        unsub1();
        unsub2();
      };
    }
  }, []);
  return ref;
}

// node_modules/@react-three/drei/core/useBoxProjectedEnv.js
var React66 = __toESM(require_react());
var worldposReplace = (
  /* glsl */
  `
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
  vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
  #ifdef BOX_PROJECTED_ENV_MAP
    vWorldPosition = worldPosition.xyz;
  #endif
#endif
`
);
var boxProjectDefinitions = (
  /*glsl */
  `
#ifdef BOX_PROJECTED_ENV_MAP
  uniform vec3 envMapSize;
  uniform vec3 envMapPosition;
  varying vec3 vWorldPosition;
    
  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {
    vec3 nDir = normalize( v );
    vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;
    vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;
    vec3 rbminmax;
    rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;
    rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;
    rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;
    float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );
    vec3 boxIntersection = vWorldPosition + nDir * correction;    
    return boxIntersection - cubePos;
  }
#endif
`
);
var getIBLIrradiance_patch = (
  /* glsl */
  `
#ifdef BOX_PROJECTED_ENV_MAP
  worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );
#endif
`
);
var getIBLRadiance_patch = (
  /* glsl */
  `
#ifdef BOX_PROJECTED_ENV_MAP
  reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );
#endif
`
);
function boxProjectedEnvMap(shader, envMapPosition, envMapSize) {
  shader.defines.BOX_PROJECTED_ENV_MAP = true;
  shader.uniforms.envMapPosition = {
    value: envMapPosition
  };
  shader.uniforms.envMapSize = {
    value: envMapSize
  };
  shader.vertexShader = `
  varying vec3 vWorldPosition;
  ${shader.vertexShader.replace("#include <worldpos_vertex>", worldposReplace)}`;
  shader.fragmentShader = `
    ${boxProjectDefinitions}
    ${shader.fragmentShader.replace("#include <envmap_physical_pars_fragment>", ShaderChunk.envmap_physical_pars_fragment).replace("vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
         ${getIBLIrradiance_patch}
         `).replace("reflectVec = inverseTransformDirection( reflectVec, viewMatrix );", `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
         ${getIBLRadiance_patch}
        `)}`;
}
function useBoxProjectedEnv(position2 = new Vector3(), size = new Vector3()) {
  const [config2] = React66.useState(() => ({
    position: new Vector3(),
    size: new Vector3()
  }));
  applyProps(config2, {
    position: position2,
    size
  });
  const ref = React66.useRef(null);
  const spread = React66.useMemo(() => ({
    ref,
    onBeforeCompile: (shader) => boxProjectedEnvMap(shader, config2.position, config2.size),
    customProgramCacheKey: () => JSON.stringify(config2.position.toArray()) + JSON.stringify(config2.size.toArray())
  }), [...config2.position.toArray(), ...config2.size.toArray()]);
  React66.useLayoutEffect(() => void (ref.current.needsUpdate = true), [config2]);
  return spread;
}

// node_modules/@react-three/drei/core/BBAnchor.js
var React67 = __toESM(require_react());
var boundingBox4 = new Box3();
var boundingBoxSize = new Vector3();
var BBAnchor = ({
  anchor,
  ...props
}) => {
  const ref = React67.useRef(null);
  const parentRef = React67.useRef(null);
  React67.useEffect(() => {
    var _ref$current, _ref$current$parent;
    if ((_ref$current = ref.current) != null && (_ref$current$parent = _ref$current.parent) != null && _ref$current$parent.parent) {
      parentRef.current = ref.current.parent;
      ref.current.parent.parent.add(ref.current);
    }
  }, []);
  useFrame(() => {
    if (parentRef.current) {
      boundingBox4.setFromObject(parentRef.current);
      boundingBox4.getSize(boundingBoxSize);
      ref.current.position.set(parentRef.current.position.x + boundingBoxSize.x * anchor[0] / 2, parentRef.current.position.y + boundingBoxSize.y * anchor[1] / 2, parentRef.current.position.z + boundingBoxSize.z * anchor[2] / 2);
    }
  });
  return React67.createElement("group", _extends({
    ref
  }, props));
};

// node_modules/@react-three/drei/core/useTrailTexture.js
var import_react16 = __toESM(require_react());
function smoothAverage(current, measurement, smoothing = 0.9) {
  return measurement * smoothing + current * (1 - smoothing);
}
var easeCircleOut = (x) => Math.sqrt(1 - Math.pow(x - 1, 2));
var TrailTexture = class {
  constructor({
    size = 256,
    maxAge = 750,
    radius = 0.3,
    intensity = 0.2,
    interpolate: interpolate2 = 0,
    smoothing = 0,
    minForce = 0.3,
    blend = "screen",
    // source-over is canvas default. Others are slower
    ease = easeCircleOut
  } = {}) {
    this.size = size;
    this.maxAge = maxAge;
    this.radius = radius;
    this.intensity = intensity;
    this.ease = ease;
    this.interpolate = interpolate2;
    this.smoothing = smoothing;
    this.minForce = minForce;
    this.blend = blend;
    this.trail = [];
    this.force = 0;
    this.initTexture();
  }
  initTexture() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.canvas.height = this.size;
    this.ctx = this.canvas.getContext("2d");
    this.ctx.fillStyle = "black";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.texture = new Texture(this.canvas);
    this.canvas.id = "touchTexture";
    this.canvas.style.width = this.canvas.style.height = `${this.canvas.width}px`;
  }
  update(delta) {
    this.clear();
    this.trail.forEach((point, i3) => {
      point.age += delta * 1e3;
      if (point.age > this.maxAge) {
        this.trail.splice(i3, 1);
      }
    });
    if (!this.trail.length)
      this.force = 0;
    this.trail.forEach((point) => {
      this.drawTouch(point);
    });
    this.texture.needsUpdate = true;
  }
  clear() {
    this.ctx.globalCompositeOperation = "source-over";
    this.ctx.fillStyle = "black";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  addTouch(point) {
    const last = this.trail[this.trail.length - 1];
    if (last) {
      const dx = last.x - point.x;
      const dy = last.y - point.y;
      const dd = dx * dx + dy * dy;
      const force = Math.max(this.minForce, Math.min(dd * 1e4, 1));
      this.force = smoothAverage(force, this.force, this.smoothing);
      if (!!this.interpolate) {
        const lines = Math.ceil(dd / Math.pow(this.radius * 0.5 / this.interpolate, 2));
        if (lines > 1) {
          for (let i3 = 1; i3 < lines; i3++) {
            this.trail.push({
              x: last.x - dx / lines * i3,
              y: last.y - dy / lines * i3,
              age: 0,
              force
            });
          }
        }
      }
    }
    this.trail.push({
      x: point.x,
      y: point.y,
      age: 0,
      force: this.force
    });
  }
  drawTouch(point) {
    const pos = {
      x: point.x * this.size,
      y: (1 - point.y) * this.size
    };
    let intensity = 1;
    if (point.age < this.maxAge * 0.3) {
      intensity = this.ease(point.age / (this.maxAge * 0.3));
    } else {
      intensity = this.ease(1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7));
    }
    intensity *= point.force;
    this.ctx.globalCompositeOperation = this.blend;
    const radius = this.size * this.radius * intensity;
    const grd = this.ctx.createRadialGradient(pos.x, pos.y, Math.max(0, radius * 0.25), pos.x, pos.y, Math.max(0, radius));
    grd.addColorStop(0, `rgba(255, 255, 255, ${this.intensity})`);
    grd.addColorStop(1, `rgba(0, 0, 0, 0.0)`);
    this.ctx.beginPath();
    this.ctx.fillStyle = grd;
    this.ctx.arc(pos.x, pos.y, Math.max(0, radius), 0, Math.PI * 2);
    this.ctx.fill();
  }
};
function useTrailTexture(config2 = {}) {
  const {
    size,
    maxAge,
    radius,
    intensity,
    interpolate: interpolate2,
    smoothing,
    minForce,
    blend,
    ease
  } = config2;
  const trail = (0, import_react16.useMemo)(() => new TrailTexture(config2), [size, maxAge, radius, intensity, interpolate2, smoothing, minForce, blend, ease]);
  useFrame((_, delta) => void trail.update(delta));
  const onMove = (0, import_react16.useCallback)((e2) => trail.addTouch(e2.uv), [trail]);
  return [trail.texture, onMove];
}

// node_modules/@react-three/drei/core/Example.js
var React69 = __toESM(require_react());

// node_modules/@react-three/drei/core/Center.js
var React68 = __toESM(require_react());
var Center = React68.forwardRef(function Center2({
  children,
  disable,
  disableX,
  disableY,
  disableZ,
  left,
  right,
  top,
  bottom,
  front,
  back,
  onCentered,
  precise = true,
  cacheKey: cacheKey2 = 0,
  ...props
}, fRef) {
  const ref = React68.useRef(null);
  const outer = React68.useRef(null);
  const inner = React68.useRef(null);
  React68.useLayoutEffect(() => {
    outer.current.matrixWorld.identity();
    const box3 = new Box3().setFromObject(inner.current, precise);
    const center = new Vector3();
    const sphere = new Sphere();
    const width = box3.max.x - box3.min.x;
    const height = box3.max.y - box3.min.y;
    const depth = box3.max.z - box3.min.z;
    box3.getCenter(center);
    box3.getBoundingSphere(sphere);
    const vAlign = top ? height / 2 : bottom ? -height / 2 : 0;
    const hAlign = left ? -width / 2 : right ? width / 2 : 0;
    const dAlign = front ? depth / 2 : back ? -depth / 2 : 0;
    outer.current.position.set(disable || disableX ? 0 : -center.x + hAlign, disable || disableY ? 0 : -center.y + vAlign, disable || disableZ ? 0 : -center.z + dAlign);
    if (typeof onCentered !== "undefined") {
      onCentered({
        parent: ref.current.parent,
        container: ref.current,
        width,
        height,
        depth,
        boundingBox: box3,
        boundingSphere: sphere,
        center,
        verticalAlignment: vAlign,
        horizontalAlignment: hAlign,
        depthAlignment: dAlign
      });
    }
  }, [cacheKey2, onCentered, top, left, front, disable, disableX, disableY, disableZ, precise, right, bottom, back]);
  React68.useImperativeHandle(fRef, () => ref.current, []);
  return React68.createElement("group", _extends({
    ref
  }, props), React68.createElement("group", {
    ref: outer
  }, React68.createElement("group", {
    ref: inner
  }, children)));
});

// node_modules/@react-three/drei/core/Example.js
var Example = React69.forwardRef(({
  font,
  color = "#cbcbcb",
  bevelSize = 0.04,
  debug = false,
  children,
  ...props
}, fref) => {
  const [counter, setCounter] = React69.useState(0);
  const incr = React69.useCallback((x = 1) => setCounter(counter + x), [counter]);
  const decr = React69.useCallback((x = 1) => setCounter(counter - x), [counter]);
  const api = React69.useMemo(() => ({
    incr,
    decr
  }), [incr, decr]);
  React69.useImperativeHandle(fref, () => api, [api]);
  return React69.createElement("group", props, React69.createElement(React69.Suspense, {
    fallback: null
  }, React69.createElement(Center, {
    top: true,
    cacheKey: JSON.stringify({
      counter,
      font
    })
  }, React69.createElement(Text3D, {
    bevelEnabled: true,
    bevelSize,
    font
  }, debug ? React69.createElement("meshNormalMaterial", {
    wireframe: true
  }) : React69.createElement("meshStandardMaterial", {
    color
  }), counter))), children);
});

// node_modules/@react-three/drei/core/SpriteAnimator.js
var React70 = __toESM(require_react());
var SpriteAnimator = ({
  startFrame,
  endFrame,
  fps,
  frameName,
  textureDataURL,
  textureImageURL,
  loop: loop2,
  numberOfFrames,
  autoPlay,
  animationNames,
  onStart,
  onEnd,
  onLoopEnd,
  onFrame,
  play,
  pause,
  flipX,
  alphaTest,
  children,
  ...props
}, fref) => {
  useThree((state) => state.viewport);
  const spriteData = React70.useRef(null);
  const [isJsonReady, setJsonReady] = React70.useState(false);
  const matRef = React70.useRef();
  const spriteRef = React70.useRef();
  const timerOffset = React70.useRef(window.performance.now());
  const textureData = React70.useRef();
  const currentFrame2 = React70.useRef(startFrame || 0);
  const currentFrameName = React70.useRef(frameName || "");
  const fpsInterval = 1e3 / (fps || 30);
  const [spriteTexture, setSpriteTexture] = React70.useState(new Texture());
  const totalFrames = React70.useRef(0);
  const [aspect, setAspect] = React70.useState([1, 1, 1]);
  const flipOffset = flipX ? -1 : 1;
  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {
    const textureLoader = new TextureLoader();
    const jsonPromise = fetch(jsonUrl).then((response) => response.json());
    const texturePromise = new Promise((resolve2) => {
      textureLoader.load(textureUrl, resolve2);
    });
    Promise.all([jsonPromise, texturePromise]).then((response) => {
      callback(response[0], response[1]);
    });
  }
  const calculateAspectRatio = (width, height) => {
    const aspectRatio = height / width;
    spriteRef.current.scale.set(1, aspectRatio, 1);
    return [1, aspectRatio, 1];
  };
  React70.useEffect(() => {
    if (textureDataURL && textureImageURL) {
      loadJsonAndTextureAndExecuteCallback(textureDataURL, textureImageURL, parseSpriteData);
    } else if (textureImageURL) {
      const textureLoader = new TextureLoader();
      new Promise((resolve2) => {
        textureLoader.load(textureImageURL, resolve2);
      }).then((texture) => {
        parseSpriteData(null, texture);
      });
    }
  }, []);
  React70.useLayoutEffect(() => {
    modifySpritePosition();
  }, [spriteTexture]);
  React70.useEffect(() => {
  }, [pause]);
  React70.useEffect(() => {
    if (currentFrameName.current !== frameName && frameName) {
      currentFrame2.current = 0;
      currentFrameName.current = frameName;
    }
  }, [frameName]);
  const parseSpriteData = (json, _spriteTexture) => {
    if (json === null) {
      if (_spriteTexture && numberOfFrames) {
        const width = _spriteTexture.image.width;
        const height = _spriteTexture.image.height;
        const frameWidth = width / numberOfFrames;
        const frameHeight = height;
        textureData.current = _spriteTexture;
        totalFrames.current = numberOfFrames;
        spriteData.current = {
          frames: [],
          meta: {
            version: "1.0",
            size: {
              w: width,
              h: height
            },
            scale: "1"
          }
        };
        if (parseInt(frameWidth.toString(), 10) === frameWidth) {
          for (let i3 = 0; i3 < numberOfFrames; i3++) {
            spriteData.current.frames.push({
              frame: {
                x: i3 * frameWidth,
                y: 0,
                w: frameWidth,
                h: frameHeight
              },
              rotated: false,
              trimmed: false,
              spriteSourceSize: {
                x: 0,
                y: 0,
                w: frameWidth,
                h: frameHeight
              },
              sourceSize: {
                w: frameWidth,
                h: height
              }
            });
          }
        }
      }
    } else if (_spriteTexture) {
      spriteData.current = json;
      spriteData.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();
      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;
      textureData.current = _spriteTexture;
      const {
        w,
        h
      } = getFirstItem(json.frames).sourceSize;
      const aspect2 = calculateAspectRatio(w, h);
      setAspect(aspect2);
      if (matRef.current) {
        matRef.current.map = _spriteTexture;
      }
    }
    _spriteTexture.premultiplyAlpha = false;
    setSpriteTexture(_spriteTexture);
  };
  const parseFrames = () => {
    const sprites = {};
    const data = spriteData.current;
    const delimiters = animationNames;
    if (delimiters) {
      for (let i3 = 0; i3 < delimiters.length; i3++) {
        sprites[delimiters[i3]] = [];
        for (let innerKey in data["frames"]) {
          const value = data["frames"][innerKey];
          const frameData = value["frame"];
          const x = frameData["x"];
          const y = frameData["y"];
          const width = frameData["w"];
          const height = frameData["h"];
          const sourceWidth = value["sourceSize"]["w"];
          const sourceHeight = value["sourceSize"]["h"];
          if (typeof innerKey === "string" && innerKey.toLowerCase().indexOf(delimiters[i3].toLowerCase()) !== -1) {
            sprites[delimiters[i3]].push({
              x,
              y,
              w: width,
              h: height,
              frame: frameData,
              sourceSize: {
                w: sourceWidth,
                h: sourceHeight
              }
            });
          }
        }
      }
    }
    return sprites;
  };
  const modifySpritePosition = () => {
    if (!spriteData.current)
      return;
    const {
      meta: {
        size: metaInfo
      },
      frames
    } = spriteData.current;
    const {
      w: frameW,
      h: frameH
    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {
      w: 0,
      h: 0
    } : {
      w: 0,
      h: 0
    };
    matRef.current.map.wrapS = matRef.current.map.wrapT = RepeatWrapping;
    matRef.current.map.center.set(0, 0);
    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));
    const framesV = (metaInfo.h - 1) / frameH;
    const frameOffsetY = 1 / framesV;
    matRef.current.map.offset.x = 0;
    matRef.current.map.offset.y = 1 - frameOffsetY;
    setJsonReady(true);
    if (onStart)
      onStart({
        currentFrameName: frameName,
        currentFrame: currentFrame2.current
      });
  };
  const runAnimation = () => {
    const now2 = window.performance.now();
    const diff = now2 - timerOffset.current;
    const {
      meta: {
        size: metaInfo
      },
      frames
    } = spriteData.current;
    const {
      w: frameW,
      h: frameH
    } = getFirstItem(frames).sourceSize;
    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];
    let finalValX = 0;
    let finalValY = 0;
    const _endFrame = endFrame || spriteFrames.length - 1;
    if (currentFrame2.current > _endFrame) {
      currentFrame2.current = loop2 ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;
      if (loop2) {
        onLoopEnd == null ? void 0 : onLoopEnd({
          currentFrameName: frameName,
          currentFrame: currentFrame2.current
        });
      } else {
        onEnd == null ? void 0 : onEnd({
          currentFrameName: frameName,
          currentFrame: currentFrame2.current
        });
      }
      if (!loop2)
        return;
    }
    if (diff <= fpsInterval)
      return;
    timerOffset.current = now2 - diff % fpsInterval;
    calculateAspectRatio(frameW, frameH);
    const framesH = (metaInfo.w - 1) / frameW;
    const framesV = (metaInfo.h - 1) / frameH;
    const {
      frame: {
        x: frameX,
        y: frameY
      },
      sourceSize: {
        w: originalSizeX,
        h: originalSizeY
      }
    } = spriteFrames[currentFrame2.current];
    const frameOffsetX = 1 / framesH;
    const frameOffsetY = 1 / framesV;
    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;
    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);
    matRef.current.map.offset.x = finalValX;
    matRef.current.map.offset.y = finalValY;
    currentFrame2.current += 1;
  };
  useFrame((state, delta) => {
    var _spriteData$current, _matRef$current;
    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {
      return;
    }
    if (pause) {
      return;
    }
    if (autoPlay || play) {
      runAnimation();
      onFrame && onFrame({
        currentFrameName: currentFrameName.current,
        currentFrame: currentFrame2.current
      });
    }
  });
  const getFirstItem = (param) => {
    if (Array.isArray(param)) {
      return param[0];
    } else if (typeof param === "object" && param !== null) {
      const keys = Object.keys(param);
      return param[keys[0]][0];
    } else {
      return {
        w: 0,
        h: 0
      };
    }
  };
  return React70.createElement("group", props, React70.createElement(React70.Suspense, {
    fallback: null
  }, React70.createElement("sprite", {
    ref: spriteRef,
    scale: aspect
  }, React70.createElement("spriteMaterial", {
    toneMapped: false,
    ref: matRef,
    map: spriteTexture,
    transparent: true,
    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0
  }))), children);
};

// node_modules/@react-three/drei/core/CurveModifier.js
var React71 = __toESM(require_react());
var CurveModifier = React71.forwardRef(({
  children,
  curve
}, ref) => {
  const [scene] = React71.useState(() => new Scene());
  const [obj, set] = React71.useState();
  const modifier = React71.useRef();
  React71.useEffect(() => {
    modifier.current = new Flow(scene.children[0]);
    set(modifier.current.object3D);
  }, [children]);
  React71.useEffect(() => {
    var _modifier$current;
    if (curve)
      (_modifier$current = modifier.current) == null ? void 0 : _modifier$current.updateCurve(0, curve);
  }, [curve]);
  React71.useImperativeHandle(ref, () => ({
    moveAlongCurve: (val) => {
      var _modifier$current2;
      (_modifier$current2 = modifier.current) == null ? void 0 : _modifier$current2.moveAlongCurve(val);
    }
  }));
  return React71.createElement(React71.Fragment, null, createPortal(children, scene), obj && React71.createElement("primitive", {
    object: obj
  }));
});

// node_modules/@react-three/drei/core/MeshDistortMaterial.js
var React72 = __toESM(require_react());

// node_modules/@react-three/drei/helpers/glsl/distort.vert.glsl.js
var distort = "#define GLSLIFY 1\nvec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}";

// node_modules/@react-three/drei/core/MeshDistortMaterial.js
var DistortMaterialImpl = class extends MeshPhysicalMaterial {
  constructor(parameters = {}) {
    super(parameters);
    this.setValues(parameters);
    this._time = {
      value: 0
    };
    this._distort = {
      value: 0.4
    };
    this._radius = {
      value: 1
    };
  }
  onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.radius = this._radius;
    shader.uniforms.distort = this._distort;
    shader.vertexShader = `
      uniform float time;
      uniform float radius;
      uniform float distort;
      ${distort}
      ${shader.vertexShader}
    `;
    shader.vertexShader = shader.vertexShader.replace("#include <begin_vertex>", `
        float updateTime = time / 50.0;
        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));
        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));
        `);
  }
  get time() {
    return this._time.value;
  }
  set time(v4) {
    this._time.value = v4;
  }
  get distort() {
    return this._distort.value;
  }
  set distort(v4) {
    this._distort.value = v4;
  }
  get radius() {
    return this._radius.value;
  }
  set radius(v4) {
    this._radius.value = v4;
  }
};
var MeshDistortMaterial = React72.forwardRef(({
  speed = 1,
  ...props
}, ref) => {
  const [material] = React72.useState(() => new DistortMaterialImpl());
  useFrame((state) => material && (material.time = state.clock.getElapsedTime() * speed));
  return React72.createElement("primitive", _extends({
    object: material,
    ref,
    attach: "material"
  }, props));
});

// node_modules/@react-three/drei/core/MeshWobbleMaterial.js
var React73 = __toESM(require_react());
var WobbleMaterialImpl = class extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);
    this.setValues(parameters);
    this._time = {
      value: 0
    };
    this._factor = {
      value: 1
    };
  }
  onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.factor = this._factor;
    shader.vertexShader = `
      uniform float time;
      uniform float factor;
      ${shader.vertexShader}
    `;
    shader.vertexShader = shader.vertexShader.replace("#include <begin_vertex>", `float theta = sin( time + position.y ) / 2.0 * factor;
        float c = cos( theta );
        float s = sin( theta );
        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
        vec3 transformed = vec3( position ) * m;
        vNormal = vNormal * m;`);
  }
  get time() {
    return this._time.value;
  }
  set time(v4) {
    this._time.value = v4;
  }
  get factor() {
    return this._factor.value;
  }
  set factor(v4) {
    this._factor.value = v4;
  }
};
var MeshWobbleMaterial = React73.forwardRef(({
  speed = 1,
  ...props
}, ref) => {
  const [material] = React73.useState(() => new WobbleMaterialImpl());
  useFrame((state) => material && (material.time = state.clock.getElapsedTime() * speed));
  return React73.createElement("primitive", _extends({
    object: material,
    ref,
    attach: "material"
  }, props));
});

// node_modules/@react-three/drei/core/MeshReflectorMaterial.js
var React74 = __toESM(require_react());

// node_modules/@react-three/drei/materials/ConvolutionMaterial.js
var ConvolutionMaterial = class extends ShaderMaterial {
  constructor(texelSize = new Vector2()) {
    super({
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        resolution: new Uniform(new Vector2()),
        texelSize: new Uniform(new Vector2()),
        halfTexelSize: new Uniform(new Vector2()),
        kernel: new Uniform(0),
        scale: new Uniform(1),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(1),
        minDepthThreshold: new Uniform(0),
        maxDepthThreshold: new Uniform(1),
        depthScale: new Uniform(0),
        depthToBlurRatioBias: new Uniform(0.25)
      },
      fragmentShader: `#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
            depthFactor *= depthScale;
            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));
          #endif
          
          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));
          gl_FragColor = sum * 0.25 ;

          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <encodings_fragment>
        }`,
      vertexShader: `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false
    });
    this.toneMapped = false;
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernel = new Float32Array([0, 1, 2, 2, 3]);
  }
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
    this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);
  }
  setResolution(resolution) {
    this.uniforms.resolution.value.copy(resolution);
  }
};

// node_modules/@react-three/drei/materials/BlurPass.js
var BlurPass = class {
  constructor({
    gl,
    resolution,
    width = 500,
    height = 500,
    minDepthThreshold = 0,
    maxDepthThreshold = 1,
    depthScale = 0,
    depthToBlurRatioBias = 0.25
  }) {
    this.renderToScreen = false;
    this.renderTargetA = new WebGLRenderTarget(resolution, resolution, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer: false,
      depthBuffer: false,
      type: HalfFloatType
    });
    this.renderTargetB = this.renderTargetA.clone();
    this.convolutionMaterial = new ConvolutionMaterial();
    this.convolutionMaterial.setTexelSize(1 / width, 1 / height);
    this.convolutionMaterial.setResolution(new Vector2(width, height));
    this.scene = new Scene();
    this.camera = new Camera();
    this.convolutionMaterial.uniforms.minDepthThreshold.value = minDepthThreshold;
    this.convolutionMaterial.uniforms.maxDepthThreshold.value = maxDepthThreshold;
    this.convolutionMaterial.uniforms.depthScale.value = depthScale;
    this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = depthToBlurRatioBias;
    this.convolutionMaterial.defines.USE_DEPTH = depthScale > 0;
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new BufferAttribute(vertices, 3));
    geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
    this.screen = new Mesh(geometry, this.convolutionMaterial);
    this.screen.frustumCulled = false;
    this.scene.add(this.screen);
  }
  render(renderer, inputBuffer, outputBuffer) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    let material = this.convolutionMaterial;
    let uniforms = material.uniforms;
    uniforms.depthBuffer.value = inputBuffer.depthTexture;
    const kernel = material.kernel;
    let lastRT = inputBuffer;
    let destRT;
    let i3, l2;
    for (i3 = 0, l2 = kernel.length - 1; i3 < l2; ++i3) {
      destRT = (i3 & 1) === 0 ? renderTargetA : renderTargetB;
      uniforms.kernel.value = kernel[i3];
      uniforms.inputBuffer.value = lastRT.texture;
      renderer.setRenderTarget(destRT);
      renderer.render(scene, camera);
      lastRT = destRT;
    }
    uniforms.kernel.value = kernel[i3];
    uniforms.inputBuffer.value = lastRT.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
};

// node_modules/@react-three/drei/materials/MeshReflectorMaterial.js
var MeshReflectorMaterial = class extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);
    this._tDepth = {
      value: null
    };
    this._distortionMap = {
      value: null
    };
    this._tDiffuse = {
      value: null
    };
    this._tDiffuseBlur = {
      value: null
    };
    this._textureMatrix = {
      value: null
    };
    this._hasBlur = {
      value: false
    };
    this._mirror = {
      value: 0
    };
    this._mixBlur = {
      value: 0
    };
    this._blurStrength = {
      value: 0.5
    };
    this._minDepthThreshold = {
      value: 0.9
    };
    this._maxDepthThreshold = {
      value: 1
    };
    this._depthScale = {
      value: 0
    };
    this._depthToBlurRatioBias = {
      value: 0.25
    };
    this._distortion = {
      value: 1
    };
    this._mixContrast = {
      value: 1
    };
    this.setValues(parameters);
  }
  onBeforeCompile(shader) {
    var _shader$defines;
    if (!((_shader$defines = shader.defines) != null && _shader$defines.USE_UV)) {
      shader.defines.USE_UV = "";
    }
    shader.uniforms.hasBlur = this._hasBlur;
    shader.uniforms.tDiffuse = this._tDiffuse;
    shader.uniforms.tDepth = this._tDepth;
    shader.uniforms.distortionMap = this._distortionMap;
    shader.uniforms.tDiffuseBlur = this._tDiffuseBlur;
    shader.uniforms.textureMatrix = this._textureMatrix;
    shader.uniforms.mirror = this._mirror;
    shader.uniforms.mixBlur = this._mixBlur;
    shader.uniforms.mixStrength = this._blurStrength;
    shader.uniforms.minDepthThreshold = this._minDepthThreshold;
    shader.uniforms.maxDepthThreshold = this._maxDepthThreshold;
    shader.uniforms.depthScale = this._depthScale;
    shader.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias;
    shader.uniforms.distortion = this._distortion;
    shader.uniforms.mixContrast = this._mixContrast;
    shader.vertexShader = `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${shader.vertexShader}`;
    shader.vertexShader = shader.vertexShader.replace("#include <project_vertex>", `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`);
    shader.fragmentShader = `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
			  uniform float cameraFar;
        uniform bool hasBlur;
        uniform float mixBlur;
        uniform float mirror;
        uniform float mixStrength;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float mixContrast;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec4 my_vUv;
        ${shader.fragmentShader}`;
    shader.fragmentShader = shader.fragmentShader.replace("#include <emissivemap_fragment>", `#include <emissivemap_fragment>

      float distortionFactor = 0.0;
      #ifdef USE_DISTORTION
        distortionFactor = texture2D(distortionMap, vUv).r * distortion;
      #endif

      vec4 new_vUv = my_vUv;
      new_vUv.x += distortionFactor;
      new_vUv.y += distortionFactor;

      vec4 base = texture2DProj(tDiffuse, new_vUv);
      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);

      vec4 merge = base;

      #ifdef USE_NORMALMAP
        vec2 normal_uv = vec2(0.0);
        vec4 normalColor = texture2D(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;
        vec4 base_normal = texture2D(tDiffuse, normal_uv);
        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);
        merge = base_normal;
        blur = blur_normal;
      #endif

      float depthFactor = 0.0001;
      float blurFactor = 0.0;

      #ifdef USE_DEPTH
        vec4 depth = texture2DProj(tDepth, new_vUv);
        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
        depthFactor *= depthScale;
        depthFactor = max(0.0001, min(1.0, depthFactor));

        #ifdef USE_BLUR
          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);
          merge = merge * min(1.0, depthFactor + 0.5);
        #else
          merge = merge * depthFactor;
        #endif

      #endif

      float reflectorRoughnessFactor = roughness;
      #ifdef USE_ROUGHNESSMAP
        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );
        reflectorRoughnessFactor *= reflectorTexelRoughness.g;
      #endif

      #ifdef USE_BLUR
        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);
        merge = mix(merge, blur, blurFactor);
      #endif

      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);
      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;
      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;
      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;

      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);
      `);
  }
  get tDiffuse() {
    return this._tDiffuse.value;
  }
  set tDiffuse(v4) {
    this._tDiffuse.value = v4;
  }
  get tDepth() {
    return this._tDepth.value;
  }
  set tDepth(v4) {
    this._tDepth.value = v4;
  }
  get distortionMap() {
    return this._distortionMap.value;
  }
  set distortionMap(v4) {
    this._distortionMap.value = v4;
  }
  get tDiffuseBlur() {
    return this._tDiffuseBlur.value;
  }
  set tDiffuseBlur(v4) {
    this._tDiffuseBlur.value = v4;
  }
  get textureMatrix() {
    return this._textureMatrix.value;
  }
  set textureMatrix(v4) {
    this._textureMatrix.value = v4;
  }
  get hasBlur() {
    return this._hasBlur.value;
  }
  set hasBlur(v4) {
    this._hasBlur.value = v4;
  }
  get mirror() {
    return this._mirror.value;
  }
  set mirror(v4) {
    this._mirror.value = v4;
  }
  get mixBlur() {
    return this._mixBlur.value;
  }
  set mixBlur(v4) {
    this._mixBlur.value = v4;
  }
  get mixStrength() {
    return this._blurStrength.value;
  }
  set mixStrength(v4) {
    this._blurStrength.value = v4;
  }
  get minDepthThreshold() {
    return this._minDepthThreshold.value;
  }
  set minDepthThreshold(v4) {
    this._minDepthThreshold.value = v4;
  }
  get maxDepthThreshold() {
    return this._maxDepthThreshold.value;
  }
  set maxDepthThreshold(v4) {
    this._maxDepthThreshold.value = v4;
  }
  get depthScale() {
    return this._depthScale.value;
  }
  set depthScale(v4) {
    this._depthScale.value = v4;
  }
  get depthToBlurRatioBias() {
    return this._depthToBlurRatioBias.value;
  }
  set depthToBlurRatioBias(v4) {
    this._depthToBlurRatioBias.value = v4;
  }
  get distortion() {
    return this._distortion.value;
  }
  set distortion(v4) {
    this._distortion.value = v4;
  }
  get mixContrast() {
    return this._mixContrast.value;
  }
  set mixContrast(v4) {
    this._mixContrast.value = v4;
  }
};

// node_modules/@react-three/drei/core/MeshReflectorMaterial.js
extend({
  MeshReflectorMaterialImpl: MeshReflectorMaterial
});
var MeshReflectorMaterial2 = React74.forwardRef(({
  mixBlur = 0,
  mixStrength = 1,
  resolution = 256,
  blur = [0, 0],
  minDepthThreshold = 0.9,
  maxDepthThreshold = 1,
  depthScale = 0,
  depthToBlurRatioBias = 0.25,
  mirror = 0,
  distortion = 1,
  mixContrast = 1,
  distortionMap,
  reflectorOffset = 0,
  ...props
}, ref) => {
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  blur = Array.isArray(blur) ? blur : [blur, blur];
  const hasBlur = blur[0] + blur[1] > 0;
  const materialRef = React74.useRef(null);
  const [reflectorPlane] = React74.useState(() => new Plane());
  const [normal2] = React74.useState(() => new Vector3());
  const [reflectorWorldPosition] = React74.useState(() => new Vector3());
  const [cameraWorldPosition] = React74.useState(() => new Vector3());
  const [rotationMatrix] = React74.useState(() => new Matrix4());
  const [lookAtPosition] = React74.useState(() => new Vector3(0, 0, -1));
  const [clipPlane] = React74.useState(() => new Vector4());
  const [view] = React74.useState(() => new Vector3());
  const [target2] = React74.useState(() => new Vector3());
  const [q] = React74.useState(() => new Vector4());
  const [textureMatrix] = React74.useState(() => new Matrix4());
  const [virtualCamera] = React74.useState(() => new PerspectiveCamera());
  const beforeRender = React74.useCallback(() => {
    var _materialRef$current;
    const parent = materialRef.current.parent || ((_materialRef$current = materialRef.current) == null ? void 0 : _materialRef$current.__r3f.parent);
    if (!parent)
      return;
    reflectorWorldPosition.setFromMatrixPosition(parent.matrixWorld);
    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    rotationMatrix.extractRotation(parent.matrixWorld);
    normal2.set(0, 0, 1);
    normal2.applyMatrix4(rotationMatrix);
    reflectorWorldPosition.addScaledVector(normal2, reflectorOffset);
    view.subVectors(reflectorWorldPosition, cameraWorldPosition);
    if (view.dot(normal2) > 0)
      return;
    view.reflect(normal2).negate();
    view.add(reflectorWorldPosition);
    rotationMatrix.extractRotation(camera.matrixWorld);
    lookAtPosition.set(0, 0, -1);
    lookAtPosition.applyMatrix4(rotationMatrix);
    lookAtPosition.add(cameraWorldPosition);
    target2.subVectors(reflectorWorldPosition, lookAtPosition);
    target2.reflect(normal2).negate();
    target2.add(reflectorWorldPosition);
    virtualCamera.position.copy(view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(rotationMatrix);
    virtualCamera.up.reflect(normal2);
    virtualCamera.lookAt(target2);
    virtualCamera.far = camera.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
    textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    textureMatrix.multiply(virtualCamera.projectionMatrix);
    textureMatrix.multiply(virtualCamera.matrixWorldInverse);
    textureMatrix.multiply(parent.matrixWorld);
    reflectorPlane.setFromNormalAndCoplanarPoint(normal2, reflectorWorldPosition);
    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    q.z = -1;
    q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(2 / clipPlane.dot(q));
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = clipPlane.z + 1;
    projectionMatrix.elements[14] = clipPlane.w;
  }, [camera, reflectorOffset]);
  const [fbo1, fbo2, blurpass, reflectorProps] = React74.useMemo(() => {
    const parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType
    };
    const fbo12 = new WebGLRenderTarget(resolution, resolution, parameters);
    fbo12.depthBuffer = true;
    fbo12.depthTexture = new DepthTexture(resolution, resolution);
    fbo12.depthTexture.format = DepthFormat;
    fbo12.depthTexture.type = UnsignedShortType;
    const fbo22 = new WebGLRenderTarget(resolution, resolution, parameters);
    const blurpass2 = new BlurPass({
      gl,
      resolution,
      width: blur[0],
      height: blur[1],
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias
    });
    const reflectorProps2 = {
      mirror,
      textureMatrix,
      mixBlur,
      tDiffuse: fbo12.texture,
      tDepth: fbo12.depthTexture,
      tDiffuseBlur: fbo22.texture,
      hasBlur,
      mixStrength,
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias,
      distortion,
      distortionMap,
      mixContrast,
      "defines-USE_BLUR": hasBlur ? "" : void 0,
      "defines-USE_DEPTH": depthScale > 0 ? "" : void 0,
      "defines-USE_DISTORTION": distortionMap ? "" : void 0
    };
    return [fbo12, fbo22, blurpass2, reflectorProps2];
  }, [gl, blur, textureMatrix, resolution, mirror, hasBlur, mixBlur, mixStrength, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, distortion, distortionMap, mixContrast]);
  useFrame(() => {
    var _materialRef$current2;
    const parent = materialRef.current.parent || ((_materialRef$current2 = materialRef.current) == null ? void 0 : _materialRef$current2.__r3f.parent);
    if (!parent)
      return;
    parent.visible = false;
    const currentXrEnabled = gl.xr.enabled;
    const currentShadowAutoUpdate = gl.shadowMap.autoUpdate;
    beforeRender();
    gl.xr.enabled = false;
    gl.shadowMap.autoUpdate = false;
    gl.setRenderTarget(fbo1);
    gl.state.buffers.depth.setMask(true);
    if (!gl.autoClear)
      gl.clear();
    gl.render(scene, virtualCamera);
    if (hasBlur)
      blurpass.render(gl, fbo1, fbo2);
    gl.xr.enabled = currentXrEnabled;
    gl.shadowMap.autoUpdate = currentShadowAutoUpdate;
    parent.visible = true;
    gl.setRenderTarget(null);
  });
  return React74.createElement("meshReflectorMaterialImpl", _extends({
    attach: "material",
    key: "key" + reflectorProps["defines-USE_BLUR"] + reflectorProps["defines-USE_DEPTH"] + reflectorProps["defines-USE_DISTORTION"],
    ref: react_merge_refs_esm_default([materialRef, ref])
  }, reflectorProps, props));
});

// node_modules/@react-three/drei/core/MeshRefractionMaterial.js
var React75 = __toESM(require_react());
var import_react17 = __toESM(require_react());

// node_modules/@react-three/drei/materials/MeshRefractionMaterial.js
var MeshRefractionMaterial = shaderMaterial(
  {
    envMap: null,
    bounces: 3,
    ior: 2.4,
    correctMips: true,
    aberrationStrength: 0.01,
    fresnel: 0,
    bvh: new MeshBVHUniformStruct(),
    color: new Color("white"),
    resolution: new Vector2(),
    viewMatrixInverse: new Matrix4(),
    projectionMatrixInverse: new Matrix4()
  },
  /*glsl*/
  `
  uniform mat4 viewMatrixInverse;

  varying vec3 vWorldPosition;  
  varying vec3 vNormal;
  varying mat4 vModelMatrixInverse;

  #ifdef USE_INSTANCING_COLOR
    varying vec3 vInstanceColor;
  #endif

  void main() {        
    vec4 transformedNormal = vec4(normal, 0.0);
    vec4 transformedPosition = vec4(position, 1.0);
    #ifdef USE_INSTANCING
      transformedNormal = instanceMatrix * transformedNormal;
      transformedPosition = instanceMatrix * transformedPosition;
    #endif

    #ifdef USE_INSTANCING
      vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);
    #else
      vModelMatrixInverse = inverse(modelMatrix);
    #endif

    #ifdef USE_INSTANCING_COLOR
      vInstanceColor = instanceColor.rgb;
    #endif

    vWorldPosition = (modelMatrix * transformedPosition).xyz;
    vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);
    gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;
  }`,
  /*glsl*/
  `
  #define ENVMAP_TYPE_CUBE_UV
  precision highp isampler2D;
  precision highp usampler2D;
  varying vec3 vWorldPosition;
  varying vec3 vNormal;
  varying mat4 vModelMatrixInverse;

  #ifdef USE_INSTANCING_COLOR
    varying vec3 vInstanceColor;
  #endif
    
  #ifdef ENVMAP_TYPE_CUBEM
    uniform samplerCube envMap;
  #else
    uniform sampler2D envMap;
  #endif
    
  uniform float bounces;
  ${shaderStructs}
  ${shaderIntersectFunction}
  uniform BVH bvh;
  uniform float ior;
  uniform bool correctMips;
  uniform vec2 resolution;
  uniform float fresnel;
  uniform mat4 modelMatrix;
  uniform mat4 projectionMatrixInverse;
  uniform mat4 viewMatrixInverse;
  uniform float aberrationStrength;
  uniform vec3 color;
  
  float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {
    return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );
  }
    
  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {
    vec3 rayOrigin = ro;
    vec3 rayDirection = rd;
    rayDirection = refract(rayDirection, normal, 1.0 / ior);
    rayOrigin = vWorldPosition + rayDirection * 0.001;
    rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;
    rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);
    for(float i = 0.0; i < bounces; i++) {
      uvec4 faceIndices = uvec4( 0u );
      vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
      vec3 barycoord = vec3( 0.0 );
      float side = 1.0;
      float dist = 0.0;
      bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
      vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);      
      vec3 tempDir = refract(rayDirection, faceNormal, ior);
      if (length(tempDir) != 0.0) {
        rayDirection = tempDir;
        break;
      }
      rayDirection = reflect(rayDirection, faceNormal);
      rayOrigin = hitPos + rayDirection * 0.01;
    }
    rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);
    return rayDirection;
  }
    
  #include <common>
  #include <cube_uv_reflection_fragment>
    
  #ifdef ENVMAP_TYPE_CUBEM
    vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {
      return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));
    }
  #else
    vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {
      vec2 uvv = equirectUv( rayDirection );
      vec2 smoothUv = equirectUv( directionCamPerfect );
      return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));
    }
  #endif
  
  void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;
    directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;
    directionCamPerfect = normalize(directionCamPerfect);
    vec3 normal = vNormal;
    vec3 rayOrigin = cameraPosition;
    vec3 rayDirection = normalize(vWorldPosition - cameraPosition);
    vec3 finalColor;
    #ifdef CHROMATIC_ABERRATIONS
      vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
      #ifdef FAST_CHROMA 
        vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));
        vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));
      #else
        vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);
        vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);
      #endif
      float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;
      float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;
      float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;
      finalColor = vec3(finalColorR, finalColorG, finalColorB);
    #else
      rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
      finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;    
    #endif

    finalColor *= color;
    #ifdef USE_INSTANCING_COLOR
      finalColor *= vInstanceColor;
    #endif

    vec3 viewDirection = normalize(vWorldPosition - cameraPosition);
    float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;
    gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);      
    #include <tonemapping_fragment>
    #include <encodings_fragment>
  }`
);

// node_modules/@react-three/drei/core/MeshRefractionMaterial.js
var isCubeTexture = (def) => def && def.isCubeTexture;
function MeshRefractionMaterial2({
  aberrationStrength = 0,
  fastChroma = true,
  envMap,
  ...props
}) {
  extend({
    MeshRefractionMaterial
  });
  const material = (0, import_react17.useRef)();
  const {
    size
  } = useThree();
  const defines = (0, import_react17.useMemo)(() => {
    var _ref, _envMap$image$;
    const temp5 = {};
    const isCubeMap = isCubeTexture(envMap);
    const w = (_ref = isCubeMap ? (_envMap$image$ = envMap.image[0]) == null ? void 0 : _envMap$image$.width : envMap.image.width) !== null && _ref !== void 0 ? _ref : 1024;
    const cubeSize = w / 4;
    const _lodMax = Math.floor(Math.log2(cubeSize));
    const _cubeSize = Math.pow(2, _lodMax);
    const width = 3 * Math.max(_cubeSize, 16 * 7);
    const height = 4 * _cubeSize;
    if (isCubeMap)
      temp5.ENVMAP_TYPE_CUBEM = "";
    temp5.CUBEUV_TEXEL_WIDTH = `${1 / width}`;
    temp5.CUBEUV_TEXEL_HEIGHT = `${1 / height}`;
    temp5.CUBEUV_MAX_MIP = `${_lodMax}.0`;
    if (aberrationStrength > 0)
      temp5.CHROMATIC_ABERRATIONS = "";
    if (fastChroma)
      temp5.FAST_CHROMA = "";
    return temp5;
  }, [aberrationStrength, fastChroma]);
  (0, import_react17.useLayoutEffect)(() => {
    var _material$current, _material$current$__r, _material$current$__r2;
    const geometry = (_material$current = material.current) == null ? void 0 : (_material$current$__r = _material$current.__r3f) == null ? void 0 : (_material$current$__r2 = _material$current$__r.parent) == null ? void 0 : _material$current$__r2.geometry;
    if (geometry) {
      material.current.bvh = new MeshBVHUniformStruct();
      material.current.bvh.updateFrom(new MeshBVH(geometry.clone().toNonIndexed(), {
        lazyGeneration: false,
        strategy: SAH
      }));
    }
  }, []);
  useFrame(({
    camera
  }) => {
    material.current.viewMatrixInverse = camera.matrixWorld;
    material.current.projectionMatrixInverse = camera.projectionMatrixInverse;
  });
  return React75.createElement("meshRefractionMaterial", _extends({
    // @ts-ignore
    key: JSON.stringify(defines),
    defines,
    ref: material,
    resolution: [size.width, size.height],
    aberrationStrength,
    envMap
  }, props));
}

// node_modules/@react-three/drei/core/MeshTransmissionMaterial.js
var React76 = __toESM(require_react());

// node_modules/@react-three/drei/materials/DiscardMaterial.js
var DiscardMaterial = shaderMaterial({}, "void main() { }", "void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }");

// node_modules/@react-three/drei/core/MeshTransmissionMaterial.js
var MeshTransmissionMaterialImpl = class extends MeshPhysicalMaterial {
  constructor(samples = 6, transmissionSampler = false) {
    super();
    this.uniforms = {
      chromaticAberration: {
        value: 0.05
      },
      // Transmission must always be 0, unless transmissionSampler is being used
      transmission: {
        value: 0
      },
      // Instead a workaround is used, see below for reasons why
      _transmission: {
        value: 1
      },
      transmissionMap: {
        value: null
      },
      // Roughness is 1 in THREE.MeshPhysicalMaterial but it makes little sense in a transmission material
      roughness: {
        value: 0
      },
      thickness: {
        value: 0
      },
      thicknessMap: {
        value: null
      },
      attenuationDistance: {
        value: Infinity
      },
      attenuationColor: {
        value: new Color("white")
      },
      anisotropicBlur: {
        value: 0.1
      },
      time: {
        value: 0
      },
      distortion: {
        value: 0
      },
      distortionScale: {
        value: 0.5
      },
      temporalDistortion: {
        value: 0
      },
      buffer: {
        value: null
      }
    };
    this.onBeforeCompile = (shader) => {
      shader.uniforms = {
        ...shader.uniforms,
        ...this.uniforms
      };
      if (transmissionSampler)
        shader.defines.USE_SAMPLER = "";
      else
        shader.defines.USE_TRANSMISSION = "";
      shader.fragmentShader = /*glsl*/
      `
      uniform float chromaticAberration;         
      uniform float anisotropicBlur;      
      uniform float time;
      uniform float distortion;
      uniform float distortionScale;
      uniform float temporalDistortion;
      uniform sampler2D buffer;

      vec3 random3(vec3 c) {
        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
        vec3 r;
        r.z = fract(512.0*j);
        j *= .125;
        r.x = fract(512.0*j);
        j *= .125;
        r.y = fract(512.0*j);
        return r-0.5;
      }

      float seed = 0.0;
      uint hash( uint x ) {
        x += ( x << 10u );
        x ^= ( x >>  6u );
        x += ( x <<  3u );
        x ^= ( x >> 11u );
        x += ( x << 15u );
        return x;
      }

      // Compound versions of the hashing algorithm I whipped together.
      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

      // Construct a float with half-open range [0:1] using low 23 bits.
      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
      float floatConstruct( uint m ) {
        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32
        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
        m |= ieeeOne;                          // Add fractional part to 1.0
        float  f = uintBitsToFloat( m );       // Range [1:2]
        return f - 1.0;                        // Range [0:1]
      }

      // Pseudo-random value in half-open range [0:1].
      float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
      float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }

      float rand() {
        float result = random(vec3(gl_FragCoord.xy, seed));
        seed += 1.0;
        return result;
      }

      const float F3 =  0.3333333;
      const float G3 =  0.1666667;

      float snoise(vec3 p) {
        vec3 s = floor(p + dot(p, vec3(F3)));
        vec3 x = p - s + dot(s, vec3(G3));
        vec3 e = step(vec3(0.0), x - x.yzx);
        vec3 i1 = e*(1.0 - e.zxy);
        vec3 i2 = 1.0 - e.zxy*(1.0 - e);
        vec3 x1 = x - i1 + G3;
        vec3 x2 = x - i2 + 2.0*G3;
        vec3 x3 = x - 1.0 + 3.0*G3;
        vec4 w, d;
        w.x = dot(x, x);
        w.y = dot(x1, x1);
        w.z = dot(x2, x2);
        w.w = dot(x3, x3);
        w = max(0.6 - w, 0.0);
        d.x = dot(random3(s), x);
        d.y = dot(random3(s + i1), x1);
        d.z = dot(random3(s + i2), x2);
        d.w = dot(random3(s + 1.0), x3);
        w *= w;
        w *= w;
        d *= w;
        return dot(d, vec4(52.0));
      }

      float snoiseFractal(vec3 m) {
        return 0.5333333* snoise(m)
              +0.2666667* snoise(2.0*m)
              +0.1333333* snoise(4.0*m)
              +0.0666667* snoise(8.0*m);
      }
` + shader.fragmentShader;
      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <transmission_pars_fragment>",
        /*glsl*/
        `
        #ifdef USE_TRANSMISSION
          // Transmission code is based on glTF-Sampler-Viewer
          // https://github.com/KhronosGroup/glTF-Sample-Viewer
          uniform float _transmission;
          uniform float thickness;
          uniform float attenuationDistance;
          uniform vec3 attenuationColor;
          #ifdef USE_TRANSMISSIONMAP
            uniform sampler2D transmissionMap;
          #endif
          #ifdef USE_THICKNESSMAP
            uniform sampler2D thicknessMap;
          #endif
          uniform vec2 transmissionSamplerSize;
          uniform sampler2D transmissionSamplerMap;
          uniform mat4 modelMatrix;
          uniform mat4 projectionMatrix;
          varying vec3 vWorldPosition;
          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
            // Direction of refracted light.
            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
            // Compute rotation-independant scaling of the model matrix.
            vec3 modelScale;
            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
            // The thickness is specified in local space.
            return normalize( refractionVector ) * thickness * modelScale;
          }
          float applyIorToRoughness( const in float roughness, const in float ior ) {
            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
            // an IOR of 1.5 results in the default amount of microfacet refraction.
            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
          }
          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            
            #ifdef USE_SAMPLER
              #ifdef texture2DLodEXT
                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);
              #else
                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);
              #endif
            #else
              return texture2D(buffer, fragCoord.xy);
            #endif
          }
          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
            if ( isinf( attenuationDistance ) ) {
              // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.
              return radiance;
            } else {
              // Compute light attenuation using Beer's law.
              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
              return transmittance * radiance;
            }
          }
          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
            const in vec3 attenuationColor, const in float attenuationDistance ) {
            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
            vec3 refractedRayExit = position + transmissionRay;
            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
            vec2 refractionCoords = ndcPos.xy / ndcPos.w;
            refractionCoords += 1.0;
            refractionCoords /= 2.0;
            // Sample framebuffer to get pixel the refracted ray hits.
            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
            // Get the specular component.
            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
          }
        #endif
`
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <transmission_fragment>",
        /*glsl*/
        `  
        // Improve the refraction to use the world pos
        material.transmission = _transmission;
        material.transmissionAlpha = 1.0;
        material.thickness = thickness;
        material.attenuationDistance = attenuationDistance;
        material.attenuationColor = attenuationColor;
        #ifdef USE_TRANSMISSIONMAP
          material.transmission *= texture2D( transmissionMap, vUv ).r;
        #endif
        #ifdef USE_THICKNESSMAP
          material.thickness *= texture2D( thicknessMap, vUv ).g;
        #endif
        
        vec3 pos = vWorldPosition;
        vec3 v = normalize( cameraPosition - pos );
        vec3 n = inverseTransformDirection( normal, viewMatrix );
        vec3 transmission = vec3(0.0);
        float transmissionR, transmissionB, transmissionG;
        float randomCoords = rand();
        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);
        vec3 distortionNormal = vec3(0.0);
        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;
        if (distortion > 0.0) {
          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));
        }
        for (float i = 0.0; i < ${samples}.0; i ++) {
          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand() - 0.5, rand() - 0.5, rand() - 0.5)) * pow(rand(), 0.33) + distortionNormal);
          transmissionR = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${samples}),
            material.attenuationColor, material.attenuationDistance
          ).r;
          transmissionG = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${samples})) , material.thickness + thickness_smear * (i + randomCoords) / float(${samples}),
            material.attenuationColor, material.attenuationDistance
          ).g;
          transmissionB = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${samples})), material.thickness + thickness_smear * (i + randomCoords) / float(${samples}),
            material.attenuationColor, material.attenuationDistance
          ).b;
          transmission.r += transmissionR;
          transmission.g += transmissionG;
          transmission.b += transmissionB;
        }
        transmission /= ${samples}.0;
        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
`
      );
    };
    Object.keys(this.uniforms).forEach((name) => Object.defineProperty(this, name, {
      get: () => this.uniforms[name].value,
      set: (v4) => this.uniforms[name].value = v4
    }));
  }
};
var MeshTransmissionMaterial = React76.forwardRef(({
  buffer,
  transmissionSampler = false,
  backside = false,
  side = FrontSide,
  transmission = 1,
  thickness = 0,
  backsideThickness = 0,
  samples = 10,
  resolution,
  backsideResolution,
  background,
  anisotropy,
  anisotropicBlur,
  ...props
}, fref) => {
  extend({
    MeshTransmissionMaterial: MeshTransmissionMaterialImpl
  });
  const ref = React76.useRef(null);
  const [discardMaterial] = React76.useState(() => new DiscardMaterial());
  const fboBack = useFBO(backsideResolution || resolution);
  const fboMain = useFBO(resolution);
  let oldBg;
  let oldTone;
  let parent;
  useFrame((state) => {
    ref.current.time = state.clock.getElapsedTime();
    if (ref.current.buffer === fboMain.texture && !transmissionSampler) {
      parent = ref.current.__r3f.parent;
      if (parent) {
        oldTone = state.gl.toneMapping;
        oldBg = state.scene.background;
        state.gl.toneMapping = NoToneMapping;
        if (background)
          state.scene.background = background;
        parent.material = discardMaterial;
        if (backside) {
          state.gl.setRenderTarget(fboBack);
          state.gl.render(state.scene, state.camera);
          parent.material = ref.current;
          parent.material.buffer = fboBack.texture;
          parent.material.thickness = backsideThickness;
          parent.material.side = BackSide;
        }
        state.gl.setRenderTarget(fboMain);
        state.gl.render(state.scene, state.camera);
        parent.material.thickness = thickness;
        parent.material.side = side;
        parent.material.buffer = fboMain.texture;
        state.scene.background = oldBg;
        state.gl.setRenderTarget(null);
        parent.material = ref.current;
        state.gl.toneMapping = oldTone;
      }
    }
  });
  React76.useImperativeHandle(fref, () => ref.current, []);
  return React76.createElement("meshTransmissionMaterial", _extends({
    // Samples must re-compile the shader so we memoize it
    args: [samples, transmissionSampler],
    ref
  }, props, {
    buffer: buffer || fboMain.texture,
    _transmission: transmission,
    anisotropicBlur: anisotropicBlur !== null && anisotropicBlur !== void 0 ? anisotropicBlur : anisotropy,
    transmission: transmissionSampler ? transmission : 0,
    thickness,
    side
  }));
});

// node_modules/@react-three/drei/core/MeshDiscardMaterial.js
var React77 = __toESM(require_react());
var MeshDiscardMaterial = React77.forwardRef((props, fref) => {
  extend({
    DiscardMaterialImpl: DiscardMaterial
  });
  return React77.createElement("discardMaterialImpl", _extends({
    ref: fref
  }, props));
});

// node_modules/@react-three/drei/core/PointMaterial.js
var React78 = __toESM(require_react());
var PointMaterialImpl = class extends PointsMaterial {
  constructor(props) {
    super(props);
    this.onBeforeCompile = (shader, renderer) => {
      const {
        isWebGL2
      } = renderer.capabilities;
      shader.fragmentShader = shader.fragmentShader.replace("#include <output_fragment>", `
        ${!isWebGL2 ? "#extension GL_OES_standard_derivatives : enable\n#include <output_fragment>" : "#include <output_fragment>"}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `);
    };
  }
};
var PointMaterial = React78.forwardRef((props, ref) => {
  const [material] = React78.useState(() => new PointMaterialImpl(null));
  return React78.createElement("primitive", _extends({}, props, {
    object: material,
    ref,
    attach: "material"
  }));
});

// node_modules/@react-three/drei/core/softShadows.js
var React79 = __toESM(require_react());
var pcss = ({
  focus = 0,
  size = 25,
  samples = 10
} = {}) => `
#define PENUMBRA_FILTER_SIZE float(${size})
#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
vec3 randRGB(vec2 uv) {
  return vec3(
    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
  );
}

vec3 lowPassRandRGB(vec2 uv) {
  // 3x3 convolution (average)
  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
  vec3 result = vec3(0);
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
  result *= 0.111111111; // 1.0 / 9.0
  return result;
}
vec3 highPassRandRGB(vec2 uv) {
  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
  // hp(x) = x - lp(x)
  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
}


vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}
float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
  return (zReceiver - zBlocker) / zBlocker;
}
float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float blockerDepthSum = float(${focus});
  float blockers = 0.0;

  int j = 0;
  vec2 offset = vec2(0.);
  float depth = 0.;

  #pragma unroll_loop_start
  for(int i = 0; i < ${samples}; i ++) {
    offset = (vogelDiskSample(j, ${samples}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
    if (depth < compare) {
      blockerDepthSum += depth;
      blockers++;
    }
    j++;
  }
  #pragma unroll_loop_end

  if (blockers > 0.0) {
    return blockerDepthSum / blockers;
  }
  return -1.0;
}

        
float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float shadow = 0.0f;
  int j = 0;
  vec2 vogelSample = vec2(0.0);
  vec2 offset = vec2(0.0);
  #pragma unroll_loop_start
  for (int i = 0; i < ${samples}; i++) {
    vogelSample = vogelDiskSample(j, ${samples}, angle) * texelSize;
    offset = vogelSample * (1.0 + filterRadius * float(${size}));
    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    j++;
  }
  #pragma unroll_loop_end
  return shadow * 1.0 / ${samples}.0;
}

float PCSS (sampler2D shadowMap, vec4 coords) {
  vec2 uv = coords.xy;
  float zReceiver = coords.z; // Assumed to be eye-space z in this code
  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
  if (avgBlockerDepth == -1.0) {
    return 1.0;
  }
  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
}`;
function reset(gl, scene, camera) {
  scene.traverse((object) => {
    if (object.material) {
      gl.properties.remove(object.material);
      object.material.dispose == null ? void 0 : object.material.dispose();
    }
  });
  gl.info.programs.length = 0;
  gl.compile(scene, camera);
}
function SoftShadows({
  focus = 0,
  samples = 10,
  size = 25
}) {
  const gl = useThree((state) => state.gl);
  const scene = useThree((state) => state.scene);
  const camera = useThree((state) => state.camera);
  React79.useEffect(() => {
    const original = ShaderChunk.shadowmap_pars_fragment;
    ShaderChunk.shadowmap_pars_fragment = ShaderChunk.shadowmap_pars_fragment.replace("#ifdef USE_SHADOWMAP", "#ifdef USE_SHADOWMAP\n" + pcss({
      size,
      samples,
      focus
    })).replace("#if defined( SHADOWMAP_TYPE_PCF )", "\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )");
    reset(gl, scene, camera);
    return () => {
      ShaderChunk.shadowmap_pars_fragment = original;
      reset(gl, scene, camera);
    };
  }, [focus, size, samples]);
  return null;
}

// node_modules/@react-three/drei/core/shapes.js
var React80 = __toESM(require_react());
function create2(type, effect) {
  const El = type + "Geometry";
  return React80.forwardRef(({
    args,
    children,
    ...props
  }, fref) => {
    const ref = React80.useRef(null);
    React80.useImperativeHandle(fref, () => ref.current);
    React80.useLayoutEffect(() => void (effect == null ? void 0 : effect(ref.current)));
    return React80.createElement("mesh", _extends({
      ref
    }, props), React80.createElement(El, {
      attach: "geometry",
      args
    }), children);
  });
}
var Box = create2("box");
var Circle = create2("circle");
var Cone = create2("cone");
var Cylinder = create2("cylinder");
var Sphere2 = create2("sphere");
var Plane2 = create2("plane");
var Tube = create2("tube");
var Torus = create2("torus");
var TorusKnot = create2("torusKnot");
var Tetrahedron = create2("tetrahedron");
var Ring = create2("ring");
var Polyhedron = create2("polyhedron");
var Icosahedron = create2("icosahedron");
var Octahedron = create2("octahedron");
var Dodecahedron = create2("dodecahedron");
var Extrude = create2("extrude");
var Lathe = create2("lathe");
var Capsule = create2("capsule");
var Shape2 = create2("shape", ({
  geometry
}) => {
  const pos = geometry.attributes.position;
  const b3 = new Box3().setFromBufferAttribute(pos);
  const b3size = new Vector3();
  b3.getSize(b3size);
  const uv = [];
  let x = 0, y = 0, u = 0, v4 = 0;
  for (let i3 = 0; i3 < pos.count; i3++) {
    x = pos.getX(i3);
    y = pos.getY(i3);
    u = (x - b3.min.x) / b3size.x;
    v4 = (y - b3.min.y) / b3size.y;
    uv.push(u, v4);
  }
  geometry.setAttribute("uv", new Float32BufferAttribute(uv, 2));
});

// node_modules/@react-three/drei/core/RoundedBox.js
var React81 = __toESM(require_react());
var eps = 1e-5;
function createShape(width, height, radius0) {
  const shape = new Shape();
  const radius = radius0 - eps;
  shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
  shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);
  shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);
  shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);
  return shape;
}
var RoundedBox = React81.forwardRef(function RoundedBox2({
  args: [width = 1, height = 1, depth = 1] = [],
  radius = 0.05,
  steps: steps2 = 1,
  smoothness = 4,
  creaseAngle = 0.4,
  children,
  ...rest
}, ref) {
  const shape = React81.useMemo(() => createShape(width, height, radius), [width, height, radius]);
  const params = React81.useMemo(() => ({
    depth: depth - radius * 2,
    bevelEnabled: true,
    bevelSegments: smoothness * 2,
    steps: steps2,
    bevelSize: radius - eps,
    bevelThickness: radius,
    curveSegments: smoothness
  }), [depth, radius, smoothness]);
  const geomRef = React81.useRef();
  React81.useLayoutEffect(() => {
    if (geomRef.current) {
      geomRef.current.center();
      toCreasedNormals(geomRef.current, creaseAngle);
    }
  }, [shape, params]);
  return React81.createElement("mesh", _extends({
    ref
  }, rest), React81.createElement("extrudeGeometry", {
    ref: geomRef,
    args: [shape, params]
  }), children);
});

// node_modules/@react-three/drei/core/ScreenQuad.js
var React82 = __toESM(require_react());
function createScreenQuadGeometry() {
  const geometry = new BufferGeometry();
  const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
  geometry.setAttribute("position", new BufferAttribute(vertices, 2));
  return geometry;
}
var ScreenQuad = React82.forwardRef(function ScreenQuad2({
  children,
  ...restProps
}, ref) {
  const geometry = React82.useMemo(createScreenQuadGeometry, []);
  return React82.createElement("mesh", _extends({
    ref,
    geometry,
    frustumCulled: false
  }, restProps), children);
});

// node_modules/@react-three/drei/core/Resize.js
var React83 = __toESM(require_react());
var Resize = React83.forwardRef(({
  children,
  width,
  height,
  depth,
  box3,
  precise = true,
  ...props
}, fRef) => {
  const ref = React83.useRef(null);
  const outer = React83.useRef(null);
  const inner = React83.useRef(null);
  React83.useLayoutEffect(() => {
    outer.current.matrixWorld.identity();
    let box = box3 || new Box3().setFromObject(inner.current, precise);
    const w = box.max.x - box.min.x;
    const h = box.max.y - box.min.y;
    const d2 = box.max.z - box.min.z;
    let dimension = Math.max(w, h, d2);
    if (width)
      dimension = w;
    if (height)
      dimension = h;
    if (depth)
      dimension = d2;
    outer.current.scale.setScalar(1 / dimension);
  }, [width, height, depth, box3, precise]);
  React83.useImperativeHandle(fRef, () => ref.current, []);
  return React83.createElement("group", _extends({
    ref
  }, props), React83.createElement("group", {
    ref: outer
  }, React83.createElement("group", {
    ref: inner
  }, children)));
});

// node_modules/@react-three/drei/core/Bounds.js
var React84 = __toESM(require_react());
var isOrthographic = (def) => def && def.isOrthographicCamera;
var isBox3 = (def) => def && def.isBox3;
var context5 = React84.createContext(null);
function Bounds({
  children,
  damping = 6,
  fit,
  clip,
  observe,
  margin = 1.2,
  eps: eps2 = 0.01,
  onFit
}) {
  const ref = React84.useRef(null);
  const {
    camera,
    invalidate,
    size,
    controls: controlsImpl
  } = useThree();
  const controls = controlsImpl;
  const onFitRef = React84.useRef(onFit);
  onFitRef.current = onFit;
  function equals(a3, b) {
    return Math.abs(a3.x - b.x) < eps2 && Math.abs(a3.y - b.y) < eps2 && Math.abs(a3.z - b.z) < eps2;
  }
  function damp(v4, t2, lambda, delta) {
    v4.x = MathUtils.damp(v4.x, t2.x, lambda, delta);
    v4.y = MathUtils.damp(v4.y, t2.y, lambda, delta);
    v4.z = MathUtils.damp(v4.z, t2.z, lambda, delta);
  }
  const [current] = React84.useState(() => ({
    animating: false,
    focus: new Vector3(),
    camera: new Vector3(),
    zoom: 1
  }));
  const [goal] = React84.useState(() => ({
    focus: new Vector3(),
    camera: new Vector3(),
    zoom: 1
  }));
  const [box] = React84.useState(() => new Box3());
  const api = React84.useMemo(() => {
    function getSize() {
      const size2 = box.getSize(new Vector3());
      const center = box.getCenter(new Vector3());
      const maxSize = Math.max(size2.x, size2.y, size2.z);
      const fitHeightDistance = isOrthographic(camera) ? maxSize * 4 : maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
      const fitWidthDistance = isOrthographic(camera) ? maxSize * 4 : fitHeightDistance / camera.aspect;
      const distance = margin * Math.max(fitHeightDistance, fitWidthDistance);
      return {
        box,
        size: size2,
        center,
        distance
      };
    }
    return {
      getSize,
      refresh(object) {
        if (isBox3(object))
          box.copy(object);
        else {
          const target2 = object || ref.current;
          target2.updateWorldMatrix(true, true);
          box.setFromObject(target2);
        }
        if (box.isEmpty()) {
          const max = camera.position.length() || 10;
          box.setFromCenterAndSize(new Vector3(), new Vector3(max, max, max));
        }
        if ((controls == null ? void 0 : controls.constructor.name) === "OrthographicTrackballControls") {
          const {
            distance
          } = getSize();
          const direction = camera.position.clone().sub(controls.target).normalize().multiplyScalar(distance);
          const newPos = controls.target.clone().add(direction);
          camera.position.copy(newPos);
        }
        return this;
      },
      clip() {
        const {
          distance
        } = getSize();
        if (controls)
          controls.maxDistance = distance * 10;
        camera.near = distance / 100;
        camera.far = distance * 100;
        camera.updateProjectionMatrix();
        if (controls)
          controls.update();
        invalidate();
        return this;
      },
      to({
        position: position2,
        target: target2
      }) {
        current.camera.copy(camera.position);
        const {
          center
        } = getSize();
        goal.camera.set(...position2);
        if (target2) {
          goal.focus.set(...target2);
        } else {
          goal.focus.copy(center);
        }
        if (damping) {
          current.animating = true;
        } else {
          camera.position.set(...position2);
        }
        return this;
      },
      fit() {
        current.camera.copy(camera.position);
        if (controls)
          current.focus.copy(controls.target);
        const {
          center,
          distance
        } = getSize();
        const direction = center.clone().sub(camera.position).normalize().multiplyScalar(distance);
        goal.camera.copy(center).sub(direction);
        goal.focus.copy(center);
        if (isOrthographic(camera)) {
          current.zoom = camera.zoom;
          let maxHeight = 0, maxWidth = 0;
          const vertices = [new Vector3(box.min.x, box.min.y, box.min.z), new Vector3(box.min.x, box.max.y, box.min.z), new Vector3(box.min.x, box.min.y, box.max.z), new Vector3(box.min.x, box.max.y, box.max.z), new Vector3(box.max.x, box.max.y, box.max.z), new Vector3(box.max.x, box.max.y, box.min.z), new Vector3(box.max.x, box.min.y, box.max.z), new Vector3(box.max.x, box.min.y, box.min.z)];
          center.applyMatrix4(camera.matrixWorldInverse);
          for (const v4 of vertices) {
            v4.applyMatrix4(camera.matrixWorldInverse);
            maxHeight = Math.max(maxHeight, Math.abs(v4.y - center.y));
            maxWidth = Math.max(maxWidth, Math.abs(v4.x - center.x));
          }
          maxHeight *= 2;
          maxWidth *= 2;
          const zoomForHeight = (camera.top - camera.bottom) / maxHeight;
          const zoomForWidth = (camera.right - camera.left) / maxWidth;
          goal.zoom = Math.min(zoomForHeight, zoomForWidth) / margin;
          if (!damping) {
            camera.zoom = goal.zoom;
            camera.updateProjectionMatrix();
          }
        }
        if (damping) {
          current.animating = true;
        } else {
          camera.position.copy(goal.camera);
          camera.lookAt(goal.focus);
          if (controls) {
            controls.target.copy(goal.focus);
            controls.update();
          }
        }
        if (onFitRef.current)
          onFitRef.current(this.getSize());
        invalidate();
        return this;
      }
    };
  }, [box, camera, controls, margin, damping, invalidate]);
  React84.useLayoutEffect(() => {
    if (controls) {
      const callback = () => current.animating = false;
      controls.addEventListener("start", callback);
      return () => controls.removeEventListener("start", callback);
    }
  }, [controls]);
  const count = React84.useRef(0);
  React84.useLayoutEffect(() => {
    if (observe || count.current++ === 0) {
      api.refresh();
      if (fit)
        api.fit();
      if (clip)
        api.clip();
    }
  }, [size, clip, fit, observe, camera, controls]);
  useFrame((state, delta) => {
    if (current.animating) {
      damp(current.focus, goal.focus, damping, delta);
      damp(current.camera, goal.camera, damping, delta);
      current.zoom = MathUtils.damp(current.zoom, goal.zoom, damping, delta);
      camera.position.copy(current.camera);
      if (isOrthographic(camera)) {
        camera.zoom = current.zoom;
        camera.updateProjectionMatrix();
      }
      if (!controls) {
        camera.lookAt(current.focus);
      } else {
        controls.target.copy(current.focus);
        controls.update();
      }
      invalidate();
      if (isOrthographic(camera) && !(Math.abs(current.zoom - goal.zoom) < eps2))
        return;
      if (!isOrthographic(camera) && !equals(current.camera, goal.camera))
        return;
      if (controls && !equals(current.focus, goal.focus))
        return;
      current.animating = false;
    }
  });
  return React84.createElement("group", {
    ref
  }, React84.createElement(context5.Provider, {
    value: api
  }, children));
}
function useBounds() {
  return React84.useContext(context5);
}

// node_modules/@react-three/drei/core/CameraShake.js
var React85 = __toESM(require_react());
var CameraShake = React85.forwardRef(({
  intensity = 1,
  decay,
  decayRate = 0.65,
  maxYaw = 0.1,
  maxPitch = 0.1,
  maxRoll = 0.1,
  yawFrequency = 0.1,
  pitchFrequency = 0.1,
  rollFrequency = 0.1
}, ref) => {
  const camera = useThree((state) => state.camera);
  const defaultControls = useThree((state) => state.controls);
  const intensityRef = React85.useRef(intensity);
  const initialRotation = React85.useRef(camera.rotation.clone());
  const [yawNoise] = React85.useState(() => new SimplexNoise());
  const [pitchNoise] = React85.useState(() => new SimplexNoise());
  const [rollNoise] = React85.useState(() => new SimplexNoise());
  const constrainIntensity = () => {
    if (intensityRef.current < 0 || intensityRef.current > 1) {
      intensityRef.current = intensityRef.current < 0 ? 0 : 1;
    }
  };
  React85.useImperativeHandle(ref, () => ({
    getIntensity: () => intensityRef.current,
    setIntensity: (val) => {
      intensityRef.current = val;
      constrainIntensity();
    }
  }), []);
  React85.useEffect(() => {
    if (defaultControls) {
      const callback = () => void (initialRotation.current = camera.rotation.clone());
      defaultControls.addEventListener("change", callback);
      callback();
      return () => void defaultControls.removeEventListener("change", callback);
    }
  }, [camera, defaultControls]);
  useFrame((state, delta) => {
    const shake = Math.pow(intensityRef.current, 2);
    const yaw = maxYaw * shake * yawNoise.noise(state.clock.elapsedTime * yawFrequency, 1);
    const pitch = maxPitch * shake * pitchNoise.noise(state.clock.elapsedTime * pitchFrequency, 1);
    const roll = maxRoll * shake * rollNoise.noise(state.clock.elapsedTime * rollFrequency, 1);
    camera.rotation.set(initialRotation.current.x + pitch, initialRotation.current.y + yaw, initialRotation.current.z + roll);
    if (decay && intensityRef.current > 0) {
      intensityRef.current -= decayRate * delta;
      constrainIntensity();
    }
  });
  return null;
});

// node_modules/@react-three/drei/core/Float.js
var React86 = __toESM(require_react());
var Float = React86.forwardRef(({
  children,
  enabled = true,
  speed = 1,
  rotationIntensity = 1,
  floatIntensity = 1,
  floatingRange = [-0.1, 0.1],
  ...props
}, forwardRef71) => {
  const ref = React86.useRef(null);
  const offset = React86.useRef(Math.random() * 1e4);
  useFrame((state) => {
    var _floatingRange$, _floatingRange$2;
    if (!enabled || speed === 0)
      return;
    const t2 = offset.current + state.clock.getElapsedTime();
    ref.current.rotation.x = Math.cos(t2 / 4 * speed) / 8 * rotationIntensity;
    ref.current.rotation.y = Math.sin(t2 / 4 * speed) / 8 * rotationIntensity;
    ref.current.rotation.z = Math.sin(t2 / 4 * speed) / 20 * rotationIntensity;
    let yPosition = Math.sin(t2 / 4 * speed) / 10;
    yPosition = MathUtils.mapLinear(yPosition, -0.1, 0.1, (_floatingRange$ = floatingRange == null ? void 0 : floatingRange[0]) !== null && _floatingRange$ !== void 0 ? _floatingRange$ : -0.1, (_floatingRange$2 = floatingRange == null ? void 0 : floatingRange[1]) !== null && _floatingRange$2 !== void 0 ? _floatingRange$2 : 0.1);
    ref.current.position.y = yPosition * floatIntensity;
    ref.current.updateMatrix();
  });
  return React86.createElement("group", props, React86.createElement("group", {
    ref: react_merge_refs_esm_default([ref, forwardRef71]),
    matrixAutoUpdate: false
  }, children));
});

// node_modules/@react-three/drei/core/Stage.js
var React90 = __toESM(require_react());

// node_modules/@react-three/drei/core/Environment.js
var React87 = __toESM(require_react());

// node_modules/@react-three/drei/helpers/environment-assets.js
var presetsObj = {
  apartment: "lebombo_1k.hdr",
  city: "potsdamer_platz_1k.hdr",
  dawn: "kiara_1_dawn_1k.hdr",
  forest: "forest_slope_1k.hdr",
  lobby: "st_fagans_interior_1k.hdr",
  night: "dikhololo_night_1k.hdr",
  park: "rooitou_park_1k.hdr",
  studio: "studio_small_03_1k.hdr",
  sunset: "venice_sunset_1k.hdr",
  warehouse: "empty_warehouse_01_1k.hdr"
};

// node_modules/@react-three/drei/core/useEnvironment.js
var CUBEMAP_ROOT = "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/";
var isArray2 = (arr) => Array.isArray(arr);
function useEnvironment({
  files = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"],
  path = "",
  preset = void 0,
  encoding = void 0,
  extensions: extensions2
} = {}) {
  var _files$split$pop;
  let loader2 = null;
  let isCubeMap = false;
  let extension;
  if (preset) {
    if (!(preset in presetsObj))
      throw new Error("Preset must be one of: " + Object.keys(presetsObj).join(", "));
    files = presetsObj[preset];
    path = CUBEMAP_ROOT;
  }
  isCubeMap = isArray2(files);
  extension = isArray2(files) ? "cube" : files.startsWith("data:application/exr") ? "exr" : files.startsWith("data:application/hdr") ? "hdr" : (_files$split$pop = files.split(".").pop()) == null ? void 0 : _files$split$pop.toLowerCase();
  loader2 = isCubeMap ? CubeTextureLoader : extension === "hdr" ? RGBELoader : extension === "exr" ? EXRLoader : null;
  if (!loader2)
    throw new Error("useEnvironment: Unrecognized file extension: " + files);
  const loaderResult = useLoader(
    // @ts-expect-error
    loader2,
    isCubeMap ? [files] : files,
    (loader3) => {
      loader3.setPath == null ? void 0 : loader3.setPath(path);
      if (extensions2)
        extensions2(loader3);
    }
  );
  const texture = isCubeMap ? (
    // @ts-ignore
    loaderResult[0]
  ) : loaderResult;
  texture.mapping = isCubeMap ? CubeReflectionMapping : EquirectangularReflectionMapping;
  const sRGBEncoding = 3001;
  const LinearEncoding2 = 3e3;
  if ("colorSpace" in texture)
    texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? "srgb" : "srgb-linear";
  else
    texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? sRGBEncoding : LinearEncoding2;
  return texture;
}

// node_modules/@react-three/drei/core/Environment.js
var isRef = (obj) => obj.current && obj.current.isScene;
var resolveScene = (scene) => isRef(scene) ? scene.current : scene;
function setEnvProps(background, scene, defaultScene, texture, blur = 0) {
  const target2 = resolveScene(scene || defaultScene);
  const oldbg = target2.background;
  const oldenv = target2.environment;
  const oldBlur = target2.backgroundBlurriness || 0;
  if (background !== "only")
    target2.environment = texture;
  if (background)
    target2.background = texture;
  if (background && target2.backgroundBlurriness !== void 0)
    target2.backgroundBlurriness = blur;
  return () => {
    if (background !== "only")
      target2.environment = oldenv;
    if (background)
      target2.background = oldbg;
    if (background && target2.backgroundBlurriness !== void 0)
      target2.backgroundBlurriness = oldBlur;
  };
}
function EnvironmentMap({
  scene,
  background = false,
  blur,
  map
}) {
  const defaultScene = useThree((state) => state.scene);
  React87.useLayoutEffect(() => {
    if (map)
      return setEnvProps(background, scene, defaultScene, map, blur);
  }, [defaultScene, scene, map, background, blur]);
  return null;
}
function EnvironmentCube({
  background = false,
  scene,
  blur,
  ...rest
}) {
  const texture = useEnvironment(rest);
  const defaultScene = useThree((state) => state.scene);
  React87.useLayoutEffect(() => {
    return setEnvProps(background, scene, defaultScene, texture, blur);
  }, [texture, background, scene, defaultScene, blur]);
  return null;
}
function EnvironmentPortal({
  children,
  near = 1,
  far = 1e3,
  resolution = 256,
  frames = 1,
  map,
  background = false,
  blur,
  scene,
  files,
  path,
  preset = void 0,
  extensions: extensions2
}) {
  const gl = useThree((state) => state.gl);
  const defaultScene = useThree((state) => state.scene);
  const camera = React87.useRef(null);
  const [virtualScene] = React87.useState(() => new Scene());
  const fbo = React87.useMemo(() => {
    const fbo2 = new WebGLCubeRenderTarget(resolution);
    fbo2.texture.type = HalfFloatType;
    return fbo2;
  }, [resolution]);
  React87.useLayoutEffect(() => {
    if (frames === 1)
      camera.current.update(gl, virtualScene);
    return setEnvProps(background, scene, defaultScene, fbo.texture, blur);
  }, [children, virtualScene, fbo.texture, scene, defaultScene, background, frames, gl]);
  let count = 1;
  useFrame(() => {
    if (frames === Infinity || count < frames) {
      camera.current.update(gl, virtualScene);
      count++;
    }
  });
  return React87.createElement(React87.Fragment, null, createPortal(React87.createElement(React87.Fragment, null, children, React87.createElement("cubeCamera", {
    ref: camera,
    args: [near, far, fbo]
  }), files || preset ? React87.createElement(EnvironmentCube, {
    background: true,
    files,
    preset,
    path,
    extensions: extensions2
  }) : map ? React87.createElement(EnvironmentMap, {
    background: true,
    map,
    extensions: extensions2
  }) : null), virtualScene));
}
function EnvironmentGround(props) {
  var _props$ground, _props$ground2, _scale, _props$ground3;
  const textureDefault = useEnvironment(props);
  const texture = props.map || textureDefault;
  React87.useMemo(() => extend({
    GroundProjectedEnvImpl: GroundProjectedEnv
  }), []);
  const args = React87.useMemo(() => [texture], [texture]);
  const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;
  const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;
  const scale2 = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1e3;
  return React87.createElement(React87.Fragment, null, React87.createElement(EnvironmentMap, _extends({}, props, {
    map: texture
  })), React87.createElement("groundProjectedEnvImpl", {
    args,
    scale: scale2,
    height,
    radius
  }));
}
function Environment(props) {
  return props.ground ? React87.createElement(EnvironmentGround, props) : props.map ? React87.createElement(EnvironmentMap, props) : props.children ? React87.createElement(EnvironmentPortal, props) : React87.createElement(EnvironmentCube, props);
}

// node_modules/@react-three/drei/core/ContactShadows.js
var React88 = __toESM(require_react());
var ContactShadows = React88.forwardRef(({
  scale: scale2 = 10,
  frames = Infinity,
  opacity = 1,
  width = 1,
  height = 1,
  blur = 1,
  far = 10,
  resolution = 512,
  smooth = true,
  color = "#000000",
  depthWrite = false,
  renderOrder,
  ...props
}, fref) => {
  const ref = React88.useRef(null);
  const scene = useThree((state) => state.scene);
  const gl = useThree((state) => state.gl);
  const shadowCamera = React88.useRef(null);
  width = width * (Array.isArray(scale2) ? scale2[0] : scale2 || 1);
  height = height * (Array.isArray(scale2) ? scale2[1] : scale2 || 1);
  const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = React88.useMemo(() => {
    const renderTarget2 = new WebGLRenderTarget(resolution, resolution);
    const renderTargetBlur2 = new WebGLRenderTarget(resolution, resolution);
    renderTargetBlur2.texture.generateMipmaps = renderTarget2.texture.generateMipmaps = false;
    const planeGeometry2 = new PlaneGeometry(width, height).rotateX(Math.PI / 2);
    const blurPlane2 = new Mesh(planeGeometry2);
    const depthMaterial2 = new MeshDepthMaterial();
    depthMaterial2.depthTest = depthMaterial2.depthWrite = false;
    depthMaterial2.onBeforeCompile = (shader) => {
      shader.uniforms = {
        ...shader.uniforms,
        ucolor: {
          value: new Color(color)
        }
      };
      shader.fragmentShader = shader.fragmentShader.replace(
        `void main() {`,
        //
        `uniform vec3 ucolor;
           void main() {
          `
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
        // Colorize the shadow, multiply by the falloff so that the center can remain darker
        "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
      );
    };
    const horizontalBlurMaterial2 = new ShaderMaterial(HorizontalBlurShader);
    const verticalBlurMaterial2 = new ShaderMaterial(VerticalBlurShader);
    verticalBlurMaterial2.depthTest = horizontalBlurMaterial2.depthTest = false;
    return [renderTarget2, planeGeometry2, depthMaterial2, blurPlane2, horizontalBlurMaterial2, verticalBlurMaterial2, renderTargetBlur2];
  }, [resolution, width, height, scale2, color]);
  const blurShadows = (blur2) => {
    blurPlane.visible = true;
    blurPlane.material = horizontalBlurMaterial;
    horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;
    horizontalBlurMaterial.uniforms.h.value = blur2 * 1 / 256;
    gl.setRenderTarget(renderTargetBlur);
    gl.render(blurPlane, shadowCamera.current);
    blurPlane.material = verticalBlurMaterial;
    verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;
    verticalBlurMaterial.uniforms.v.value = blur2 * 1 / 256;
    gl.setRenderTarget(renderTarget);
    gl.render(blurPlane, shadowCamera.current);
    blurPlane.visible = false;
  };
  let count = 0;
  let initialBackground;
  let initialOverrideMaterial;
  useFrame(() => {
    if (shadowCamera.current && (frames === Infinity || count < frames)) {
      count++;
      initialBackground = scene.background;
      initialOverrideMaterial = scene.overrideMaterial;
      ref.current.visible = false;
      scene.background = null;
      scene.overrideMaterial = depthMaterial;
      gl.setRenderTarget(renderTarget);
      gl.render(scene, shadowCamera.current);
      blurShadows(blur);
      if (smooth)
        blurShadows(blur * 0.4);
      gl.setRenderTarget(null);
      ref.current.visible = true;
      scene.overrideMaterial = initialOverrideMaterial;
      scene.background = initialBackground;
    }
  });
  React88.useImperativeHandle(fref, () => ref.current, []);
  return React88.createElement("group", _extends({
    "rotation-x": Math.PI / 2
  }, props, {
    ref
  }), React88.createElement("mesh", {
    renderOrder,
    geometry: planeGeometry,
    scale: [1, -1, 1],
    rotation: [-Math.PI / 2, 0, 0]
  }, React88.createElement("meshBasicMaterial", {
    transparent: true,
    map: renderTarget.texture,
    opacity,
    depthWrite
  })), React88.createElement("orthographicCamera", {
    ref: shadowCamera,
    args: [-width / 2, width / 2, height / 2, -height / 2, 0, far]
  }));
});

// node_modules/@react-three/drei/core/AccumulativeShadows.js
var React89 = __toESM(require_react());
function isLight(object) {
  return object.isLight;
}
function isGeometry(object) {
  return !!object.geometry;
}
var accumulativeContext = React89.createContext(null);
var SoftShadowMaterial = shaderMaterial({
  color: new Color(),
  blend: 2,
  alphaTest: 0.75,
  opacity: 0,
  map: null
}, `varying vec2 vUv;
   void main() {
     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
     vUv = uv;
   }`, `varying vec2 vUv;
   uniform sampler2D map;
   uniform vec3 color;
   uniform float opacity;
   uniform float alphaTest;
   uniform float blend;
   void main() {
     vec4 sampledDiffuseColor = texture2D(map, vUv);
     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);
     #include <tonemapping_fragment>
     #include <encodings_fragment>
   }`);
var AccumulativeShadows = React89.forwardRef(({
  children,
  temporal,
  frames = 40,
  limit = Infinity,
  blend = 20,
  scale: scale2 = 10,
  opacity = 1,
  alphaTest = 0.75,
  color = "black",
  colorBlend = 2,
  resolution = 1024,
  toneMapped = true,
  ...props
}, forwardRef71) => {
  extend({
    SoftShadowMaterial
  });
  const gl = useThree((state) => state.gl);
  const scene = useThree((state) => state.scene);
  const camera = useThree((state) => state.camera);
  const invalidate = useThree((state) => state.invalidate);
  const gPlane = React89.useRef(null);
  const gLights = React89.useRef(null);
  const [plm] = React89.useState(() => new ProgressiveLightMap(gl, scene, resolution));
  React89.useLayoutEffect(() => {
    plm.configure(gPlane.current);
  }, []);
  const api = React89.useMemo(() => ({
    lights: /* @__PURE__ */ new Map(),
    temporal: !!temporal,
    frames: Math.max(2, frames),
    blend: Math.max(2, frames === Infinity ? blend : frames),
    count: 0,
    getMesh: () => gPlane.current,
    reset: () => {
      plm.clear();
      const material = gPlane.current.material;
      material.opacity = 0;
      material.alphaTest = 0;
      api.count = 0;
    },
    update: (frames2 = 1) => {
      const material = gPlane.current.material;
      if (!api.temporal) {
        material.opacity = opacity;
        material.alphaTest = alphaTest;
      } else {
        material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);
        material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);
      }
      gLights.current.visible = true;
      plm.prepare();
      for (let i3 = 0; i3 < frames2; i3++) {
        api.lights.forEach((light) => light.update());
        plm.update(camera, api.blend);
      }
      gLights.current.visible = false;
      plm.finish();
    }
  }), [plm, camera, scene, temporal, frames, blend, opacity, alphaTest]);
  React89.useLayoutEffect(() => {
    api.reset();
    if (!api.temporal && api.frames !== Infinity)
      api.update(api.blend);
  });
  React89.useImperativeHandle(forwardRef71, () => api, [api]);
  useFrame(() => {
    if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {
      invalidate();
      api.update();
      api.count++;
    }
  });
  return React89.createElement("group", props, React89.createElement("group", {
    traverse: () => null,
    ref: gLights
  }, React89.createElement(accumulativeContext.Provider, {
    value: api
  }, children)), React89.createElement("mesh", {
    receiveShadow: true,
    ref: gPlane,
    scale: scale2,
    rotation: [-Math.PI / 2, 0, 0]
  }, React89.createElement("planeGeometry", null), React89.createElement("softShadowMaterial", {
    transparent: true,
    depthWrite: false,
    toneMapped,
    color,
    blend: colorBlend,
    map: plm.progressiveLightMap2.texture
  })));
});
var RandomizedLight = React89.forwardRef(({
  castShadow = true,
  bias = 1e-3,
  mapSize = 512,
  size = 5,
  near = 0.5,
  far = 500,
  frames = 1,
  position: position2 = [0, 0, 0],
  radius = 1,
  amount = 8,
  intensity = 1,
  ambient = 0.5,
  ...props
}, forwardRef71) => {
  const gLights = React89.useRef(null);
  const length = new Vector3(...position2).length();
  const parent = React89.useContext(accumulativeContext);
  const update3 = React89.useCallback(() => {
    let light;
    if (gLights.current) {
      for (let l2 = 0; l2 < gLights.current.children.length; l2++) {
        light = gLights.current.children[l2];
        if (Math.random() > ambient) {
          light.position.set(position2[0] + MathUtils.randFloatSpread(radius), position2[1] + MathUtils.randFloatSpread(radius), position2[2] + MathUtils.randFloatSpread(radius));
        } else {
          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2;
          let phi = 2 * Math.PI * Math.random();
          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);
        }
      }
    }
  }, [radius, ambient, length, ...position2]);
  const api = React89.useMemo(() => ({
    update: update3
  }), [update3]);
  React89.useImperativeHandle(forwardRef71, () => api, [api]);
  React89.useLayoutEffect(() => {
    const group = gLights.current;
    if (parent)
      parent.lights.set(group.uuid, api);
    return () => void parent.lights.delete(group.uuid);
  }, [parent, api]);
  return React89.createElement("group", _extends({
    ref: gLights
  }, props), Array.from({
    length: amount
  }, (_, index) => React89.createElement("directionalLight", {
    key: index,
    castShadow,
    "shadow-bias": bias,
    "shadow-mapSize": [mapSize, mapSize],
    intensity: intensity / amount
  }, React89.createElement("orthographicCamera", {
    attach: "shadow-camera",
    args: [-size, size, size, -size, near, far]
  }))));
});
var ProgressiveLightMap = class {
  constructor(renderer, scene, res = 1024) {
    this.renderer = renderer;
    this.res = res;
    this.scene = scene;
    this.buffer1Active = false;
    this.lights = [];
    this.meshes = [];
    this.object = null;
    this.clearColor = new Color();
    this.clearAlpha = 0;
    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? HalfFloatType : FloatType;
    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {
      type: format
    });
    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {
      type: format
    });
    this.discardMat = new DiscardMaterial();
    this.targetMat = new MeshLambertMaterial({
      fog: false
    });
    this.previousShadowMap = {
      value: this.progressiveLightMap1.texture
    };
    this.averagingWindow = {
      value: 100
    };
    this.targetMat.onBeforeCompile = (shader) => {
      shader.vertexShader = "varying vec2 vUv;\n" + shader.vertexShader.slice(0, -1) + "vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";
      const bodyStart = shader.fragmentShader.indexOf("void main() {");
      shader.fragmentShader = "varying vec2 vUv;\n" + shader.fragmentShader.slice(0, bodyStart) + "uniform sampler2D previousShadowMap;\n	uniform float averagingWindow;\n" + shader.fragmentShader.slice(bodyStart - 1, -1) + `
vec3 texelOld = texture2D(previousShadowMap, vUv).rgb;
        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);
      }`;
      shader.uniforms.previousShadowMap = this.previousShadowMap;
      shader.uniforms.averagingWindow = this.averagingWindow;
    };
  }
  clear() {
    this.renderer.getClearColor(this.clearColor);
    this.clearAlpha = this.renderer.getClearAlpha();
    this.renderer.setClearColor("black", 1);
    this.renderer.setRenderTarget(this.progressiveLightMap1);
    this.renderer.clear();
    this.renderer.setRenderTarget(this.progressiveLightMap2);
    this.renderer.clear();
    this.renderer.setRenderTarget(null);
    this.renderer.setClearColor(this.clearColor, this.clearAlpha);
    this.lights = [];
    this.meshes = [];
    this.scene.traverse((object) => {
      if (isGeometry(object)) {
        this.meshes.push({
          object,
          material: object.material
        });
      } else if (isLight(object)) {
        this.lights.push({
          object,
          intensity: object.intensity
        });
      }
    });
  }
  prepare() {
    this.lights.forEach((light) => light.object.intensity = 0);
    this.meshes.forEach((mesh) => mesh.object.material = this.discardMat);
  }
  finish() {
    this.lights.forEach((light) => light.object.intensity = light.intensity);
    this.meshes.forEach((mesh) => mesh.object.material = mesh.material);
  }
  configure(object) {
    this.object = object;
  }
  update(camera, blendWindow = 100) {
    if (!this.object)
      return;
    this.averagingWindow.value = blendWindow;
    this.object.material = this.targetMat;
    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;
    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;
    const oldBg = this.scene.background;
    this.scene.background = null;
    this.renderer.setRenderTarget(activeMap);
    this.previousShadowMap.value = inactiveMap.texture;
    this.buffer1Active = !this.buffer1Active;
    this.renderer.render(this.scene, camera);
    this.renderer.setRenderTarget(null);
    this.scene.background = oldBg;
  }
};

// node_modules/@react-three/drei/core/Stage.js
var presets = {
  rembrandt: {
    main: [1, 2, 1],
    fill: [-2, -0.5, -2]
  },
  portrait: {
    main: [-1, 2, 0.5],
    fill: [-1, 0.5, -1.5]
  },
  upfront: {
    main: [0, 2, 1],
    fill: [-1, 0.5, -1.5]
  },
  soft: {
    main: [-2, 4, 4],
    fill: [-1, 0.5, -1.5]
  }
};
function Refit({
  radius,
  adjustCamera
}) {
  const api = useBounds();
  React90.useEffect(() => {
    if (adjustCamera)
      api.refresh().clip().fit();
  }, [radius, adjustCamera]);
  return null;
}
function Stage({
  children,
  center,
  adjustCamera = true,
  intensity = 0.5,
  shadows = "contact",
  environment = "city",
  preset = "rembrandt",
  ...props
}) {
  var _bias, _normalBias, _size, _offset, _amount, _radius, _ambient, _intensity;
  const config2 = typeof preset === "string" ? presets[preset] : preset;
  const [{
    radius,
    height
  }, set] = React90.useState({
    radius: 0,
    width: 0,
    height: 0,
    depth: 0
  });
  const shadowBias = (_bias = shadows == null ? void 0 : shadows.bias) !== null && _bias !== void 0 ? _bias : -1e-4;
  const normalBias = (_normalBias = shadows == null ? void 0 : shadows.normalBias) !== null && _normalBias !== void 0 ? _normalBias : 0;
  const shadowSize = (_size = shadows == null ? void 0 : shadows.size) !== null && _size !== void 0 ? _size : 1024;
  const shadowOffset = (_offset = shadows == null ? void 0 : shadows.offset) !== null && _offset !== void 0 ? _offset : 0;
  const contactShadow = shadows === "contact" || (shadows == null ? void 0 : shadows.type) === "contact";
  const accumulativeShadow = shadows === "accumulative" || (shadows == null ? void 0 : shadows.type) === "accumulative";
  const shadowSpread = {
    ...typeof shadows === "object" ? shadows : {}
  };
  const environmentProps = !environment ? null : typeof environment === "string" ? {
    preset: environment
  } : environment;
  const onCentered = React90.useCallback((props2) => {
    const {
      width,
      height: height2,
      depth,
      boundingSphere
    } = props2;
    set({
      radius: boundingSphere.radius,
      width,
      height: height2,
      depth
    });
    if (center != null && center.onCentered)
      center.onCentered(props2);
  }, []);
  return React90.createElement(React90.Fragment, null, React90.createElement("ambientLight", {
    intensity: intensity / 3
  }), React90.createElement("spotLight", {
    penumbra: 1,
    position: [config2.main[0] * radius, config2.main[1] * radius, config2.main[2] * radius],
    intensity: intensity * 2,
    castShadow: !!shadows,
    "shadow-bias": shadowBias,
    "shadow-normalBias": normalBias,
    "shadow-mapSize": shadowSize
  }), React90.createElement("pointLight", {
    position: [config2.fill[0] * radius, config2.fill[1] * radius, config2.fill[2] * radius],
    intensity
  }), React90.createElement(Bounds, _extends({
    fit: !!adjustCamera,
    clip: !!adjustCamera,
    margin: Number(adjustCamera),
    observe: true
  }, props), React90.createElement(Refit, {
    radius,
    adjustCamera
  }), React90.createElement(Center, _extends({}, center, {
    position: [0, shadowOffset / 2, 0],
    onCentered
  }), children)), React90.createElement("group", {
    position: [0, -height / 2 - shadowOffset / 2, 0]
  }, contactShadow && React90.createElement(ContactShadows, _extends({
    scale: radius * 4,
    far: radius,
    blur: 2
  }, shadowSpread)), accumulativeShadow && React90.createElement(AccumulativeShadows, _extends({
    temporal: true,
    frames: 100,
    alphaTest: 0.9,
    toneMapped: true,
    scale: radius * 4
  }, shadowSpread), React90.createElement(RandomizedLight, {
    amount: (_amount = shadowSpread.amount) !== null && _amount !== void 0 ? _amount : 8,
    radius: (_radius = shadowSpread.radius) !== null && _radius !== void 0 ? _radius : radius,
    ambient: (_ambient = shadowSpread.ambient) !== null && _ambient !== void 0 ? _ambient : 0.5,
    intensity: (_intensity = shadowSpread.intensity) !== null && _intensity !== void 0 ? _intensity : 1,
    position: [config2.main[0] * radius, config2.main[1] * radius, config2.main[2] * radius],
    size: radius * 4,
    bias: -shadowBias,
    mapSize: shadowSize
  }))), environment && React90.createElement(Environment, environmentProps));
}

// node_modules/@react-three/drei/core/Backdrop.js
var React91 = __toESM(require_react());
var easeInExpo = (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10);
function Backdrop({
  children,
  floor = 0.25,
  segments = 20,
  receiveShadow,
  ...props
}) {
  const ref = React91.useRef(null);
  React91.useLayoutEffect(() => {
    let i3 = 0;
    const offset = segments / segments / 2;
    const position2 = ref.current.attributes.position;
    for (let x = 0; x < segments + 1; x++) {
      for (let y = 0; y < segments + 1; y++) {
        position2.setXYZ(i3++, x / segments - offset + (x === 0 ? -floor : 0), y / segments - offset, easeInExpo(x / segments));
      }
    }
    position2.needsUpdate = true;
    ref.current.computeVertexNormals();
  }, [segments, floor]);
  return React91.createElement("group", props, React91.createElement("mesh", {
    receiveShadow,
    rotation: [-Math.PI / 2, 0, Math.PI / 2]
  }, React91.createElement("planeGeometry", {
    ref,
    args: [1, 1, segments, segments]
  }), children));
}

// node_modules/@react-three/drei/core/Shadow.js
var React92 = __toESM(require_react());
var Shadow = React92.forwardRef(({
  fog = false,
  renderOrder,
  depthWrite = false,
  colorStop = 0,
  color = "black",
  opacity = 0.5,
  ...props
}, ref) => {
  const canvas = React92.useMemo(() => {
    const canvas2 = document.createElement("canvas");
    canvas2.width = 128;
    canvas2.height = 128;
    const context10 = canvas2.getContext("2d");
    const gradient = context10.createRadialGradient(canvas2.width / 2, canvas2.height / 2, 0, canvas2.width / 2, canvas2.height / 2, canvas2.width / 2);
    gradient.addColorStop(colorStop, new Color(color).getStyle());
    gradient.addColorStop(1, "rgba(0,0,0,0)");
    context10.fillStyle = gradient;
    context10.fillRect(0, 0, canvas2.width, canvas2.height);
    return canvas2;
  }, [color, colorStop]);
  return React92.createElement("mesh", _extends({
    renderOrder,
    ref,
    "rotation-x": -Math.PI / 2
  }, props), React92.createElement("planeGeometry", null), React92.createElement("meshBasicMaterial", {
    transparent: true,
    opacity,
    fog,
    depthWrite,
    side: DoubleSide
  }, React92.createElement("canvasTexture", {
    attach: "map",
    args: [canvas]
  })));
});

// node_modules/@react-three/drei/core/Caustics.js
var React93 = __toESM(require_react());
function createNormalMaterial(side = FrontSide) {
  const viewMatrix = {
    value: new Matrix4()
  };
  return Object.assign(new MeshNormalMaterial({
    side
  }), {
    viewMatrix,
    onBeforeCompile: (shader) => {
      shader.uniforms.viewMatrix = viewMatrix;
      shader.fragmentShader = `vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
         }
` + shader.fragmentShader.replace("#include <normal_fragment_maps>", `#include <normal_fragment_maps>
           normal = inverseTransformDirection( normal, viewMatrix );
`);
    }
  });
}
var CausticsProjectionMaterial = shaderMaterial({
  causticsTexture: null,
  causticsTextureB: null,
  color: new Color(),
  lightProjMatrix: new Matrix4(),
  lightViewMatrix: new Matrix4()
}, `varying vec3 vWorldPosition;   
   void main() {
     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
     vec4 worldPosition = modelMatrix * vec4(position, 1.);
     vWorldPosition = worldPosition.xyz;
   }`, `varying vec3 vWorldPosition;
  uniform vec3 color;
  uniform sampler2D causticsTexture; 
  uniform sampler2D causticsTextureB; 
  uniform mat4 lightProjMatrix;
  uniform mat4 lightViewMatrix;
   void main() {
    // Apply caustics  
    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);
    lightSpacePos.xyz /= lightSpacePos.w;
    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; 
    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;
    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;
    gl_FragColor = vec4((front + back) * color, 1.0);
    #include <tonemapping_fragment>
    #include <encodings_fragment>
   }`);
var CausticsMaterial = shaderMaterial(
  {
    cameraMatrixWorld: new Matrix4(),
    cameraProjectionMatrixInv: new Matrix4(),
    normalTexture: null,
    depthTexture: null,
    lightDir: new Vector3(0, 1, 0),
    lightPlaneNormal: new Vector3(0, 1, 0),
    lightPlaneConstant: 0,
    near: 0.1,
    far: 100,
    modelMatrix: new Matrix4(),
    worldRadius: 1 / 40,
    ior: 1.1,
    bounces: 0,
    resolution: 1024,
    size: 10,
    intensity: 0.5
  },
  /* glsl */
  `
  varying vec2 vUv;
  void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }`,
  /* glsl */
  `  
  uniform mat4 cameraMatrixWorld;
  uniform mat4 cameraProjectionMatrixInv;
  uniform vec3 lightDir;
  uniform vec3 lightPlaneNormal;
  uniform float lightPlaneConstant;
  uniform float near;
  uniform float far;
  uniform float time;
  uniform float worldRadius;
  uniform float resolution;
  uniform float size;
  uniform float intensity;
  uniform float ior;
  precision highp isampler2D;
  precision highp usampler2D;
  uniform sampler2D normalTexture;
  uniform sampler2D depthTexture;
  uniform float bounces;
  varying vec2 vUv;
  vec3 WorldPosFromDepth(float depth, vec2 coord) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;
    // Perspective division
    viewSpacePosition /= viewSpacePosition.w;
    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;
    return worldSpacePosition.xyz;
  }                  
  float sdPlane( vec3 p, vec3 n, float h ) {
    // n must be normalized
    return dot(p,n) + h;
  }
  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {
    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
  }
  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {
    rayOrigin = ro;
    rayDirection = rd;
    rayDirection = refract(rayDirection, normal, 1.0 / ior);
    rayOrigin = pos + rayDirection * 0.1;
    return rayDirection;
  }
  void main() {
    // Each sample consists of random offset in the x and y direction
    float caustic = 0.0;
    float causticTexelSize = (1.0 / resolution) * size * 2.0;
    float texelsNeeded = worldRadius / causticTexelSize;
    float sampleRadius = texelsNeeded / resolution;
    float sum = 0.0;
    if (texture2D(depthTexture, vUv).x == 1.0) {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
      return;
    }
    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);
    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);
    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);
    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);
    vec2 uv1 = vUv + offset1 * sampleRadius;
    vec2 uv2 = vUv + offset2 * sampleRadius;
    vec2 uv3 = vUv + offset3 * sampleRadius;
    vec2 uv4 = vUv + offset4 * sampleRadius;
    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;
    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;
    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;
    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;
    float depth1 = texture2D(depthTexture, uv1, -10.0).x;
    float depth2 = texture2D(depthTexture, uv2, -10.0).x;
    float depth3 = texture2D(depthTexture, uv3, -10.0).x;
    float depth4 = texture2D(depthTexture, uv4, -10.0).x;
    // Sanity check the depths
    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
      return;
    }
    vec3 pos1 = WorldPosFromDepth(depth1, uv1);
    vec3 pos2 = WorldPosFromDepth(depth2, uv2);
    vec3 pos3 = WorldPosFromDepth(depth3, uv3);
    vec3 pos4 = WorldPosFromDepth(depth4, uv4);
    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);
    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);
    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);
    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);
    vec3 endPos1, endPos2, endPos3, endPos4;
    vec3 endDir1, endDir2, endDir3, endDir4;
    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);
    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);
    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);
    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);
    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));
    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));
    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));
    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));
    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));
    vec3 finalPos1 = endPos1 + endDir1 * t1;
    vec3 finalPos2 = endPos2 + endDir2 * t2;
    vec3 finalPos3 = endPos3 + endDir3 * t3;
    vec3 finalPos4 = endPos4 + endDir4 * t4;
    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));
    caustic += intensity * (lightPosArea / finalArea);
    // Calculate the area of the triangle in light spaces
    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);
  }`
);
var NORMALPROPS = {
  depth: true,
  minFilter: LinearFilter,
  magFilter: LinearFilter,
  encoding: LinearEncoding,
  type: UnsignedByteType
};
var CAUSTICPROPS = {
  minFilter: LinearMipmapLinearFilter,
  magFilter: LinearFilter,
  encoding: LinearEncoding,
  format: RGBAFormat,
  type: FloatType,
  generateMipmaps: true
};
var Caustics = React93.forwardRef(({
  debug,
  children,
  frames = 1,
  ior = 1.1,
  color = "white",
  causticsOnly = false,
  backside = false,
  backsideIOR = 1.1,
  worldRadius = 0.3125,
  intensity = 0.05,
  resolution = 2024,
  lightSource = [5, 5, 5],
  ...props
}, fref) => {
  extend({
    CausticsProjectionMaterial
  });
  const ref = React93.useRef(null);
  const camera = React93.useRef(null);
  const scene = React93.useRef(null);
  const plane = React93.useRef(null);
  const gl = useThree((state) => state.gl);
  const helper = useHelper(debug && camera, CameraHelper);
  const normalTarget = useFBO(resolution, resolution, NORMALPROPS);
  const normalTargetB = useFBO(resolution, resolution, NORMALPROPS);
  const causticsTarget = useFBO(resolution, resolution, CAUSTICPROPS);
  const causticsTargetB = useFBO(resolution, resolution, CAUSTICPROPS);
  const [normalMat] = React93.useState(() => createNormalMaterial());
  const [normalMatB] = React93.useState(() => createNormalMaterial(BackSide));
  const [causticsMaterial] = React93.useState(() => new CausticsMaterial());
  const [causticsQuad] = React93.useState(() => new FullScreenQuad(causticsMaterial));
  React93.useLayoutEffect(() => {
    ref.current.updateWorldMatrix(false, true);
  });
  let count = 0;
  const v4 = new Vector3();
  const lpF = new Frustum();
  const lpM = new Matrix4();
  const lpP = new Plane();
  const lightDir = new Vector3();
  const lightDirInv = new Vector3();
  const bounds = new Box3();
  const focusPos = new Vector3();
  const boundsVertices = [];
  const worldVerts = [];
  const projectedVerts = [];
  const lightDirs = [];
  const cameraPos = new Vector3();
  for (let i3 = 0; i3 < 8; i3++) {
    boundsVertices.push(new Vector3());
    worldVerts.push(new Vector3());
    projectedVerts.push(new Vector3());
    lightDirs.push(new Vector3());
  }
  useFrame(() => {
    if (frames === Infinity || count++ < frames) {
      var _scene$current$parent, _helper$current;
      if (Array.isArray(lightSource))
        lightDir.fromArray(lightSource).normalize();
      else
        lightDir.copy(ref.current.worldToLocal(lightSource.current.getWorldPosition(v4)).normalize());
      lightDirInv.copy(lightDir).multiplyScalar(-1);
      (_scene$current$parent = scene.current.parent) == null ? void 0 : _scene$current$parent.matrixWorld.identity();
      bounds.setFromObject(scene.current, true);
      boundsVertices[0].set(bounds.min.x, bounds.min.y, bounds.min.z);
      boundsVertices[1].set(bounds.min.x, bounds.min.y, bounds.max.z);
      boundsVertices[2].set(bounds.min.x, bounds.max.y, bounds.min.z);
      boundsVertices[3].set(bounds.min.x, bounds.max.y, bounds.max.z);
      boundsVertices[4].set(bounds.max.x, bounds.min.y, bounds.min.z);
      boundsVertices[5].set(bounds.max.x, bounds.min.y, bounds.max.z);
      boundsVertices[6].set(bounds.max.x, bounds.max.y, bounds.min.z);
      boundsVertices[7].set(bounds.max.x, bounds.max.y, bounds.max.z);
      for (let i3 = 0; i3 < 8; i3++) {
        worldVerts[i3].copy(boundsVertices[i3]);
      }
      bounds.getCenter(focusPos);
      boundsVertices.map((v5) => v5.sub(focusPos));
      const lightPlane = lpP.set(lightDirInv, 0);
      boundsVertices.map((v5, i3) => lightPlane.projectPoint(v5, projectedVerts[i3]));
      const centralVert = projectedVerts.reduce((a3, b) => a3.add(b), v4.set(0, 0, 0)).divideScalar(projectedVerts.length);
      const radius = projectedVerts.map((v5) => v5.distanceTo(centralVert)).reduce((a3, b) => Math.max(a3, b));
      const dirLength = boundsVertices.map((x) => x.dot(lightDir)).reduce((a3, b) => Math.max(a3, b));
      camera.current.position.copy(cameraPos.copy(lightDir).multiplyScalar(dirLength).add(focusPos));
      camera.current.lookAt(scene.current.localToWorld(focusPos));
      const dirMatrix = lpM.lookAt(camera.current.position, focusPos, v4.set(0, 1, 0));
      camera.current.left = -radius;
      camera.current.right = radius;
      camera.current.top = radius;
      camera.current.bottom = -radius;
      const yOffset = v4.set(0, radius, 0).applyMatrix4(dirMatrix);
      const yTime = (camera.current.position.y + yOffset.y) / lightDir.y;
      camera.current.near = 0.1;
      camera.current.far = yTime;
      camera.current.updateProjectionMatrix();
      camera.current.updateMatrixWorld();
      const groundProjectedCoords = worldVerts.map((v5, i3) => v5.add(lightDirs[i3].copy(lightDir).multiplyScalar(-v5.y / lightDir.y)));
      const centerPos = groundProjectedCoords.reduce((a3, b) => a3.add(b), v4.set(0, 0, 0)).divideScalar(groundProjectedCoords.length);
      const maxSize = 2 * groundProjectedCoords.map((v5) => Math.hypot(v5.x - centerPos.x, v5.z - centerPos.z)).reduce((a3, b) => Math.max(a3, b));
      plane.current.scale.setScalar(maxSize);
      plane.current.position.copy(centerPos);
      if (debug)
        (_helper$current = helper.current) == null ? void 0 : _helper$current.update();
      normalMatB.viewMatrix.value = normalMat.viewMatrix.value = camera.current.matrixWorldInverse;
      const dirLightNearPlane = lpF.setFromProjectionMatrix(lpM.multiplyMatrices(camera.current.projectionMatrix, camera.current.matrixWorldInverse)).planes[4];
      causticsMaterial.cameraMatrixWorld = camera.current.matrixWorld;
      causticsMaterial.cameraProjectionMatrixInv = camera.current.projectionMatrixInverse;
      causticsMaterial.lightDir = lightDirInv;
      causticsMaterial.lightPlaneNormal = dirLightNearPlane.normal;
      causticsMaterial.lightPlaneConstant = dirLightNearPlane.constant;
      causticsMaterial.near = camera.current.near;
      causticsMaterial.far = camera.current.far;
      causticsMaterial.resolution = resolution;
      causticsMaterial.size = radius;
      causticsMaterial.intensity = intensity;
      causticsMaterial.worldRadius = worldRadius;
      scene.current.visible = true;
      gl.setRenderTarget(normalTarget);
      gl.clear();
      scene.current.overrideMaterial = normalMat;
      gl.render(scene.current, camera.current);
      gl.setRenderTarget(normalTargetB);
      gl.clear();
      if (backside) {
        scene.current.overrideMaterial = normalMatB;
        gl.render(scene.current, camera.current);
      }
      scene.current.overrideMaterial = null;
      causticsMaterial.ior = ior;
      plane.current.material.lightProjMatrix = camera.current.projectionMatrix;
      plane.current.material.lightViewMatrix = camera.current.matrixWorldInverse;
      causticsMaterial.normalTexture = normalTarget.texture;
      causticsMaterial.depthTexture = normalTarget.depthTexture;
      gl.setRenderTarget(causticsTarget);
      gl.clear();
      causticsQuad.render(gl);
      causticsMaterial.ior = backsideIOR;
      causticsMaterial.normalTexture = normalTargetB.texture;
      causticsMaterial.depthTexture = normalTargetB.depthTexture;
      gl.setRenderTarget(causticsTargetB);
      gl.clear();
      if (backside)
        causticsQuad.render(gl);
      gl.setRenderTarget(null);
      if (causticsOnly)
        scene.current.visible = false;
    }
  });
  React93.useImperativeHandle(fref, () => ref.current, []);
  return React93.createElement("group", _extends({
    ref
  }, props), React93.createElement("scene", {
    ref: scene
  }, React93.createElement("orthographicCamera", {
    ref: camera,
    up: [0, 1, 0]
  }), children), React93.createElement("mesh", {
    renderOrder: 2,
    ref: plane,
    "rotation-x": -Math.PI / 2
  }, React93.createElement("planeGeometry", null), React93.createElement("causticsProjectionMaterial", {
    transparent: true,
    color,
    causticsTexture: causticsTarget.texture,
    causticsTextureB: causticsTargetB.texture,
    blending: CustomBlending,
    blendSrc: OneFactor,
    blendDst: SrcAlphaFactor,
    depthWrite: false
  }), debug && React93.createElement(Edges, null, React93.createElement("lineBasicMaterial", {
    color: "#ffff00",
    toneMapped: false
  }))));
});

// node_modules/@react-three/drei/core/Reflector.js
var React94 = __toESM(require_react());
extend({
  MeshReflectorMaterial
});
var Reflector = React94.forwardRef(({
  mixBlur = 0,
  mixStrength = 0.5,
  resolution = 256,
  blur = [0, 0],
  args = [1, 1],
  minDepthThreshold = 0.9,
  maxDepthThreshold = 1,
  depthScale = 0,
  depthToBlurRatioBias = 0.25,
  mirror = 0,
  children,
  debug = 0,
  distortion = 1,
  mixContrast = 1,
  distortionMap,
  ...props
}, ref) => {
  React94.useEffect(() => {
    console.warn("Reflector has been deprecated and will be removed next major. Replace it with <MeshReflectorMaterial />!");
  }, []);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  blur = Array.isArray(blur) ? blur : [blur, blur];
  const hasBlur = blur[0] + blur[1] > 0;
  const meshRef = React94.useRef(null);
  const [reflectorPlane] = React94.useState(() => new Plane());
  const [normal2] = React94.useState(() => new Vector3());
  const [reflectorWorldPosition] = React94.useState(() => new Vector3());
  const [cameraWorldPosition] = React94.useState(() => new Vector3());
  const [rotationMatrix] = React94.useState(() => new Matrix4());
  const [lookAtPosition] = React94.useState(() => new Vector3(0, 0, -1));
  const [clipPlane] = React94.useState(() => new Vector4());
  const [view] = React94.useState(() => new Vector3());
  const [target2] = React94.useState(() => new Vector3());
  const [q] = React94.useState(() => new Vector4());
  const [textureMatrix] = React94.useState(() => new Matrix4());
  const [virtualCamera] = React94.useState(() => new PerspectiveCamera());
  const beforeRender = React94.useCallback(() => {
    reflectorWorldPosition.setFromMatrixPosition(meshRef.current.matrixWorld);
    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    rotationMatrix.extractRotation(meshRef.current.matrixWorld);
    normal2.set(0, 0, 1);
    normal2.applyMatrix4(rotationMatrix);
    view.subVectors(reflectorWorldPosition, cameraWorldPosition);
    if (view.dot(normal2) > 0)
      return;
    view.reflect(normal2).negate();
    view.add(reflectorWorldPosition);
    rotationMatrix.extractRotation(camera.matrixWorld);
    lookAtPosition.set(0, 0, -1);
    lookAtPosition.applyMatrix4(rotationMatrix);
    lookAtPosition.add(cameraWorldPosition);
    target2.subVectors(reflectorWorldPosition, lookAtPosition);
    target2.reflect(normal2).negate();
    target2.add(reflectorWorldPosition);
    virtualCamera.position.copy(view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(rotationMatrix);
    virtualCamera.up.reflect(normal2);
    virtualCamera.lookAt(target2);
    virtualCamera.far = camera.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
    textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    textureMatrix.multiply(virtualCamera.projectionMatrix);
    textureMatrix.multiply(virtualCamera.matrixWorldInverse);
    textureMatrix.multiply(meshRef.current.matrixWorld);
    reflectorPlane.setFromNormalAndCoplanarPoint(normal2, reflectorWorldPosition);
    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    q.z = -1;
    q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(2 / clipPlane.dot(q));
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = clipPlane.z + 1;
    projectionMatrix.elements[14] = clipPlane.w;
  }, []);
  const [fbo1, fbo2, blurpass, reflectorProps] = React94.useMemo(() => {
    const parameters = {
      type: HalfFloatType,
      minFilter: LinearFilter,
      magFilter: LinearFilter
    };
    const fbo12 = new WebGLRenderTarget(resolution, resolution, parameters);
    fbo12.depthBuffer = true;
    fbo12.depthTexture = new DepthTexture(resolution, resolution);
    fbo12.depthTexture.format = DepthFormat;
    fbo12.depthTexture.type = UnsignedShortType;
    const fbo22 = new WebGLRenderTarget(resolution, resolution, parameters);
    const blurpass2 = new BlurPass({
      gl,
      resolution,
      width: blur[0],
      height: blur[1],
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias
    });
    const reflectorProps2 = {
      mirror,
      textureMatrix,
      mixBlur,
      tDiffuse: fbo12.texture,
      tDepth: fbo12.depthTexture,
      tDiffuseBlur: fbo22.texture,
      hasBlur,
      mixStrength,
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias,
      transparent: true,
      debug,
      distortion,
      distortionMap,
      mixContrast,
      "defines-USE_BLUR": hasBlur ? "" : void 0,
      "defines-USE_DEPTH": depthScale > 0 ? "" : void 0,
      "defines-USE_DISTORTION": distortionMap ? "" : void 0
    };
    return [fbo12, fbo22, blurpass2, reflectorProps2];
  }, [gl, blur, textureMatrix, resolution, mirror, hasBlur, mixBlur, mixStrength, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, debug, distortion, distortionMap, mixContrast]);
  useFrame(() => {
    if (!(meshRef != null && meshRef.current))
      return;
    meshRef.current.visible = false;
    const currentXrEnabled = gl.xr.enabled;
    const currentShadowAutoUpdate = gl.shadowMap.autoUpdate;
    beforeRender();
    gl.xr.enabled = false;
    gl.shadowMap.autoUpdate = false;
    gl.setRenderTarget(fbo1);
    gl.state.buffers.depth.setMask(true);
    if (!gl.autoClear)
      gl.clear();
    gl.render(scene, virtualCamera);
    if (hasBlur)
      blurpass.render(gl, fbo1, fbo2);
    gl.xr.enabled = currentXrEnabled;
    gl.shadowMap.autoUpdate = currentShadowAutoUpdate;
    meshRef.current.visible = true;
    gl.setRenderTarget(null);
  });
  return React94.createElement("mesh", _extends({
    ref: react_merge_refs_esm_default([meshRef, ref])
  }, props), React94.createElement("planeGeometry", {
    args
  }), children ? children("meshReflectorMaterial", reflectorProps) : React94.createElement("meshReflectorMaterial", reflectorProps));
});

// node_modules/@react-three/drei/core/SpotLight.js
var React95 = __toESM(require_react());

// node_modules/@react-three/drei/materials/SpotLightMaterial.js
var SpotLightMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        depth: {
          value: null
        },
        opacity: {
          value: 1
        },
        attenuation: {
          value: 2.5
        },
        anglePower: {
          value: 12
        },
        spotPosition: {
          value: new Vector3(0, 0, 0)
        },
        lightColor: {
          value: new Color("white")
        },
        cameraNear: {
          value: 0
        },
        cameraFar: {
          value: 1
        },
        resolution: {
          value: new Vector2(0, 0)
        }
      },
      transparent: true,
      depthWrite: false,
      vertexShader: (
        /* glsl */
        `
      varying vec3 vNormal;
      varying vec3 vWorldPosition;
      varying float vViewZ;
      varying float vIntensity;
      uniform vec3 spotPosition;
      uniform float attenuation;      

      void main() {
        // compute intensity
        vNormal = normalize( normalMatrix * normal );
        vec4 worldPosition	= modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;
        vec4 viewPosition = viewMatrix * worldPosition;
        vViewZ = viewPosition.z;
        float intensity	= distance(worldPosition.xyz, spotPosition) / attenuation;
        intensity	= 1.0 - clamp(intensity, 0.0, 1.0);
        vIntensity = intensity;        
        // set gl_Position
        gl_Position	= projectionMatrix * viewPosition;

      }`
      ),
      fragmentShader: (
        /* glsl */
        `
      #include <packing>

      varying vec3 vNormal;
      varying vec3 vWorldPosition;
      uniform vec3 lightColor;
      uniform vec3 spotPosition;
      uniform float attenuation;
      uniform float anglePower;
      uniform sampler2D depth;
      uniform vec2 resolution;
      uniform float cameraNear;
      uniform float cameraFar;
      varying float vViewZ;
      varying float vIntensity;
      uniform float opacity;

      float readDepth( sampler2D depthSampler, vec2 coord ) {
        float fragCoordZ = texture2D( depthSampler, coord ).x;
        float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
        return viewZ;
      }

      void main() {
        float d = 1.0;
        bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;
        if (isSoft) {
          vec2 sUv = gl_FragCoord.xy / resolution;
          d = readDepth(depth, sUv);
        }
        float intensity = vIntensity;
        vec3 normal	= vec3(vNormal.x, vNormal.y, abs(vNormal.z));
        float angleIntensity	= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );
        intensity	*= angleIntensity;
        // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry
        if (isSoft) {
          intensity	*= smoothstep(0., 1., vViewZ - d);
        }
        gl_FragColor = vec4(lightColor, intensity * opacity);

        #include <tonemapping_fragment>
	      #include <encodings_fragment>
      }`
      )
    });
  }
};

// node_modules/@react-three/drei/helpers/glsl/DefaultSpotlightShadowShadows.glsl.js
var SpotlightShadowShader = "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D uShadowMap;uniform float uTime;void main(){vec3 color=texture2D(uShadowMap,vUv).xyz;gl_FragColor=vec4(color,1.);}";

// node_modules/@react-three/drei/core/SpotLight.js
var isSpotLight = (child) => {
  return child == null ? void 0 : child.isSpotLight;
};
function VolumetricMesh({
  opacity = 1,
  radiusTop,
  radiusBottom,
  depthBuffer,
  color = "white",
  distance = 5,
  angle = 0.15,
  attenuation = 5,
  anglePower = 5
}) {
  const mesh = React95.useRef(null);
  const size = useThree((state) => state.size);
  const camera = useThree((state) => state.camera);
  const dpr = useThree((state) => state.viewport.dpr);
  const [material] = React95.useState(() => new SpotLightMaterial());
  const [vec] = React95.useState(() => new Vector3());
  radiusTop = radiusTop === void 0 ? 0.1 : radiusTop;
  radiusBottom = radiusBottom === void 0 ? angle * 7 : radiusBottom;
  useFrame(() => {
    material.uniforms.spotPosition.value.copy(mesh.current.getWorldPosition(vec));
    mesh.current.lookAt(mesh.current.parent.target.getWorldPosition(vec));
  });
  const geom = React95.useMemo(() => {
    const geometry = new CylinderGeometry(radiusTop, radiusBottom, distance, 128, 64, true);
    geometry.applyMatrix4(new Matrix4().makeTranslation(0, -distance / 2, 0));
    geometry.applyMatrix4(new Matrix4().makeRotationX(-Math.PI / 2));
    return geometry;
  }, [distance, radiusTop, radiusBottom]);
  return React95.createElement(React95.Fragment, null, React95.createElement("mesh", {
    ref: mesh,
    geometry: geom,
    raycast: () => null
  }, React95.createElement("primitive", {
    object: material,
    attach: "material",
    "uniforms-opacity-value": opacity,
    "uniforms-lightColor-value": color,
    "uniforms-attenuation-value": attenuation,
    "uniforms-anglePower-value": anglePower,
    "uniforms-depth-value": depthBuffer,
    "uniforms-cameraNear-value": camera.near,
    "uniforms-cameraFar-value": camera.far,
    "uniforms-resolution-value": depthBuffer ? [size.width * dpr, size.height * dpr] : [0, 0]
  })));
}
function useCommon(spotlight, mesh, width, height, distance) {
  const [[pos, dir]] = React95.useState(() => [new Vector3(), new Vector3()]);
  React95.useLayoutEffect(() => {
    if (isSpotLight(spotlight.current)) {
      spotlight.current.shadow.mapSize.set(width, height);
      spotlight.current.shadow.needsUpdate = true;
    } else {
      throw new Error("SpotlightShadow must be a child of a SpotLight");
    }
  }, [spotlight, width, height]);
  useFrame(() => {
    if (!spotlight.current)
      return;
    const A = spotlight.current.position;
    const B = spotlight.current.target.position;
    dir.copy(B).sub(A);
    var len = dir.length();
    dir.normalize().multiplyScalar(len * distance);
    pos.copy(A).add(dir);
    mesh.current.position.copy(pos);
    mesh.current.lookAt(spotlight.current.target.position);
  });
}
function SpotlightShadowWithShader({
  distance = 0.4,
  alphaTest = 0.5,
  map,
  shader = SpotlightShadowShader,
  width = 512,
  height = 512,
  scale: scale2 = 1,
  children,
  ...rest
}) {
  const mesh = React95.useRef(null);
  const spotlight = rest.spotlightRef;
  const debug = rest.debug;
  useCommon(spotlight, mesh, width, height, distance);
  const renderTarget = React95.useMemo(() => new WebGLRenderTarget(width, height, {
    format: RGBAFormat,
    encoding: LinearEncoding,
    stencilBuffer: false
    // depthTexture: null!
  }), [width, height]);
  const uniforms = React95.useRef({
    uShadowMap: {
      value: map
    },
    uTime: {
      value: 0
    }
  });
  React95.useEffect(() => void (uniforms.current.uShadowMap.value = map), [map]);
  const fsQuad = React95.useMemo(() => new FullScreenQuad(new ShaderMaterial({
    uniforms: uniforms.current,
    vertexShader: (
      /* glsl */
      `
          varying vec2 vUv;

          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
          `
    ),
    fragmentShader: shader
  })), [shader]);
  React95.useEffect(() => () => {
    fsQuad.material.dispose();
    fsQuad.dispose();
  }, [fsQuad]);
  React95.useEffect(() => () => renderTarget.dispose(), [renderTarget]);
  useFrame(({
    gl
  }, dt) => {
    uniforms.current.uTime.value += dt;
    gl.setRenderTarget(renderTarget);
    fsQuad.render(gl);
    gl.setRenderTarget(null);
  });
  return React95.createElement(React95.Fragment, null, React95.createElement("mesh", {
    ref: mesh,
    scale: scale2,
    castShadow: true
  }, React95.createElement("planeGeometry", null), React95.createElement("meshBasicMaterial", {
    transparent: true,
    side: DoubleSide,
    alphaTest,
    alphaMap: renderTarget.texture,
    "alphaMap-wrapS": RepeatWrapping,
    "alphaMap-wrapT": RepeatWrapping,
    opacity: debug ? 1 : 0
  }, children)));
}
function SpotlightShadowWithoutShader({
  distance = 0.4,
  alphaTest = 0.5,
  map,
  width = 512,
  height = 512,
  scale: scale2,
  children,
  ...rest
}) {
  const mesh = React95.useRef(null);
  const spotlight = rest.spotlightRef;
  const debug = rest.debug;
  useCommon(spotlight, mesh, width, height, distance);
  return React95.createElement(React95.Fragment, null, React95.createElement("mesh", {
    ref: mesh,
    scale: scale2,
    castShadow: true
  }, React95.createElement("planeGeometry", null), React95.createElement("meshBasicMaterial", {
    transparent: true,
    side: DoubleSide,
    alphaTest,
    alphaMap: map,
    "alphaMap-wrapS": RepeatWrapping,
    "alphaMap-wrapT": RepeatWrapping,
    opacity: debug ? 1 : 0
  }, children)));
}
function SpotLightShadow(props) {
  if (props.shader)
    return React95.createElement(SpotlightShadowWithShader, props);
  return React95.createElement(SpotlightShadowWithoutShader, props);
}
var SpotLight = React95.forwardRef(({
  // Volumetric
  opacity = 1,
  radiusTop,
  radiusBottom,
  depthBuffer,
  color = "white",
  distance = 5,
  angle = 0.15,
  attenuation = 5,
  anglePower = 5,
  volumetric = true,
  debug = false,
  children,
  ...props
}, ref) => {
  const spotlight = React95.useRef(null);
  return React95.createElement("group", null, debug && spotlight.current && React95.createElement("spotLightHelper", {
    args: [spotlight.current]
  }), React95.createElement("spotLight", _extends({
    ref: react_merge_refs_esm_default([ref, spotlight]),
    angle,
    color,
    distance,
    castShadow: true
  }, props), volumetric && React95.createElement(VolumetricMesh, {
    debug,
    opacity,
    radiusTop,
    radiusBottom,
    depthBuffer,
    color,
    distance,
    angle,
    attenuation,
    anglePower
  })), children && React95.cloneElement(children, {
    spotlightRef: spotlight,
    debug
  }));
});

// node_modules/@react-three/drei/core/Lightformer.js
var React96 = __toESM(require_react());
var Lightformer = React96.forwardRef(({
  args,
  map,
  toneMapped = false,
  color = "white",
  form: Form = "rect",
  intensity = 1,
  scale: scale2 = 1,
  target: target2,
  children,
  ...props
}, forwardRef71) => {
  const ref = React96.useRef(null);
  React96.useLayoutEffect(() => {
    if (!children && !props.material) {
      applyProps(ref.current.material, {
        color
      });
      ref.current.material.color.multiplyScalar(intensity);
    }
  }, [color, intensity, children, props.material]);
  React96.useLayoutEffect(() => {
    if (target2)
      ref.current.lookAt(Array.isArray(target2) ? new Vector3(...target2) : target2);
  }, [target2]);
  scale2 = Array.isArray(scale2) && scale2.length === 2 ? [scale2[0], scale2[1], 1] : scale2;
  return React96.createElement("mesh", _extends({
    ref: react_merge_refs_esm_default([ref, forwardRef71]),
    scale: scale2
  }, props), Form === "circle" ? React96.createElement("ringGeometry", {
    args: [0, 1, 64]
  }) : Form === "ring" ? React96.createElement("ringGeometry", {
    args: [0.5, 1, 64]
  }) : Form === "rect" ? React96.createElement("planeGeometry", null) : React96.createElement(Form, {
    args
  }), children ? children : !props.material ? React96.createElement("meshBasicMaterial", {
    toneMapped,
    map,
    side: DoubleSide
  }) : null);
});

// node_modules/@react-three/drei/core/Sky.js
var React97 = __toESM(require_react());
function calcPosFromAngles(inclination, azimuth, vector = new Vector3()) {
  const theta = Math.PI * (inclination - 0.5);
  const phi = 2 * Math.PI * (azimuth - 0.5);
  vector.x = Math.cos(phi);
  vector.y = Math.sin(theta);
  vector.z = Math.sin(phi);
  return vector;
}
var Sky2 = React97.forwardRef(({
  inclination = 0.6,
  azimuth = 0.1,
  distance = 1e3,
  mieCoefficient = 5e-3,
  mieDirectionalG = 0.8,
  rayleigh = 0.5,
  turbidity = 10,
  sunPosition = calcPosFromAngles(inclination, azimuth),
  ...props
}, ref) => {
  const scale2 = React97.useMemo(() => new Vector3().setScalar(distance), [distance]);
  const [sky] = React97.useState(() => new Sky());
  return React97.createElement("primitive", _extends({
    object: sky,
    ref,
    "material-uniforms-mieCoefficient-value": mieCoefficient,
    "material-uniforms-mieDirectionalG-value": mieDirectionalG,
    "material-uniforms-rayleigh-value": rayleigh,
    "material-uniforms-sunPosition-value": sunPosition,
    "material-uniforms-turbidity-value": turbidity,
    scale: scale2
  }, props));
});

// node_modules/@react-three/drei/core/Stars.js
var React98 = __toESM(require_react());
var StarfieldMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        time: {
          value: 0
        },
        fade: {
          value: 1
        }
      },
      vertexShader: (
        /* glsl */
        `
      uniform float time;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
        gl_Position = projectionMatrix * mvPosition;
      }`
      ),
      fragmentShader: (
        /* glsl */
        `
      uniform sampler2D pointTexture;
      uniform float fade;
      varying vec3 vColor;
      void main() {
        float opacity = 1.0;
        if (fade == 1.0) {
          float d = distance(gl_PointCoord, vec2(0.5, 0.5));
          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
        }
        gl_FragColor = vec4(vColor, opacity);

        #include <tonemapping_fragment>
	      #include <encodings_fragment>
      }`
      )
    });
  }
};
var genStar = (r2) => {
  return new Vector3().setFromSpherical(new Spherical(r2, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
};
var Stars = React98.forwardRef(({
  radius = 100,
  depth = 50,
  count = 5e3,
  saturation = 0,
  factor = 4,
  fade = false,
  speed = 1
}, ref) => {
  const material = React98.useRef();
  const [position2, color, size] = React98.useMemo(() => {
    const positions = [];
    const colors3 = [];
    const sizes = Array.from({
      length: count
    }, () => (0.5 + 0.5 * Math.random()) * factor);
    const color2 = new Color();
    let r2 = radius + depth;
    const increment = depth / count;
    for (let i3 = 0; i3 < count; i3++) {
      r2 -= increment * Math.random();
      positions.push(...genStar(r2).toArray());
      color2.setHSL(i3 / count, saturation, 0.9);
      colors3.push(color2.r, color2.g, color2.b);
    }
    return [new Float32Array(positions), new Float32Array(colors3), new Float32Array(sizes)];
  }, [count, depth, factor, radius, saturation]);
  useFrame((state) => material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime() * speed));
  const [starfieldMaterial] = React98.useState(() => new StarfieldMaterial());
  return React98.createElement("points", {
    ref
  }, React98.createElement("bufferGeometry", null, React98.createElement("bufferAttribute", {
    attach: "attributes-position",
    args: [position2, 3]
  }), React98.createElement("bufferAttribute", {
    attach: "attributes-color",
    args: [color, 3]
  }), React98.createElement("bufferAttribute", {
    attach: "attributes-size",
    args: [size, 1]
  })), React98.createElement("primitive", {
    ref: material,
    object: starfieldMaterial,
    attach: "material",
    blending: AdditiveBlending,
    "uniforms-fade-value": fade,
    depthWrite: false,
    transparent: true,
    vertexColors: true
  }));
});

// node_modules/@react-three/drei/core/Cloud.js
var React99 = __toESM(require_react());
var CLOUD_URL = "https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png";
function Cloud({
  opacity = 0.5,
  speed = 0.4,
  width = 10,
  depth = 1.5,
  segments = 20,
  texture = CLOUD_URL,
  color = "#ffffff",
  depthTest = true,
  ...props
}) {
  const group = React99.useRef();
  const cloudTexture = useTexture(texture);
  const clouds = React99.useMemo(() => [...new Array(segments)].map((_, index) => ({
    x: width / 2 - Math.random() * width,
    y: width / 2 - Math.random() * width,
    scale: 0.4 + Math.sin((index + 1) / segments * Math.PI) * ((0.2 + Math.random()) * 10),
    density: Math.max(0.2, Math.random()),
    rotation: Math.max(2e-3, 5e-3 * Math.random()) * speed
  })), [width, segments, speed]);
  useFrame((state) => {
    var _group$current;
    return (_group$current = group.current) == null ? void 0 : _group$current.children.forEach((cloud, index) => {
      cloud.children[0].rotation.z += clouds[index].rotation;
      cloud.children[0].scale.setScalar(clouds[index].scale + (1 + Math.sin(state.clock.getElapsedTime() / 10)) / 2 * index / 10);
    });
  });
  return React99.createElement("group", props, React99.createElement("group", {
    position: [0, 0, segments / 2 * depth],
    ref: group
  }, clouds.map(({
    x,
    y,
    scale: scale2,
    density
  }, index) => React99.createElement(Billboard, {
    key: index,
    position: [x, y, -index * depth]
  }, React99.createElement(Plane2, {
    scale: scale2,
    rotation: [0, 0, 0]
  }, React99.createElement("meshStandardMaterial", {
    map: cloudTexture,
    transparent: true,
    opacity: scale2 / 6 * density * opacity,
    depthTest,
    color
  }))))));
}

// node_modules/@react-three/drei/core/Sparkles.js
var React100 = __toESM(require_react());
var SparklesImplMaterial = shaderMaterial({
  time: 0,
  pixelRatio: 1
}, ` uniform float pixelRatio;
    uniform float time;
    attribute float size;  
    attribute float speed;  
    attribute float opacity;
    attribute vec3 noise;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vOpacity;
    void main() {
      vec4 modelPosition = modelMatrix * vec4(position, 1.0);
      modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;
      modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;
      modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;
      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;
      gl_PointSize = size * 25. * pixelRatio;
      gl_PointSize *= (1.0 / - viewPosition.z);
      vColor = color;
      vOpacity = opacity;
    }`, ` varying vec3 vColor;
    varying float vOpacity;
    void main() {
      float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
      float strength = 0.05 / distanceToCenter - 0.1;
      gl_FragColor = vec4(vColor, strength * vOpacity);
      #include <tonemapping_fragment>
      #include <encodings_fragment>
    }`);
var isFloat32Array = (def) => def && def.constructor === Float32Array;
var expandColor = (v4) => [v4.r, v4.g, v4.b];
var isVector = (v4) => v4 instanceof Vector2 || v4 instanceof Vector3 || v4 instanceof Vector4;
var normalizeVector = (v4) => {
  if (Array.isArray(v4))
    return v4;
  else if (isVector(v4))
    return v4.toArray();
  return [v4, v4, v4];
};
function usePropAsIsOrAsAttribute(count, prop, setDefault) {
  return React100.useMemo(() => {
    if (prop !== void 0) {
      if (isFloat32Array(prop)) {
        return prop;
      } else {
        if (prop instanceof Color) {
          const a3 = Array.from({
            length: count * 3
          }, () => expandColor(prop)).flat();
          return Float32Array.from(a3);
        } else if (isVector(prop) || Array.isArray(prop)) {
          const a3 = Array.from({
            length: count * 3
          }, () => normalizeVector(prop)).flat();
          return Float32Array.from(a3);
        }
        return Float32Array.from({
          length: count
        }, () => prop);
      }
    }
    return Float32Array.from({
      length: count
    }, setDefault);
  }, [prop]);
}
var Sparkles = React100.forwardRef(({
  noise = 1,
  count = 100,
  speed = 1,
  opacity = 1,
  scale: scale2 = 1,
  size,
  color,
  children,
  ...props
}, forwardRef71) => {
  React100.useMemo(() => extend({
    SparklesImplMaterial
  }), []);
  const ref = React100.useRef(null);
  const dpr = useThree((state) => state.viewport.dpr);
  const positions = React100.useMemo(() => Float32Array.from(Array.from({
    length: count
  }, () => normalizeVector(scale2).map(MathUtils.randFloatSpread)).flat()), [count, scale2]);
  const sizes = usePropAsIsOrAsAttribute(count, size, Math.random);
  const opacities = usePropAsIsOrAsAttribute(count, opacity);
  const speeds = usePropAsIsOrAsAttribute(count, speed);
  const noises = usePropAsIsOrAsAttribute(count * 3, noise);
  const colors3 = usePropAsIsOrAsAttribute(color === void 0 ? count * 3 : count, !isFloat32Array(color) ? new Color(color) : color, () => 1);
  useFrame((state) => {
    if (ref.current && ref.current.material)
      ref.current.material.time = state.clock.elapsedTime;
  });
  React100.useImperativeHandle(forwardRef71, () => ref.current, []);
  return React100.createElement("points", _extends({
    key: `particle-${count}-${JSON.stringify(scale2)}`
  }, props, {
    ref
  }), React100.createElement("bufferGeometry", null, React100.createElement("bufferAttribute", {
    attach: "attributes-position",
    args: [positions, 3]
  }), React100.createElement("bufferAttribute", {
    attach: "attributes-size",
    args: [sizes, 1]
  }), React100.createElement("bufferAttribute", {
    attach: "attributes-opacity",
    args: [opacities, 1]
  }), React100.createElement("bufferAttribute", {
    attach: "attributes-speed",
    args: [speeds, 1]
  }), React100.createElement("bufferAttribute", {
    attach: "attributes-color",
    args: [colors3, 3]
  }), React100.createElement("bufferAttribute", {
    attach: "attributes-noise",
    args: [noises, 3]
  })), children ? children : React100.createElement("sparklesImplMaterial", {
    transparent: true,
    pixelRatio: dpr,
    depthWrite: false
  }));
});

// node_modules/@react-three/drei/core/useMatcapTexture.js
var React101 = __toESM(require_react());
function getFormatString(format) {
  switch (format) {
    case 64:
      return "-64px";
    case 128:
      return "-128px";
    case 256:
      return "-256px";
    case 512:
      return "-512px";
    default:
      return "";
  }
}
var LIST_URL = "https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/matcaps.json";
var MATCAP_ROOT = "https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d";
function useMatcapTexture(id = 0, format = 1024, onLoad) {
  const matcapList = suspend(() => fetch(LIST_URL).then((res) => res.json()), ["matcapList"]);
  const DEFAULT_MATCAP = matcapList[0];
  const numTot = React101.useMemo(() => Object.keys(matcapList).length, []);
  const fileHash = React101.useMemo(() => {
    if (typeof id === "string") {
      return id;
    } else if (typeof id === "number") {
      return matcapList[id];
    }
    return null;
  }, [id]);
  const fileName = `${fileHash || DEFAULT_MATCAP}${getFormatString(format)}.png`;
  const url = `${MATCAP_ROOT}/${format}/${fileName}`;
  const matcapTexture = useTexture(url, onLoad);
  return [matcapTexture, url, numTot];
}

// node_modules/@react-three/drei/core/useNormalTexture.js
var React102 = __toESM(require_react());
var NORMAL_ROOT = "https://rawcdn.githack.com/pmndrs/drei-assets/7a3104997e1576f83472829815b00880d88b32fb";
var LIST_URL2 = "https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/normals/normals.json";
function useNormalTexture(id = 0, settings = {}, onLoad) {
  const {
    repeat = [1, 1],
    anisotropy = 1,
    offset = [0, 0]
  } = settings;
  const normalsList = suspend(() => fetch(LIST_URL2).then((res) => res.json()), ["normalsList"]);
  const numTot = React102.useMemo(() => Object.keys(normalsList).length, []);
  const DEFAULT_NORMAL = normalsList[0];
  const imageName = normalsList[id] || DEFAULT_NORMAL;
  const url = `${NORMAL_ROOT}/normals/${imageName}`;
  const normalTexture = useTexture(url, onLoad);
  React102.useLayoutEffect(() => {
    if (!normalTexture)
      return;
    normalTexture.wrapS = normalTexture.wrapT = RepeatWrapping;
    normalTexture.repeat = new Vector2(repeat[0], repeat[1]);
    normalTexture.offset = new Vector2(offset[0], offset[1]);
    normalTexture.anisotropy = anisotropy;
  }, [normalTexture, anisotropy, repeat, offset]);
  return [normalTexture, url, numTot];
}

// node_modules/@react-three/drei/core/Wireframe.js
var React104 = __toESM(require_react());

// node_modules/@react-three/drei/materials/WireframeMaterial.js
var React103 = __toESM(require_react());
var WireframeMaterialShaders = {
  uniforms: {
    strokeOpacity: 1,
    fillOpacity: 0.25,
    fillMix: 0,
    thickness: 0.05,
    colorBackfaces: false,
    dashInvert: true,
    dash: false,
    dashRepeats: 4,
    dashLength: 0.5,
    squeeze: false,
    squeezeMin: 0.2,
    squeezeMax: 1,
    stroke: new Color("#ff0000"),
    backfaceStroke: new Color("#0000ff"),
    fill: new Color("#00ff00")
  },
  vertex: (
    /* glsl */
    `
	  attribute vec3 barycentric;
	
		varying vec3 v_edges_Barycentric;
		varying vec3 v_edges_Position;

		void initWireframe() {
			v_edges_Barycentric = barycentric;
			v_edges_Position = position.xyz;
		}
	  `
  ),
  fragment: (
    /* glsl */
    `
		#ifndef PI
	  	#define PI 3.1415926535897932384626433832795
		#endif
  
	  varying vec3 v_edges_Barycentric;
	  varying vec3 v_edges_Position;
  
	  uniform float strokeOpacity;
	  uniform float fillOpacity;
	  uniform float fillMix;
	  uniform float thickness;
	  uniform bool colorBackfaces;
  
	  // Dash
	  uniform bool dashInvert;
	  uniform bool dash;
	  uniform bool dashOnly;
	  uniform float dashRepeats;
	  uniform float dashLength;
  
	  // Squeeze
	  uniform bool squeeze;
	  uniform float squeezeMin;
	  uniform float squeezeMax;
  
	  // Colors
	  uniform vec3 stroke;
	  uniform vec3 backfaceStroke;
	  uniform vec3 fill;
  
	  // This is like
	  float wireframe_aastep(float threshold, float dist) {
		  float afwidth = fwidth(dist) * 0.5;
		  return smoothstep(threshold - afwidth, threshold + afwidth, dist);
	  }
  
	  float wireframe_map(float value, float min1, float max1, float min2, float max2) {
		  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
	  }
  
	  float getWireframe() {
			vec3 barycentric = v_edges_Barycentric;
		
			// Distance from center of each triangle to its edges.
			float d = min(min(barycentric.x, barycentric.y), barycentric.z);

			// for dashed rendering, we can use this to get the 0 .. 1 value of the line length
			float positionAlong = max(barycentric.x, barycentric.y);
			if (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {
				positionAlong = 1.0 - positionAlong;
			}

			// the thickness of the stroke
			float computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);

			// if we want to shrink the thickness toward the center of the line segment
			if (squeeze) {
				computedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));
			}

			// Create dash pattern
			if (dash) {
				// here we offset the stroke position depending on whether it
				// should overlap or not
				float offset = 1.0 / dashRepeats * dashLength / 2.0;
				if (!dashInvert) {
					offset += 1.0 / dashRepeats / 2.0;
				}

				// if we should animate the dash or not
				// if (dashAnimate) {
				// 	offset += time * 0.22;
				// }

				// create the repeating dash pattern
				float pattern = fract((positionAlong + offset) * dashRepeats);
				computedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);
			}

			// compute the anti-aliased stroke edge  
			float edge = 1.0 - wireframe_aastep(computedThickness, d);

			return edge;
	  }
	  `
  )
};
var WireframeMaterial = shaderMaterial(WireframeMaterialShaders.uniforms, WireframeMaterialShaders.vertex + /* glsl */
`
  	void main() {
		initWireframe();
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
  `, WireframeMaterialShaders.fragment + /* glsl */
`
  void main () {
		// Compute color

		float edge = getWireframe();
		vec4 colorStroke = vec4(stroke, edge);

		#ifdef FLIP_SIDED
			colorStroke.rgb = backfaceStroke;
		#endif
    
		vec4 colorFill = vec4(fill, fillOpacity);
		vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);

		gl_FragColor = outColor;
	}
  `);
function setWireframeOverride(material, uniforms) {
  material.onBeforeCompile = (shader) => {
    shader.uniforms = {
      ...shader.uniforms,
      ...uniforms
    };
    shader.vertexShader = shader.vertexShader.replace("void main() {", `
		  ${WireframeMaterialShaders.vertex}
		  void main() {
			initWireframe();
		`);
    shader.fragmentShader = shader.fragmentShader.replace("void main() {", `
		  ${WireframeMaterialShaders.fragment}
		  void main() {
		`);
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <color_fragment>",
      /* glsl */
      `
		  #include <color_fragment>
			  float edge = getWireframe();
		  vec4 colorStroke = vec4(stroke, edge);
		  #ifdef FLIP_SIDED
			colorStroke.rgb = backfaceStroke;
		  #endif
		  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));
		  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);

		  diffuseColor.rgb = outColor.rgb;
		  diffuseColor.a *= outColor.a;
		`
    );
  };
  material.side = DoubleSide;
  material.transparent = true;
}
function useWireframeUniforms(uniforms, props) {
  React103.useEffect(() => {
    var _props$fillOpacity;
    return void (uniforms.fillOpacity.value = (_props$fillOpacity = props.fillOpacity) !== null && _props$fillOpacity !== void 0 ? _props$fillOpacity : uniforms.fillOpacity.value);
  }, [props.fillOpacity]);
  React103.useEffect(() => {
    var _props$fillMix;
    return void (uniforms.fillMix.value = (_props$fillMix = props.fillMix) !== null && _props$fillMix !== void 0 ? _props$fillMix : uniforms.fillMix.value);
  }, [props.fillMix]);
  React103.useEffect(() => {
    var _props$strokeOpacity;
    return void (uniforms.strokeOpacity.value = (_props$strokeOpacity = props.strokeOpacity) !== null && _props$strokeOpacity !== void 0 ? _props$strokeOpacity : uniforms.strokeOpacity.value);
  }, [props.strokeOpacity]);
  React103.useEffect(() => {
    var _props$thickness;
    return void (uniforms.thickness.value = (_props$thickness = props.thickness) !== null && _props$thickness !== void 0 ? _props$thickness : uniforms.thickness.value);
  }, [props.thickness]);
  React103.useEffect(() => void (uniforms.colorBackfaces.value = !!props.colorBackfaces), [props.colorBackfaces]);
  React103.useEffect(() => void (uniforms.dash.value = !!props.dash), [props.dash]);
  React103.useEffect(() => void (uniforms.dashInvert.value = !!props.dashInvert), [props.dashInvert]);
  React103.useEffect(() => {
    var _props$dashRepeats;
    return void (uniforms.dashRepeats.value = (_props$dashRepeats = props.dashRepeats) !== null && _props$dashRepeats !== void 0 ? _props$dashRepeats : uniforms.dashRepeats.value);
  }, [props.dashRepeats]);
  React103.useEffect(() => {
    var _props$dashLength;
    return void (uniforms.dashLength.value = (_props$dashLength = props.dashLength) !== null && _props$dashLength !== void 0 ? _props$dashLength : uniforms.dashLength.value);
  }, [props.dashLength]);
  React103.useEffect(() => void (uniforms.squeeze.value = !!props.squeeze), [props.squeeze]);
  React103.useEffect(() => {
    var _props$squeezeMin;
    return void (uniforms.squeezeMin.value = (_props$squeezeMin = props.squeezeMin) !== null && _props$squeezeMin !== void 0 ? _props$squeezeMin : uniforms.squeezeMin.value);
  }, [props.squeezeMin]);
  React103.useEffect(() => {
    var _props$squeezeMax;
    return void (uniforms.squeezeMax.value = (_props$squeezeMax = props.squeezeMax) !== null && _props$squeezeMax !== void 0 ? _props$squeezeMax : uniforms.squeezeMax.value);
  }, [props.squeezeMax]);
  React103.useEffect(() => void (uniforms.stroke.value = props.stroke ? new Color(props.stroke) : uniforms.stroke.value), [props.stroke]);
  React103.useEffect(() => void (uniforms.fill.value = props.fill ? new Color(props.fill) : uniforms.fill.value), [props.fill]);
  React103.useEffect(() => void (uniforms.backfaceStroke.value = props.backfaceStroke ? new Color(props.backfaceStroke) : uniforms.backfaceStroke.value), [props.backfaceStroke]);
}

// node_modules/@react-three/drei/core/Wireframe.js
extend({
  MeshWireframeMaterial: WireframeMaterial
});
function isWithGeometry(object) {
  return !!(object != null && object.geometry);
}
function isGeometry2(object) {
  return !!(object != null && object.isBufferGeometry);
}
function isRefObject2(object) {
  return !!(object != null && object.current);
}
function isRef2(object) {
  return (object == null ? void 0 : object.current) !== void 0;
}
function isWireframeGeometry(geometry) {
  return geometry.type === "WireframeGeometry";
}
function getUniforms() {
  const u = {};
  for (const key in WireframeMaterialShaders.uniforms) {
    u[key] = {
      value: WireframeMaterialShaders.uniforms[key]
    };
  }
  return u;
}
function getBarycentricCoordinates(geometry, removeEdge) {
  const position2 = geometry.getAttribute("position");
  const count = position2.count;
  const barycentric = [];
  for (let i3 = 0; i3 < count; i3++) {
    const even = i3 % 2 === 0;
    const Q = removeEdge ? 1 : 0;
    if (even) {
      barycentric.push(0, 0, 1, 0, 1, 0, 1, 0, Q);
    } else {
      barycentric.push(0, 1, 0, 0, 0, 1, 1, 0, Q);
    }
  }
  return new BufferAttribute(Float32Array.from(barycentric), 3);
}
function getInputGeometry(inputGeometry) {
  const geo = isRefObject2(inputGeometry) ? inputGeometry.current : inputGeometry;
  if (!isGeometry2(geo)) {
    if (isWireframeGeometry(geo)) {
      throw new Error("Wireframe: WireframeGeometry is not supported.");
    }
    const parent = geo.parent;
    if (isWithGeometry(parent)) {
      if (isWireframeGeometry(parent.geometry)) {
        throw new Error("Wireframe: WireframeGeometry is not supported.");
      }
      return parent.geometry;
    }
  } else {
    return geo;
  }
}
function setBarycentricCoordinates(geometry, simplify) {
  if (geometry.index) {
    console.warn("Wireframe: Requires non-indexed geometry, converting to non-indexed geometry.");
    const nonIndexedGeo = geometry.toNonIndexed();
    geometry.copy(nonIndexedGeo);
    geometry.setIndex(null);
  }
  const newBarycentric = getBarycentricCoordinates(geometry, simplify);
  geometry.setAttribute("barycentric", newBarycentric);
}
function WireframeWithCustomGeo({
  geometry: customGeometry,
  simplify = false,
  ...props
}) {
  const [geometry, setGeometry] = React104.useState(null);
  React104.useLayoutEffect(() => {
    const geom = getInputGeometry(customGeometry);
    if (!geom) {
      throw new Error("Wireframe: geometry prop must be a BufferGeometry or a ref to a BufferGeometry.");
    }
    setBarycentricCoordinates(geom, simplify);
    if (isRef2(customGeometry)) {
      setGeometry(geom);
    }
  }, [simplify, customGeometry]);
  const drawnGeo = isRef2(customGeometry) ? geometry : customGeometry;
  return React104.createElement(React104.Fragment, null, drawnGeo && React104.createElement("mesh", {
    geometry: drawnGeo
  }, React104.createElement("meshWireframeMaterial", _extends({
    attach: "material",
    transparent: true,
    side: DoubleSide,
    polygonOffset: true,
    polygonOffsetFactor: -4
  }, props, {
    extensions: {
      derivatives: true,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    }
  }))));
}
function WireframeWithoutCustomGeo({
  simplify = false,
  ...props
}) {
  const objectRef = React104.useRef(null);
  const uniforms = React104.useMemo(() => getUniforms(), [WireframeMaterialShaders.uniforms]);
  useWireframeUniforms(uniforms, props);
  React104.useLayoutEffect(() => {
    const geom = getInputGeometry(objectRef);
    if (!geom) {
      throw new Error("Wireframe: Must be a child of a Mesh, Line or Points object or specify a geometry prop.");
    }
    const og = geom.clone();
    setBarycentricCoordinates(geom, simplify);
    return () => {
      geom.copy(og);
      og.dispose();
    };
  }, [simplify]);
  React104.useLayoutEffect(() => {
    const parentMesh = objectRef.current.parent;
    const og = parentMesh.material.clone();
    setWireframeOverride(parentMesh.material, uniforms);
    return () => {
      parentMesh.material.dispose();
      parentMesh.material = og;
    };
  }, []);
  return React104.createElement("object3D", {
    ref: objectRef
  });
}
function Wireframe({
  geometry: customGeometry,
  ...props
}) {
  if (customGeometry) {
    return React104.createElement(WireframeWithCustomGeo, _extends({
      geometry: customGeometry
    }, props));
  }
  return React104.createElement(WireframeWithoutCustomGeo, props);
}

// node_modules/@react-three/drei/core/Points.js
var React105 = __toESM(require_react());
var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere2 = new Sphere();
var _position = new Vector3();
var PositionPoint = class extends Group {
  constructor() {
    super();
    this.size = 0;
    this.color = new Color("white");
    this.instance = {
      current: void 0
    };
    this.instanceKey = {
      current: void 0
    };
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    var _this$instance$curren;
    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;
  }
  raycast(raycaster, intersects) {
    var _raycaster$params$Poi, _raycaster$params$Poi2;
    const parent = this.instance.current;
    if (!parent || !parent.geometry)
      return;
    const instanceId = parent.userData.instances.indexOf(this.instanceKey);
    if (instanceId === -1 || instanceId > parent.geometry.drawRange.count)
      return;
    const threshold = (_raycaster$params$Poi = (_raycaster$params$Poi2 = raycaster.params.Points) == null ? void 0 : _raycaster$params$Poi2.threshold) !== null && _raycaster$params$Poi !== void 0 ? _raycaster$params$Poi : 1;
    _sphere2.set(this.getWorldPosition(_position), threshold);
    if (raycaster.ray.intersectsSphere(_sphere2) === false)
      return;
    _inverseMatrix.copy(parent.matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const rayPointDistanceSq = _ray.distanceSqToPoint(this.position);
    if (rayPointDistanceSq < localThresholdSq) {
      const intersectPoint = new Vector3();
      _ray.closestPointToPoint(this.position, intersectPoint);
      intersectPoint.applyMatrix4(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects.push({
        distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index: instanceId,
        face: null,
        object: this
      });
    }
  }
};
var i2;
var positionRef;
var context6 = React105.createContext(null);
var parentMatrix = new Matrix4();
var position = new Vector3();
var PointsInstances = React105.forwardRef(({
  children,
  range,
  limit = 1e3,
  ...props
}, ref) => {
  const parentRef = React105.useRef(null);
  const [refs, setRefs] = React105.useState([]);
  const [[positions, colors3, sizes]] = React105.useState(() => [new Float32Array(limit * 3), Float32Array.from({
    length: limit * 3
  }, () => 1), Float32Array.from({
    length: limit
  }, () => 1)]);
  React105.useEffect(() => {
    parentRef.current.geometry.attributes.position.needsUpdate = true;
  });
  useFrame(() => {
    parentRef.current.updateMatrix();
    parentRef.current.updateMatrixWorld();
    parentMatrix.copy(parentRef.current.matrixWorld).invert();
    parentRef.current.geometry.drawRange.count = Math.min(limit, range !== void 0 ? range : limit, refs.length);
    for (i2 = 0; i2 < refs.length; i2++) {
      positionRef = refs[i2].current;
      positionRef.getWorldPosition(position).applyMatrix4(parentMatrix);
      position.toArray(positions, i2 * 3);
      parentRef.current.geometry.attributes.position.needsUpdate = true;
      positionRef.matrixWorldNeedsUpdate = true;
      positionRef.color.toArray(colors3, i2 * 3);
      parentRef.current.geometry.attributes.color.needsUpdate = true;
      sizes.set([positionRef.size], i2);
      parentRef.current.geometry.attributes.size.needsUpdate = true;
    }
  });
  const api = React105.useMemo(() => ({
    getParent: () => parentRef,
    subscribe: (ref2) => {
      setRefs((refs2) => [...refs2, ref2]);
      return () => setRefs((refs2) => refs2.filter((item) => item.current !== ref2.current));
    }
  }), []);
  return React105.createElement("points", _extends({
    userData: {
      instances: refs
    },
    matrixAutoUpdate: false,
    ref: react_merge_refs_esm_default([ref, parentRef]),
    raycast: () => null
  }, props), React105.createElement("bufferGeometry", null, React105.createElement("bufferAttribute", {
    attach: "attributes-position",
    count: positions.length / 3,
    array: positions,
    itemSize: 3,
    usage: DynamicDrawUsage
  }), React105.createElement("bufferAttribute", {
    attach: "attributes-color",
    count: colors3.length / 3,
    array: colors3,
    itemSize: 3,
    usage: DynamicDrawUsage
  }), React105.createElement("bufferAttribute", {
    attach: "attributes-size",
    count: sizes.length,
    array: sizes,
    itemSize: 1,
    usage: DynamicDrawUsage
  })), React105.createElement(context6.Provider, {
    value: api
  }, children));
});
var Point = React105.forwardRef(({
  children,
  ...props
}, ref) => {
  React105.useMemo(() => extend({
    PositionPoint
  }), []);
  const group = React105.useRef();
  const {
    subscribe,
    getParent
  } = React105.useContext(context6);
  React105.useLayoutEffect(() => subscribe(group), []);
  return React105.createElement("positionPoint", _extends({
    instance: getParent(),
    instanceKey: group,
    ref: react_merge_refs_esm_default([ref, group])
  }, props), children);
});
var PointsBuffer = React105.forwardRef(({
  children,
  positions,
  colors: colors3,
  sizes,
  stride = 3,
  ...props
}, forwardedRef) => {
  const pointsRef = React105.useRef(null);
  useFrame(() => {
    const attr = pointsRef.current.geometry.attributes;
    attr.position.needsUpdate = true;
    if (colors3)
      attr.color.needsUpdate = true;
    if (sizes)
      attr.size.needsUpdate = true;
  });
  return React105.createElement("points", _extends({
    ref: react_merge_refs_esm_default([forwardedRef, pointsRef])
  }, props), React105.createElement("bufferGeometry", null, React105.createElement("bufferAttribute", {
    attach: "attributes-position",
    count: positions.length / stride,
    array: positions,
    itemSize: stride,
    usage: DynamicDrawUsage
  }), colors3 && React105.createElement("bufferAttribute", {
    attach: "attributes-color",
    count: colors3.length / stride,
    array: colors3,
    itemSize: 3,
    usage: DynamicDrawUsage
  }), sizes && React105.createElement("bufferAttribute", {
    attach: "attributes-size",
    count: sizes.length / stride,
    array: sizes,
    itemSize: 1,
    usage: DynamicDrawUsage
  })), children);
});
var Points = React105.forwardRef((props, forwardedRef) => {
  if (props.positions instanceof Float32Array) {
    return React105.createElement(PointsBuffer, _extends({}, props, {
      ref: forwardedRef
    }));
  } else
    return React105.createElement(PointsInstances, _extends({}, props, {
      ref: forwardedRef
    }));
});

// node_modules/@react-three/drei/core/Instances.js
var React106 = __toESM(require_react());

// node_modules/react-composer/es/index.js
var import_react18 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
function Composer(props) {
  return renderRecursive(props.children, props.components);
}
Composer.propTypes = {
  children: import_prop_types.default.func.isRequired,
  components: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.element, import_prop_types.default.func])).isRequired
};
function renderRecursive(render, remaining, results) {
  results = results || [];
  if (!remaining[0]) {
    return render(results);
  }
  function nextRender(value) {
    return renderRecursive(render, remaining.slice(1), results.concat([value]));
  }
  return typeof remaining[0] === "function" ? (
    // When it is a function, produce an element by invoking it with "render component values".
    remaining[0]({ results, render: nextRender })
  ) : (
    // When it is an element, enhance the element's props with the render prop.
    (0, import_react18.cloneElement)(remaining[0], { children: nextRender })
  );
}

// node_modules/@react-three/drei/core/Instances.js
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
var PositionMesh = class extends Group {
  constructor() {
    super();
    this.color = new Color("white");
    this.instance = {
      current: void 0
    };
    this.instanceKey = {
      current: void 0
    };
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    var _this$instance$curren;
    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;
  }
  // And this will allow the virtual instance to receive events
  raycast(raycaster, intersects) {
    const parent = this.instance.current;
    if (!parent)
      return;
    if (!parent.geometry || !parent.material)
      return;
    _mesh.geometry = parent.geometry;
    const matrixWorld = parent.matrixWorld;
    const instanceId = parent.userData.instances.indexOf(this.instanceKey);
    if (instanceId === -1 || instanceId > parent.count)
      return;
    parent.getMatrixAt(instanceId, _instanceLocalMatrix);
    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
    _mesh.matrixWorld = _instanceWorldMatrix;
    if (parent.material instanceof Material)
      _mesh.material.side = parent.material.side;
    else
      _mesh.material.side = parent.material[0].side;
    _mesh.raycast(raycaster, _instanceIntersects);
    for (let i3 = 0, l2 = _instanceIntersects.length; i3 < l2; i3++) {
      const intersect = _instanceIntersects[i3];
      intersect.instanceId = instanceId;
      intersect.object = this;
      intersects.push(intersect);
    }
    _instanceIntersects.length = 0;
  }
};
var globalContext2 = React106.createContext(null);
var parentMatrix2 = new Matrix4();
var instanceMatrix = new Matrix4();
var tempMatrix3 = new Matrix4();
var translation = new Vector3();
var rotation = new Quaternion();
var scale = new Vector3();
var Instance = React106.forwardRef(({
  context: context10,
  children,
  ...props
}, ref) => {
  React106.useMemo(() => extend({
    PositionMesh
  }), []);
  const group = React106.useRef();
  const {
    subscribe,
    getParent
  } = React106.useContext(context10 || globalContext2);
  React106.useLayoutEffect(() => subscribe(group), []);
  return React106.createElement("positionMesh", _extends({
    instance: getParent(),
    instanceKey: group,
    ref: react_merge_refs_esm_default([ref, group])
  }, props), children);
});
var Instances = React106.forwardRef(({
  children,
  range,
  limit = 1e3,
  frames = Infinity,
  ...props
}, ref) => {
  const [{
    context: context10,
    instance
  }] = React106.useState(() => {
    const context11 = React106.createContext(null);
    return {
      context: context11,
      instance: React106.forwardRef((props2, ref2) => React106.createElement(Instance, _extends({
        context: context11
      }, props2, {
        ref: ref2
      })))
    };
  });
  const parentRef = React106.useRef(null);
  const [instances, setInstances] = React106.useState([]);
  const [[matrices, colors3]] = React106.useState(() => {
    const mArray = new Float32Array(limit * 16);
    for (let i3 = 0; i3 < limit; i3++)
      tempMatrix3.identity().toArray(mArray, i3 * 16);
    return [mArray, new Float32Array([...new Array(limit * 3)].map(() => 1))];
  });
  React106.useEffect(() => {
    parentRef.current.instanceMatrix.needsUpdate = true;
  });
  let count = 0;
  let updateRange = 0;
  useFrame(() => {
    if (frames === Infinity || count < frames) {
      parentRef.current.updateMatrix();
      parentRef.current.updateMatrixWorld();
      parentMatrix2.copy(parentRef.current.matrixWorld).invert();
      updateRange = Math.min(limit, range !== void 0 ? range : limit, instances.length);
      parentRef.current.count = updateRange;
      parentRef.current.instanceMatrix.updateRange.count = updateRange * 16;
      parentRef.current.instanceColor.updateRange.count = updateRange * 3;
      for (let i3 = 0; i3 < instances.length; i3++) {
        const instance2 = instances[i3].current;
        instance2.matrixWorld.decompose(translation, rotation, scale);
        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix2);
        instanceMatrix.toArray(matrices, i3 * 16);
        parentRef.current.instanceMatrix.needsUpdate = true;
        instance2.color.toArray(colors3, i3 * 3);
        parentRef.current.instanceColor.needsUpdate = true;
      }
      count++;
    }
  });
  const api = React106.useMemo(() => ({
    getParent: () => parentRef,
    subscribe: (ref2) => {
      setInstances((instances2) => [...instances2, ref2]);
      return () => setInstances((instances2) => instances2.filter((item) => item.current !== ref2.current));
    }
  }), []);
  return React106.createElement("instancedMesh", _extends({
    userData: {
      instances
    },
    matrixAutoUpdate: false,
    ref: react_merge_refs_esm_default([ref, parentRef]),
    args: [null, null, 0],
    raycast: () => null
  }, props), React106.createElement("instancedBufferAttribute", {
    attach: "instanceMatrix",
    count: matrices.length / 16,
    array: matrices,
    itemSize: 16,
    usage: DynamicDrawUsage
  }), React106.createElement("instancedBufferAttribute", {
    attach: "instanceColor",
    count: colors3.length / 3,
    array: colors3,
    itemSize: 3,
    usage: DynamicDrawUsage
  }), typeof children === "function" ? React106.createElement(context10.Provider, {
    value: api
  }, children(instance)) : React106.createElement(globalContext2.Provider, {
    value: api
  }, children));
});
var Merged = React106.forwardRef(function Merged2({
  meshes,
  children,
  ...props
}, ref) {
  const isArray3 = Array.isArray(meshes);
  if (!isArray3) {
    for (const key of Object.keys(meshes))
      if (!meshes[key].isMesh)
        delete meshes[key];
  }
  return React106.createElement("group", {
    ref
  }, React106.createElement(Composer, {
    components: (isArray3 ? meshes : Object.values(meshes)).map(({
      geometry,
      material
    }) => React106.createElement(Instances, _extends({
      key: geometry.uuid,
      geometry,
      material
    }, props)))
  }, (args) => isArray3 ? children(...args) : children(Object.keys(meshes).filter((key) => meshes[key].isMesh).reduce((acc, key, i3) => ({
    ...acc,
    [key]: args[i3]
  }), {}))));
});

// node_modules/@react-three/drei/core/Segments.js
var React107 = __toESM(require_react());
var context7 = React107.createContext(null);
var Segments = React107.forwardRef((props, forwardedRef) => {
  React107.useMemo(() => extend({
    SegmentObject
  }), []);
  const {
    limit = 1e3,
    lineWidth = 1,
    children,
    ...rest
  } = props;
  const [segments, setSegments] = React107.useState([]);
  const [line] = React107.useState(() => new Line2());
  const [material] = React107.useState(() => new LineMaterial());
  const [geometry] = React107.useState(() => new LineSegmentsGeometry());
  const [resolution] = React107.useState(() => new Vector2(512, 512));
  const [positions] = React107.useState(() => Array(limit * 6).fill(0));
  const [colors3] = React107.useState(() => Array(limit * 6).fill(0));
  const api = React107.useMemo(() => ({
    subscribe: (ref) => {
      setSegments((segments2) => [...segments2, ref]);
      return () => setSegments((segments2) => segments2.filter((item) => item.current !== ref.current));
    }
  }), []);
  useFrame(() => {
    for (let i3 = 0; i3 < limit; i3++) {
      var _segments$i;
      const segment = (_segments$i = segments[i3]) == null ? void 0 : _segments$i.current;
      if (segment) {
        positions[i3 * 6 + 0] = segment.start.x;
        positions[i3 * 6 + 1] = segment.start.y;
        positions[i3 * 6 + 2] = segment.start.z;
        positions[i3 * 6 + 3] = segment.end.x;
        positions[i3 * 6 + 4] = segment.end.y;
        positions[i3 * 6 + 5] = segment.end.z;
        colors3[i3 * 6 + 0] = segment.color.r;
        colors3[i3 * 6 + 1] = segment.color.g;
        colors3[i3 * 6 + 2] = segment.color.b;
        colors3[i3 * 6 + 3] = segment.color.r;
        colors3[i3 * 6 + 4] = segment.color.g;
        colors3[i3 * 6 + 5] = segment.color.b;
      }
    }
    geometry.setColors(colors3);
    geometry.setPositions(positions);
    line.computeLineDistances();
  });
  return React107.createElement("primitive", {
    object: line,
    ref: forwardedRef
  }, React107.createElement("primitive", {
    object: geometry,
    attach: "geometry"
  }), React107.createElement("primitive", _extends({
    object: material,
    attach: "material",
    vertexColors: true,
    resolution,
    linewidth: lineWidth
  }, rest)), React107.createElement(context7.Provider, {
    value: api
  }, children));
});
var SegmentObject = class {
  constructor() {
    this.color = new Color("white");
    this.start = new Vector3(0, 0, 0);
    this.end = new Vector3(0, 0, 0);
  }
};
var normPos = (pos) => pos instanceof Vector3 ? pos : new Vector3(...typeof pos === "number" ? [pos, pos, pos] : pos);
var Segment = React107.forwardRef(({
  color,
  start: start2,
  end
}, forwardedRef) => {
  const api = React107.useContext(context7);
  if (!api)
    throw "Segment must used inside Segments component.";
  const ref = React107.useRef(null);
  React107.useLayoutEffect(() => api.subscribe(ref), []);
  return React107.createElement("segmentObject", {
    ref: react_merge_refs_esm_default([ref, forwardedRef]),
    color,
    start: normPos(start2),
    end: normPos(end)
  });
});

// node_modules/@react-three/drei/core/Detailed.js
var React108 = __toESM(require_react());
var Detailed = React108.forwardRef(({
  children,
  hysteresis = 0,
  distances,
  ...props
}, ref) => {
  const lodRef = React108.useRef(null);
  React108.useLayoutEffect(() => {
    const {
      current: lod
    } = lodRef;
    lod.levels.length = 0;
    lod.children.forEach((object, index) => lod.levels.push({
      object,
      hysteresis,
      distance: distances[index]
    }));
  });
  useFrame((state) => {
    var _lodRef$current;
    return (_lodRef$current = lodRef.current) == null ? void 0 : _lodRef$current.update(state.camera);
  });
  return React108.createElement("lOD", _extends({
    ref: react_merge_refs_esm_default([lodRef, ref])
  }, props), children);
});

// node_modules/@react-three/drei/core/Preload.js
var React109 = __toESM(require_react());
function Preload({
  all,
  scene,
  camera
}) {
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const dCamera = useThree(({
    camera: camera2
  }) => camera2);
  const dScene = useThree(({
    scene: scene2
  }) => scene2);
  React109.useLayoutEffect(() => {
    const invisible = [];
    if (all) {
      (scene || dScene).traverse((object) => {
        if (object.visible === false) {
          invisible.push(object);
          object.visible = true;
        }
      });
    }
    gl.compile(scene || dScene, camera || dCamera);
    const cubeRenderTarget = new WebGLCubeRenderTarget(128);
    const cubeCamera = new CubeCamera(0.01, 1e5, cubeRenderTarget);
    cubeCamera.update(gl, scene || dScene);
    cubeRenderTarget.dispose();
    invisible.forEach((object) => object.visible = false);
  }, []);
  return null;
}

// node_modules/@react-three/drei/core/BakeShadows.js
var import_react19 = __toESM(require_react());
function BakeShadows() {
  const gl = useThree((state) => state.gl);
  (0, import_react19.useEffect)(() => {
    gl.shadowMap.autoUpdate = false;
    gl.shadowMap.needsUpdate = true;
    return () => {
      gl.shadowMap.autoUpdate = gl.shadowMap.needsUpdate = true;
    };
  }, [gl.shadowMap]);
  return null;
}

// node_modules/@react-three/drei/core/meshBounds.js
var _inverseMatrix2 = new Matrix4();
var _ray2 = new Ray();
var _sphere3 = new Sphere();
var _vA2 = new Vector3();
function meshBounds(raycaster, intersects) {
  const geometry = this.geometry;
  const material = this.material;
  const matrixWorld = this.matrixWorld;
  if (material === void 0)
    return;
  if (geometry.boundingSphere === null)
    geometry.computeBoundingSphere();
  _sphere3.copy(geometry.boundingSphere);
  _sphere3.applyMatrix4(matrixWorld);
  if (raycaster.ray.intersectsSphere(_sphere3) === false)
    return;
  _inverseMatrix2.copy(matrixWorld).invert();
  _ray2.copy(raycaster.ray).applyMatrix4(_inverseMatrix2);
  if (geometry.boundingBox !== null && _ray2.intersectBox(geometry.boundingBox, _vA2) === null)
    return;
  intersects.push({
    distance: _vA2.distanceTo(raycaster.ray.origin),
    point: _vA2.clone(),
    object: this
  });
}

// node_modules/@react-three/drei/core/AdaptiveDpr.js
var React110 = __toESM(require_react());
function AdaptiveDpr({
  pixelated
}) {
  const gl = useThree((state) => state.gl);
  const active = useThree((state) => state.internal.active);
  const current = useThree((state) => state.performance.current);
  const initialDpr = useThree((state) => state.viewport.initialDpr);
  const setDpr = useThree((state) => state.setDpr);
  React110.useEffect(() => {
    const domElement = gl.domElement;
    return () => {
      if (active)
        setDpr(initialDpr);
      if (pixelated && domElement)
        domElement.style.imageRendering = "auto";
    };
  }, []);
  React110.useEffect(() => {
    setDpr(current * initialDpr);
    if (pixelated && gl.domElement)
      gl.domElement.style.imageRendering = current === 1 ? "auto" : "pixelated";
  }, [current]);
  return null;
}

// node_modules/@react-three/drei/core/AdaptiveEvents.js
var React111 = __toESM(require_react());
function AdaptiveEvents() {
  const get = useThree((state) => state.get);
  const setEvents = useThree((state) => state.setEvents);
  const current = useThree((state) => state.performance.current);
  React111.useEffect(() => {
    const enabled = get().events.enabled;
    return () => setEvents({
      enabled
    });
  }, []);
  React111.useEffect(() => setEvents({
    enabled: current === 1
  }), [current]);
  return null;
}

// node_modules/@react-three/drei/core/PerformanceMonitor.js
var React112 = __toESM(require_react());
var import_react20 = __toESM(require_react());
var context8 = (0, import_react20.createContext)(null);
function PerformanceMonitor({
  iterations = 10,
  ms = 250,
  threshold = 0.75,
  step = 0.1,
  factor: _factor = 0.5,
  flipflops = Infinity,
  bounds = (refreshrate) => refreshrate > 100 ? [60, 100] : [40, 60],
  onIncline,
  onDecline,
  onChange,
  onFallback,
  children
}) {
  const decimalPlacesRatio = Math.pow(10, 0);
  const [api, _] = (0, import_react20.useState)(() => ({
    fps: 0,
    index: 0,
    factor: _factor,
    flipped: 0,
    refreshrate: 0,
    fallback: false,
    frames: [],
    averages: [],
    subscriptions: /* @__PURE__ */ new Map(),
    subscribe: (ref) => {
      const key = Symbol();
      api.subscriptions.set(key, ref.current);
      return () => void api.subscriptions.delete(key);
    }
  }));
  let lastFactor = 0;
  useFrame(() => {
    const {
      frames,
      averages
    } = api;
    if (api.fallback)
      return;
    if (averages.length < iterations) {
      frames.push(performance.now());
      const msPassed = frames[frames.length - 1] - frames[0];
      if (msPassed >= ms) {
        api.fps = Math.round(frames.length / msPassed * 1e3 * decimalPlacesRatio) / decimalPlacesRatio;
        api.refreshrate = Math.max(api.refreshrate, api.fps);
        averages[api.index++ % iterations] = api.fps;
        if (averages.length === iterations) {
          const [lower, upper] = bounds(api.refreshrate);
          const upperBounds = averages.filter((value) => value >= upper);
          const lowerBounds = averages.filter((value) => value < lower);
          if (upperBounds.length > iterations * threshold) {
            api.factor = Math.min(1, api.factor + step);
            api.flipped++;
            if (onIncline)
              onIncline(api);
            api.subscriptions.forEach((value) => value.onIncline && value.onIncline(api));
          }
          if (lowerBounds.length > iterations * threshold) {
            api.factor = Math.max(0, api.factor - step);
            api.flipped++;
            if (onDecline)
              onDecline(api);
            api.subscriptions.forEach((value) => value.onDecline && value.onDecline(api));
          }
          if (lastFactor !== api.factor) {
            lastFactor = api.factor;
            if (onChange)
              onChange(api);
            api.subscriptions.forEach((value) => value.onChange && value.onChange(api));
          }
          if (api.flipped > flipflops && !api.fallback) {
            api.fallback = true;
            if (onFallback)
              onFallback(api);
            api.subscriptions.forEach((value) => value.onFallback && value.onFallback(api));
          }
          api.averages = [];
        }
        api.frames = [];
      }
    }
  });
  return React112.createElement(context8.Provider, {
    value: api
  }, children);
}
function usePerformanceMonitor({
  onIncline,
  onDecline,
  onChange,
  onFallback
}) {
  const api = (0, import_react20.useContext)(context8);
  const ref = (0, import_react20.useRef)({
    onIncline,
    onDecline,
    onChange,
    onFallback
  });
  (0, import_react20.useLayoutEffect)(() => {
    ref.current.onIncline = onIncline;
    ref.current.onDecline = onDecline;
    ref.current.onChange = onChange;
    ref.current.onFallback = onFallback;
  }, [onIncline, onDecline, onChange, onFallback]);
  (0, import_react20.useLayoutEffect)(() => api.subscribe(ref), [api]);
}

// node_modules/@react-three/drei/core/RenderTexture.js
var React113 = __toESM(require_react());
var RenderTexture = React113.forwardRef(({
  children,
  compute: compute2,
  width,
  height,
  samples = 8,
  renderPriority = 0,
  eventPriority = 0,
  frames = Infinity,
  stencilBuffer = false,
  depthBuffer = true,
  generateMipmaps = false,
  ...props
}, forwardRef71) => {
  const {
    size,
    viewport
  } = useThree();
  const fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {
    samples,
    stencilBuffer,
    depthBuffer,
    generateMipmaps
  });
  const [vScene] = React113.useState(() => new Scene());
  const uvCompute = React113.useCallback((event, state, previous) => {
    var _fbo$texture, _previous$previousRoo;
    let parent = (_fbo$texture = fbo.texture) == null ? void 0 : _fbo$texture.__r3f.parent;
    while (parent && !(parent instanceof Object3D)) {
      parent = parent.__r3f.parent;
    }
    if (!parent)
      return false;
    if (!previous.raycaster.camera)
      previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState());
    const [intersection3] = previous.raycaster.intersectObject(parent);
    if (!intersection3)
      return false;
    const uv = intersection3.uv;
    if (!uv)
      return false;
    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);
  }, []);
  React113.useImperativeHandle(forwardRef71, () => fbo.texture, [fbo]);
  return React113.createElement(React113.Fragment, null, createPortal(React113.createElement(Container, {
    renderPriority,
    frames,
    fbo
  }, children, React113.createElement("group", {
    onPointerOver: () => null
  })), vScene, {
    events: {
      compute: compute2 || uvCompute,
      priority: eventPriority
    }
  }), React113.createElement("primitive", _extends({
    object: fbo.texture
  }, props)));
});
function Container({
  frames,
  renderPriority,
  children,
  fbo
}) {
  let count = 0;
  let oldAutoClear;
  useFrame((state) => {
    if (frames === Infinity || count < frames) {
      oldAutoClear = state.gl.autoClear;
      state.gl.autoClear = true;
      state.gl.setRenderTarget(fbo);
      state.gl.render(state.scene, state.camera);
      state.gl.setRenderTarget(null);
      state.gl.autoClear = oldAutoClear;
      count++;
    }
  }, renderPriority);
  return React113.createElement(React113.Fragment, null, children);
}

// node_modules/@react-three/drei/core/Mask.js
var React114 = __toESM(require_react());
var Mask = React114.forwardRef(({
  id = 1,
  colorWrite = false,
  depthWrite = false,
  ...props
}, fref) => {
  const ref = React114.useRef(null);
  const spread = React114.useMemo(() => ({
    colorWrite,
    depthWrite,
    stencilWrite: true,
    stencilRef: id,
    stencilFunc: AlwaysStencilFunc,
    stencilFail: ReplaceStencilOp,
    stencilZFail: ReplaceStencilOp,
    stencilZPass: ReplaceStencilOp
  }), [id, colorWrite, depthWrite]);
  React114.useLayoutEffect(() => {
    Object.assign(ref.current.material, spread);
  });
  React114.useImperativeHandle(fref, () => ref.current, []);
  return React114.createElement("mesh", _extends({
    ref,
    renderOrder: -id
  }, props));
});
function useMask(id, inverse = false) {
  return {
    stencilWrite: true,
    stencilRef: id,
    stencilFunc: inverse ? NotEqualStencilFunc : EqualStencilFunc,
    stencilFail: KeepStencilOp,
    stencilZFail: KeepStencilOp,
    stencilZPass: KeepStencilOp
  };
}

// node_modules/@react-three/drei/core/MeshPortalMaterial.js
var React115 = __toESM(require_react());
var PortalMaterialImpl = shaderMaterial({
  blur: 0,
  map: null,
  sdf: null,
  blend: 0,
  size: 0,
  resolution: new Vector2()
}, `varying vec2 vUv;
   void main() {
     gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
     vUv = uv;
   }`, `uniform sampler2D sdf;
   uniform sampler2D map;
   uniform float blur;
   uniform float size;
   uniform float time;
   uniform vec2 resolution;
   varying vec2 vUv;
   #include <packing>
   void main() {
     vec2 uv = gl_FragCoord.xy / resolution.xy;
     vec4 t = texture2D(map, uv);
     float k = blur;
     float d = texture2D(sdf, vUv).r/size;
     float alpha = 1.0 - smoothstep(0.0, 1.0, clamp(d/k + 1.0, 0.0, 1.0));
     gl_FragColor = vec4(t.rgb, blur == 0.0 ? t.a : t.a * alpha);
     #include <tonemapping_fragment>
     #include <encodings_fragment>
   }`);
var MeshPortalMaterial = React115.forwardRef(({
  children,
  events = void 0,
  blur = 0,
  eventPriority = 0,
  renderPriority = 0,
  worldUnits = false,
  resolution = 512,
  ...props
}, fref) => {
  extend({
    PortalMaterialImpl
  });
  const ref = React115.useRef(null);
  const {
    scene,
    gl,
    size,
    viewport,
    setEvents
  } = useThree();
  const maskRenderTarget = useFBO(resolution, resolution);
  const [priority2, setPriority] = React115.useState(0);
  useFrame(() => {
    const p = ref.current.blend > 0 ? Math.max(1, renderPriority) : 0;
    if (priority2 !== p)
      setPriority(p);
  });
  React115.useEffect(() => {
    if (events !== void 0)
      setEvents({
        enabled: !events
      });
  }, [events]);
  const [visible, setVisible] = React115.useState(true);
  const parent = useIntersect(setVisible);
  React115.useLayoutEffect(() => {
    var _ref$current;
    parent.current = (_ref$current = ref.current) == null ? void 0 : _ref$current.__r3f.parent;
  }, []);
  React115.useLayoutEffect(() => {
    if (!parent.current)
      return;
    if (blur && ref.current.sdf === null) {
      const tempMesh = new Mesh(parent.current.geometry, new MeshBasicMaterial());
      const boundingBox5 = new Box3().setFromBufferAttribute(tempMesh.geometry.attributes.position);
      const orthoCam = new OrthographicCamera(boundingBox5.min.x * (1 + 2 / resolution), boundingBox5.max.x * (1 + 2 / resolution), boundingBox5.max.y * (1 + 2 / resolution), boundingBox5.min.y * (1 + 2 / resolution), 0.1, 1e3);
      orthoCam.position.set(0, 0, 1);
      orthoCam.lookAt(0, 0, 0);
      gl.setRenderTarget(maskRenderTarget);
      gl.render(tempMesh, orthoCam);
      const sg = makeSDFGenerator(resolution, resolution, gl);
      const sdf = sg(maskRenderTarget.texture);
      const readSdf = new Float32Array(resolution * resolution);
      gl.readRenderTargetPixels(sdf, 0, 0, resolution, resolution, readSdf);
      let min = Infinity;
      for (let i3 = 0; i3 < readSdf.length; i3++) {
        if (readSdf[i3] < min)
          min = readSdf[i3];
      }
      min = -min;
      ref.current.size = min;
      ref.current.sdf = sdf.texture;
      gl.setRenderTarget(null);
    }
  }, [resolution, blur]);
  React115.useImperativeHandle(fref, () => ref.current);
  const compute2 = React115.useCallback((event, state, previous) => {
    var _ref$current2;
    if (!parent.current)
      return false;
    state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);
    state.raycaster.setFromCamera(state.pointer, state.camera);
    if (((_ref$current2 = ref.current) == null ? void 0 : _ref$current2.blend) === 0) {
      const [intersection3] = state.raycaster.intersectObject(parent.current);
      if (!intersection3) {
        state.raycaster.camera = void 0;
        return false;
      }
    }
  }, []);
  return React115.createElement("portalMaterialImpl", _extends({
    ref,
    blur,
    blend: 0,
    resolution: [size.width * viewport.dpr, size.height * viewport.dpr],
    toneMapped: false,
    attach: "material"
  }, props), React115.createElement(RenderTexture, {
    attach: "map",
    frames: visible ? Infinity : 0,
    eventPriority,
    renderPriority,
    compute: compute2
  }, children, React115.createElement(CopyMatrix, {
    events,
    rootScene: scene,
    priority: priority2,
    material: ref,
    worldUnits
  })));
});
function CopyMatrix({
  events = void 0,
  rootScene,
  material,
  priority: priority2,
  worldUnits
}) {
  const scene = useThree((state) => state.scene);
  const setEvents = useThree((state) => state.setEvents);
  const buffer1 = useFBO();
  const buffer2 = useFBO();
  React115.useLayoutEffect(() => {
    scene.matrixAutoUpdate = false;
  }, []);
  React115.useEffect(() => {
    if (events !== void 0)
      setEvents({
        enabled: events
      });
  }, [events]);
  const [quad, blend] = React115.useMemo(() => {
    const blend2 = {
      value: 0
    };
    const quad2 = new FullScreenQuad(new ShaderMaterial({
      uniforms: {
        a: {
          value: buffer1.texture
        },
        b: {
          value: buffer2.texture
        },
        blend: blend2
      },
      vertexShader: (
        /*glsl*/
        `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
          }`
      ),
      fragmentShader: (
        /*glsl*/
        `
          uniform sampler2D a;
          uniform sampler2D b;
          uniform float blend;
          varying vec2 vUv;
          #include <packing>
          void main() {
            vec4 ta = texture2D(a, vUv);
            vec4 tb = texture2D(b, vUv);
            gl_FragColor = mix(tb, ta, blend);
            #include <encodings_fragment>
          }`
      )
    }));
    return [quad2, blend2];
  }, []);
  useFrame((state) => {
    var _material$current;
    let parent = material == null ? void 0 : (_material$current = material.current) == null ? void 0 : _material$current.__r3f.parent;
    if (parent) {
      if (!worldUnits)
        scene.matrixWorld.copy(parent.matrixWorld);
      else
        scene.matrixWorld.identity();
      if (priority2) {
        var _material$current2, _material$current3, _material$current4;
        if (((_material$current2 = material.current) == null ? void 0 : _material$current2.blend) > 0 && ((_material$current3 = material.current) == null ? void 0 : _material$current3.blend) < 1 && parent) {
          blend.value = material.current.blend;
          state.gl.setRenderTarget(buffer1);
          state.gl.render(scene, state.camera);
          state.gl.setRenderTarget(buffer2);
          state.gl.render(rootScene, state.camera);
          state.gl.setRenderTarget(null);
          quad.render(state.gl);
        } else if (((_material$current4 = material.current) == null ? void 0 : _material$current4.blend) === 1) {
          state.gl.render(scene, state.camera);
        }
      }
    }
  }, priority2);
  return React115.createElement(React115.Fragment, null);
}
var makeSDFGenerator = (clientWidth, clientHeight, renderer) => {
  let finalTarget = new WebGLRenderTarget(clientWidth, clientHeight, {
    minFilter: LinearMipmapLinearFilter,
    magFilter: LinearFilter,
    type: FloatType,
    format: RedFormat,
    generateMipmaps: true
  });
  let outsideRenderTarget = new WebGLRenderTarget(clientWidth, clientHeight, {
    minFilter: NearestFilter,
    magFilter: NearestFilter
  });
  let insideRenderTarget = new WebGLRenderTarget(clientWidth, clientHeight, {
    minFilter: NearestFilter,
    magFilter: NearestFilter
  });
  let outsideRenderTarget2 = new WebGLRenderTarget(clientWidth, clientHeight, {
    minFilter: NearestFilter,
    magFilter: NearestFilter
  });
  let insideRenderTarget2 = new WebGLRenderTarget(clientWidth, clientHeight, {
    minFilter: NearestFilter,
    magFilter: NearestFilter
  });
  let outsideRenderTargetFinal = new WebGLRenderTarget(clientWidth, clientHeight, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    type: FloatType,
    format: RedFormat
  });
  let insideRenderTargetFinal = new WebGLRenderTarget(clientWidth, clientHeight, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    type: FloatType,
    format: RedFormat
  });
  const uvRender = new FullScreenQuad(new ShaderMaterial({
    uniforms: {
      tex: {
        value: null
      }
    },
    vertexShader: (
      /*glsl*/
      `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`
    ),
    fragmentShader: (
      /*glsl*/
      `
        uniform sampler2D tex;
        varying vec2 vUv;
        #include <packing>
        void main() {
          gl_FragColor = pack2HalfToRGBA(vUv * (round(texture2D(tex, vUv).x)));
        }`
    )
  }));
  const uvRenderInside = new FullScreenQuad(new ShaderMaterial({
    uniforms: {
      tex: {
        value: null
      }
    },
    vertexShader: (
      /*glsl*/
      `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`
    ),
    fragmentShader: (
      /*glsl*/
      `
        uniform sampler2D tex;
        varying vec2 vUv;
        #include <packing>
        void main() {
          gl_FragColor = pack2HalfToRGBA(vUv * (1.0 - round(texture2D(tex, vUv).x)));
        }`
    )
  }));
  const jumpFloodRender = new FullScreenQuad(new ShaderMaterial({
    uniforms: {
      tex: {
        value: null
      },
      offset: {
        value: 0
      },
      level: {
        value: 0
      },
      maxSteps: {
        value: 0
      }
    },
    vertexShader: (
      /*glsl*/
      `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`
    ),
    fragmentShader: (
      /*glsl*/
      `
        varying vec2 vUv;
        uniform sampler2D tex;
        uniform float offset;
        uniform float level;
        uniform float maxSteps;
        #include <packing>
        void main() {
          float closestDist = 9999999.9;
          vec2 closestPos = vec2(0.0);
          for (float x = -1.0; x <= 1.0; x += 1.0) {
            for (float y = -1.0; y <= 1.0; y += 1.0) {
              vec2 voffset = vUv;
              voffset += vec2(x, y) * vec2(${1 / clientWidth}, ${1 / clientHeight}) * offset;
              vec2 pos = unpackRGBATo2Half(texture2D(tex, voffset));
              float dist = distance(pos.xy, vUv);
              if(pos.x != 0.0 && pos.y != 0.0 && dist < closestDist) {
                closestDist = dist;
                closestPos = pos;
              }
            }
          }
          gl_FragColor = pack2HalfToRGBA(closestPos);
        }`
    )
  }));
  const distanceFieldRender = new FullScreenQuad(new ShaderMaterial({
    uniforms: {
      tex: {
        value: null
      },
      size: {
        value: new Vector2(clientWidth, clientHeight)
      }
    },
    vertexShader: (
      /*glsl*/
      `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`
    ),
    fragmentShader: (
      /*glsl*/
      `
        varying vec2 vUv;
        uniform sampler2D tex;
        uniform vec2 size;
        #include <packing>
        void main() {
          gl_FragColor = vec4(distance(size * unpackRGBATo2Half(texture2D(tex, vUv)), size * vUv), 0.0, 0.0, 0.0);
        }`
    )
  }));
  const compositeRender = new FullScreenQuad(new ShaderMaterial({
    uniforms: {
      inside: {
        value: insideRenderTargetFinal.texture
      },
      outside: {
        value: outsideRenderTargetFinal.texture
      },
      tex: {
        value: null
      }
    },
    vertexShader: (
      /*glsl*/
      `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }`
    ),
    fragmentShader: (
      /*glsl*/
      `
        varying vec2 vUv;
        uniform sampler2D inside;
        uniform sampler2D outside;
        uniform sampler2D tex;
        #include <packing>
        void main() {
          float i = texture2D(inside, vUv).x;
          float o =texture2D(outside, vUv).x;
          if (texture2D(tex, vUv).x == 0.0) {
            gl_FragColor = vec4(o, 0.0, 0.0, 0.0);
          } else {
            gl_FragColor = vec4(-i, 0.0, 0.0, 0.0);
          }
        }`
    )
  }));
  return (image2) => {
    let ft = finalTarget;
    image2.minFilter = NearestFilter;
    image2.magFilter = NearestFilter;
    uvRender.material.uniforms.tex.value = image2;
    renderer.setRenderTarget(outsideRenderTarget);
    uvRender.render(renderer);
    const passes = Math.ceil(Math.log(Math.max(clientWidth, clientHeight)) / Math.log(2));
    let lastTarget = outsideRenderTarget;
    let target2 = null;
    for (let i3 = 0; i3 < passes; i3++) {
      const offset = Math.pow(2, passes - i3 - 1);
      target2 = lastTarget === outsideRenderTarget ? outsideRenderTarget2 : outsideRenderTarget;
      jumpFloodRender.material.uniforms.level.value = i3;
      jumpFloodRender.material.uniforms.maxSteps.value = passes;
      jumpFloodRender.material.uniforms.offset.value = offset;
      jumpFloodRender.material.uniforms.tex.value = lastTarget.texture;
      renderer.setRenderTarget(target2);
      jumpFloodRender.render(renderer);
      lastTarget = target2;
    }
    renderer.setRenderTarget(outsideRenderTargetFinal);
    distanceFieldRender.material.uniforms.tex.value = target2.texture;
    distanceFieldRender.render(renderer);
    uvRenderInside.material.uniforms.tex.value = image2;
    renderer.setRenderTarget(insideRenderTarget);
    uvRenderInside.render(renderer);
    lastTarget = insideRenderTarget;
    for (let i3 = 0; i3 < passes; i3++) {
      const offset = Math.pow(2, passes - i3 - 1);
      target2 = lastTarget === insideRenderTarget ? insideRenderTarget2 : insideRenderTarget;
      jumpFloodRender.material.uniforms.level.value = i3;
      jumpFloodRender.material.uniforms.maxSteps.value = passes;
      jumpFloodRender.material.uniforms.offset.value = offset;
      jumpFloodRender.material.uniforms.tex.value = lastTarget.texture;
      renderer.setRenderTarget(target2);
      jumpFloodRender.render(renderer);
      lastTarget = target2;
    }
    renderer.setRenderTarget(insideRenderTargetFinal);
    distanceFieldRender.material.uniforms.tex.value = target2.texture;
    distanceFieldRender.render(renderer);
    renderer.setRenderTarget(ft);
    compositeRender.material.uniforms.tex.value = image2;
    compositeRender.render(renderer);
    renderer.setRenderTarget(null);
    return ft;
  };
};

// node_modules/@react-three/drei/web/View.js
var React116 = __toESM(require_react());
var isOrthographicCamera2 = (def) => def && def.isOrthographicCamera;
var col = new Color();
function isNonLegacyCanvasSize(size) {
  return "top" in size;
}
function computeContainerPosition(canvasSize, trackRect) {
  const {
    right,
    top,
    left: trackLeft,
    bottom: trackBottom,
    width,
    height
  } = trackRect;
  const isOffscreen = trackRect.bottom < 0 || top > canvasSize.height || right < 0 || trackRect.left > canvasSize.width;
  if (isNonLegacyCanvasSize(canvasSize)) {
    const canvasBottom = canvasSize.top + canvasSize.height;
    const bottom2 = canvasBottom - trackBottom;
    const left = trackLeft - canvasSize.left;
    return {
      position: {
        width,
        height,
        left,
        top,
        bottom: bottom2,
        right
      },
      isOffscreen
    };
  }
  const bottom = canvasSize.height - trackBottom;
  return {
    position: {
      width,
      height,
      top,
      left: trackLeft,
      bottom,
      right
    },
    isOffscreen
  };
}
function Container2({
  canvasSize,
  scene,
  index,
  children,
  frames,
  rect,
  track
}) {
  const get = useThree((state) => state.get);
  const camera = useThree((state) => state.camera);
  const virtualScene = useThree((state) => state.scene);
  const setEvents = useThree((state) => state.setEvents);
  let frameCount = 0;
  useFrame((state) => {
    if (frames === Infinity || frameCount <= frames) {
      var _track$current;
      rect.current = (_track$current = track.current) == null ? void 0 : _track$current.getBoundingClientRect();
      frameCount++;
    }
    if (rect.current) {
      const {
        position: {
          left,
          bottom,
          width,
          height
        },
        isOffscreen
      } = computeContainerPosition(canvasSize, rect.current);
      const aspect = width / height;
      if (isOrthographicCamera2(camera)) {
        if (camera.left !== width / -2 || camera.right !== width / 2 || camera.top !== height / 2 || camera.bottom !== height / -2) {
          Object.assign(camera, {
            left: width / -2,
            right: width / 2,
            top: height / 2,
            bottom: height / -2
          });
          camera.updateProjectionMatrix();
        }
      } else if (camera.aspect !== aspect) {
        camera.aspect = aspect;
        camera.updateProjectionMatrix();
      }
      state.gl.setViewport(left, bottom, width, height);
      state.gl.setScissor(left, bottom, width, height);
      state.gl.setScissorTest(true);
      if (isOffscreen) {
        state.gl.getClearColor(col);
        state.gl.setClearColor(col, state.gl.getClearAlpha());
        state.gl.clear(true, true);
      } else {
        state.gl.render(children ? virtualScene : scene, camera);
      }
      state.gl.setScissorTest(true);
    }
  }, index);
  React116.useEffect(() => {
    const old = get().events.connected;
    setEvents({
      connected: track.current
    });
    return () => setEvents({
      connected: old
    });
  }, []);
  React116.useEffect(() => {
    if (isNonLegacyCanvasSize(canvasSize)) {
      return;
    }
    console.warn("Detected @react-three/fiber canvas size does not include position information. <View /> may not work as expected. Upgrade to @react-three/fiber ^8.1.0 for support.\n See https://github.com/pmndrs/drei/issues/944");
  }, []);
  return React116.createElement(React116.Fragment, null, children);
}
var View = ({
  track,
  index = 1,
  frames = Infinity,
  children
}) => {
  var _rect$current, _rect$current2;
  const rect = React116.useRef(null);
  const {
    size,
    scene
  } = useThree();
  const [virtualScene] = React116.useState(() => new Scene());
  const compute2 = React116.useCallback((event, state) => {
    if (rect.current && track.current && event.target === track.current) {
      const {
        width,
        height,
        left,
        top
      } = rect.current;
      const x = event.clientX - left;
      const y = event.clientY - top;
      state.pointer.set(x / width * 2 - 1, -(y / height) * 2 + 1);
      state.raycaster.setFromCamera(state.pointer, state.camera);
    }
  }, [rect, track]);
  const [ready, toggle] = React116.useReducer(() => true, false);
  React116.useEffect(() => {
    var _track$current2;
    rect.current = (_track$current2 = track.current) == null ? void 0 : _track$current2.getBoundingClientRect();
    toggle();
  }, [track]);
  return React116.createElement(React116.Fragment, null, ready && createPortal(React116.createElement(Container2, {
    canvasSize: size,
    frames,
    scene,
    track,
    rect,
    index
  }, children, React116.createElement("group", {
    onPointerOver: () => null
  })), virtualScene, {
    events: {
      compute: compute2,
      priority: index
    },
    size: {
      width: (_rect$current = rect.current) == null ? void 0 : _rect$current.width,
      height: (_rect$current2 = rect.current) == null ? void 0 : _rect$current2.height
    }
  }));
};

// node_modules/@react-three/drei/web/pivotControls/index.js
var React121 = __toESM(require_react());

// node_modules/@react-three/drei/web/pivotControls/AxisArrow.js
var React118 = __toESM(require_react());

// node_modules/@react-three/drei/web/pivotControls/context.js
var React117 = __toESM(require_react());
var context9 = React117.createContext(null);

// node_modules/@react-three/drei/web/pivotControls/AxisArrow.js
var vec1 = new Vector3();
var vec2 = new Vector3();
var calculateOffset = (clickPoint, normal2, rayStart, rayDir) => {
  const e1 = normal2.dot(normal2);
  const e2 = normal2.dot(clickPoint) - normal2.dot(rayStart);
  const e3 = normal2.dot(rayDir);
  if (e3 === 0) {
    return -e2 / e1;
  }
  vec1.copy(rayDir).multiplyScalar(e1 / e3).sub(normal2);
  vec2.copy(rayDir).multiplyScalar(e2 / e3).add(rayStart).sub(clickPoint);
  const offset = -vec1.dot(vec2) / vec1.dot(vec1);
  return offset;
};
var upV = new Vector3(0, 1, 0);
var offsetMatrix = new Matrix4();
var AxisArrow = ({
  direction,
  axis
}) => {
  const {
    translation: translation2,
    translationLimits,
    annotations,
    annotationsClass,
    depthTest,
    scale: scale2,
    lineWidth,
    fixed,
    axisColors,
    hoveredColor,
    opacity,
    onDragStart,
    onDrag,
    onDragEnd,
    userData
  } = React118.useContext(context9);
  const camControls = useThree((state) => state.controls);
  const divRef = React118.useRef(null);
  const objRef = React118.useRef(null);
  const clickInfo = React118.useRef(null);
  const offset0 = React118.useRef(0);
  const [isHovered, setIsHovered] = React118.useState(false);
  const onPointerDown = React118.useCallback((e2) => {
    if (annotations) {
      divRef.current.innerText = `${translation2.current[axis].toFixed(2)}`;
      divRef.current.style.display = "block";
    }
    e2.stopPropagation();
    const rotation2 = new Matrix4().extractRotation(objRef.current.matrixWorld);
    const clickPoint = e2.point.clone();
    const origin2 = new Vector3().setFromMatrixPosition(objRef.current.matrixWorld);
    const dir = direction.clone().applyMatrix4(rotation2).normalize();
    clickInfo.current = {
      clickPoint,
      dir
    };
    offset0.current = translation2.current[axis];
    onDragStart({
      component: "Arrow",
      axis,
      origin: origin2,
      directions: [dir]
    });
    camControls && (camControls.enabled = false);
    e2.target.setPointerCapture(e2.pointerId);
  }, [annotations, direction, camControls, onDragStart, translation2, axis]);
  const onPointerMove = React118.useCallback((e2) => {
    e2.stopPropagation();
    if (!isHovered)
      setIsHovered(true);
    if (clickInfo.current) {
      const {
        clickPoint,
        dir
      } = clickInfo.current;
      const [min, max] = (translationLimits == null ? void 0 : translationLimits[axis]) || [void 0, void 0];
      let offset = calculateOffset(clickPoint, dir, e2.ray.origin, e2.ray.direction);
      if (min !== void 0) {
        offset = Math.max(offset, min - offset0.current);
      }
      if (max !== void 0) {
        offset = Math.min(offset, max - offset0.current);
      }
      translation2.current[axis] = offset0.current + offset;
      if (annotations) {
        divRef.current.innerText = `${translation2.current[axis].toFixed(2)}`;
      }
      offsetMatrix.makeTranslation(dir.x * offset, dir.y * offset, dir.z * offset);
      onDrag(offsetMatrix);
    }
  }, [annotations, onDrag, isHovered, translation2, translationLimits, axis]);
  const onPointerUp = React118.useCallback((e2) => {
    if (annotations) {
      divRef.current.style.display = "none";
    }
    e2.stopPropagation();
    clickInfo.current = null;
    onDragEnd();
    camControls && (camControls.enabled = true);
    e2.target.releasePointerCapture(e2.pointerId);
  }, [annotations, camControls, onDragEnd]);
  const onPointerOut = React118.useCallback((e2) => {
    e2.stopPropagation();
    setIsHovered(false);
  }, []);
  const {
    cylinderLength,
    coneWidth,
    coneLength,
    matrixL
  } = React118.useMemo(() => {
    const coneWidth2 = fixed ? lineWidth / scale2 * 1.6 : scale2 / 20;
    const coneLength2 = fixed ? 0.2 : scale2 / 5;
    const cylinderLength2 = fixed ? 1 - coneLength2 : scale2 - coneLength2;
    const quaternion = new Quaternion().setFromUnitVectors(upV, direction.clone().normalize());
    const matrixL2 = new Matrix4().makeRotationFromQuaternion(quaternion);
    return {
      cylinderLength: cylinderLength2,
      coneWidth: coneWidth2,
      coneLength: coneLength2,
      matrixL: matrixL2
    };
  }, [direction, scale2, lineWidth, fixed]);
  const color_ = isHovered ? hoveredColor : axisColors[axis];
  return React118.createElement("group", {
    ref: objRef
  }, React118.createElement("group", {
    matrix: matrixL,
    matrixAutoUpdate: false,
    onPointerDown,
    onPointerMove,
    onPointerUp,
    onPointerOut
  }, annotations && React118.createElement(Html, {
    position: [0, -coneLength, 0]
  }, React118.createElement("div", {
    style: {
      display: "none",
      background: "#151520",
      color: "white",
      padding: "6px 8px",
      borderRadius: 7,
      whiteSpace: "nowrap"
    },
    className: annotationsClass,
    ref: divRef
  })), React118.createElement("mesh", {
    visible: false,
    position: [0, (cylinderLength + coneLength) / 2, 0],
    userData
  }, React118.createElement("cylinderGeometry", {
    args: [coneWidth * 1.4, coneWidth * 1.4, cylinderLength + coneLength, 8, 1]
  })), React118.createElement(Line, {
    transparent: true,
    raycast: () => null,
    depthTest,
    points: [0, 0, 0, 0, cylinderLength, 0],
    lineWidth,
    color: color_,
    opacity,
    polygonOffset: true,
    renderOrder: 1,
    polygonOffsetFactor: -10,
    fog: false
  }), React118.createElement("mesh", {
    raycast: () => null,
    position: [0, cylinderLength + coneLength / 2, 0],
    renderOrder: 500
  }, React118.createElement("coneGeometry", {
    args: [coneWidth, coneLength, 24, 1]
  }), React118.createElement("meshBasicMaterial", {
    transparent: true,
    depthTest,
    color: color_,
    opacity,
    polygonOffset: true,
    polygonOffsetFactor: -10,
    fog: false
  }))));
};

// node_modules/@react-three/drei/web/pivotControls/PlaneSlider.js
var React119 = __toESM(require_react());
var decomposeIntoBasis = (e1, e2, offset) => {
  const i1 = Math.abs(e1.x) >= Math.abs(e1.y) && Math.abs(e1.x) >= Math.abs(e1.z) ? 0 : Math.abs(e1.y) >= Math.abs(e1.x) && Math.abs(e1.y) >= Math.abs(e1.z) ? 1 : 2;
  const e2DegrowthOrder = [0, 1, 2].sort((a3, b) => Math.abs(e2.getComponent(b)) - Math.abs(e2.getComponent(a3)));
  const i22 = i1 === e2DegrowthOrder[0] ? e2DegrowthOrder[1] : e2DegrowthOrder[0];
  const a1 = e1.getComponent(i1);
  const a22 = e1.getComponent(i22);
  const b1 = e2.getComponent(i1);
  const b2 = e2.getComponent(i22);
  const c12 = offset.getComponent(i1);
  const c22 = offset.getComponent(i22);
  const y = (c22 - c12 * (a22 / a1)) / (b2 - b1 * (a22 / a1));
  const x = (c12 - y * b1) / a1;
  return [x, y];
};
var ray2 = new Ray();
var intersection = new Vector3();
var offsetMatrix2 = new Matrix4();
var PlaneSlider = ({
  dir1,
  dir2,
  axis
}) => {
  const {
    translation: translation2,
    translationLimits,
    annotations,
    annotationsClass,
    depthTest,
    scale: scale2,
    lineWidth,
    fixed,
    axisColors,
    hoveredColor,
    opacity,
    onDragStart,
    onDrag,
    onDragEnd,
    userData
  } = React119.useContext(context9);
  const camControls = useThree((state) => state.controls);
  const divRef = React119.useRef(null);
  const objRef = React119.useRef(null);
  const clickInfo = React119.useRef(null);
  const offsetX0 = React119.useRef(0);
  const offsetY0 = React119.useRef(0);
  const [isHovered, setIsHovered] = React119.useState(false);
  const onPointerDown = React119.useCallback((e2) => {
    if (annotations) {
      divRef.current.innerText = `${translation2.current[(axis + 1) % 3].toFixed(2)}, ${translation2.current[(axis + 2) % 3].toFixed(2)}`;
      divRef.current.style.display = "block";
    }
    e2.stopPropagation();
    const clickPoint = e2.point.clone();
    const origin2 = new Vector3().setFromMatrixPosition(objRef.current.matrixWorld);
    const e1 = new Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 0).normalize();
    const e22 = new Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 1).normalize();
    const normal2 = new Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 2).normalize();
    const plane = new Plane().setFromNormalAndCoplanarPoint(normal2, origin2);
    clickInfo.current = {
      clickPoint,
      e1,
      e2: e22,
      plane
    };
    offsetX0.current = translation2.current[(axis + 1) % 3];
    offsetY0.current = translation2.current[(axis + 2) % 3];
    onDragStart({
      component: "Slider",
      axis,
      origin: origin2,
      directions: [e1, e22, normal2]
    });
    camControls && (camControls.enabled = false);
    e2.target.setPointerCapture(e2.pointerId);
  }, [annotations, camControls, onDragStart, axis]);
  const onPointerMove = React119.useCallback((e2) => {
    e2.stopPropagation();
    if (!isHovered)
      setIsHovered(true);
    if (clickInfo.current) {
      const {
        clickPoint,
        e1,
        e2: e22,
        plane
      } = clickInfo.current;
      const [minX, maxX] = (translationLimits == null ? void 0 : translationLimits[(axis + 1) % 3]) || [void 0, void 0];
      const [minY, maxY] = (translationLimits == null ? void 0 : translationLimits[(axis + 2) % 3]) || [void 0, void 0];
      ray2.copy(e2.ray);
      ray2.intersectPlane(plane, intersection);
      ray2.direction.negate();
      ray2.intersectPlane(plane, intersection);
      intersection.sub(clickPoint);
      let [offsetX, offsetY] = decomposeIntoBasis(e1, e22, intersection);
      if (minX !== void 0) {
        offsetX = Math.max(offsetX, minX - offsetX0.current);
      }
      if (maxX !== void 0) {
        offsetX = Math.min(offsetX, maxX - offsetX0.current);
      }
      if (minY !== void 0) {
        offsetY = Math.max(offsetY, minY - offsetY0.current);
      }
      if (maxY !== void 0) {
        offsetY = Math.min(offsetY, maxY - offsetY0.current);
      }
      translation2.current[(axis + 1) % 3] = offsetX0.current + offsetX;
      translation2.current[(axis + 2) % 3] = offsetY0.current + offsetY;
      if (annotations) {
        divRef.current.innerText = `${translation2.current[(axis + 1) % 3].toFixed(2)}, ${translation2.current[(axis + 2) % 3].toFixed(2)}`;
      }
      offsetMatrix2.makeTranslation(offsetX * e1.x + offsetY * e22.x, offsetX * e1.y + offsetY * e22.y, offsetX * e1.z + offsetY * e22.z);
      onDrag(offsetMatrix2);
    }
  }, [annotations, onDrag, isHovered, translation2, translationLimits, axis]);
  const onPointerUp = React119.useCallback((e2) => {
    if (annotations) {
      divRef.current.style.display = "none";
    }
    e2.stopPropagation();
    clickInfo.current = null;
    onDragEnd();
    camControls && (camControls.enabled = true);
    e2.target.releasePointerCapture(e2.pointerId);
  }, [annotations, camControls, onDragEnd]);
  const onPointerOut = React119.useCallback((e2) => {
    e2.stopPropagation();
    setIsHovered(false);
  }, []);
  const matrixL = React119.useMemo(() => {
    const dir1N = dir1.clone().normalize();
    const dir2N = dir2.clone().normalize();
    return new Matrix4().makeBasis(dir1N, dir2N, dir1N.clone().cross(dir2N));
  }, [dir1, dir2]);
  const pos1 = fixed ? 1 / 7 : scale2 / 7;
  const length = fixed ? 0.225 : scale2 * 0.225;
  const color = isHovered ? hoveredColor : axisColors[axis];
  const points = React119.useMemo(() => [new Vector3(0, 0, 0), new Vector3(0, length, 0), new Vector3(length, length, 0), new Vector3(length, 0, 0), new Vector3(0, 0, 0)], [length]);
  return React119.createElement("group", {
    ref: objRef,
    matrix: matrixL,
    matrixAutoUpdate: false
  }, annotations && React119.createElement(Html, {
    position: [0, 0, 0]
  }, React119.createElement("div", {
    style: {
      display: "none",
      background: "#151520",
      color: "white",
      padding: "6px 8px",
      borderRadius: 7,
      whiteSpace: "nowrap"
    },
    className: annotationsClass,
    ref: divRef
  })), React119.createElement("group", {
    position: [pos1 * 1.7, pos1 * 1.7, 0]
  }, React119.createElement("mesh", {
    visible: true,
    onPointerDown,
    onPointerMove,
    onPointerUp,
    onPointerOut,
    scale: length,
    userData
  }, React119.createElement("planeGeometry", null), React119.createElement("meshBasicMaterial", {
    transparent: true,
    depthTest,
    color,
    polygonOffset: true,
    polygonOffsetFactor: -10,
    side: DoubleSide,
    fog: false
  })), React119.createElement(Line, {
    position: [-length / 2, -length / 2, 0],
    transparent: true,
    depthTest,
    points,
    lineWidth,
    color,
    opacity,
    polygonOffset: true,
    polygonOffsetFactor: -10,
    userData,
    fog: false
  })));
};

// node_modules/@react-three/drei/web/pivotControls/AxisRotator.js
var React120 = __toESM(require_react());
var import_lodash4 = __toESM(require_lodash3());
var clickDir = new Vector3();
var intersectionDir = new Vector3();
var toDegrees = (radians) => radians * 180 / Math.PI;
var toRadians = (degrees) => degrees * Math.PI / 180;
var calculateAngle = (clickPoint, intersectionPoint, origin2, e1, e2) => {
  clickDir.copy(clickPoint).sub(origin2);
  intersectionDir.copy(intersectionPoint).sub(origin2);
  const dote1e1 = e1.dot(e1);
  const dote2e2 = e2.dot(e2);
  const uClick = clickDir.dot(e1) / dote1e1;
  const vClick = clickDir.dot(e2) / dote2e2;
  const uIntersection = intersectionDir.dot(e1) / dote1e1;
  const vIntersection = intersectionDir.dot(e2) / dote2e2;
  const angleClick = Math.atan2(vClick, uClick);
  const angleIntersection = Math.atan2(vIntersection, uIntersection);
  return angleIntersection - angleClick;
};
var fmod = (num, denom) => {
  let k = Math.floor(num / denom);
  k = k < 0 ? k + 1 : k;
  return num - k * denom;
};
var minimizeAngle = (angle) => {
  let result = fmod(angle, 2 * Math.PI);
  if (Math.abs(result) < 1e-6) {
    return 0;
  }
  if (result < 0) {
    result += 2 * Math.PI;
  }
  return result;
};
var rotMatrix = new Matrix4();
var posNew = new Vector3();
var ray3 = new Ray();
var intersection2 = new Vector3();
var AxisRotator = ({
  dir1,
  dir2,
  axis
}) => {
  const {
    rotationLimits,
    annotations,
    annotationsClass,
    depthTest,
    scale: scale2,
    lineWidth,
    fixed,
    axisColors,
    hoveredColor,
    opacity,
    onDragStart,
    onDrag,
    onDragEnd,
    userData
  } = React120.useContext(context9);
  const camControls = useThree((state) => state.controls);
  const divRef = React120.useRef(null);
  const objRef = React120.useRef(null);
  const angle0 = React120.useRef(0);
  const angle = React120.useRef(0);
  const clickInfo = React120.useRef(null);
  const [isHovered, setIsHovered] = React120.useState(false);
  const onPointerDown = React120.useCallback((e2) => {
    if (annotations) {
      divRef.current.innerText = `${toDegrees(angle.current).toFixed(0)}º`;
      divRef.current.style.display = "block";
    }
    e2.stopPropagation();
    const clickPoint = e2.point.clone();
    const origin2 = new Vector3().setFromMatrixPosition(objRef.current.matrixWorld);
    const e1 = new Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 0).normalize();
    const e22 = new Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 1).normalize();
    const normal2 = new Vector3().setFromMatrixColumn(objRef.current.matrixWorld, 2).normalize();
    const plane = new Plane().setFromNormalAndCoplanarPoint(normal2, origin2);
    clickInfo.current = {
      clickPoint,
      origin: origin2,
      e1,
      e2: e22,
      normal: normal2,
      plane
    };
    onDragStart({
      component: "Rotator",
      axis,
      origin: origin2,
      directions: [e1, e22, normal2]
    });
    camControls && (camControls.enabled = false);
    e2.target.setPointerCapture(e2.pointerId);
  }, [annotations, camControls, onDragStart, axis]);
  const onPointerMove = React120.useCallback((e2) => {
    e2.stopPropagation();
    if (!isHovered)
      setIsHovered(true);
    if (clickInfo.current) {
      const {
        clickPoint,
        origin: origin2,
        e1,
        e2: e22,
        normal: normal2,
        plane
      } = clickInfo.current;
      const [min, max] = (rotationLimits == null ? void 0 : rotationLimits[axis]) || [void 0, void 0];
      ray3.copy(e2.ray);
      ray3.intersectPlane(plane, intersection2);
      ray3.direction.negate();
      ray3.intersectPlane(plane, intersection2);
      let deltaAngle = calculateAngle(clickPoint, intersection2, origin2, e1, e22);
      let degrees = toDegrees(deltaAngle);
      if (e2.shiftKey) {
        degrees = Math.round(degrees / 10) * 10;
        deltaAngle = toRadians(degrees);
      }
      if (min !== void 0 && max !== void 0 && max - min < 2 * Math.PI) {
        deltaAngle = minimizeAngle(deltaAngle);
        deltaAngle = deltaAngle > Math.PI ? deltaAngle - 2 * Math.PI : deltaAngle;
        deltaAngle = (0, import_lodash4.default)(deltaAngle, min - angle0.current, max - angle0.current);
        angle.current = angle0.current + deltaAngle;
      } else {
        angle.current = minimizeAngle(angle0.current + deltaAngle);
        angle.current = angle.current > Math.PI ? angle.current - 2 * Math.PI : angle.current;
      }
      if (annotations) {
        degrees = toDegrees(angle.current);
        divRef.current.innerText = `${degrees.toFixed(0)}º`;
      }
      rotMatrix.makeRotationAxis(normal2, deltaAngle);
      posNew.copy(origin2).applyMatrix4(rotMatrix).sub(origin2).negate();
      rotMatrix.setPosition(posNew);
      onDrag(rotMatrix);
    }
  }, [annotations, onDrag, isHovered, rotationLimits, axis]);
  const onPointerUp = React120.useCallback((e2) => {
    if (annotations) {
      divRef.current.style.display = "none";
    }
    e2.stopPropagation();
    angle0.current = angle.current;
    clickInfo.current = null;
    onDragEnd();
    camControls && (camControls.enabled = true);
    e2.target.releasePointerCapture(e2.pointerId);
  }, [annotations, camControls, onDragEnd]);
  const onPointerOut = React120.useCallback((e2) => {
    e2.stopPropagation();
    setIsHovered(false);
  }, []);
  const matrixL = React120.useMemo(() => {
    const dir1N = dir1.clone().normalize();
    const dir2N = dir2.clone().normalize();
    return new Matrix4().makeBasis(dir1N, dir2N, dir1N.clone().cross(dir2N));
  }, [dir1, dir2]);
  const r2 = fixed ? 0.65 : scale2 * 0.65;
  const arc = React120.useMemo(() => {
    const segments = 32;
    const points = [];
    for (let j = 0; j <= segments; j++) {
      const angle2 = j * (Math.PI / 2) / segments;
      points.push(new Vector3(Math.cos(angle2) * r2, Math.sin(angle2) * r2, 0));
    }
    return points;
  }, [r2]);
  return React120.createElement("group", {
    ref: objRef,
    onPointerDown,
    onPointerMove,
    onPointerUp,
    onPointerOut,
    matrix: matrixL,
    matrixAutoUpdate: false
  }, annotations && React120.createElement(Html, {
    position: [r2, r2, 0]
  }, React120.createElement("div", {
    style: {
      display: "none",
      background: "#151520",
      color: "white",
      padding: "6px 8px",
      borderRadius: 7,
      whiteSpace: "nowrap"
    },
    className: annotationsClass,
    ref: divRef
  })), React120.createElement(Line, {
    points: arc,
    lineWidth: lineWidth * 4,
    visible: false,
    userData
  }), React120.createElement(Line, {
    transparent: true,
    raycast: () => null,
    depthTest,
    points: arc,
    lineWidth,
    color: isHovered ? hoveredColor : axisColors[axis],
    opacity,
    polygonOffset: true,
    polygonOffsetFactor: -10,
    fog: false
  }));
};

// node_modules/@react-three/drei/web/pivotControls/index.js
var tV0 = new Vector3();
var tV1 = new Vector3();
var tV2 = new Vector3();
var getPoint2 = (point3, camera, size) => {
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  camera.updateMatrixWorld(false);
  const vector = point3.project(camera);
  vector.x = vector.x * widthHalf + widthHalf;
  vector.y = -(vector.y * heightHalf) + heightHalf;
  return vector;
};
var getPoint3 = (point2, camera, size, zValue = 1) => {
  const vector = tV0.set(point2.x / size.width * 2 - 1, -(point2.y / size.height) * 2 + 1, zValue);
  vector.unproject(camera);
  return vector;
};
var calculateScaleFactor = (point3, radiusPx, camera, size) => {
  const point2 = getPoint2(tV2.copy(point3), camera, size);
  let scale2 = 0;
  for (let i3 = 0; i3 < 2; ++i3) {
    const point2off = tV1.copy(point2).setComponent(i3, point2.getComponent(i3) + radiusPx);
    const point3off = getPoint3(point2off, camera, size, point2off.z);
    scale2 = Math.max(scale2, point3.distanceTo(point3off));
  }
  return scale2;
};
var mL0 = new Matrix4();
var mW0 = new Matrix4();
var mP = new Matrix4();
var mPInv = new Matrix4();
var mW = new Matrix4();
var mL = new Matrix4();
var mL0Inv = new Matrix4();
var mdL = new Matrix4();
var bb = new Box3();
var bbObj = new Box3();
var vCenter = new Vector3();
var vSize = new Vector3();
var vAnchorOffset = new Vector3();
var vPosition = new Vector3();
var xDir = new Vector3(1, 0, 0);
var yDir = new Vector3(0, 1, 0);
var zDir = new Vector3(0, 0, 1);
var PivotControls = React121.forwardRef(({
  matrix: matrix2,
  onDragStart,
  onDrag,
  onDragEnd,
  autoTransform = true,
  anchor,
  disableAxes = false,
  disableSliders = false,
  disableRotations = false,
  activeAxes = [true, true, true],
  offset = [0, 0, 0],
  rotation: rotation2 = [0, 0, 0],
  scale: scale2 = 1,
  lineWidth = 4,
  fixed = false,
  translationLimits,
  rotationLimits,
  depthTest = true,
  axisColors = ["#ff2060", "#20df80", "#2080ff"],
  hoveredColor = "#ffff40",
  annotations = false,
  annotationsClass,
  opacity = 1,
  visible = true,
  userData,
  children,
  ...props
}, fRef) => {
  const invalidate = useThree((state) => state.invalidate);
  const parentRef = React121.useRef(null);
  const ref = React121.useRef(null);
  const gizmoRef = React121.useRef(null);
  const childrenRef = React121.useRef(null);
  const translation2 = React121.useRef([0, 0, 0]);
  React121.useLayoutEffect(() => {
    if (!anchor)
      return;
    childrenRef.current.updateWorldMatrix(true, true);
    mPInv.copy(childrenRef.current.matrixWorld).invert();
    bb.makeEmpty();
    childrenRef.current.traverse((obj) => {
      if (!obj.geometry)
        return;
      if (!obj.geometry.boundingBox)
        obj.geometry.computeBoundingBox();
      mL.copy(obj.matrixWorld).premultiply(mPInv);
      bbObj.copy(obj.geometry.boundingBox);
      bbObj.applyMatrix4(mL);
      bb.union(bbObj);
    });
    vCenter.copy(bb.max).add(bb.min).multiplyScalar(0.5);
    vSize.copy(bb.max).sub(bb.min).multiplyScalar(0.5);
    vAnchorOffset.copy(vSize).multiply(new Vector3(...anchor)).add(vCenter);
    vPosition.set(...offset).add(vAnchorOffset);
    gizmoRef.current.position.copy(vPosition);
    invalidate();
  });
  const config2 = React121.useMemo(() => ({
    onDragStart: (props2) => {
      mL0.copy(ref.current.matrix);
      mW0.copy(ref.current.matrixWorld);
      onDragStart && onDragStart(props2);
      invalidate();
    },
    onDrag: (mdW) => {
      mP.copy(parentRef.current.matrixWorld);
      mPInv.copy(mP).invert();
      mW.copy(mW0).premultiply(mdW);
      mL.copy(mW).premultiply(mPInv);
      mL0Inv.copy(mL0).invert();
      mdL.copy(mL).multiply(mL0Inv);
      if (autoTransform)
        ref.current.matrix.copy(mL);
      onDrag && onDrag(mL, mdL, mW, mdW);
      invalidate();
    },
    onDragEnd: () => {
      if (onDragEnd)
        onDragEnd();
      invalidate();
    },
    translation: translation2,
    translationLimits,
    rotationLimits,
    axisColors,
    hoveredColor,
    opacity,
    scale: scale2,
    lineWidth,
    fixed,
    depthTest,
    userData,
    annotations,
    annotationsClass
  }), [onDragStart, onDrag, onDragEnd, translation2, translationLimits, rotationLimits, depthTest, scale2, lineWidth, fixed, ...axisColors, hoveredColor, opacity, userData, autoTransform, annotations, annotationsClass]);
  const vec = new Vector3();
  useFrame((state) => {
    if (fixed) {
      const sf = calculateScaleFactor(gizmoRef.current.getWorldPosition(vec), scale2, state.camera, state.size);
      if (gizmoRef.current) {
        var _gizmoRef$current, _gizmoRef$current2, _gizmoRef$current3;
        if (((_gizmoRef$current = gizmoRef.current) == null ? void 0 : _gizmoRef$current.scale.x) !== sf || ((_gizmoRef$current2 = gizmoRef.current) == null ? void 0 : _gizmoRef$current2.scale.y) !== sf || ((_gizmoRef$current3 = gizmoRef.current) == null ? void 0 : _gizmoRef$current3.scale.z) !== sf) {
          gizmoRef.current.scale.setScalar(sf);
          state.invalidate();
        }
      }
    }
  });
  React121.useImperativeHandle(fRef, () => ref.current, []);
  React121.useLayoutEffect(() => {
    if (matrix2 && matrix2 instanceof Matrix4)
      ref.current.matrix = matrix2;
  }, [matrix2]);
  return React121.createElement(context9.Provider, {
    value: config2
  }, React121.createElement("group", {
    ref: parentRef
  }, React121.createElement("group", _extends({
    ref,
    matrix: matrix2,
    matrixAutoUpdate: false
  }, props), React121.createElement("group", {
    visible,
    ref: gizmoRef,
    position: offset,
    rotation: rotation2
  }, !disableAxes && activeAxes[0] && React121.createElement(AxisArrow, {
    axis: 0,
    direction: xDir
  }), !disableAxes && activeAxes[1] && React121.createElement(AxisArrow, {
    axis: 1,
    direction: yDir
  }), !disableAxes && activeAxes[2] && React121.createElement(AxisArrow, {
    axis: 2,
    direction: zDir
  }), !disableSliders && activeAxes[0] && activeAxes[1] && React121.createElement(PlaneSlider, {
    axis: 2,
    dir1: xDir,
    dir2: yDir
  }), !disableSliders && activeAxes[0] && activeAxes[2] && React121.createElement(PlaneSlider, {
    axis: 1,
    dir1: zDir,
    dir2: xDir
  }), !disableSliders && activeAxes[2] && activeAxes[1] && React121.createElement(PlaneSlider, {
    axis: 0,
    dir1: yDir,
    dir2: zDir
  }), !disableRotations && activeAxes[0] && activeAxes[1] && React121.createElement(AxisRotator, {
    axis: 2,
    dir1: xDir,
    dir2: yDir
  }), !disableRotations && activeAxes[0] && activeAxes[2] && React121.createElement(AxisRotator, {
    axis: 1,
    dir1: zDir,
    dir2: xDir
  }), !disableRotations && activeAxes[2] && activeAxes[1] && React121.createElement(AxisRotator, {
    axis: 0,
    dir1: yDir,
    dir2: zDir
  })), React121.createElement("group", {
    ref: childrenRef
  }, children))));
});
export {
  AccumulativeShadows,
  AdaptiveDpr,
  AdaptiveEvents,
  ArcballControls2 as ArcballControls,
  AsciiRenderer,
  BBAnchor,
  Backdrop,
  BakeShadows,
  Billboard,
  Bounds,
  Box,
  Bvh,
  CameraControls2 as CameraControls,
  CameraShake,
  Capsule,
  CatmullRomLine,
  Caustics,
  Center,
  Circle,
  Clone,
  Cloud,
  ComputedAttribute,
  Cone,
  ContactShadows,
  CubeCamera2 as CubeCamera,
  CubicBezierLine,
  CurveModifier,
  CycleRaycast,
  Cylinder,
  Decal,
  Detailed,
  DeviceOrientationControls2 as DeviceOrientationControls,
  Dodecahedron,
  Edges,
  Effects,
  Environment,
  EnvironmentCube,
  EnvironmentMap,
  EnvironmentPortal,
  Example,
  Extrude,
  FaceControls,
  FaceLandmarker2 as FaceLandmarker,
  FaceLandmarkerDefaults,
  Facemesh,
  FacemeshDatas,
  FacemeshEye,
  FacemeshEyeDefaults,
  FirstPersonControls2 as FirstPersonControls,
  Float,
  FlyControls2 as FlyControls,
  GizmoHelper,
  GizmoViewcube,
  GizmoViewport,
  Gltf,
  GradientTexture,
  Grid,
  Html,
  Hud,
  Icosahedron,
  Image,
  Instance,
  Instances,
  IsObject,
  KeyboardControls,
  Lathe,
  Lightformer,
  Line,
  Loader,
  MapControls2 as MapControls,
  MarchingCube,
  MarchingCubes2 as MarchingCubes,
  MarchingPlane,
  Mask,
  Merged,
  MeshDiscardMaterial,
  MeshDistortMaterial,
  MeshPortalMaterial,
  MeshReflectorMaterial2 as MeshReflectorMaterial,
  MeshRefractionMaterial2 as MeshRefractionMaterial,
  MeshTransmissionMaterial,
  MeshWobbleMaterial,
  Octahedron,
  OrbitControls2 as OrbitControls,
  OrthographicCamera2 as OrthographicCamera,
  PerformanceMonitor,
  PerspectiveCamera2 as PerspectiveCamera,
  PivotControls,
  Plane2 as Plane,
  Point,
  PointMaterial,
  PointMaterialImpl,
  PointerLockControls2 as PointerLockControls,
  Points,
  PointsBuffer,
  Polyhedron,
  PositionPoint,
  PositionalAudio,
  Preload,
  PresentationControls,
  QuadraticBezierLine,
  RandomizedLight,
  Reflector,
  RenderTexture,
  Resize,
  Ring,
  RoundedBox,
  Sampler,
  ScreenQuad,
  ScreenSpace,
  Scroll,
  ScrollControls,
  Segment,
  SegmentObject,
  Segments,
  Select,
  Shadow,
  Shape2 as Shape,
  Sky2 as Sky,
  SoftShadows,
  Sparkles,
  Sphere2 as Sphere,
  SpotLight,
  SpotLightShadow,
  SpriteAnimator,
  Stage,
  Stars,
  Stats,
  Svg,
  Tetrahedron,
  Text2 as Text,
  Text3D,
  Torus,
  TorusKnot,
  TrackballControls2 as TrackballControls,
  Trail,
  TransformControls2 as TransformControls,
  Tube,
  View,
  Wireframe,
  accumulativeContext,
  calcPosFromAngles,
  calculateScaleFactor,
  isWebGL2Available,
  meshBounds,
  shaderMaterial,
  useAnimations,
  useAspect,
  useBVH,
  useBounds,
  useBoxProjectedEnv,
  useCamera,
  useContextBridge,
  useCubeCamera,
  useCubeTexture,
  useCursor,
  useDepthBuffer,
  useDetectGPU,
  useEnvironment,
  useFBO,
  useFBX,
  useFaceControls,
  useFaceLandmarker,
  useFont,
  useGLTF,
  useGizmoContext,
  useHelper,
  useIntersect,
  useKTX2,
  useKeyboardControls,
  useMask,
  useMatcapTexture,
  useNormalTexture,
  usePerformanceMonitor,
  useProgress,
  useScroll,
  useSelect,
  useSurfaceSampler,
  useTexture,
  useTrail,
  useTrailTexture,
  useVideoTexture
};
/*! Bundled license information:

troika-three-text/dist/troika-three-text.esm.js:
  (*!
  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
  *)
  (*!
  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
  (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
  Original licenses apply: 
  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
  *)

camera-controls/dist/camera-controls.module.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=@react-three_drei.js.map
